ca65 V2.18 - N/A
Main file   : bw6502.s
Current file: bw6502.s

000000r 1               
000000r 1               ; Minimal monitor for my 6502 Single Board Computer.
000000r 1               .setcpu "65C02"
000000r 1               .code
000000r 1               
000000r 1               	.include "basic.s"
000000r 2               
000000r 2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22
000000r 2               
000000r 2               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 2               
000000r 2               ; 2.00	new revision numbers start here
000000r 2               ; 2.01	fixed LCASE$() and UCASE$()
000000r 2               ; 2.02	new get value routine done
000000r 2               ; 2.03	changed RND() to galoise method
000000r 2               ; 2.04	fixed SPC()
000000r 2               ; 2.05	new get value routine fixed
000000r 2               ; 2.06	changed USR() code
000000r 2               ; 2.07	fixed STR$()
000000r 2               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09	fixed RND()
000000r 2               ; 2.10	integrated missed changes from an earlier version
000000r 2               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21	fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22	fixed RND() breaking the get byte routine
000000r 2               
000000r 2               ; zero page use ..
000000r 2               
000000r 2               LAB_WARM 		= $00		; BASIC warm start entry point
000000r 2               Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
000000r 2               Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp		= $0A		; USR function JMP address
000000r 2               Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
000000r 2               Usrjph		= Usrjmp+2	; USR function JMP vector high byte
000000r 2               Nullct		= $0D		; nulls output after each line
000000r 2               TPos			= $0E		; BASIC terminal position byte
000000r 2               TWidth		= $0F		; BASIC terminal width byte
000000r 2               Iclim			= $10		; input column limit
000000r 2               Itempl		= $11		; temporary integer low byte
000000r 2               Itemph		= Itempl+1	; temporary integer high byte
000000r 2               
000000r 2               nums_1		= Itempl	; number to bin/hex string convert MSB
000000r 2               nums_2		= nums_1+1	; number to bin/hex string convert
000000r 2               nums_3		= nums_1+2	; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc			= $5B		; search character
000000r 2               Temp3			= Srchc	; temp byte used in number routines
000000r 2               Scnquo		= $5C		; scan-between-quotes flag
000000r 2               Asrch			= Scnquo	; alt search character
000000r 2               
000000r 2               XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr			= $5D		; input buffer pointer
000000r 2               Dimcnt		= Ibptr	; # of dimensions
000000r 2               Tindx			= Ibptr	; token index
000000r 2               
000000r 2               Defdim		= $5E		; default DIM flag
000000r 2               Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
000000r 2               Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd		= $60		; garbage collected flag
000000r 2               Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode			= $62		; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag			= $63		; comparison evaluation flag
000000r 2               
000000r 2               TabSiz		= $64		; TAB step size (was input flag)
000000r 2               
000000r 2               next_s		= $65		; next descriptor stack address
000000r 2               
000000r 2               					; these two bytes form a word pointer to the item
000000r 2               					; currently on top of the descriptor stack
000000r 2               last_sl		= $66		; last descriptor stack address low byte
000000r 2               last_sh		= $67		; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk		= $68		; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ;			= $70		; End of descriptor stack
000000r 2               
000000r 2               ut1_pl		= $71		; utility pointer 1 low byte
000000r 2               ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
000000r 2               ut2_pl		= $73		; utility pointer 2 low byte
000000r 2               ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2		= ut1_pl	; temp byte for block move
000000r 2               
000000r 2               FACt_1		= $75		; FAC temp mantissa1
000000r 2               FACt_2		= FACt_1+1	; FAC temp mantissa2
000000r 2               FACt_3		= FACt_2+1	; FAC temp mantissa3
000000r 2               
000000r 2               dims_l		= FACt_2	; array dimension size low byte
000000r 2               dims_h		= FACt_3	; array dimension size high byte
000000r 2               
000000r 2               TempB			= $78		; temp page 0 byte
000000r 2               
000000r 2               Smeml			= $79		; start of mem low byte		(Start-of-Basic)
000000r 2               Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
000000r 2               Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
000000r 2               Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
000000r 2               Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
000000r 2               Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
000000r 2               Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
000000r 2               Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
000000r 2               Sstorl		= $81		; string storage low byte	(String storage (moving down))
000000r 2               Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
000000r 2               Sutill		= $83		; string utility ptr low byte
000000r 2               Sutilh		= Sutill+1	; string utility ptr high byte
000000r 2               Ememl			= $85		; end of mem low byte		(Limit-of-memory)
000000r 2               Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
000000r 2               Clinel		= $87		; current line low byte		(Basic line number)
000000r 2               Clineh		= Clinel+1	; current line high byte	(Basic line number)
000000r 2               Blinel		= $89		; break line low byte		(Previous Basic line number)
000000r 2               Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
000000r 2               
000000r 2               Cpntrl		= $8B		; continue pointer low byte
000000r 2               Cpntrh		= Cpntrl+1	; continue pointer high byte
000000r 2               
000000r 2               Dlinel		= $8D		; current DATA line low byte
000000r 2               Dlineh		= Dlinel+1	; current DATA line high byte
000000r 2               
000000r 2               Dptrl			= $8F		; DATA pointer low byte
000000r 2               Dptrh			= Dptrl+1	; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl		= $91		; read pointer low byte
000000r 2               Rdptrh		= Rdptrl+1	; read pointer high byte
000000r 2               
000000r 2               Varnm1		= $93		; current var name 1st byte
000000r 2               Varnm2		= Varnm1+1	; current var name 2nd byte
000000r 2               
000000r 2               Cvaral		= $95		; current var address low byte
000000r 2               Cvarah		= Cvaral+1	; current var address high byte
000000r 2               
000000r 2               Frnxtl		= $97		; var pointer for FOR/NEXT low byte
000000r 2               Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1			= Frnxtl	; temp line index
000000r 2               
000000r 2               Lvarpl		= Frnxtl	; let var pointer low byte
000000r 2               Lvarph		= Frnxth	; let var pointer high byte
000000r 2               
000000r 2               prstk			= $99		; precedence stacked flag
000000r 2               
000000r 2               comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
000000r 2               					; bit 2 set if >
000000r 2               					; bit 1 set if =
000000r 2               					; bit 0 set if <
000000r 2               
000000r 2               func_l		= $9C		; function pointer low byte
000000r 2               func_h		= func_l+1	; function pointer high byte
000000r 2               
000000r 2               garb_l		= func_l	; garbage collection working pointer low byte
000000r 2               garb_h		= func_h	; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l		= $9E		; string descriptor_2 pointer low byte
000000r 2               des_2h		= des_2l+1	; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step		= $A0		; garbage collect step size
000000r 2               
000000r 2               Fnxjmp		= $A1		; jump vector for functions
000000r 2               Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
000000r 2               Fnxjph		= Fnxjmp+2	; functions jump vector high byte
000000r 2               
000000r 2               g_indx		= Fnxjpl	; garbage collect temp index
000000r 2               
000000r 2               FAC2_r		= $A3		; FAC2 rounding byte
000000r 2               
000000r 2               Adatal		= $A4		; array data pointer low byte
000000r 2               Adatah		= Adatal+1	; array data pointer high  byte
000000r 2               
000000r 2               Nbendl		= Adatal	; new block end pointer low byte
000000r 2               Nbendh		= Adatah	; new block end pointer high  byte
000000r 2               
000000r 2               Obendl		= $A6		; old block end pointer low byte
000000r 2               Obendh		= Obendl+1	; old block end pointer high  byte
000000r 2               
000000r 2               numexp		= $A8		; string to float number exponent count
000000r 2               expcnt		= $A9		; string to float exponent count
000000r 2               
000000r 2               numbit		= numexp	; bit count for array element calculations
000000r 2               
000000r 2               numdpf		= $AA		; string to float decimal point flag
000000r 2               expneg		= $AB		; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl		= numdpf	; array start pointer low byte
000000r 2               Astrth		= expneg	; array start pointer high  byte
000000r 2               
000000r 2               Histrl		= numdpf	; highest string low byte
000000r 2               Histrh		= expneg	; highest string high  byte
000000r 2               
000000r 2               Baslnl		= numdpf	; BASIC search line pointer low byte
000000r 2               Baslnh		= expneg	; BASIC search line pointer high  byte
000000r 2               
000000r 2               Fvar_l		= numdpf	; find/found variable pointer low byte
000000r 2               Fvar_h		= expneg	; find/found variable pointer high  byte
000000r 2               
000000r 2               Ostrtl		= numdpf	; old block start pointer low byte
000000r 2               Ostrth		= expneg	; old block start pointer high  byte
000000r 2               
000000r 2               Vrschl		= numdpf	; variable search pointer low byte
000000r 2               Vrschh		= expneg	; variable search pointer high  byte
000000r 2               
000000r 2               FAC1_e		= $AC		; FAC1 exponent
000000r 2               FAC1_1		= FAC1_e+1	; FAC1 mantissa1
000000r 2               FAC1_2		= FAC1_e+2	; FAC1 mantissa2
000000r 2               FAC1_3		= FAC1_e+3	; FAC1 mantissa3
000000r 2               FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln		= FAC1_e	; string length
000000r 2               str_pl		= FAC1_1	; string pointer low byte
000000r 2               str_ph		= FAC1_2	; string pointer high byte
000000r 2               
000000r 2               des_pl		= FAC1_2	; string descriptor pointer low byte
000000r 2               des_ph		= FAC1_3	; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l		= FAC1_3	; MID$ string temp length byte
000000r 2               
000000r 2               negnum		= $B1		; string to float eval -ve flag
000000r 2               numcon		= $B1		; series evaluation constant count
000000r 2               
000000r 2               FAC1_o		= $B2		; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e		= $B3		; FAC2 exponent
000000r 2               FAC2_1		= FAC2_e+1	; FAC2 mantissa1
000000r 2               FAC2_2		= FAC2_e+2	; FAC2 mantissa2
000000r 2               FAC2_3		= FAC2_e+3	; FAC2 mantissa3
000000r 2               FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r		= $B9		; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l		= FAC_sc	; string start pointer low byte
000000r 2               ssptr_h		= FAC1_r	; string start pointer high byte
000000r 2               
000000r 2               sdescr		= FAC_sc	; string descriptor pointer
000000r 2               
000000r 2               csidx			= $BA		; line crunch save index
000000r 2               Asptl			= csidx	; array size/pointer low byte
000000r 2               Aspth			= $BB		; array size/pointer high byte
000000r 2               
000000r 2               Btmpl			= Asptl	; BASIC pointer temp low byte
000000r 2               Btmph			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl			= Asptl	; BASIC pointer temp low byte
000000r 2               Cptrh			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl			= Asptl	; BASIC pointer temp low byte
000000r 2               Sendh			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               LAB_IGBY		= $BC		; get next BASIC byte subroutine
000000r 2               
000000r 2               LAB_GBYT		= $C2		; get current BASIC byte subroutine
000000r 2               Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               ;			= $D7		; end of get BASIC char subroutine
000000r 2               
000000r 2               Rbyte4		= $D8		; extra PRNG byte
000000r 2               Rbyte1		= Rbyte4+1	; most significant PRNG byte
000000r 2               Rbyte2		= Rbyte4+2	; middle PRNG byte
000000r 2               Rbyte3		= Rbyte4+3	; least significant PRNG byte
000000r 2               
000000r 2               NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
000000r 2               					; bit	function
000000r 2               					; ===	========
000000r 2               					; 7	interrupt enabled
000000r 2               					; 6	interrupt setup
000000r 2               					; 5	interrupt happened
000000r 2               ;			= $DD		; NMI handler addr low byte
000000r 2               ;			= $DE		; NMI handler addr high byte
000000r 2               IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
000000r 2               ;			= $E0		; IRQ handler addr low byte
000000r 2               ;			= $E1		; IRQ handler addr high byte
000000r 2               r0 = $E8 ; 2 bytes
000000r 2               r0L = $E8 ; low byte
000000r 2               r0H = $E9 ; high byte
000000r 2               r1 = $EA ; 2 bytes
000000r 2               r1L = $EA ; low byte
000000r 2               r1H = $EB ; high byte
000000r 2               r2 = $EC ; 2 bytes
000000r 2               r2L = $EC ; low byte
000000r 2               r2H = $ED ; high byte
000000r 2               lcd_addr = $E2 ; 1 byte, lcd busy flag and address
000000r 2               kb_wptr = $E3 ; 1 byte
000000r 2               kb_rptr = $E4 ; 1 byte
000000r 2               kb_flags = $E5 ; 1 byte
000000r 2               kb_modifiers = $E6 ; 1 byte
000000r 2               
000000r 2               ;			= $DE		; unused
000000r 2               ;			= $DF		; unused
000000r 2               ;			= $E0		; unused
000000r 2               ;			= $E1		; unused
000000r 2               ;			= $E2		; unused
000000r 2               ;			= $E3		; unused
000000r 2               ;			= $E4		; unused
000000r 2               ;			= $E5		; unused
000000r 2               ;			= $E6		; unused
000000r 2               ;			= $E7		; unused
000000r 2               ;			= $E8		; unused
000000r 2               ;			= $E9		; unused
000000r 2               ;			= $EA		; unused
000000r 2               ;			= $EB		; unused
000000r 2               ;			= $EC		; unused
000000r 2               ;			= $ED		; unused
000000r 2               ;			= $EE		; unused
000000r 2               
000000r 2               Decss			= $EF		; number to decimal string start
000000r 2               Decssp1		= Decss+1	; number to decimal string start
000000r 2               
000000r 2               ;			= $FF		; decimal string end
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END		= $80			; END token
000000r 2               TK_FOR		= TK_END+1		; FOR token
000000r 2               TK_NEXT		= TK_FOR+1		; NEXT token
000000r 2               TK_DATA		= TK_NEXT+1		; DATA token
000000r 2               TK_INPUT		= TK_DATA+1		; INPUT token
000000r 2               TK_DIM		= TK_INPUT+1	; DIM token
000000r 2               TK_READ		= TK_DIM+1		; READ token
000000r 2               TK_LET		= TK_READ+1		; LET token
000000r 2               TK_DEC		= TK_LET+1		; DEC token
000000r 2               TK_GOTO		= TK_DEC+1		; GOTO token
000000r 2               TK_RUN		= TK_GOTO+1		; RUN token
000000r 2               TK_IF			= TK_RUN+1		; IF token
000000r 2               TK_RESTORE		= TK_IF+1		; RESTORE token
000000r 2               TK_GOSUB		= TK_RESTORE+1	; GOSUB token
000000r 2               TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
000000r 2               TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
000000r 2               TK_RETURN		= TK_RETNMI+1	; RETURN token
000000r 2               TK_REM		= TK_RETURN+1	; REM token
000000r 2               TK_STOP		= TK_REM+1		; STOP token
000000r 2               TK_ON			= TK_STOP+1		; ON token
000000r 2               TK_NULL		= TK_ON+1		; NULL token
000000r 2               TK_INC		= TK_NULL+1		; INC token
000000r 2               TK_WAIT		= TK_INC+1		; WAIT token
000000r 2               TK_LOAD		= TK_WAIT+1		; LOAD token
000000r 2               TK_SAVE		= TK_LOAD+1		; SAVE token
000000r 2               TK_DEF		= TK_SAVE+1		; DEF token
000000r 2               TK_POKE		= TK_DEF+1		; POKE token
000000r 2               TK_DOKE		= TK_POKE+1		; DOKE token
000000r 2               TK_CALL		= TK_DOKE+1		; CALL token
000000r 2               TK_DO			= TK_CALL+1		; DO token
000000r 2               TK_LOOP		= TK_DO+1		; LOOP token
000000r 2               TK_PRINT		= TK_LOOP+1		; PRINT token
000000r 2               TK_CONT		= TK_PRINT+1	; CONT token
000000r 2               TK_LIST		= TK_CONT+1		; LIST token
000000r 2               TK_CLEAR		= TK_LIST+1		; CLEAR token
000000r 2               TK_NEW		= TK_CLEAR+1	; NEW token
000000r 2               TK_WIDTH		= TK_NEW+1		; WIDTH token
000000r 2               TK_GET		= TK_WIDTH+1	; GET token
000000r 2               TK_SWAP		= TK_GET+1		; SWAP token
000000r 2               TK_BITSET		= TK_SWAP+1		; BITSET token
000000r 2               TK_BITCLR		= TK_BITSET+1	; BITCLR token
000000r 2               TK_IRQ		= TK_BITCLR+1	; IRQ token
000000r 2               TK_NMI		= TK_IRQ+1		; NMI token
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB		= TK_NMI+1		; TAB token
000000r 2               TK_ELSE		= TK_TAB+1		; ELSE token
000000r 2               TK_TO			= TK_ELSE+1		; TO token
000000r 2               TK_FN			= TK_TO+1		; FN token
000000r 2               TK_SPC		= TK_FN+1		; SPC token
000000r 2               TK_THEN		= TK_SPC+1		; THEN token
000000r 2               TK_NOT		= TK_THEN+1		; NOT token
000000r 2               TK_STEP		= TK_NOT+1		; STEP token
000000r 2               TK_UNTIL		= TK_STEP+1		; UNTIL token
000000r 2               TK_WHILE		= TK_UNTIL+1	; WHILE token
000000r 2               TK_OFF		= TK_WHILE+1	; OFF token
000000r 2               
000000r 2               ; opperator tokens
000000r 2               
000000r 2               TK_PLUS		= TK_OFF+1		; + token
000000r 2               TK_MINUS		= TK_PLUS+1		; - token
000000r 2               TK_MUL		= TK_MINUS+1	; * token
000000r 2               TK_DIV		= TK_MUL+1		; / token
000000r 2               TK_POWER		= TK_DIV+1		; ^ token
000000r 2               TK_AND		= TK_POWER+1	; AND token
000000r 2               TK_EOR		= TK_AND+1		; EOR token
000000r 2               TK_OR			= TK_EOR+1		; OR token
000000r 2               TK_RSHIFT		= TK_OR+1		; RSHIFT token
000000r 2               TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
000000r 2               TK_GT			= TK_LSHIFT+1	; > token
000000r 2               TK_EQUAL		= TK_GT+1		; = token
000000r 2               TK_LT			= TK_EQUAL+1	; < token
000000r 2               
000000r 2               ; functions tokens
000000r 2               
000000r 2               TK_SGN		= TK_LT+1		; SGN token
000000r 2               TK_INT		= TK_SGN+1		; INT token
000000r 2               TK_ABS		= TK_INT+1		; ABS token
000000r 2               TK_USR		= TK_ABS+1		; USR token
000000r 2               TK_FRE		= TK_USR+1		; FRE token
000000r 2               TK_POS		= TK_FRE+1		; POS token
000000r 2               TK_SQR		= TK_POS+1		; SQR token
000000r 2               TK_RND		= TK_SQR+1		; RND token
000000r 2               TK_LOG		= TK_RND+1		; LOG token
000000r 2               TK_EXP		= TK_LOG+1		; EXP token
000000r 2               TK_COS		= TK_EXP+1		; COS token
000000r 2               TK_SIN		= TK_COS+1		; SIN token
000000r 2               TK_TAN		= TK_SIN+1		; TAN token
000000r 2               TK_ATN		= TK_TAN+1		; ATN token
000000r 2               TK_PEEK		= TK_ATN+1		; PEEK token
000000r 2               TK_DEEK		= TK_PEEK+1		; DEEK token
000000r 2               TK_SADD		= TK_DEEK+1		; SADD token
000000r 2               TK_LEN		= TK_SADD+1		; LEN token
000000r 2               TK_STRS		= TK_LEN+1		; STR$ token
000000r 2               TK_VAL		= TK_STRS+1		; VAL token
000000r 2               TK_ASC		= TK_VAL+1		; ASC token
000000r 2               TK_UCASES		= TK_ASC+1		; UCASE$ token
000000r 2               TK_LCASES		= TK_UCASES+1	; LCASE$ token
000000r 2               TK_CHRS		= TK_LCASES+1	; CHR$ token
000000r 2               TK_HEXS		= TK_CHRS+1		; HEX$ token
000000r 2               TK_BINS		= TK_HEXS+1		; BIN$ token
000000r 2               TK_BITTST		= TK_BINS+1		; BITTST token
000000r 2               TK_MAX		= TK_BITTST+1	; MAX token
000000r 2               TK_MIN		= TK_MAX+1		; MIN token
000000r 2               TK_PI			= TK_MIN+1		; PI token
000000r 2               TK_TWOPI		= TK_PI+1		; TWOPI token
000000r 2               TK_VPTR		= TK_TWOPI+1	; VARPTR token
000000r 2               TK_LEFTS		= TK_VPTR+1		; LEFT$ token
000000r 2               TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
000000r 2               TK_MIDS		= TK_RIGHTS+1	; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0		= $00		; X or Y plus 0
000000r 2               PLUS_1		= $01		; X or Y plus 1
000000r 2               PLUS_2		= $02		; X or Y plus 2
000000r 2               PLUS_3		= $03		; X or Y plus 3
000000r 2               
000000r 2               LAB_STAK		= $0100	; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE		= LAB_STAK+$FE
000000r 2               					; flushed stack address
000000r 2               LAB_SKFF		= LAB_STAK+$FF
000000r 2               					; flushed stack address
000000r 2               
000000r 2               ccflag		= $0300	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte		= ccflag+1	; BASIC CTRL-C byte
000000r 2               ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC		= ccnull+1	; ctrl c check vector
000000r 2               
000000r 2               VEC_IN		= VEC_CC+2	; input vector
000000r 2               VEC_OUT		= VEC_IN+2	; output vector
000000r 2               VEC_LD		= VEC_OUT+2	; load vector
000000r 2               VEC_SV		= VEC_LD+2	; save vector
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
000000r 2               
000000r 2               Ibuffs		= IRQ_vec+$14
000000r 2               					; start of input buffer after IRQ/NMI code
000000r 2               Ibuffe		= Ibuffs+$47; end of input buffer
000000r 2               
000000r 2               Ram_base		= $0500	; start of user RAM (set as needed, should be page aligned)
000000r 2               Ram_top		= $8000	; end of user RAM+1 (set as needed, should be page aligned)
000000r 2               
000000r 2               ; This start can be changed to suit your system
000000r 2               
000000r 2               	.org	$8000
008000  2               
008000  2               ; For convenience, put jump here to reset location so it can be
008000  2               ; run from the load address.
008000  2               
008000  2  4C 00 AD     JMP	RES_vec
008003  2               
008003  2               ; BASIC cold start entry point
008003  2               
008003  2               ; new page 2 initialisation, copy block to ccflag on
008003  2               
008003  2               LAB_COLD
008003  2  A0 04        	LDY	#PG2_TABE-PG2_TABS-1
008005  2               					; byte count-1
008005  2               LAB_2D13
008005  2  B9 F9 A0     	LDA	PG2_TABS,Y		; get byte
008008  2  99 00 03     	STA	ccflag,Y		; store in page 2
00800B  2  88           	DEY				; decrement count
00800C  2  10 F7        	BPL	LAB_2D13		; loop if not done
00800E  2               
00800E  2  A2 FF        	LDX	#$FF			; set byte
008010  2  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
008012  2  9A           	TXS				; reset stack pointer
008013  2               
008013  2  A9 4C        	LDA	#$4C			; code for JMP
008015  2  85 A1        	STA	Fnxjmp		; save for jump vector for functions
008017  2               
008017  2               ; copy block from LAB_2CEE to $00BC - $00D3
008017  2               
008017  2  A2 1C        	LDX	#StrTab-LAB_2CEE	; set byte count
008019  2               LAB_2D4E
008019  2  BD FD A0     	LDA	LAB_2CEE-1,X	; get byte from table
00801C  2  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
00801E  2  CA           	DEX				; decrement count
00801F  2  D0 F8        	BNE	LAB_2D4E		; loop if not all done
008021  2               
008021  2               ; copy block from StrTab to $0000 - $0012
008021  2               
008021  2               LAB_GMEM
008021  2  A2 12        	LDX	#EndTab-StrTab-1	; set byte count-1
008023  2               TabLoop
008023  2  BD 1A A1     	LDA	StrTab,X		; get byte from table
008026  2  95 00        	STA	PLUS_0,X		; save byte in page zero
008028  2  CA           	DEX				; decrement count
008029  2  10 F8        	BPL	TabLoop		; loop if not all done
00802B  2               
00802B  2               ; set-up start values
00802B  2               
00802B  2  A9 00        	LDA	#$00			; clear A
00802D  2  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
00802F  2  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
008031  2  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
008033  2  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
008035  2               
008035  2  A9 0E        	LDA	#$0E			; set default tab size
008037  2  85 64        	STA	TabSiz		; save it
008039  2  A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
00803B  2  85 A0        	STA	g_step		; save it
00803D  2  A2 68        	LDX	#des_sk		; descriptor stack start
00803F  2  86 65        	STX	next_s		; set descriptor stack pointer
008041  2  20 95 88     	JSR	LAB_CRLF		; print CR/LF
008044  2  A9 2D        	LDA	#<LAB_MSZM		; point to memory size message (low addr)
008046  2  A0 A1        	LDY	#>LAB_MSZM		; point to memory size message (high addr)
008048  2  20 D6 88     	JSR	LAB_18C3		; print null terminated string from memory
00804B  2  20 43 82     	JSR	LAB_INLN		; print "? " and get BASIC input
00804E  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
008050  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
008052  2  20 C2 00     	JSR	LAB_GBYT		; get last byte back
008055  2               
008055  2  D0 1F        	BNE	LAB_2DAA		; branch if not null (user typed something)
008057  2               
008057  2  A0 00        	LDY	#$00			; else clear Y
008059  2               					; character was null so get memory size the hard way
008059  2               					; we get here with Y=0 and Itempl/h = Ram_base
008059  2               LAB_2D93
008059  2  E6 11        	INC	Itempl		; increment temporary integer low byte
00805B  2  D0 08        	BNE	LAB_2D99		; branch if no overflow
00805D  2               
00805D  2  E6 12        	INC	Itemph		; increment temporary integer high byte
00805F  2  A5 12        	LDA	Itemph		; get high byte
008061  2  C9 80        	CMP	#>Ram_top		; compare with top of RAM+1
008063  2  F0 1D        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
008065  2               
008065  2               LAB_2D99
008065  2  A9 55        	LDA	#$55			; set test byte
008067  2  91 11        	STA	(Itempl),Y		; save via temporary integer
008069  2  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
00806B  2  D0 15        	BNE	LAB_2DB6		; branch if fail
00806D  2               
00806D  2  0A           	ASL				; shift test byte left (now $AA)
00806E  2  91 11        	STA	(Itempl),Y		; save via temporary integer
008070  2  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
008072  2  F0 E5        	BEQ	LAB_2D93		; if ok go do next byte
008074  2               
008074  2  D0 0C        	BNE	LAB_2DB6		; branch if fail
008076  2               
008076  2               LAB_2DAA
008076  2  20 A9 99     	JSR	LAB_2887		; get FAC1 from string
008079  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00807B  2  C9 98        	CMP	#$98			; compare with exponent = 2^24
00807D  2  B0 A2        	BCS	LAB_GMEM		; if too large go try again
00807F  2               
00807F  2  20 FA 94     	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
008082  2               					; (no range check)
008082  2               
008082  2               LAB_2DB6
008082  2  A5 11        	LDA	Itempl		; get temporary integer low byte
008084  2  A4 12        	LDY	Itemph		; get temporary integer high byte
008086  2  C0 01        	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
008088  2  90 97        	BCC	LAB_GMEM		; if too small go try again
00808A  2               
00808A  2               
00808A  2               ; uncomment these lines if you want to check on the high limit of memory. Note if
00808A  2               ; Ram_top is set too low then this will fail. default is ignore it and assume the
00808A  2               ; users know what they're doing!
00808A  2               
00808A  2               ;	CPY	#>Ram_top		; compare with top of RAM high byte
00808A  2               ;	BCC	MEM_OK		; branch if < RAM top
00808A  2               
00808A  2               ;	BNE	LAB_GMEM		; if too large go try again
00808A  2               					; else was = so compare low bytes
00808A  2               ;	CMP	#<Ram_top		; compare with top of RAM low byte
00808A  2               ;	BEQ	MEM_OK		; branch if = RAM top
00808A  2               
00808A  2               ;	BCS	LAB_GMEM		; if too large go try again
00808A  2               
00808A  2               ;MEM_OK
00808A  2  85 85        	STA	Ememl			; set end of mem low byte
00808C  2  84 86        	STY	Ememh			; set end of mem high byte
00808E  2  85 81        	STA	Sstorl		; set bottom of string space low byte
008090  2  84 82        	STY	Sstorh		; set bottom of string space high byte
008092  2               
008092  2  A0 00        	LDY	#<Ram_base		; set start addr low byte
008094  2  A2 05        	LDX	#>Ram_base		; set start addr high byte
008096  2  84 79        	STY	Smeml			; save start of mem low byte
008098  2  86 7A        	STX	Smemh			; save start of mem high byte
00809A  2               
00809A  2               ; this line is only needed if Ram_base is not $xx00
00809A  2               
00809A  2               ;	LDY	#$00			; clear Y
00809A  2  98           	TYA				; clear A
00809B  2  91 79        	STA	(Smeml),Y		; clear first byte
00809D  2  E6 79        	INC	Smeml			; increment start of mem low byte
00809F  2               
00809F  2               ; these two lines are only needed if Ram_base is $xxFF
00809F  2               
00809F  2               ;	BNE	LAB_2E05		; branch if no rollover
00809F  2               
00809F  2               ;	INC	Smemh			; increment start of mem high byte
00809F  2               LAB_2E05
00809F  2  20 95 88     	JSR	LAB_CRLF		; print CR/LF
0080A2  2  20 53 83     	JSR	LAB_1463		; do "NEW" and "CLEAR"
0080A5  2  A5 85        	LDA	Ememl			; get end of mem low byte
0080A7  2  38           	SEC				; set carry for subtract
0080A8  2  E5 79        	SBC	Smeml			; subtract start of mem low byte
0080AA  2  AA           	TAX				; copy to X
0080AB  2  A5 86        	LDA	Ememh			; get end of mem high byte
0080AD  2  E5 7A        	SBC	Smemh			; subtract start of mem high byte
0080AF  2  20 85 9A     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
0080B2  2  A9 3C        	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
0080B4  2  A0 A1        	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
0080B6  2  20 D6 88     	JSR	LAB_18C3		; print null terminated string from memory
0080B9  2  A9 5D        	LDA	#<LAB_1274		; warm start vector low byte
0080BB  2  A0 81        	LDY	#>LAB_1274		; warm start vector high byte
0080BD  2  85 01        	STA	Wrmjpl		; save warm start vector low byte
0080BF  2  84 02        	STY	Wrmjph		; save warm start vector high byte
0080C1  2  6C 01 00     	JMP	(Wrmjpl)		; go do warm start
0080C4  2               
0080C4  2               ; open up space in memory
0080C4  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0080C4  2               
0080C4  2               ; Nbendl,Nbendh - new block end address (A/Y)
0080C4  2               ; Obendl,Obendh - old block end address
0080C4  2               ; Ostrtl,Ostrth - old block start address
0080C4  2               
0080C4  2               ; returns with ..
0080C4  2               
0080C4  2               ; Nbendl,Nbendh - new block start address (high byte - $100)
0080C4  2               ; Obendl,Obendh - old block start address (high byte - $100)
0080C4  2               ; Ostrtl,Ostrth - old block start address (unchanged)
0080C4  2               
0080C4  2               LAB_11CF
0080C4  2  20 0E 81     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
0080C7  2               					; addr to check is in AY (low/high)
0080C7  2  85 7F        	STA	Earryl		; save new array mem end low byte
0080C9  2  84 80        	STY	Earryh		; save new array mem end high byte
0080CB  2               
0080CB  2               ; open up space in memory
0080CB  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0080CB  2               ; don't set array end
0080CB  2               
0080CB  2               LAB_11D6
0080CB  2  38           	SEC				; set carry for subtract
0080CC  2  A5 A6        	LDA	Obendl		; get block end low byte
0080CE  2  E5 AA        	SBC	Ostrtl		; subtract block start low byte
0080D0  2  A8           	TAY				; copy MOD(block length/$100) byte to Y
0080D1  2  A5 A7        	LDA	Obendh		; get block end high byte
0080D3  2  E5 AB        	SBC	Ostrth		; subtract block start high byte
0080D5  2  AA           	TAX				; copy block length high byte to X
0080D6  2  E8           	INX				; +1 to allow for count=0 exit
0080D7  2  98           	TYA				; copy block length low byte to A
0080D8  2  F0 24        	BEQ	LAB_120A		; branch if length low byte=0
0080DA  2               
0080DA  2               					; block is (X-1)*256+Y bytes, do the Y bytes first
0080DA  2               
0080DA  2  38           	SEC				; set carry for add + 1, two's complement
0080DB  2  49 FF        	EOR	#$FF			; invert low byte for subtract
0080DD  2  65 A6        	ADC	Obendl		; add block end low byte
0080DF  2               
0080DF  2  85 A6        	STA	Obendl		; save corrected old block end low byte
0080E1  2  B0 03        	BCS	LAB_11F3		; branch if no underflow
0080E3  2               
0080E3  2  C6 A7        	DEC	Obendh		; else decrement block end high byte
0080E5  2  38           	SEC				; set carry for add + 1, two's complement
0080E6  2               LAB_11F3
0080E6  2  98           	TYA				; get MOD(block length/$100) byte
0080E7  2  49 FF        	EOR	#$FF			; invert low byte for subtract
0080E9  2  65 A4        	ADC	Nbendl		; add destination end low byte
0080EB  2  85 A4        	STA	Nbendl		; save modified new block end low byte
0080ED  2  B0 08        	BCS	LAB_1203		; branch if no underflow
0080EF  2               
0080EF  2  C6 A5        	DEC	Nbendh		; else decrement block end high byte
0080F1  2  90 04        	BCC	LAB_1203		; branch always
0080F3  2               
0080F3  2               LAB_11FF
0080F3  2  B1 A6        	LDA	(Obendl),Y		; get byte from source
0080F5  2  91 A4        	STA	(Nbendl),Y		; copy byte to destination
0080F7  2               LAB_1203
0080F7  2  88           	DEY				; decrement index
0080F8  2  D0 F9        	BNE	LAB_11FF		; loop until Y=0
0080FA  2               
0080FA  2               					; now do Y=0 indexed byte
0080FA  2  B1 A6        	LDA	(Obendl),Y		; get byte from source
0080FC  2  91 A4        	STA	(Nbendl),Y		; save byte to destination
0080FE  2               LAB_120A
0080FE  2  C6 A7        	DEC	Obendh		; decrement source pointer high byte
008100  2  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
008102  2  CA           	DEX				; decrement block count
008103  2  D0 F2        	BNE	LAB_1203		; loop until count = $0
008105  2               
008105  2  60           	RTS
008106  2               
008106  2               ; check room on stack for A bytes
008106  2               ; stack too deep? do OM error
008106  2               
008106  2               LAB_1212
008106  2  85 78        	STA	TempB			; save result in temp byte
008108  2  BA           	TSX				; copy stack
008109  2  E4 78        	CPX	TempB			; compare new "limit" with stack
00810B  2  90 30        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
00810D  2               
00810D  2  60           	RTS
00810E  2               
00810E  2               ; check available memory, "Out of memory" error if no room
00810E  2               ; addr to check is in AY (low/high)
00810E  2               
00810E  2               LAB_121F
00810E  2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
008110  2  90 2A        	BCC	LAB_124B		; if less then exit (is ok)
008112  2               
008112  2  D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
008114  2               
008114  2               					; high byte was =, now do low byte
008114  2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
008116  2  90 24        	BCC	LAB_124B		; if less then exit (is ok)
008118  2               
008118  2               					; addr is > string storage ptr (oops!)
008118  2               LAB_1229
008118  2  48           	PHA				; push addr low byte
008119  2  A2 08        	LDX	#$08			; set index to save Adatal to expneg inclusive
00811B  2  98           	TYA				; copy addr high byte (to push on stack)
00811C  2               
00811C  2               					; save misc numeric work area
00811C  2               LAB_122D
00811C  2  48           	PHA				; push byte
00811D  2  B5 A3        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
00811F  2  CA           	DEX				; decrement index
008120  2  10 FA        	BPL	LAB_122D		; loop until all done
008122  2               
008122  2  20 E2 91     	JSR	LAB_GARB		; garbage collection routine
008125  2               
008125  2               					; restore misc numeric work area
008125  2  A2 00        	LDX	#$00			; clear the index to restore bytes
008127  2               LAB_1238
008127  2  68           	PLA				; pop byte
008128  2  95 A4        	STA	Adatal,X		; save byte to Adatal to expneg
00812A  2  E8           	INX				; increment index
00812B  2  E0 08        	CPX	#$08			; compare with end + 1
00812D  2  30 F8        	BMI	LAB_1238		; loop if more to do
00812F  2               
00812F  2  68           	PLA				; pop addr high byte
008130  2  A8           	TAY				; copy back to Y
008131  2  68           	PLA				; pop addr low byte
008132  2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
008134  2  90 06        	BCC	LAB_124B		; if less then exit (is ok)
008136  2               
008136  2  D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
008138  2               
008138  2               					; high byte was =, now do low byte
008138  2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00813A  2  B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
00813C  2               
00813C  2               					; ok exit, carry clear
00813C  2               LAB_124B
00813C  2  60           	RTS
00813D  2               
00813D  2               ; do "Out of memory" error then warm start
00813D  2               
00813D  2               LAB_OMER
00813D  2  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
00813F  2               
00813F  2               ; do error #X, then warm start
00813F  2               
00813F  2               LAB_XERR
00813F  2  20 95 88     	JSR	LAB_CRLF		; print CR/LF
008142  2               
008142  2  BD AC A6     	LDA	LAB_BAER,X		; get error message pointer low byte
008145  2  BC AD A6     	LDY	LAB_BAER+1,X	; get error message pointer high byte
008148  2  20 D6 88     	JSR	LAB_18C3		; print null terminated string from memory
00814B  2               
00814B  2  20 8C 83     	JSR	LAB_1491		; flush stack and clear continue flag
00814E  2  A9 E9        	LDA	#<LAB_EMSG		; point to " Error" low addr
008150  2  A0 A7        	LDY	#>LAB_EMSG		; point to " Error" high addr
008152  2               LAB_1269
008152  2  20 D6 88     	JSR	LAB_18C3		; print null terminated string from memory
008155  2  A4 88        	LDY	Clineh		; get current line high byte
008157  2  C8           	INY				; increment it
008158  2  F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
00815A  2               
00815A  2               					; else print line number
00815A  2  20 7A 9A     	JSR	LAB_2953		; print " in line [LINE #]"
00815D  2               
00815D  2               ; BASIC warm start entry point
00815D  2               ; wait for Basic command
00815D  2               
00815D  2               LAB_1274
00815D  2               					; clear ON IRQ/NMI bytes
00815D  2  A9 00        	LDA	#$00			; clear A
00815F  2  85 DF        	STA	IrqBase		; clear enabled byte
008161  2  85 DC        	STA	NmiBase		; clear enabled byte
008163  2  A9 FA        	LDA	#<LAB_RMSG		; point to "Ready" message low byte
008165  2  A0 A7        	LDY	#>LAB_RMSG		; point to "Ready" message high byte
008167  2               
008167  2  20 D6 88     	JSR	LAB_18C3		; go do print string
00816A  2               
00816A  2               ; wait for Basic command (no "Ready")
00816A  2               
00816A  2               LAB_127D
00816A  2  20 50 82     	JSR	LAB_1357		; call for BASIC input
00816D  2               LAB_1280
00816D  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00816F  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
008171  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008174  2  F0 F4        	BEQ	LAB_127D		; loop while null
008176  2               
008176  2               ; got to interpret input line now ..
008176  2               
008176  2  A2 FF        	LDX	#$FF			; current line to null value
008178  2  86 88        	STX	Clineh		; set current line high byte
00817A  2  90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
00817C  2               
00817C  2               					; no line number .. immediate mode
00817C  2  20 81 82     	JSR	LAB_13A6		; crunch keywords into Basic tokens
00817F  2  4C F6 84     	JMP	LAB_15F6		; go scan and interpret code
008182  2               
008182  2               ; handle new BASIC line
008182  2               
008182  2               LAB_1295
008182  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer
008185  2  20 81 82     	JSR	LAB_13A6		; crunch keywords into Basic tokens
008188  2  84 5D        	STY	Ibptr			; save index pointer to end of crunched line
00818A  2  20 27 83     	JSR	LAB_SSLN		; search BASIC for temp integer line number
00818D  2  90 44        	BCC	LAB_12E6		; branch if not found
00818F  2               
00818F  2               					; aroooogah! line # already exists! delete it
00818F  2  A0 01        	LDY	#$01			; set index to next line pointer high byte
008191  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
008193  2  85 72        	STA	ut1_ph		; save it
008195  2  A5 7B        	LDA	Svarl			; get start of vars low byte
008197  2  85 71        	STA	ut1_pl		; save it
008199  2  A5 AB        	LDA	Baslnh		; get found line pointer high byte
00819B  2  85 74        	STA	ut2_ph		; save it
00819D  2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00819F  2  88           	DEY				; decrement index
0081A0  2  F1 AA        	SBC	(Baslnl),Y		; subtract next line pointer low byte
0081A2  2  18           	CLC				; clear carry for add
0081A3  2  65 7B        	ADC	Svarl			; add start of vars low byte
0081A5  2  85 7B        	STA	Svarl			; save new start of vars low byte
0081A7  2  85 73        	STA	ut2_pl		; save destination pointer low byte
0081A9  2  A5 7C        	LDA	Svarh			; get start of vars high byte
0081AB  2  69 FF        	ADC	#$FF			; -1 + carry
0081AD  2  85 7C        	STA	Svarh			; save start of vars high byte
0081AF  2  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
0081B1  2  AA           	TAX				; copy to block count
0081B2  2  38           	SEC				; set carry for subtract
0081B3  2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
0081B5  2  E5 7B        	SBC	Svarl			; subtract start of vars low byte
0081B7  2  A8           	TAY				; copy to bytes in first block count
0081B8  2  B0 03        	BCS	LAB_12D0		; branch if overflow
0081BA  2               
0081BA  2  E8           	INX				; increment block count (correct for =0 loop exit)
0081BB  2  C6 74        	DEC	ut2_ph		; decrement destination high byte
0081BD  2               LAB_12D0
0081BD  2  18           	CLC				; clear carry for add
0081BE  2  65 71        	ADC	ut1_pl		; add source pointer low byte
0081C0  2  90 03        	BCC	LAB_12D8		; branch if no overflow
0081C2  2               
0081C2  2  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
0081C4  2  18           	CLC				; clear carry
0081C5  2               
0081C5  2               					; close up memory to delete old line
0081C5  2               LAB_12D8
0081C5  2  B1 71        	LDA	(ut1_pl),Y		; get byte from source
0081C7  2  91 73        	STA	(ut2_pl),Y		; copy to destination
0081C9  2  C8           	INY				; increment index
0081CA  2  D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
0081CC  2               
0081CC  2  E6 72        	INC	ut1_ph		; increment source pointer high byte
0081CE  2  E6 74        	INC	ut2_ph		; increment destination pointer high byte
0081D0  2  CA           	DEX				; decrement block count
0081D1  2  D0 F2        	BNE	LAB_12D8		; loop until all done
0081D3  2               
0081D3  2               					; got new line in buffer and no existing same #
0081D3  2               LAB_12E6
0081D3  2  AD 21 03     	LDA	Ibuffs		; get byte from start of input buffer
0081D6  2  F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
0081D8  2               
0081D8  2               					; got new line and it isn't empty line
0081D8  2  A5 85        	LDA	Ememl			; get end of mem low byte
0081DA  2  A4 86        	LDY	Ememh			; get end of mem high byte
0081DC  2  85 81        	STA	Sstorl		; set bottom of string space low byte
0081DE  2  84 82        	STY	Sstorh		; set bottom of string space high byte
0081E0  2  A5 7B        	LDA	Svarl			; get start of vars low byte	(end of BASIC)
0081E2  2  85 A6        	STA	Obendl		; save old block end low byte
0081E4  2  A4 7C        	LDY	Svarh			; get start of vars high byte	(end of BASIC)
0081E6  2  84 A7        	STY	Obendh		; save old block end high byte
0081E8  2  65 5D        	ADC	Ibptr			; add input buffer pointer	(also buffer length)
0081EA  2  90 01        	BCC	LAB_1301		; branch if no overflow from add
0081EC  2               
0081EC  2  C8           	INY				; else increment high byte
0081ED  2               LAB_1301
0081ED  2  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
0081EF  2  84 A5        	STY	Nbendh		; save new block end high byte
0081F1  2  20 C4 80     	JSR	LAB_11CF		; open up space in memory
0081F4  2               					; old start pointer Ostrtl,Ostrth set by the find line call
0081F4  2  A5 7F        	LDA	Earryl		; get array mem end low byte
0081F6  2  A4 80        	LDY	Earryh		; get array mem end high byte
0081F8  2  85 7B        	STA	Svarl			; save start of vars low byte
0081FA  2  84 7C        	STY	Svarh			; save start of vars high byte
0081FC  2  A4 5D        	LDY	Ibptr			; get input buffer pointer	(also buffer length)
0081FE  2  88           	DEY				; adjust for loop type
0081FF  2               LAB_1311
0081FF  2  B9 1D 03     	LDA	Ibuffs-4,Y		; get byte from crunched line
008202  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
008204  2  88           	DEY				; decrement count
008205  2  C0 03        	CPY	#$03			; compare with first byte-1
008207  2  D0 F6        	BNE	LAB_1311		; continue while count <> 3
008209  2               
008209  2  A5 12        	LDA	Itemph		; get line # high byte
00820B  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00820D  2  88           	DEY				; decrement count
00820E  2  A5 11        	LDA	Itempl		; get line # low byte
008210  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
008212  2  88           	DEY				; decrement count
008213  2  A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
008215  2               					; byte then a zero already here would stop the chain rebuild
008215  2               					; as it would think it was the [EOT] marker.
008215  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
008217  2               
008217  2               LAB_1319
008217  2  20 68 83     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
00821A  2  A6 79        	LDX	Smeml			; get start of mem low byte
00821C  2  A5 7A        	LDA	Smemh			; get start of mem high byte
00821E  2  A0 01        	LDY	#$01			; index to high byte of next line pointer
008220  2               LAB_1325
008220  2  86 71        	STX	ut1_pl		; set line start pointer low byte
008222  2  85 72        	STA	ut1_ph		; set line start pointer high byte
008224  2  B1 71        	LDA	(ut1_pl),Y		; get it
008226  2  F0 18        	BEQ	LAB_133E		; exit if end of program
008228  2               
008228  2               ; rebuild chaining of Basic lines
008228  2               
008228  2  A0 04        	LDY	#$04			; point to first code byte of line
00822A  2               					; there is always 1 byte + [EOL] as null entries are deleted
00822A  2               LAB_1330
00822A  2  C8           	INY				; next code byte
00822B  2  B1 71        	LDA	(ut1_pl),Y		; get byte
00822D  2  D0 FB        	BNE	LAB_1330		; loop if not [EOL]
00822F  2               
00822F  2  38           	SEC				; set carry for add + 1
008230  2  98           	TYA				; copy end index
008231  2  65 71        	ADC	ut1_pl		; add to line start pointer low byte
008233  2  AA           	TAX				; copy to X
008234  2  A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
008236  2  91 71        	STA	(ut1_pl),Y		; set next line pointer low byte
008238  2  98           	TYA				; clear A
008239  2  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
00823B  2  C8           	INY				; increment index to high byte
00823C  2  91 71        	STA	(ut1_pl),Y		; save next line pointer low byte
00823E  2  90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
008240  2               
008240  2               
008240  2               LAB_133E
008240  2  4C 6A 81     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
008243  2               
008243  2               ; print "? " and get BASIC input
008243  2               
008243  2               LAB_INLN
008243  2  20 EE 88     	JSR	LAB_18E3		; print "?" character
008246  2  20 EB 88     	JSR	LAB_18E0		; print " "
008249  2  D0 05        	BNE	LAB_1357		; call for BASIC input and return
00824B  2               
00824B  2               ; receive line from keyboard
00824B  2               
00824B  2               					; $08 as delete key (BACKSPACE on standard keyboard)
00824B  2               LAB_134B
00824B  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
00824E  2  CA           	DEX				; decrement the buffer counter (delete)
00824F  2  2C           	.byte	$2C			; make LDX into BIT abs
008250  2               
008250  2               ; call for BASIC input (main entry point)
008250  2               
008250  2               LAB_1357
008250  2  A2 00        	LDX	#$00			; clear BASIC line buffer pointer
008252  2               LAB_1359
008252  2  20 ED A0     	JSR	V_INPT		; call scan input device
008255  2  90 FB        	BCC	LAB_1359		; loop if no byte
008257  2               
008257  2  F0 F9        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
008259  2               
008259  2  C9 07        	CMP	#$07			; compare with [BELL]
00825B  2  F0 10        	BEQ	LAB_1378		; branch if [BELL]
00825D  2               
00825D  2  C9 0D        	CMP	#$0D			; compare with [CR]
00825F  2  F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
008261  2               
008261  2  E0 00        	CPX	#$00			; compare pointer with $00
008263  2  D0 04        	BNE	LAB_1374		; branch if not empty
008265  2               
008265  2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
008265  2               
008265  2  C9 21        	CMP	#$21			; compare with [SP]+1
008267  2  90 E9        	BCC	LAB_1359		; if < ignore character
008269  2               
008269  2               LAB_1374
008269  2  C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
00826B  2  F0 DE        	BEQ	LAB_134B		; go delete last character
00826D  2               
00826D  2               LAB_1378
00826D  2  E0 47        	CPX	#Ibuffe-Ibuffs	; compare character count with max
00826F  2  B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
008271  2               
008271  2  9D 21 03     	STA	Ibuffs,X		; else store in buffer
008274  2  E8           	INX				; increment pointer
008275  2               LAB_137F
008275  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
008278  2  D0 D8        	BNE	LAB_1359		; always loop for next character
00827A  2               
00827A  2               LAB_1384
00827A  2  4C 8C 88     	JMP	LAB_1866		; do CR/LF exit to BASIC
00827D  2               
00827D  2               ; announce buffer full
00827D  2               
00827D  2               LAB_138E
00827D  2  A9 07        	LDA	#$07			; [BELL] character into A
00827F  2  D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
008281  2               					; branch always
008281  2               
008281  2               ; crunch keywords into Basic tokens
008281  2               ; position independent buffer version ..
008281  2               ; faster, dictionary search version ....
008281  2               
008281  2               LAB_13A6
008281  2  A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
008283  2               
008283  2  38           	SEC				; set carry for subtract
008284  2  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
008286  2  E9 21        	SBC	#<Ibuffs		; subtract input buffer start pointer
008288  2  AA           	TAX				; copy result to X (index past line # if any)
008289  2               
008289  2  86 60        	STX	Oquote		; clear open quote/DATA flag
00828B  2               LAB_13AC
00828B  2  BD 21 03     	LDA	Ibuffs,X		; get byte from input buffer
00828E  2  F0 51        	BEQ	LAB_13EC		; if null save byte then exit
008290  2               
008290  2  C9 5F        	CMP	#'_'			; compare with "_"
008292  2  B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
008294  2               
008294  2  C9 3C        	CMP	#'<'			; compare with "<"
008296  2  B0 0E        	BCS	LAB_13CC		; if >= go crunch now
008298  2               
008298  2  C9 30        	CMP	#'0'			; compare with "0"
00829A  2  B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
00829C  2               
00829C  2  85 5C        	STA	Scnquo		; save buffer byte as search character
00829E  2  C9 22        	CMP	#$22			; is it quote character?
0082A0  2  F0 61        	BEQ	LAB_1410		; branch if so (copy quoted string)
0082A2  2               
0082A2  2  C9 2A        	CMP	#'*'			; compare with "*"
0082A4  2  90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
0082A6  2               
0082A6  2               					; else crunch now
0082A6  2               LAB_13CC
0082A6  2  24 60        	BIT	Oquote		; get open quote/DATA token flag
0082A8  2  70 37        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
0082AA  2               					; go save byte then continue crunching
0082AA  2               
0082AA  2  86 78        	STX	TempB			; save buffer read index
0082AC  2  84 BA        	STY	csidx			; copy buffer save index
0082AE  2  A0 13        	LDY	#<TAB_1STC		; get keyword first character table low address
0082B0  2  84 73        	STY	ut2_pl		; save pointer low byte
0082B2  2  A0 A3        	LDY	#>TAB_1STC		; get keyword first character table high address
0082B4  2  84 74        	STY	ut2_ph		; save pointer high byte
0082B6  2  A0 00        	LDY	#$00			; clear table pointer
0082B8  2               
0082B8  2               LAB_13D0
0082B8  2  D1 73        	CMP	(ut2_pl),Y		; compare with keyword first character table byte
0082BA  2  F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
0082BC  2               
0082BC  2  90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
0082BE  2               					; Y and save to crunched
0082BE  2               
0082BE  2  C8           	INY				; else increment pointer
0082BF  2  D0 F7        	BNE	LAB_13D0		; and loop (branch always)
0082C1  2               
0082C1  2               ; have matched first character of some keyword
0082C1  2               
0082C1  2               LAB_13D1
0082C1  2  98           	TYA				; copy matching index
0082C2  2  0A           	ASL				; *2 (bytes per pointer)
0082C3  2  AA           	TAX				; copy to new index
0082C4  2  BD 31 A3     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
0082C7  2  85 73        	STA	ut2_pl		; save pointer low byte
0082C9  2  BD 32 A3     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
0082CC  2  85 74        	STA	ut2_ph		; save pointer high byte
0082CE  2               
0082CE  2  A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
0082D0  2               
0082D0  2  A6 78        	LDX	TempB			; restore buffer read index
0082D2  2               
0082D2  2               LAB_13D6
0082D2  2  C8           	INY				; next table byte
0082D3  2  B1 73        	LDA	(ut2_pl),Y		; get byte from table
0082D5  2               LAB_13D8
0082D5  2  30 08        	BMI	LAB_13EA		; all bytes matched so go save token
0082D7  2               
0082D7  2  E8           	INX				; next buffer byte
0082D8  2  DD 21 03     	CMP	Ibuffs,X		; compare with byte from input buffer
0082DB  2  F0 F5        	BEQ	LAB_13D6		; go compare next if match
0082DD  2               
0082DD  2  D0 2B        	BNE	LAB_1417		; branch if >< (not found keyword)
0082DF  2               
0082DF  2               LAB_13EA
0082DF  2  A4 BA        	LDY	csidx			; restore save index
0082E1  2               
0082E1  2               					; save crunched to output
0082E1  2               LAB_13EC
0082E1  2  E8           	INX				; increment buffer index (to next input byte)
0082E2  2  C8           	INY				; increment save index (to next output byte)
0082E3  2  99 21 03     	STA	Ibuffs,Y		; save byte to output
0082E6  2  C9 00        	CMP	#$00			; set the flags, set carry
0082E8  2  F0 32        	BEQ	LAB_142A		; do exit if was null [EOL]
0082EA  2               
0082EA  2               					; A holds token or byte here
0082EA  2  E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
0082EC  2  F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
0082EE  2               
0082EE  2               					; A now holds token-$3A
0082EE  2  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
0082F0  2  D0 02        	BNE	LAB_1401		; branch if not DATA
0082F2  2               
0082F2  2               					; token was : or DATA
0082F2  2               LAB_13FF
0082F2  2  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0082F4  2               LAB_1401
0082F4  2  49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
0082F6  2  D0 93        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
0082F8  2               
0082F8  2  85 5C        	STA	Asrch			; else was REM so set search for [EOL]
0082FA  2               
0082FA  2               					; loop for REM, "..." etc.
0082FA  2               LAB_1408
0082FA  2  BD 21 03     	LDA	Ibuffs,X		; get byte from input buffer
0082FD  2  F0 E2        	BEQ	LAB_13EC		; branch if null [EOL]
0082FF  2               
0082FF  2  C5 5C        	CMP	Asrch			; compare with stored character
008301  2  F0 DE        	BEQ	LAB_13EC		; branch if match (end quote)
008303  2               
008303  2               					; entry for copy string in quotes, don't crunch
008303  2               LAB_1410
008303  2  C8           	INY				; increment buffer save index
008304  2  99 21 03     	STA	Ibuffs,Y		; save byte to output
008307  2  E8           	INX				; increment buffer read index
008308  2  D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
00830A  2               
00830A  2               					; not found keyword this go
00830A  2               LAB_1417
00830A  2  A6 78        	LDX	TempB			; compare has failed, restore buffer index (start byte!)
00830C  2               
00830C  2               					; now find the end of this word in the table
00830C  2               LAB_141B
00830C  2  B1 73        	LDA	(ut2_pl),Y		; get table byte
00830E  2  08           	PHP				; save status
00830F  2  C8           	INY				; increment table index
008310  2  28           	PLP				; restore byte status
008311  2  10 F9        	BPL	LAB_141B		; if not end of keyword go do next
008313  2               
008313  2  B1 73        	LDA	(ut2_pl),Y		; get byte from keyword table
008315  2  D0 BE        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
008317  2               
008317  2               					; reached end of table with no match
008317  2  BD 21 03     	LDA	Ibuffs,X		; restore byte from input buffer
00831A  2  10 C3        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
00831C  2               					; go save byte in output and continue crunching
00831C  2               
00831C  2               					; reached [EOL]
00831C  2               LAB_142A
00831C  2  C8           	INY				; increment pointer
00831D  2  C8           	INY				; increment pointer (makes it next line pointer high byte)
00831E  2  99 21 03     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
008321  2  C8           	INY				; adjust for line copy
008322  2  C8           	INY				; adjust for line copy
008323  2  C8           	INY				; adjust for line copy
008324  2  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
008326  2  60           	RTS
008327  2               
008327  2               ; search Basic for temp integer line number from start of mem
008327  2               
008327  2               LAB_SSLN
008327  2  A5 79        	LDA	Smeml			; get start of mem low byte
008329  2  A6 7A        	LDX	Smemh			; get start of mem high byte
00832B  2               
00832B  2               ; search Basic for temp integer line number from AX
00832B  2               ; returns carry set if found
00832B  2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
00832B  2               
00832B  2               ; old 541 new 507
00832B  2               
00832B  2               LAB_SHLN
00832B  2  A0 01        	LDY	#$01			; set index
00832D  2  85 AA        	STA	Baslnl		; save low byte as current
00832F  2  86 AB        	STX	Baslnh		; save high byte as current
008331  2  B1 AA        	LDA	(Baslnl),Y		; get pointer high byte from addr
008333  2  F0 1A        	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
008335  2               
008335  2  A0 03        	LDY	#$03			; set index to line # high byte
008337  2  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
008339  2  88           	DEY				; decrement index (point to low byte)
00833A  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00833C  2  D0 04        	BNE	LAB_1455		; if <> skip low byte check
00833E  2               
00833E  2  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
008340  2  C5 11        	CMP	Itempl		; compare with temporary integer low byte
008342  2               LAB_1455
008342  2  B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
008344  2               
008344  2               LAB_1456
008344  2  88           	DEY				; decrement index to next line ptr high byte
008345  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
008347  2  AA           	TAX				; copy to X
008348  2  88           	DEY				; decrement index to next line ptr low byte
008349  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
00834B  2  90 DE        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
00834D  2               					; (carry always clear)
00834D  2               
00834D  2               LAB_145E
00834D  2  F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
00834F  2               
00834F  2               LAB_145F
00834F  2  18           	CLC				; clear found flag
008350  2               LAB_1460
008350  2  60           	RTS
008351  2               
008351  2               ; perform NEW
008351  2               
008351  2               LAB_NEW
008351  2  D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
008353  2               
008353  2               LAB_1463
008353  2  A9 00        	LDA	#$00			; clear A
008355  2  A8           	TAY				; clear Y
008356  2  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, low byte
008358  2  C8           	INY				; increment index
008359  2  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, high byte
00835B  2  18           	CLC				; clear carry
00835C  2  A5 79        	LDA	Smeml			; get start of mem low byte
00835E  2  69 02        	ADC	#$02			; calculate end of BASIC low byte
008360  2  85 7B        	STA	Svarl			; save start of vars low byte
008362  2  A5 7A        	LDA	Smemh			; get start of mem high byte
008364  2  69 00        	ADC	#$00			; add any carry
008366  2  85 7C        	STA	Svarh			; save start of vars high byte
008368  2               
008368  2               ; reset execution to start, clear vars and flush stack
008368  2               
008368  2               LAB_1477
008368  2  18           	CLC				; clear carry
008369  2  A5 79        	LDA	Smeml			; get start of mem low byte
00836B  2  69 FF        	ADC	#$FF			; -1
00836D  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00836F  2  A5 7A        	LDA	Smemh			; get start of mem high byte
008371  2  69 FF        	ADC	#$FF			; -1+carry
008373  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
008375  2               
008375  2               ; "CLEAR" command gets here
008375  2               
008375  2               LAB_147A
008375  2  A5 85        	LDA	Ememl			; get end of mem low byte
008377  2  A4 86        	LDY	Ememh			; get end of mem high byte
008379  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00837B  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00837D  2  A5 7B        	LDA	Svarl			; get start of vars low byte
00837F  2  A4 7C        	LDY	Svarh			; get start of vars high byte
008381  2  85 7D        	STA	Sarryl		; save var mem end low byte
008383  2  84 7E        	STY	Sarryh		; save var mem end high byte
008385  2  85 7F        	STA	Earryl		; save array mem end low byte
008387  2  84 80        	STY	Earryh		; save array mem end high byte
008389  2  20 47 85     	JSR	LAB_161A		; perform RESTORE command
00838C  2               
00838C  2               ; flush stack and clear continue flag
00838C  2               
00838C  2               LAB_1491
00838C  2  A2 68        	LDX	#des_sk		; set descriptor stack pointer
00838E  2  86 65        	STX	next_s		; save descriptor stack pointer
008390  2  68           	PLA				; pull return address low byte
008391  2  AA           	TAX				; copy return address low byte
008392  2  68           	PLA				; pull return address high byte
008393  2  8E FE 01     	STX	LAB_SKFE		; save to cleared stack
008396  2  8D FF 01     	STA	LAB_SKFF		; save to cleared stack
008399  2  A2 FD        	LDX	#$FD			; new stack pointer
00839B  2  9A           	TXS				; reset stack
00839C  2  A9 00        	LDA	#$00			; clear byte
00839E  2  85 8C        	STA	Cpntrh		; clear continue pointer high byte
0083A0  2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
0083A2  2               LAB_14A6
0083A2  2  60           	RTS
0083A3  2               
0083A3  2               ; perform CLEAR
0083A3  2               
0083A3  2               LAB_CLEAR
0083A3  2  F0 D0        	BEQ	LAB_147A		; if no following token go do "CLEAR"
0083A5  2               
0083A5  2               					; else there was a following token (go do syntax error)
0083A5  2  60           	RTS
0083A6  2               
0083A6  2               ; perform LIST [n][-m]
0083A6  2               ; bigger, faster version (a _lot_ faster)
0083A6  2               
0083A6  2               LAB_LIST
0083A6  2  90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
0083A8  2               
0083A8  2  F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
0083AA  2               
0083AA  2  C9 B7        	CMP	#TK_MINUS		; compare with token for -
0083AC  2  D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
0083AE  2               
0083AE  2               					; LIST [[n][-m]]
0083AE  2               					; this bit sets the n , if present, as the start and end
0083AE  2               LAB_14BD
0083AE  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0083B1  2  20 27 83     	JSR	LAB_SSLN		; search BASIC for temp integer line number
0083B4  2               					; (pointer in Baslnl/Baslnh)
0083B4  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0083B7  2  F0 0C        	BEQ	LAB_14D4		; branch if no more characters
0083B9  2               
0083B9  2               					; this bit checks the - is present
0083B9  2  C9 B7        	CMP	#TK_MINUS		; compare with token for -
0083BB  2  D0 93        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
0083BD  2               
0083BD  2               					; LIST [n]-m
0083BD  2               					; the - was there so set m as the end value
0083BD  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0083C0  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0083C3  2  D0 8B        	BNE	LAB_1460		; exit if not ok
0083C5  2               
0083C5  2               LAB_14D4
0083C5  2  A5 11        	LDA	Itempl		; get temporary integer low byte
0083C7  2  05 12        	ORA	Itemph		; OR temporary integer high byte
0083C9  2  D0 06        	BNE	LAB_14E2		; branch if start set
0083CB  2               
0083CB  2  A9 FF        	LDA	#$FF			; set for -1
0083CD  2  85 11        	STA	Itempl		; set temporary integer low byte
0083CF  2  85 12        	STA	Itemph		; set temporary integer high byte
0083D1  2               LAB_14E2
0083D1  2  A0 01        	LDY	#$01			; set index for line
0083D3  2  84 60        	STY	Oquote		; clear open quote flag
0083D5  2  20 95 88     	JSR	LAB_CRLF		; print CR/LF
0083D8  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
0083DA  2               					; pointer initially set by search at LAB_14BD
0083DA  2  F0 3E        	BEQ	LAB_152B		; if null all done so exit
0083DC  2  20 17 85     	JSR	LAB_1629		; do CRTL-C check vector
0083DF  2               
0083DF  2  C8           	INY				; increment index for line
0083E0  2  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
0083E2  2  AA           	TAX				; copy to X
0083E3  2  C8           	INY				; increment index
0083E4  2  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
0083E6  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
0083E8  2  D0 04        	BNE	LAB_14FF		; branch if no high byte match
0083EA  2               
0083EA  2  E4 11        	CPX	Itempl		; compare with temporary integer low byte
0083EC  2  F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
0083EE  2               
0083EE  2               LAB_14FF				; else ..
0083EE  2  B0 2A        	BCS	LAB_152B		; if greater all done so exit
0083F0  2               
0083F0  2               LAB_1501
0083F0  2  84 97        	STY	Tidx1			; save index for line
0083F2  2  20 85 9A     	JSR	LAB_295E		; print XA as unsigned integer
0083F5  2  A9 20        	LDA	#$20			; space is the next character
0083F7  2               LAB_1508
0083F7  2  A4 97        	LDY	Tidx1			; get index for line
0083F9  2  29 7F        	AND	#$7F			; mask top out bit of character
0083FB  2               LAB_150C
0083FB  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
0083FE  2  C9 22        	CMP	#$22			; was it " character
008400  2  D0 06        	BNE	LAB_1519		; branch if not
008402  2               
008402  2               					; we are either entering or leaving a pair of quotes
008402  2  A5 60        	LDA	Oquote		; get open quote flag
008404  2  49 FF        	EOR	#$FF			; toggle it
008406  2  85 60        	STA	Oquote		; save it back
008408  2               LAB_1519
008408  2  C8           	INY				; increment index
008409  2  B1 AA        	LDA	(Baslnl),Y		; get next byte
00840B  2  D0 0E        	BNE	LAB_152E		; branch if not [EOL] (go print character)
00840D  2  A8           	TAY				; else clear index
00840E  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
008410  2  AA           	TAX				; copy to X
008411  2  C8           	INY				; increment index
008412  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
008414  2  86 AA        	STX	Baslnl		; set pointer to line low byte
008416  2  85 AB        	STA	Baslnh		; set pointer to line high byte
008418  2  D0 B7        	BNE	LAB_14E2		; go do next line if not [EOT]
00841A  2               					; else ..
00841A  2               LAB_152B
00841A  2  60           	RTS
00841B  2               
00841B  2               LAB_152E
00841B  2  10 DE        	BPL	LAB_150C		; just go print it if not token byte
00841D  2               
00841D  2               					; else was token byte so uncrunch it (maybe)
00841D  2  24 60        	BIT	Oquote		; test the open quote flag
00841F  2  30 DA        	BMI	LAB_150C		; just go print character if open quote set
008421  2               
008421  2  A2 A5        	LDX	#>LAB_KEYT		; get table address high byte
008423  2  0A           	ASL				; *2
008424  2  0A           	ASL				; *4
008425  2  90 02        	BCC	LAB_152F		; branch if no carry
008427  2               
008427  2  E8           	INX				; else increment high byte
008428  2  18           	CLC				; clear carry for add
008429  2               LAB_152F
008429  2  69 14        	ADC	#<LAB_KEYT		; add low byte
00842B  2  90 01        	BCC	LAB_1530		; branch if no carry
00842D  2               
00842D  2  E8           	INX				; else increment high byte
00842E  2               LAB_1530
00842E  2  85 73        	STA	ut2_pl		; save table pointer low byte
008430  2  86 74        	STX	ut2_ph		; save table pointer high byte
008432  2  84 97        	STY	Tidx1			; save index for line
008434  2  A0 00        	LDY	#$00			; clear index
008436  2  B1 73        	LDA	(ut2_pl),Y		; get length
008438  2  AA           	TAX				; copy length
008439  2  C8           	INY				; increment index
00843A  2  B1 73        	LDA	(ut2_pl),Y		; get 1st character
00843C  2  CA           	DEX				; decrement length
00843D  2  F0 B8        	BEQ	LAB_1508		; if no more characters exit and print
00843F  2               
00843F  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
008442  2  C8           	INY				; increment index
008443  2  B1 73        	LDA	(ut2_pl),Y		; get keyword address low byte
008445  2  48           	PHA				; save it for now
008446  2  C8           	INY				; increment index
008447  2  B1 73        	LDA	(ut2_pl),Y		; get keyword address high byte
008449  2  A0 00        	LDY	#$00
00844B  2  85 74        	STA	ut2_ph		; save keyword pointer high byte
00844D  2  68           	PLA				; pull low byte
00844E  2  85 73        	STA	ut2_pl		; save keyword pointer low byte
008450  2               LAB_1540
008450  2  B1 73        	LDA	(ut2_pl),Y		; get character
008452  2  CA           	DEX				; decrement character count
008453  2  F0 A2        	BEQ	LAB_1508		; if last character exit and print
008455  2               
008455  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
008458  2  C8           	INY				; increment index
008459  2  D0 F5        	BNE	LAB_1540		; loop for next character
00845B  2               
00845B  2               ; perform FOR
00845B  2               
00845B  2               LAB_FOR
00845B  2  A9 80        	LDA	#$80			; set FNX
00845D  2  85 61        	STA	Sufnxf		; set subscript/FNX flag
00845F  2  20 B7 87     	JSR	LAB_LET		; go do LET
008462  2  68           	PLA				; pull return address
008463  2  68           	PLA				; pull return address
008464  2  A9 10        	LDA	#$10			; we need 16d bytes !
008466  2  20 06 81     	JSR	LAB_1212		; check room on stack for A bytes
008469  2  20 A0 86     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
00846C  2  18           	CLC				; clear carry for add
00846D  2  98           	TYA				; copy index to A
00846E  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
008470  2  48           	PHA				; push onto stack
008471  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
008473  2  69 00        	ADC	#$00			; add carry
008475  2  48           	PHA				; push onto stack
008476  2  A5 88        	LDA	Clineh		; get current line high byte
008478  2  48           	PHA				; push onto stack
008479  2  A5 87        	LDA	Clinel		; get current line low byte
00847B  2  48           	PHA				; push onto stack
00847C  2  A9 AD        	LDA	#TK_TO		; get "TO" token
00847E  2  20 F4 8B     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
008481  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
008484  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
008487  2               					; else do type mismatch
008487  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
008489  2  09 7F        	ORA	#$7F			; set all non sign bits
00848B  2  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
00848D  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00848F  2  A9 9A        	LDA	#<LAB_159F		; set return address low byte
008491  2  A0 84        	LDY	#>LAB_159F		; set return address high byte
008493  2  85 71        	STA	ut1_pl		; save return address low byte
008495  2  84 72        	STY	ut1_ph		; save return address high byte
008497  2  4C 87 8B     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
00849A  2               
00849A  2               LAB_159F
00849A  2  A9 E3        	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
00849C  2  A0 A1        	LDY	#>LAB_259C		; set 1 pointer high addr
00849E  2  20 80 98     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
0084A1  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0084A4  2  C9 B2        	CMP	#TK_STEP		; compare with STEP token
0084A6  2  D0 06        	BNE	LAB_15B3		; jump if not "STEP"
0084A8  2               
0084A8  2               					;.was step so ..
0084A8  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0084AB  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
0084AE  2               					; else do type mismatch
0084AE  2               LAB_15B3
0084AE  2  20 EC 98     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
0084B1  2  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
0084B3  2               					; this is +1 for +ve step and -1 for -ve step, in NEXT we
0084B3  2               					; compare the FOR value and the TO value and return +1 if
0084B3  2               					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
0084B3  2               					; here (+/-1) is then compared to that result and if they
0084B3  2               					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
0084B3  2               					; the loop is done
0084B3  2  20 7C 8B     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
0084B6  2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
0084B8  2  48           	PHA				; push on stack
0084B9  2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
0084BB  2  48           	PHA				; push on stack
0084BC  2  A9 81        	LDA	#TK_FOR		; get FOR token
0084BE  2  48           	PHA				; push on stack
0084BF  2               
0084BF  2               ; interpreter inner loop
0084BF  2               
0084BF  2               LAB_15C2
0084BF  2  20 17 85     	JSR	LAB_1629		; do CRTL-C check vector
0084C2  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0084C4  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0084C6  2               
0084C6  2  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
0084C8  2               					; ($00xx for RUN from immediate mode)
0084C8  2  E8           	INX				; increment it (now $00 if immediate mode)
0084C9  2  F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
0084CB  2               
0084CB  2  85 8B        	STA	Cpntrl		; save continue pointer low byte
0084CD  2  84 8C        	STY	Cpntrh		; save continue pointer high byte
0084CF  2               LAB_15D1
0084CF  2  A0 00        	LDY	#$00			; clear index
0084D1  2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
0084D3  2  F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
0084D5  2               
0084D5  2  C9 3A        	CMP	#':'			; compare with ":"
0084D7  2  F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
0084D9  2               
0084D9  2               LAB_15D9
0084D9  2  4C 05 8C     	JMP	LAB_SNER		; else syntax error then warm start
0084DC  2               
0084DC  2               					; have reached [EOL]
0084DC  2               LAB_15DC
0084DC  2  A0 02        	LDY	#$02			; set index
0084DE  2  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
0084E0  2  18           	CLC				; clear carry for no "BREAK" message
0084E1  2  F0 56        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
0084E3  2               					; marker)
0084E3  2               
0084E3  2  C8           	INY				; increment index
0084E4  2  B1 C3        	LDA	(Bpntrl),Y		; get line # low byte
0084E6  2  85 87        	STA	Clinel		; save current line low byte
0084E8  2  C8           	INY				; increment index
0084E9  2  B1 C3        	LDA	(Bpntrl),Y		; get line # high byte
0084EB  2  85 88        	STA	Clineh		; save current line high byte
0084ED  2  98           	TYA				; A now = 4
0084EE  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
0084F0  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
0084F2  2  90 02        	BCC	LAB_15F6		; branch if no overflow
0084F4  2               
0084F4  2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
0084F6  2               LAB_15F6
0084F6  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0084F9  2               
0084F9  2               LAB_15F9
0084F9  2  20 FF 84     	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
0084FC  2               
0084FC  2               LAB_15FC
0084FC  2  4C BF 84     	JMP	LAB_15C2		; loop
0084FF  2               
0084FF  2               ; interpret BASIC code from (Bpntrl)
0084FF  2               
0084FF  2               LAB_15FF
0084FF  2  F0 54        	BEQ	LAB_1628		; exit if zero [EOL]
008501  2               
008501  2               LAB_1602
008501  2  0A           	ASL				; *2 bytes per vector and normalise token
008502  2  B0 03        	BCS	LAB_1609		; branch if was token
008504  2               
008504  2  4C B7 87     	JMP	LAB_LET		; else go do implied LET
008507  2               
008507  2               LAB_1609
008507  2  C9 56        	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
008509  2  B0 CE        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
00850B  2               					; only tokens before TAB can start a line
00850B  2  A8           	TAY				; copy to index
00850C  2  B9 0B A2     	LDA	LAB_CTBL+1,Y	; get vector high byte
00850F  2  48           	PHA				; onto stack
008510  2  B9 0A A2     	LDA	LAB_CTBL,Y		; get vector low byte
008513  2  48           	PHA				; onto stack
008514  2  4C BC 00     	JMP	LAB_IGBY		; jump to increment and scan memory
008517  2               					; then "return" to vector
008517  2               
008517  2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
008517  2               ; key press is detected.
008517  2               
008517  2               LAB_1629
008517  2  6C 03 03     	JMP	(VEC_CC)		; ctrl c check vector
00851A  2               
00851A  2               ; if there was a key press it gets back here ..
00851A  2               
00851A  2               LAB_1636
00851A  2  C9 03        	CMP	#$03			; compare with CTRL-C
00851C  2               
00851C  2               ; perform STOP
00851C  2               
00851C  2               LAB_STOP
00851C  2  B0 01        	BCS	LAB_163B		; branch if token follows STOP
00851E  2               					; else just END
00851E  2               ; END
00851E  2               
00851E  2               LAB_END
00851E  2  18           	CLC				; clear the carry, indicate a normal program end
00851F  2               LAB_163B
00851F  2  D0 67        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
008521  2               
008521  2  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
008523  2  49 03        	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
008525  2  F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
008527  2               					; (can't continue in immediate mode)
008527  2               
008527  2               					; else ..
008527  2  49 03        	EOR	#>Ibuffs		; correct the bits
008529  2  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
00852B  2  84 8B        	STY	Cpntrl		; save continue pointer low byte
00852D  2  85 8C        	STA	Cpntrh		; save continue pointer high byte
00852F  2               LAB_1647
00852F  2  A5 87        	LDA	Clinel		; get current line low byte
008531  2  A4 88        	LDY	Clineh		; get current line high byte
008533  2  85 89        	STA	Blinel		; save break line low byte
008535  2  84 8A        	STY	Blineh		; save break line high byte
008537  2               LAB_164F
008537  2  68           	PLA				; pull return address low
008538  2  68           	PLA				; pull return address high
008539  2               LAB_1651
008539  2  90 07        	BCC	LAB_165E		; if was program end just do warm start
00853B  2               
00853B  2               					; else ..
00853B  2  A9 E1        	LDA	#<LAB_BMSG		; point to "Break" low byte
00853D  2  A0 A7        	LDY	#>LAB_BMSG		; point to "Break" high byte
00853F  2  4C 52 81     	JMP	LAB_1269		; print "Break" and do warm start
008542  2               
008542  2               LAB_165E
008542  2  4C 5D 81     	JMP	LAB_1274		; go do warm start
008545  2               
008545  2               ; perform RESTORE
008545  2               
008545  2               LAB_RESTORE
008545  2  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
008547  2               
008547  2               LAB_161A
008547  2  38           	SEC				; set carry for subtract
008548  2  A5 79        	LDA	Smeml			; get start of mem low byte
00854A  2  E9 01        	SBC	#$01			; -1
00854C  2  A4 7A        	LDY	Smemh			; get start of mem high byte
00854E  2  B0 01        	BCS	LAB_1624		; branch if no underflow
008550  2               
008550  2               LAB_uflow
008550  2  88           	DEY				; else decrement high byte
008551  2               LAB_1624
008551  2  85 8F        	STA	Dptrl			; save DATA pointer low byte
008553  2  84 90        	STY	Dptrh			; save DATA pointer high byte
008555  2               LAB_1628
008555  2  60           	RTS
008556  2               
008556  2               					; is RESTORE n
008556  2               LAB_RESTOREn
008556  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer
008559  2  20 A3 86     	JSR	LAB_SNBL		; scan for next BASIC line
00855C  2  A5 88        	LDA	Clineh		; get current line high byte
00855E  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
008560  2  B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
008562  2               
008562  2  98           	TYA				; else copy line index to A
008563  2  38           	SEC				; set carry (+1)
008564  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
008566  2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
008568  2  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
00856A  2               
00856A  2  E8           	INX				; increment high byte
00856B  2  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
00856D  2               
00856D  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00856D  2               
00856D  2               LAB_reset_search
00856D  2  A5 79        	LDA	Smeml			; get start of mem low byte
00856F  2  A6 7A        	LDX	Smemh			; get start of mem high byte
008571  2               
008571  2               ; search for line # in temp (Itempl/Itemph) from (AX)
008571  2               
008571  2               LAB_go_search
008571  2               
008571  2  20 2B 83     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
008574  2  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
008576  2               
008576  2  4C 75 86     	JMP	LAB_16F7		; else go do "Undefined statement" error
008579  2               
008579  2               LAB_line_found
008579  2               					; carry already set for subtract
008579  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00857B  2  E9 01        	SBC	#$01			; -1
00857D  2  A4 AB        	LDY	Baslnh		; get pointer high byte
00857F  2  B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
008581  2               
008581  2  90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
008583  2               					; return (branch always)
008583  2               
008583  2               ; perform NULL
008583  2               
008583  2               LAB_NULL
008583  2  20 8F 94     	JSR	LAB_GTBY		; get byte parameter
008586  2  86 0D        	STX	Nullct		; save new NULL count
008588  2               LAB_167A
008588  2  60           	RTS
008589  2               
008589  2               ; perform CONT
008589  2               
008589  2               LAB_CONT
008589  2  D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
00858B  2               
00858B  2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00858D  2  D0 05        	BNE	LAB_166C		; go do continue if we can
00858F  2               
00858F  2  A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
008591  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
008594  2               
008594  2               					; we can continue so ..
008594  2               LAB_166C
008594  2  A9 93        	LDA	#TK_ON		; set token for ON
008596  2  20 17 9F     	JSR	LAB_IRQ		; set IRQ flags
008599  2  A9 93        	LDA	#TK_ON		; set token for ON
00859B  2  20 1A 9F     	JSR	LAB_NMI		; set NMI flags
00859E  2               
00859E  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
0085A0  2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
0085A2  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
0085A4  2  A5 89        	LDA	Blinel		; get break line low byte
0085A6  2  A4 8A        	LDY	Blineh		; get break line high byte
0085A8  2  85 87        	STA	Clinel		; set current line low byte
0085AA  2  84 88        	STY	Clineh		; set current line high byte
0085AC  2  60           	RTS
0085AD  2               
0085AD  2               ; perform RUN
0085AD  2               
0085AD  2               LAB_RUN
0085AD  2  D0 03        	BNE	LAB_1696		; branch if RUN n
0085AF  2  4C 68 83     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
0085B2  2               					; return
0085B2  2               
0085B2  2               ; does RUN n
0085B2  2               
0085B2  2               LAB_1696
0085B2  2  20 75 83     	JSR	LAB_147A		; go do "CLEAR"
0085B5  2  F0 2E        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
0085B7  2               
0085B7  2               ; perform DO
0085B7  2               
0085B7  2               LAB_DO
0085B7  2  A9 05        	LDA	#$05			; need 5 bytes for DO
0085B9  2  20 06 81     	JSR	LAB_1212		; check room on stack for A bytes
0085BC  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0085BE  2  48           	PHA				; push on stack
0085BF  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0085C1  2  48           	PHA				; push on stack
0085C2  2  A5 88        	LDA	Clineh		; get current line high byte
0085C4  2  48           	PHA				; push on stack
0085C5  2  A5 87        	LDA	Clinel		; get current line low byte
0085C7  2  48           	PHA				; push on stack
0085C8  2  A9 9D        	LDA	#TK_DO		; token for DO
0085CA  2  48           	PHA				; push on stack
0085CB  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0085CE  2  4C BF 84     	JMP	LAB_15C2		; go do interpreter inner loop
0085D1  2               
0085D1  2               ; perform GOSUB
0085D1  2               
0085D1  2               LAB_GOSUB
0085D1  2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
0085D3  2  20 06 81     	JSR	LAB_1212		; check room on stack for A bytes
0085D6  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0085D8  2  48           	PHA				; push on stack
0085D9  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0085DB  2  48           	PHA				; push on stack
0085DC  2  A5 88        	LDA	Clineh		; get current line high byte
0085DE  2  48           	PHA				; push on stack
0085DF  2  A5 87        	LDA	Clinel		; get current line low byte
0085E1  2  48           	PHA				; push on stack
0085E2  2  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
0085E4  2  48           	PHA				; push on stack
0085E5  2               LAB_16B0
0085E5  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0085E8  2  20 EE 85     	JSR	LAB_GOTO		; perform GOTO n
0085EB  2  4C BF 84     	JMP	LAB_15C2		; go do interpreter inner loop
0085EE  2               					; (can't RTS, we used the stack!)
0085EE  2               
0085EE  2               ; perform GOTO
0085EE  2               
0085EE  2               LAB_GOTO
0085EE  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0085F1  2  20 A3 86     	JSR	LAB_SNBL		; scan for next BASIC line
0085F4  2  A5 88        	LDA	Clineh		; get current line high byte
0085F6  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
0085F8  2  B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
0085FA  2               
0085FA  2  98           	TYA				; else copy line index to A
0085FB  2  38           	SEC				; set carry (+1)
0085FC  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
0085FE  2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
008600  2  90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
008602  2               
008602  2  E8           	INX				; increment high byte
008603  2  B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
008605  2               
008605  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
008605  2               
008605  2               LAB_16D0
008605  2  A5 79        	LDA	Smeml			; get start of mem low byte
008607  2  A6 7A        	LDX	Smemh			; get start of mem high byte
008609  2               
008609  2               ; search for line # in temp (Itempl/Itemph) from (AX)
008609  2               
008609  2               LAB_16D4
008609  2  20 2B 83     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
00860C  2  90 67        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
00860E  2               					; (unspecified statement)
00860E  2               
00860E  2               					; carry already set for subtract
00860E  2  A5 AA        	LDA	Baslnl		; get pointer low byte
008610  2  E9 01        	SBC	#$01			; -1
008612  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
008614  2  A5 AB        	LDA	Baslnh		; get pointer high byte
008616  2  E9 00        	SBC	#$00			; subtract carry
008618  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00861A  2               LAB_16E5
00861A  2  60           	RTS
00861B  2               
00861B  2               LAB_DONOK
00861B  2  A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
00861D  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
008620  2               
008620  2               ; perform LOOP
008620  2               
008620  2               LAB_LOOP
008620  2  A8           	TAY				; save following token
008621  2  BA           	TSX				; copy stack pointer
008622  2  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
008625  2  C9 9D        	CMP	#TK_DO		; compare with DO token
008627  2  D0 F2        	BNE	LAB_DONOK		; branch if no matching DO
008629  2               
008629  2  E8           	INX				; dump calling routine return address
00862A  2  E8           	INX				; dump calling routine return address
00862B  2  9A           	TXS				; correct stack
00862C  2  98           	TYA				; get saved following token back
00862D  2  F0 20        	BEQ	LoopAlways		; if no following token loop forever
00862F  2               					; (stack pointer in X)
00862F  2               
00862F  2  C9 3A        	CMP	#':'			; could be ':'
008631  2  F0 1C        	BEQ	LoopAlways		; if :... loop forever
008633  2               
008633  2  E9 B3        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
008635  2  AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
008636  2  F0 04        	BEQ	DoRest		; branch if was UNTIL
008638  2               
008638  2  CA           	DEX				; decrement result
008639  2  D0 62        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
00863B  2               					; only if the token was WHILE will this fail
00863B  2               
00863B  2  CA           	DEX				; set invert result byte
00863C  2               DoRest
00863C  2  86 98        	STX	Frnxth		; save invert result byte
00863E  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
008641  2  20 E4 8A     	JSR	LAB_EVEX		; evaluate expression
008644  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
008646  2  F0 02        	BEQ	DoCmp			; if =0 go do straight compare
008648  2               
008648  2  A9 FF        	LDA	#$FF			; else set all bits
00864A  2               DoCmp
00864A  2  BA           	TSX				; copy stack pointer
00864B  2  45 98        	EOR	Frnxth		; EOR with invert byte
00864D  2  D0 1A        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
00864F  2               
00864F  2               					; loop condition wasn't met so do it again
00864F  2               LoopAlways
00864F  2  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
008652  2  85 87        	STA	Clinel		; save current line low byte
008654  2  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
008657  2  85 88        	STA	Clineh		; save current line high byte
008659  2  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
00865C  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00865E  2  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
008661  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
008663  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008666  2  4C BF 84     	JMP	LAB_15C2		; go do interpreter inner loop
008669  2               
008669  2               					; clear stack and back to interpreter loop
008669  2               LoopDone
008669  2  E8           	INX				; dump DO token
00866A  2  E8           	INX				; dump current line low byte
00866B  2  E8           	INX				; dump current line high byte
00866C  2  E8           	INX				; dump BASIC execute pointer low byte
00866D  2  E8           	INX				; dump BASIC execute pointer high byte
00866E  2  9A           	TXS				; correct stack
00866F  2  4C 8F 86     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
008672  2               
008672  2               ; do the return without gosub error
008672  2               
008672  2               LAB_16F4
008672  2  A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
008674  2  2C           	.byte	$2C			; makes next line BIT LAB_0EA2
008675  2               
008675  2               LAB_16F7				; do undefined statement error
008675  2  A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
008677  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
00867A  2               
00867A  2               ; perform RETURN
00867A  2               
00867A  2               LAB_RETURN
00867A  2  D0 9E        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
00867C  2               
00867C  2               LAB_16E8
00867C  2  68           	PLA				; dump calling routine return address
00867D  2  68           	PLA				; dump calling routine return address
00867E  2  68           	PLA				; pull token
00867F  2  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
008681  2  D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
008683  2               
008683  2               LAB_16FF
008683  2  68           	PLA				; pull current line low byte
008684  2  85 87        	STA	Clinel		; save current line low byte
008686  2  68           	PLA				; pull current line high byte
008687  2  85 88        	STA	Clineh		; save current line high byte
008689  2  68           	PLA				; pull BASIC execute pointer low byte
00868A  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00868C  2  68           	PLA				; pull BASIC execute pointer high byte
00868D  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00868F  2               
00868F  2               					; now do the DATA statement as we could be returning into
00868F  2               					; the middle of an ON <var> GOSUB n,m,p,q line
00868F  2               					; (the return address used by the DATA statement is the one
00868F  2               					; pushed before the GOSUB was executed!)
00868F  2               
00868F  2               ; perform DATA
00868F  2               
00868F  2               LAB_DATA
00868F  2  20 A0 86     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
008692  2               
008692  2               					; set BASIC execute pointer
008692  2               LAB_170F
008692  2  98           	TYA				; copy index to A
008693  2  18           	CLC				; clear carry for add
008694  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
008696  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
008698  2  90 02        	BCC	LAB_1719		; skip next if no carry
00869A  2               
00869A  2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
00869C  2               LAB_1719
00869C  2  60           	RTS
00869D  2               
00869D  2               LAB_16FC
00869D  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
0086A0  2               
0086A0  2               ; scan for next BASIC statement ([:] or [EOL])
0086A0  2               ; returns Y as index to [:] or [EOL]
0086A0  2               
0086A0  2               LAB_SNBS
0086A0  2  A2 3A        	LDX	#':'			; set look for character = ":"
0086A2  2  2C           	.byte	$2C			; makes next line BIT $00A2
0086A3  2               
0086A3  2               ; scan for next BASIC line
0086A3  2               ; returns Y as index to [EOL]
0086A3  2               
0086A3  2               LAB_SNBL
0086A3  2  A2 00        	LDX	#$00			; set alt search character = [EOL]
0086A5  2  A0 00        	LDY	#$00			; set search character = [EOL]
0086A7  2  84 5C        	STY	Asrch			; store search character
0086A9  2               LAB_1725
0086A9  2  8A           	TXA				; get alt search character
0086AA  2  45 5C        	EOR	Asrch			; toggle search character, effectively swap with $00
0086AC  2  85 5C        	STA	Asrch			; save swapped search character
0086AE  2               LAB_172D
0086AE  2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
0086B0  2  F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
0086B2  2               
0086B2  2  C5 5C        	CMP	Asrch			; compare with search character
0086B4  2  F0 E6        	BEQ	LAB_1719		; exit if found
0086B6  2               
0086B6  2  C8           	INY				; increment index
0086B7  2  C9 22        	CMP	#$22			; compare current character with open quote
0086B9  2  D0 F3        	BNE	LAB_172D		; if not open quote go get next character
0086BB  2               
0086BB  2  F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
0086BD  2               
0086BD  2               ; perform IF
0086BD  2               
0086BD  2               LAB_IF
0086BD  2  20 E4 8A     	JSR	LAB_EVEX		; evaluate the expression
0086C0  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0086C3  2  C9 B0        	CMP	#TK_THEN		; compare with THEN token
0086C5  2  F0 11        	BEQ	LAB_174B		; if it was THEN go do IF
0086C7  2               
0086C7  2               					; wasn't IF .. THEN so must be IF .. GOTO
0086C7  2  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
0086C9  2  D0 D2        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
0086CB  2               
0086CB  2  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
0086CD  2  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
0086CF  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0086D2  2  B0 C9        	BCS	LAB_16FC		; if not numeric go do syntax error
0086D4  2               
0086D4  2  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
0086D6  2  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
0086D8  2               LAB_174B
0086D8  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0086DA  2  F0 1B        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
0086DC  2               
0086DC  2  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
0086DF  2  B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
0086E1  2               
0086E1  2               LAB_174C
0086E1  2  4C EE 85     	JMP	LAB_GOTO		; else was numeric so do GOTO n
0086E4  2               
0086E4  2               					; is var or keyword
0086E4  2               LAB_174D
0086E4  2  C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
0086E6  2  D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
0086E8  2               					; and return to this code to process any following code
0086E8  2               
0086E8  2  4C 01 85     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
0086EB  2               					; but don't return here
0086EB  2               
0086EB  2               LAB_174G
0086EB  2  20 FF 84     	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
0086EE  2               
0086EE  2               ; the IF was executed and there may be a following ELSE so the code needs to return
0086EE  2               ; here to check and ignore the ELSE if present
0086EE  2               
0086EE  2  A0 00        	LDY	#$00			; clear the index
0086F0  2  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
0086F2  2  C9 AC        	CMP	#TK_ELSE		; compare it with the token for ELSE
0086F4  2  F0 99        	BEQ	LAB_DATA		; if ELSE ignore the following statement
0086F6  2               
0086F6  2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0086F6  2               ; following ELSE will, correctly, cause a syntax error
0086F6  2               
0086F6  2  60           	RTS				; else return to the interpreter inner loop
0086F7  2               
0086F7  2               ; perform ELSE after IF
0086F7  2               
0086F7  2               LAB_174E
0086F7  2  A0 00        	LDY	#$00			; clear the BASIC byte index
0086F9  2  A2 01        	LDX	#$01			; clear the nesting depth
0086FB  2               LAB_1750
0086FB  2  C8           	INY				; increment the BASIC byte index
0086FC  2  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
0086FE  2  F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
008700  2               
008700  2  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
008702  2  D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
008704  2               
008704  2  E8           	INX				; else increment the nesting depth ..
008705  2  D0 F4        	BNE	LAB_1750		; .. and continue looking
008707  2               
008707  2               LAB_1752
008707  2  C9 AC        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
008709  2  D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
00870B  2               
00870B  2  CA           	DEX				; was ELSE so decrement the nesting depth
00870C  2  D0 ED        	BNE	LAB_1750		; loop if still nested
00870E  2               
00870E  2  C8           	INY				; increment the BASIC byte index past the ELSE
00870F  2               
00870F  2               ; found the matching ELSE, now do <{n|statement}>
00870F  2               
00870F  2               LAB_1753
00870F  2  98           	TYA				; else copy line index to A
008710  2  18           	CLC				; clear carry for add
008711  2  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
008713  2  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
008715  2  90 02        	BCC	LAB_1754		; branch if no overflow to high byte
008717  2               
008717  2  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
008719  2               LAB_1754
008719  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00871C  2  90 C3        	BCC	LAB_174C		; if numeric do GOTO n
00871E  2               					; the code will return to the interpreter loop at the
00871E  2               					; tail end of the GOTO <n>
00871E  2               
00871E  2  4C FF 84     	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
008721  2               					; the code will return to the interpreter loop at the
008721  2               					; tail end of the <statement>
008721  2               
008721  2               ; perform REM, skip (rest of) line
008721  2               
008721  2               LAB_REM
008721  2  20 A3 86     	JSR	LAB_SNBL		; scan for next BASIC line
008724  2  4C 92 86     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
008727  2               
008727  2               LAB_16FD
008727  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
00872A  2               
00872A  2               ; perform ON
00872A  2               
00872A  2               LAB_ON
00872A  2  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
00872C  2  D0 03        	BNE	LAB_NOIN		; if not go check NMI
00872E  2               
00872E  2  4C 3B 9F     	JMP	LAB_SIRQ		; else go set-up IRQ
008731  2               
008731  2               LAB_NOIN
008731  2  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
008733  2  D0 03        	BNE	LAB_NONM		; if not go do normal ON command
008735  2               
008735  2  4C 3F 9F     	JMP	LAB_SNMI		; else go set-up NMI
008738  2               
008738  2               LAB_NONM
008738  2  20 8F 94     	JSR	LAB_GTBY		; get byte parameter
00873B  2  48           	PHA				; push GOTO/GOSUB token
00873C  2  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
00873E  2  F0 04        	BEQ	LAB_176B		; branch if GOSUB
008740  2               
008740  2  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
008742  2               LAB_1767
008742  2  D0 E3        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
008744  2               
008744  2               
008744  2               ; next character was GOTO or GOSUB
008744  2               
008744  2               LAB_176B
008744  2  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
008746  2  D0 04        	BNE	LAB_1773		; branch if not zero
008748  2               
008748  2  68           	PLA				; pull GOTO/GOSUB token
008749  2  4C 01 85     	JMP	LAB_1602		; go execute it
00874C  2               
00874C  2               LAB_1773
00874C  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00874F  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
008752  2               					; (we could LDX #',' and JSR LAB_SNBL+2, then we
008752  2               					; just BNE LAB_176B for the loop. should be quicker ..
008752  2               					; no we can't, what if we meet a colon or [EOL]?)
008752  2  C9 2C        	CMP	#$2C			; compare next character with ","
008754  2  F0 EE        	BEQ	LAB_176B		; loop if ","
008756  2               
008756  2               LAB_177E
008756  2  68           	PLA				; else pull keyword token (run out of options)
008757  2               					; also dump +/-1 pointer low byte and exit
008757  2               LAB_177F
008757  2  60           	RTS
008758  2               
008758  2               ; takes n * 106 + 11 cycles where n is the number of digits
008758  2               
008758  2               ; get fixed-point number into temp integer
008758  2               
008758  2               LAB_GFPN
008758  2  A2 00        	LDX	#$00			; clear reg
00875A  2  86 11        	STX	Itempl		; clear temporary integer low byte
00875C  2               LAB_1785
00875C  2  86 12        	STX	Itemph		; save temporary integer high byte
00875E  2  B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
008760  2               					; not 0-9
008760  2               
008760  2  E0 19        	CPX	#$19			; compare high byte with $19
008762  2  A8           	TAY				; ensure Zb = 0 if the branch is taken
008763  2  B0 DD        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
008765  2               					; bit does *$0A, = 64000, compare at target will fail
008765  2               					; and do syntax error
008765  2               
008765  2  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
008767  2  A8           	TAY				; copy binary digit
008768  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00876A  2  0A           	ASL				; *2 low byte
00876B  2  26 12        	ROL	Itemph		; *2 high byte
00876D  2  0A           	ASL				; *2 low byte
00876E  2  26 12        	ROL	Itemph		; *2 high byte, *4
008770  2  65 11        	ADC	Itempl		; + low byte, *5
008772  2  85 11        	STA	Itempl		; save it
008774  2  8A           	TXA				; get high byte copy to A
008775  2  65 12        	ADC	Itemph		; + high byte, *5
008777  2  06 11        	ASL	Itempl		; *2 low byte, *10d
008779  2  2A           	ROL				; *2 high byte, *10d
00877A  2  AA           	TAX				; copy high byte back to X
00877B  2  98           	TYA				; get binary digit back
00877C  2  65 11        	ADC	Itempl		; add number low byte
00877E  2  85 11        	STA	Itempl		; save number low byte
008780  2  90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
008782  2               
008782  2  E8           	INX				; else increment high byte
008783  2               LAB_17B3
008783  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
008786  2  4C 5C 87     	JMP	LAB_1785		; loop for next character
008789  2               
008789  2               ; perform DEC
008789  2               
008789  2               LAB_DEC
008789  2  A9 E7        	LDA	#<LAB_2AFD		; set -1 pointer low byte
00878B  2  2C           	.byte	$2C			; BIT abs to skip the LDA below
00878C  2               
00878C  2               ; perform INC
00878C  2               
00878C  2               LAB_INC
00878C  2  A9 E3        	LDA	#<LAB_259C		; set 1 pointer low byte
00878E  2               LAB_17B5
00878E  2  48           	PHA				; save +/-1 pointer low byte
00878F  2               LAB_17B7
00878F  2  20 AD 8D     	JSR	LAB_GVAR		; get var address
008792  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
008794  2  30 1E        	BMI	IncrErr		; exit if string
008796  2               
008796  2  85 97        	STA	Lvarpl		; save var address low byte
008798  2  84 98        	STY	Lvarph		; save var address high byte
00879A  2  20 80 98     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00879D  2  68           	PLA				; get +/-1 pointer low byte
00879E  2  48           	PHA				; save +/-1 pointer low byte
00879F  2  A0 A1        	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
0087A1  2  20 C1 95     	JSR	LAB_246C		; add (AY) to FAC1
0087A4  2  20 A6 98     	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
0087A7  2               
0087A7  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0087AA  2  C9 2C        	CMP	#','			; compare with ","
0087AC  2  D0 A8        	BNE	LAB_177E		; exit if not "," (either end or error)
0087AE  2               
0087AE  2               					; was "," so another INCR variable to do
0087AE  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0087B1  2  4C 8F 87     	JMP	LAB_17B7		; go do next var
0087B4  2               
0087B4  2               IncrErr
0087B4  2  4C DF 8A     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
0087B7  2               
0087B7  2               ; perform LET
0087B7  2               
0087B7  2               LAB_LET
0087B7  2  20 AD 8D     	JSR	LAB_GVAR		; get var address
0087BA  2  85 97        	STA	Lvarpl		; save var address low byte
0087BC  2  84 98        	STY	Lvarph		; save var address high byte
0087BE  2  A9 C1        	LDA	#TK_EQUAL		; get = token
0087C0  2  20 F4 8B     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
0087C3  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
0087C5  2  48           	PHA				; push data type flag
0087C6  2  20 E4 8A     	JSR	LAB_EVEX		; evaluate expression
0087C9  2  68           	PLA				; pop data type flag
0087CA  2  2A           	ROL				; set carry if type = string
0087CB  2  20 D6 8A     	JSR	LAB_CKTM		; type match check, set C for string
0087CE  2  D0 03        	BNE	LAB_17D5		; branch if string
0087D0  2               
0087D0  2  4C A6 98     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
0087D3  2               
0087D3  2               ; string LET
0087D3  2               
0087D3  2               LAB_17D5
0087D3  2  A0 02        	LDY	#$02			; set index to pointer high byte
0087D5  2  B1 AE        	LDA	(des_pl),Y		; get string pointer high byte
0087D7  2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
0087D9  2  90 17        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
0087DB  2               
0087DB  2  D0 07        	BNE	LAB_17E6		; branch if >
0087DD  2               					; else was equal so compare low bytes
0087DD  2  88           	DEY				; decrement index
0087DE  2  B1 AE        	LDA	(des_pl),Y		; get pointer low byte
0087E0  2  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
0087E2  2  90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
0087E4  2               
0087E4  2               					; pointer was >= to bottom of string space pointer
0087E4  2               LAB_17E6
0087E4  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
0087E6  2  C4 7C        	CPY	Svarh			; compare start of vars high byte
0087E8  2  90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
0087EA  2               
0087EA  2  D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
0087EC  2               
0087EC  2               					; else high bytes were equal so ..
0087EC  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
0087EE  2  C5 7B        	CMP	Svarl			; compare start of vars low byte
0087F0  2  B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
0087F2  2               
0087F2  2               LAB_17F4
0087F2  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
0087F4  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
0087F6  2  4C 0F 88     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
0087F9  2               
0087F9  2               					; make space and copy string
0087F9  2               LAB_17FB
0087F9  2  A0 00        	LDY	#$00			; index to length
0087FB  2  B1 AE        	LDA	(des_pl),Y		; get string length
0087FD  2  20 35 91     	JSR	LAB_209C		; copy string
008800  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
008802  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
008804  2  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
008806  2  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
008808  2  20 14 93     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
00880B  2  A9 AC        	LDA	#<FAC1_e		; set descriptor pointer low byte
00880D  2  A0 00        	LDY	#>FAC1_e		; get descriptor pointer high byte
00880F  2               
00880F  2               					; clean stack and assign value to string variable
00880F  2               LAB_1811
00880F  2  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
008811  2  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
008813  2  20 76 93     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
008816  2  A0 00        	LDY	#$00			; index to length
008818  2  B1 9E        	LDA	(des_2l),Y		; get string length
00881A  2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
00881C  2  C8           	INY				; index to string pointer low byte
00881D  2  B1 9E        	LDA	(des_2l),Y		; get string pointer low byte
00881F  2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
008821  2  C8           	INY				; index to string pointer high byte
008822  2  B1 9E        	LDA	(des_2l),Y		; get string pointer high byte
008824  2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
008826  2  60           	RTS
008827  2               
008827  2               ; perform GET
008827  2               
008827  2               LAB_GET
008827  2  20 AD 8D     	JSR	LAB_GVAR		; get var address
00882A  2  85 97        	STA	Lvarpl		; save var address low byte
00882C  2  84 98        	STY	Lvarph		; save var address high byte
00882E  2  20 03 9F     	JSR	INGET			; get input byte
008831  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
008833  2  30 07        	BMI	LAB_GETS		; go get string character
008835  2               
008835  2               					; was numeric get
008835  2  A8           	TAY				; copy character to Y
008836  2  20 69 90     	JSR	LAB_1FD0		; convert Y to byte in FAC1
008839  2  4C A6 98     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
00883C  2               
00883C  2               LAB_GETS
00883C  2  48           	PHA				; save character
00883D  2  A9 01        	LDA	#$01			; string is single byte
00883F  2  B0 01        	BCS	LAB_IsByte		; branch if byte received
008841  2               
008841  2  68           	PLA				; string is null
008842  2               LAB_IsByte
008842  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
008845  2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
008845  2  F0 05        	BEQ	LAB_NoSt		; skip store if null string
008847  2               
008847  2  68           	PLA				; get character back
008848  2  A0 00        	LDY	#$00			; clear index
00884A  2  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
00884C  2               LAB_NoSt
00884C  2  20 88 91     	JSR	LAB_RTST		; check for space on descriptor stack then put address
00884F  2               					; and length on descriptor stack and update stack pointers
00884F  2               
00884F  2  4C D3 87     	JMP	LAB_17D5		; do string LET and return
008852  2               
008852  2               ; perform PRINT
008852  2               
008852  2               LAB_1829
008852  2  20 D9 88     	JSR	LAB_18C6		; print string from Sutill/Sutilh
008855  2               LAB_182C
008855  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008858  2               
008858  2               ; PRINT
008858  2               
008858  2               LAB_PRINT
008858  2  F0 3B        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
00885A  2               
00885A  2               LAB_1831
00885A  2  C9 AB        	CMP	#TK_TAB		; compare with TAB( token
00885C  2  F0 56        	BEQ	LAB_18A2		; go do TAB/SPC
00885E  2               
00885E  2  C9 AF        	CMP	#TK_SPC		; compare with SPC( token
008860  2  F0 52        	BEQ	LAB_18A2		; go do TAB/SPC
008862  2               
008862  2  C9 2C        	CMP	#','			; compare with ","
008864  2  F0 38        	BEQ	LAB_188B		; go do move to next TAB mark
008866  2               
008866  2  C9 3B        	CMP	#';'			; compare with ";"
008868  2  F0 66        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
00886A  2               
00886A  2  20 E4 8A     	JSR	LAB_EVEX		; evaluate expression
00886D  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00886F  2  30 E1        	BMI	LAB_1829		; branch if string
008871  2               
008871  2  20 98 9A     	JSR	LAB_296E		; convert FAC1 to string
008874  2  20 47 91     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
008877  2  A0 00        	LDY	#$00			; clear index
008879  2               
008879  2               ; don't check fit if terminal width byte is zero
008879  2               
008879  2  A5 0F        	LDA	TWidth		; get terminal width byte
00887B  2  F0 0A        	BEQ	LAB_185E		; skip check if zero
00887D  2               
00887D  2  38           	SEC				; set carry for subtract
00887E  2  E5 0E        	SBC	TPos			; subtract terminal position
008880  2  F1 AE        	SBC	(des_pl),Y		; subtract string length
008882  2  B0 03        	BCS	LAB_185E		; branch if less than terminal width
008884  2               
008884  2  20 95 88     	JSR	LAB_CRLF		; else print CR/LF
008887  2               LAB_185E
008887  2  20 D9 88     	JSR	LAB_18C6		; print string from Sutill/Sutilh
00888A  2  F0 C9        	BEQ	LAB_182C		; always go continue processing line
00888C  2               
00888C  2               ; CR/LF return to BASIC from BASIC input handler
00888C  2               
00888C  2               LAB_1866
00888C  2  A9 00        	LDA	#$00			; clear byte
00888E  2  9D 21 03     	STA	Ibuffs,X		; null terminate input
008891  2  A2 21        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
008893  2  A0 03        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
008895  2               
008895  2               ; print CR/LF
008895  2               
008895  2               LAB_CRLF
008895  2  A9 0D        	LDA	#$0D			; load [CR]
008897  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
00889A  2  A9 0A        	LDA	#$0A			; load [LF]
00889C  2  D0 52        	BNE	LAB_PRNA		; go print the character and return, branch always
00889E  2               
00889E  2               LAB_188B
00889E  2  A5 0E        	LDA	TPos			; get terminal position
0088A0  2  C5 10        	CMP	Iclim			; compare with input column limit
0088A2  2  90 05        	BCC	LAB_1897		; branch if less
0088A4  2               
0088A4  2  20 95 88     	JSR	LAB_CRLF		; else print CR/LF (next line)
0088A7  2  D0 27        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
0088A9  2               
0088A9  2               LAB_1897
0088A9  2  38           	SEC				; set carry for subtract
0088AA  2               LAB_1898
0088AA  2  E5 64        	SBC	TabSiz		; subtract TAB size
0088AC  2  B0 FC        	BCS	LAB_1898		; loop if result was +ve
0088AE  2               
0088AE  2  49 FF        	EOR	#$FF			; complement it
0088B0  2  69 01        	ADC	#$01			; +1 (twos complement)
0088B2  2  D0 12        	BNE	LAB_18B6		; always print A spaces (result is never $00)
0088B4  2               
0088B4  2               					; do TAB/SPC
0088B4  2               LAB_18A2
0088B4  2  48           	PHA				; save token
0088B5  2  20 8C 94     	JSR	LAB_SGBY		; scan and get byte parameter
0088B8  2  C9 29        	CMP	#$29			; is next character )
0088BA  2  D0 7B        	BNE	LAB_1910		; if not do syntax error then warm start
0088BC  2               
0088BC  2  68           	PLA				; get token back
0088BD  2  C9 AB        	CMP	#TK_TAB		; was it TAB ?
0088BF  2  D0 06        	BNE	LAB_18B7		; if not go do SPC
0088C1  2               
0088C1  2               					; calculate TAB offset
0088C1  2  8A           	TXA				; copy integer value to A
0088C2  2  E5 0E        	SBC	TPos			; subtract terminal position
0088C4  2  90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
0088C6  2               
0088C6  2               					; print A spaces
0088C6  2               LAB_18B6
0088C6  2  AA           	TAX				; copy result to X
0088C7  2               LAB_18B7
0088C7  2  8A           	TXA				; set flags on size for SPC
0088C8  2  F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
0088CA  2               
0088CA  2               					; print X spaces
0088CA  2               LAB_18BA
0088CA  2  20 EB 88     	JSR	LAB_18E0		; print " "
0088CD  2  CA           	DEX				; decrement count
0088CE  2  D0 FA        	BNE	LAB_18BA		; loop if not all done
0088D0  2               
0088D0  2               					; continue with PRINT processing
0088D0  2               LAB_18BD
0088D0  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0088D3  2  D0 85        	BNE	LAB_1831		; if more to print go do it
0088D5  2               
0088D5  2  60           	RTS
0088D6  2               
0088D6  2               ; print null terminated string from memory
0088D6  2               
0088D6  2               LAB_18C3
0088D6  2  20 47 91     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
0088D9  2               
0088D9  2               ; print string from Sutill/Sutilh
0088D9  2               
0088D9  2               LAB_18C6
0088D9  2  20 41 93     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
0088DC  2               					; space returns with A = length, X=$71=pointer low byte,
0088DC  2               					; Y=$72=pointer high byte
0088DC  2  A0 00        	LDY	#$00			; reset index
0088DE  2  AA           	TAX				; copy length to X
0088DF  2  F0 49        	BEQ	LAB_188C		; exit (RTS) if null string
0088E1  2               
0088E1  2               LAB_18CD
0088E1  2               
0088E1  2  B1 71        	LDA	(ut1_pl),Y		; get next byte
0088E3  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
0088E6  2  C8           	INY				; increment index
0088E7  2  CA           	DEX				; decrement count
0088E8  2  D0 F7        	BNE	LAB_18CD		; loop if not done yet
0088EA  2               
0088EA  2  60           	RTS
0088EB  2               
0088EB  2               					; Print single format character
0088EB  2               ; print " "
0088EB  2               
0088EB  2               LAB_18E0
0088EB  2  A9 20        	LDA	#$20			; load " "
0088ED  2  2C           	.byte	$2C			; change next line to BIT LAB_3FA9
0088EE  2               
0088EE  2               ; print "?" character
0088EE  2               
0088EE  2               LAB_18E3
0088EE  2  A9 3F        	LDA	#$3F			; load "?" character
0088F0  2               
0088F0  2               ; print character in A
0088F0  2               ; now includes the null handler
0088F0  2               ; also includes infinite line length code
0088F0  2               ; note! some routines expect this one to exit with Zb=0
0088F0  2               
0088F0  2               LAB_PRNA
0088F0  2  C9 20        	CMP	#' '			; compare with " "
0088F2  2  90 19        	BCC	LAB_18F9		; branch if less (non printing)
0088F4  2               
0088F4  2               					; else printable character
0088F4  2  48           	PHA				; save the character
0088F5  2               
0088F5  2               ; don't check fit if terminal width byte is zero
0088F5  2               
0088F5  2  A5 0F        	LDA	TWidth		; get terminal width
0088F7  2  D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
0088F9  2               
0088F9  2               ; is "infinite line" so check TAB position
0088F9  2               
0088F9  2  A5 0E        	LDA	TPos			; get position
0088FB  2  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
0088FD  2  D0 0B        	BNE	LAB_18F7		; skip reset if different
0088FF  2               
0088FF  2  85 0E        	STA	TPos			; else reset position
008901  2  F0 07        	BEQ	LAB_18F7		; go print character
008903  2               
008903  2               LAB_18F0
008903  2  C5 0E        	CMP	TPos			; compare with terminal character position
008905  2  D0 03        	BNE	LAB_18F7		; branch if not at end of line
008907  2               
008907  2  20 95 88     	JSR	LAB_CRLF		; else print CR/LF
00890A  2               LAB_18F7
00890A  2  E6 0E        	INC	TPos			; increment terminal position
00890C  2  68           	PLA				; get character back
00890D  2               LAB_18F9
00890D  2  20 F0 A0     	JSR	V_OUTP		; output byte via output vector
008910  2  C9 0D        	CMP	#$0D			; compare with [CR]
008912  2  D0 14        	BNE	LAB_188A		; branch if not [CR]
008914  2               
008914  2               					; else print nullct nulls after the [CR]
008914  2  86 78        	STX	TempB			; save buffer index
008916  2  A6 0D        	LDX	Nullct		; get null count
008918  2  F0 0A        	BEQ	LAB_1886		; branch if no nulls
00891A  2               
00891A  2  A9 00        	LDA	#$00			; load [NULL]
00891C  2               LAB_1880
00891C  2  20 F0 88     	JSR	LAB_PRNA		; go print the character
00891F  2  CA           	DEX				; decrement count
008920  2  D0 FA        	BNE	LAB_1880		; loop if not all done
008922  2               
008922  2  A9 0D        	LDA	#$0D			; restore the character (and set the flags)
008924  2               LAB_1886
008924  2  86 0E        	STX	TPos			; clear terminal position (X always = zero when we get here)
008926  2  A6 78        	LDX	TempB			; restore buffer index
008928  2               LAB_188A
008928  2  29 FF        	AND	#$FF			; set the flags
00892A  2               LAB_188C
00892A  2  60           	RTS
00892B  2               
00892B  2               ; handle bad input data
00892B  2               
00892B  2               LAB_1904
00892B  2  A5 62        	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
00892D  2  10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
00892F  2               
00892F  2  A5 8D        	LDA	Dlinel		; get current DATA line low byte
008931  2  A4 8E        	LDY	Dlineh		; get current DATA line high byte
008933  2  85 87        	STA	Clinel		; save current line low byte
008935  2  84 88        	STY	Clineh		; save current line high byte
008937  2               LAB_1910
008937  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
00893A  2               
00893A  2               					; mode was INPUT
00893A  2               LAB_1913
00893A  2  A9 15        	LDA	#<LAB_REDO		; point to redo message (low addr)
00893C  2  A0 A8        	LDY	#>LAB_REDO		; point to redo message (high addr)
00893E  2  20 D6 88     	JSR	LAB_18C3		; print null terminated string from memory
008941  2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
008943  2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
008945  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
008947  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
008949  2  60           	RTS
00894A  2               
00894A  2               ; perform INPUT
00894A  2               
00894A  2               LAB_INPUT
00894A  2  C9 22        	CMP	#$22			; compare next byte with open quote
00894C  2  D0 0B        	BNE	LAB_1934		; branch if no prompt string
00894E  2               
00894E  2  20 C1 8B     	JSR	LAB_1BC1		; print "..." string
008951  2  A9 3B        	LDA	#$3B			; load A with ";"
008953  2  20 F4 8B     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
008956  2  20 D9 88     	JSR	LAB_18C6		; print string from Sutill/Sutilh
008959  2               
008959  2               					; done with prompt, now get data
008959  2               LAB_1934
008959  2  20 6D 90     	JSR	LAB_CKRN		; check not Direct, back here if ok
00895C  2  20 43 82     	JSR	LAB_INLN		; print "? " and get BASIC input
00895F  2  A9 00        	LDA	#$00			; set mode = INPUT
008961  2  CD 21 03     	CMP	Ibuffs		; test first byte in buffer
008964  2  D0 0A        	BNE	LAB_1953		; branch if not null input
008966  2               
008966  2  18           	CLC				; was null input so clear carry to exit program
008967  2  4C 2F 85     	JMP	LAB_1647		; go do BREAK exit
00896A  2               
00896A  2               ; perform READ
00896A  2               
00896A  2               LAB_READ
00896A  2  A6 8F        	LDX	Dptrl			; get DATA pointer low byte
00896C  2  A4 90        	LDY	Dptrh			; get DATA pointer high byte
00896E  2  A9 80        	LDA	#$80			; set mode = READ
008970  2               
008970  2               LAB_1953
008970  2  85 62        	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
008972  2  86 91        	STX	Rdptrl		; save READ pointer low byte
008974  2  84 92        	STY	Rdptrh		; save READ pointer high byte
008976  2               
008976  2               					; READ or INPUT next variable from list
008976  2               LAB_195B
008976  2  20 AD 8D     	JSR	LAB_GVAR		; get (var) address
008979  2  85 97        	STA	Lvarpl		; save address low byte
00897B  2  84 98        	STY	Lvarph		; save address high byte
00897D  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00897F  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
008981  2  85 11        	STA	Itempl		; save as temporary integer low byte
008983  2  84 12        	STY	Itemph		; save as temporary integer high byte
008985  2  A6 91        	LDX	Rdptrl		; get READ pointer low byte
008987  2  A4 92        	LDY	Rdptrh		; get READ pointer high byte
008989  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00898B  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00898D  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008990  2  D0 11        	BNE	LAB_1988		; branch if not null
008992  2               
008992  2               					; pointer was to null entry
008992  2  24 62        	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
008994  2  30 65        	BMI	LAB_19DD		; branch if READ
008996  2               
008996  2               					; mode was INPUT
008996  2  20 EE 88     	JSR	LAB_18E3		; print "?" character (double ? for extended input)
008999  2  20 43 82     	JSR	LAB_INLN		; print "? " and get BASIC input
00899C  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00899E  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
0089A0  2               LAB_1985
0089A0  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0089A3  2               LAB_1988
0089A3  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
0089A5  2  10 24        	BPL	LAB_19B0		; branch if numeric
0089A7  2               
0089A7  2               					; else get string
0089A7  2  85 5B        	STA	Srchc			; save search character
0089A9  2  C9 22        	CMP	#$22			; was it " ?
0089AB  2  F0 07        	BEQ	LAB_1999		; branch if so
0089AD  2               
0089AD  2  A9 3A        	LDA	#':'			; else search character is ":"
0089AF  2  85 5B        	STA	Srchc			; set new search character
0089B1  2  A9 2C        	LDA	#','			; other search character is ","
0089B3  2  18           	CLC				; clear carry for add
0089B4  2               LAB_1999
0089B4  2  85 5C        	STA	Asrch			; set second search character
0089B6  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0089B8  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0089BA  2               
0089BA  2  69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
0089BC  2  90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
0089BE  2               
0089BE  2  C8           	INY				; else increment high byte
0089BF  2               LAB_19A4
0089BF  2  20 4D 91     	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
0089C2  2  20 D2 94     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
0089C5  2  20 D3 87     	JSR	LAB_17D5		; go do string LET
0089C8  2  4C D1 89     	JMP	LAB_19B6		; go check string terminator
0089CB  2               
0089CB  2               					; get numeric INPUT
0089CB  2               LAB_19B0
0089CB  2  20 A9 99     	JSR	LAB_2887		; get FAC1 from string
0089CE  2  20 A6 98     	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
0089D1  2               LAB_19B6
0089D1  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0089D4  2  F0 0A        	BEQ	LAB_19C5		; branch if null (last entry)
0089D6  2               
0089D6  2  C9 2C        	CMP	#','			; else compare with ","
0089D8  2  F0 03        	BEQ	LAB_19C2		; branch if ","
0089DA  2               
0089DA  2  4C 2B 89     	JMP	LAB_1904		; else go handle bad input data
0089DD  2               
0089DD  2               					; got good input data
0089DD  2               LAB_19C2
0089DD  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0089E0  2               LAB_19C5
0089E0  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
0089E2  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
0089E4  2  85 91        	STA	Rdptrl		; save for now
0089E6  2  84 92        	STY	Rdptrh		; save for now
0089E8  2  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
0089EA  2  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
0089EC  2  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
0089EE  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
0089F0  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0089F3  2  F0 2C        	BEQ	LAB_1A03		; if null go do extra ignored message
0089F5  2               
0089F5  2  20 01 8C     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
0089F8  2  4C 76 89     	JMP	LAB_195B		; go INPUT next variable from list
0089FB  2               
0089FB  2               					; find next DATA statement or do "Out of DATA" error
0089FB  2               LAB_19DD
0089FB  2  20 A0 86     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
0089FE  2  C8           	INY				; increment index
0089FF  2  AA           	TAX				; copy character ([:] or [EOL])
008A00  2  D0 12        	BNE	LAB_19F6		; branch if [:]
008A02  2               
008A02  2  A2 06        	LDX	#$06			; set for "Out of DATA" error
008A04  2  C8           	INY				; increment index, now points to next line pointer high byte
008A05  2  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
008A07  2  F0 73        	BEQ	LAB_1A54		; branch if end (eventually does error X)
008A09  2               
008A09  2  C8           	INY				; increment index
008A0A  2  B1 C3        	LDA	(Bpntrl),Y		; get next line # low byte
008A0C  2  85 8D        	STA	Dlinel		; save current DATA line low byte
008A0E  2  C8           	INY				; increment index
008A0F  2  B1 C3        	LDA	(Bpntrl),Y		; get next line # high byte
008A11  2  C8           	INY				; increment index
008A12  2  85 8E        	STA	Dlineh		; save current DATA line high byte
008A14  2               LAB_19F6
008A14  2  B1 C3        	LDA	(Bpntrl),Y		; get byte
008A16  2  C8           	INY				; increment index
008A17  2  AA           	TAX				; copy to X
008A18  2  20 92 86     	JSR	LAB_170F		; set BASIC execute pointer
008A1B  2  E0 83        	CPX	#TK_DATA		; compare with "DATA" token
008A1D  2  F0 81        	BEQ	LAB_1985		; was "DATA" so go do next READ
008A1F  2               
008A1F  2  D0 DA        	BNE	LAB_19DD		; go find next statement if not "DATA"
008A21  2               
008A21  2               ; end of INPUT/READ routine
008A21  2               
008A21  2               LAB_1A03
008A21  2  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
008A23  2  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
008A25  2  A6 62        	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
008A27  2  10 03        	BPL	LAB_1A0E		; branch if INPUT
008A29  2               
008A29  2  4C 51 85     	JMP	LAB_1624		; save AY as DATA pointer and return
008A2C  2               
008A2C  2               					; we were getting INPUT
008A2C  2               LAB_1A0E
008A2C  2  A0 00        	LDY	#$00			; clear index
008A2E  2  B1 91        	LDA	(Rdptrl),Y		; get next byte
008A30  2  D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
008A32  2               
008A32  2  60           	RTS
008A33  2               
008A33  2               					; user typed too much
008A33  2               LAB_1A1B
008A33  2  A9 04        	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
008A35  2  A0 A8        	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
008A37  2  4C D6 88     	JMP	LAB_18C3		; print null terminated string from memory and return
008A3A  2               
008A3A  2               ; search the stack for FOR activity
008A3A  2               ; exit with z=1 if FOR else exit with z=0
008A3A  2               
008A3A  2               LAB_11A1
008A3A  2  BA           	TSX				; copy stack pointer
008A3B  2  E8           	INX				; +1 pass return address
008A3C  2  E8           	INX				; +2 pass return address
008A3D  2  E8           	INX				; +3 pass calling routine return address
008A3E  2  E8           	INX				; +4 pass calling routine return address
008A3F  2               LAB_11A6
008A3F  2  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
008A42  2  C9 81        	CMP	#TK_FOR		; is it FOR token
008A44  2  D0 21        	BNE	LAB_11CE		; exit if not FOR token
008A46  2               
008A46  2               					; was FOR token
008A46  2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
008A48  2  D0 0A        	BNE	LAB_11BB		; branch if not null
008A4A  2               
008A4A  2  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
008A4D  2  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
008A4F  2  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
008A52  2  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
008A54  2               LAB_11BB
008A54  2  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
008A57  2  D0 07        	BNE	LAB_11C7		; branch if no match
008A59  2               
008A59  2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
008A5B  2  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
008A5E  2  F0 07        	BEQ	LAB_11CE		; exit if match found
008A60  2               
008A60  2               LAB_11C7
008A60  2  8A           	TXA				; copy index
008A61  2  18           	CLC				; clear carry for add
008A62  2  69 10        	ADC	#$10			; add FOR stack use size
008A64  2  AA           	TAX				; copy back to index
008A65  2  D0 D8        	BNE	LAB_11A6		; loop if not at start of stack
008A67  2               
008A67  2               LAB_11CE
008A67  2  60           	RTS
008A68  2               
008A68  2               ; perform NEXT
008A68  2               
008A68  2               LAB_NEXT
008A68  2  D0 04        	BNE	LAB_1A46		; branch if NEXT var
008A6A  2               
008A6A  2  A0 00        	LDY	#$00			; else clear Y
008A6C  2  F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
008A6E  2               
008A6E  2               ; NEXT var
008A6E  2               
008A6E  2               LAB_1A46
008A6E  2  20 AD 8D     	JSR	LAB_GVAR		; get variable address
008A71  2               LAB_1A49
008A71  2  85 97        	STA	Frnxtl		; store variable pointer low byte
008A73  2  84 98        	STY	Frnxth		; store variable pointer high byte
008A75  2               					; (both cleared if no variable defined)
008A75  2  20 3A 8A     	JSR	LAB_11A1		; search the stack for FOR activity
008A78  2  F0 04        	BEQ	LAB_1A56		; branch if found
008A7A  2               
008A7A  2  A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
008A7C  2               LAB_1A54
008A7C  2  F0 63        	BEQ	LAB_1ABE		; do error #X, then warm start
008A7E  2               
008A7E  2               LAB_1A56
008A7E  2  9A           	TXS				; set stack pointer, X set by search, dumps return addresses
008A7F  2               
008A7F  2  8A           	TXA				; copy stack pointer
008A80  2  38           	SEC				; set carry for subtract
008A81  2  E9 F7        	SBC	#$F7			; point to TO var
008A83  2  85 73        	STA	ut2_pl		; save pointer to TO var for compare
008A85  2  69 FB        	ADC	#$FB			; point to STEP var
008A87  2               
008A87  2  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
008A89  2  20 80 98     	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
008A8C  2  BA           	TSX				; get stack pointer back
008A8D  2  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
008A90  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
008A92  2  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
008A94  2  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
008A96  2  20 C1 95     	JSR	LAB_246C		; add (FOR variable) to FAC1
008A99  2  20 A6 98     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
008A9C  2  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
008A9E  2  20 1C 99     	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
008AA1  2  BA           	TSX				; get stack pointer back
008AA2  2  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
008AA5  2  F0 17        	BEQ	LAB_1A9B		; branch if = (loop complete)
008AA7  2               
008AA7  2               					; loop back and do it all again
008AA7  2  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
008AAA  2  85 87        	STA	Clinel		; save current line low byte
008AAC  2  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
008AAF  2  85 88        	STA	Clineh		; save current line high byte
008AB1  2  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
008AB4  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
008AB6  2  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
008AB9  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
008ABB  2               LAB_1A98
008ABB  2  4C BF 84     	JMP	LAB_15C2		; go do interpreter inner loop
008ABE  2               
008ABE  2               					; loop complete so carry on
008ABE  2               LAB_1A9B
008ABE  2  8A           	TXA				; stack copy to A
008ABF  2  69 0F        	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
008AC1  2  AA           	TAX				; copy back to index
008AC2  2  9A           	TXS				; copy to stack pointer
008AC3  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008AC6  2  C9 2C        	CMP	#','			; compare with ","
008AC8  2  D0 F1        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
008ACA  2               
008ACA  2               					; was "," so another NEXT variable to do
008ACA  2  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
008ACD  2  20 6E 8A     	JSR	LAB_1A46		; do NEXT (var)
008AD0  2               
008AD0  2               ; evaluate expression and check is numeric, else do type mismatch
008AD0  2               
008AD0  2               LAB_EVNM
008AD0  2  20 E4 8A     	JSR	LAB_EVEX		; evaluate expression
008AD3  2               
008AD3  2               ; check if source is numeric, else do type mismatch
008AD3  2               
008AD3  2               LAB_CTNM
008AD3  2  18           	CLC				; destination is numeric
008AD4  2  24           	.byte	$24			; makes next line BIT $38
008AD5  2               
008AD5  2               ; check if source is string, else do type mismatch
008AD5  2               
008AD5  2               LAB_CTST
008AD5  2  38           	SEC				; required type is string
008AD6  2               
008AD6  2               ; type match check, set C for string, clear C for numeric
008AD6  2               
008AD6  2               LAB_CKTM
008AD6  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
008AD8  2  30 03        	BMI	LAB_1ABA		; branch if data type is string
008ADA  2               
008ADA  2               					; else data type was numeric
008ADA  2  B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
008ADC  2               LAB_1AB9
008ADC  2  60           	RTS
008ADD  2               
008ADD  2               					; data type was string, now check required type
008ADD  2               LAB_1ABA
008ADD  2  B0 FD        	BCS	LAB_1AB9		; exit if required type is string
008ADF  2               
008ADF  2               					; else do type mismatch error
008ADF  2               LAB_1ABC
008ADF  2  A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
008AE1  2               LAB_1ABE
008AE1  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
008AE4  2               
008AE4  2               ; evaluate expression
008AE4  2               
008AE4  2               LAB_EVEX
008AE4  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
008AE6  2  D0 02        	BNE	LAB_1AC7		; skip next if not zero
008AE8  2               
008AE8  2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
008AEA  2               LAB_1AC7
008AEA  2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
008AEC  2               
008AEC  2               LAB_EVEZ
008AEC  2  A9 00        	LDA	#$00			; set null precedence (flag done)
008AEE  2               LAB_1ACC
008AEE  2  48           	PHA				; push precedence byte
008AEF  2  A9 02        	LDA	#$02			; 2 bytes
008AF1  2  20 06 81     	JSR	LAB_1212		; check room on stack for A bytes
008AF4  2  20 D0 8B     	JSR	LAB_GVAL		; get value from line
008AF7  2  A9 00        	LDA	#$00			; clear A
008AF9  2  85 9B        	STA	comp_f		; clear compare function flag
008AFB  2               LAB_1ADB
008AFB  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008AFE  2               LAB_1ADE
008AFE  2  38           	SEC				; set carry for subtract
008AFF  2  E9 C0        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
008B01  2  90 17        	BCC	LAB_1AFA		; branch if < TK_GT
008B03  2               
008B03  2  C9 03        	CMP	#$03			; compare with ">" to "<" tokens
008B05  2  B0 13        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
008B07  2               
008B07  2               					; was token for > = or < (A = 0, 1 or 2)
008B07  2  C9 01        	CMP	#$01			; compare with token for =
008B09  2  2A           	ROL				; *2, b0 = carry (=1 if token was = or <)
008B0A  2               					; (A = 0, 3 or 5)
008B0A  2  49 01        	EOR	#$01			; toggle b0
008B0C  2               					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
008B0C  2  45 9B        	EOR	comp_f		; EOR with compare function flag bits
008B0E  2  C5 9B        	CMP	comp_f		; compare with compare function flag
008B10  2  90 67        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
008B12  2               					; was more than one <, = or >)
008B12  2               
008B12  2  85 9B        	STA	comp_f		; save new compare function flag
008B14  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
008B17  2  4C FE 8A     	JMP	LAB_1ADE		; go do next character
008B1A  2               
008B1A  2               					; token is < ">" or > "<" tokens
008B1A  2               LAB_1AFA
008B1A  2  A6 9B        	LDX	comp_f		; get compare function flag
008B1C  2  D0 2C        	BNE	LAB_1B2A		; branch if compare function
008B1E  2               
008B1E  2  B0 79        	BCS	LAB_1B78		; go do functions
008B20  2               
008B20  2               					; else was <  TK_GT so is operator or lower
008B20  2  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
008B22  2  90 75        	BCC	LAB_1B78		; branch if < + operator
008B24  2               
008B24  2               					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
008B24  2  D0 07        	BNE	LAB_1B0B		; branch if not + token
008B26  2               
008B26  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
008B28  2  10 03        	BPL	LAB_1B0B		; branch if not string
008B2A  2               
008B2A  2               					; will only be $00 if type is string and token was +
008B2A  2  4C D7 92     	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
008B2D  2               					; is in line, and return
008B2D  2               
008B2D  2               LAB_1B0B
008B2D  2  85 71        	STA	ut1_pl		; save it
008B2F  2  0A           	ASL				; *2
008B30  2  65 71        	ADC	ut1_pl		; *3
008B32  2  A8           	TAY				; copy to index
008B33  2               LAB_1B13
008B33  2  68           	PLA				; pull previous precedence
008B34  2  D9 EC A2     	CMP	LAB_OPPT,Y		; compare with precedence byte
008B37  2  B0 65        	BCS	LAB_1B7D		; branch if A >=
008B39  2               
008B39  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
008B3C  2               LAB_1B1C
008B3C  2  48           	PHA				; save precedence
008B3D  2               LAB_1B1D
008B3D  2  20 65 8B     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
008B40  2  68           	PLA				; restore precedence
008B41  2  A4 99        	LDY	prstk			; get precedence stacked flag
008B43  2  10 19        	BPL	LAB_1B3C		; branch if stacked values
008B45  2               
008B45  2  AA           	TAX				; copy precedence (set flags)
008B46  2  F0 76        	BEQ	LAB_1B9D		; exit if done
008B48  2               
008B48  2  D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
008B4A  2               
008B4A  2               LAB_1B2A
008B4A  2  26 5F        	ROL	Dtypef		; shift data type flag into Cb
008B4C  2  8A           	TXA				; copy compare function flag
008B4D  2  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
008B4F  2  2A           	ROL				; shift data type into compare function byte b0
008B50  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
008B52  2  D0 02        	BNE	LAB_1B34		; branch if no underflow
008B54  2               
008B54  2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
008B56  2               LAB_1B34
008B56  2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
008B58  2               TK_LT_PLUS	= TK_LT-TK_PLUS
008B58  2  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
008B5A  2  85 9B        	STA	comp_f		; save new compare function flag
008B5C  2  D0 D5        	BNE	LAB_1B13		; branch always
008B5E  2               
008B5E  2               LAB_1B3C
008B5E  2  D9 EC A2     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
008B61  2  B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
008B63  2               
008B63  2  90 D7        	BCC	LAB_1B1C		; branch always
008B65  2               
008B65  2               ;.get vector, execute function then continue evaluation
008B65  2               
008B65  2               LAB_1B43
008B65  2  B9 EE A2     	LDA	LAB_OPPT+2,Y	; get function vector high byte
008B68  2  48           	PHA				; onto stack
008B69  2  B9 ED A2     	LDA	LAB_OPPT+1,Y	; get function vector low byte
008B6C  2  48           	PHA				; onto stack
008B6D  2               					; now push sign, round FAC1 and put on stack
008B6D  2  20 7C 8B     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
008B70  2               					; the function
008B70  2  A5 9B        	LDA	comp_f		; get compare function flag
008B72  2  48           	PHA				; push compare evaluation byte
008B73  2  B9 EC A2     	LDA	LAB_OPPT,Y		; get precedence byte
008B76  2  4C EE 8A     	JMP	LAB_1ACC		; continue evaluating expression
008B79  2               
008B79  2               LAB_1B53
008B79  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
008B7C  2               
008B7C  2               ; push sign, round FAC1 and put on stack
008B7C  2               
008B7C  2               LAB_1B5B
008B7C  2  68           	PLA				; get return addr low byte
008B7D  2  85 71        	STA	ut1_pl		; save it
008B7F  2  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
008B81  2               					; note! no check is made on the high byte! if the calling
008B81  2               					; routine assembles to a page edge then this all goes
008B81  2               					; horribly wrong !!!
008B81  2  68           	PLA				; get return addr high byte
008B82  2  85 72        	STA	ut1_ph		; save it
008B84  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
008B86  2  48           	PHA				; push sign
008B87  2               
008B87  2               ; round FAC1 and put on stack
008B87  2               
008B87  2               LAB_1B66
008B87  2  20 DC 98     	JSR	LAB_27BA		; round FAC1
008B8A  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
008B8C  2  48           	PHA				; push on stack
008B8D  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
008B8F  2  48           	PHA				; push on stack
008B90  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
008B92  2  48           	PHA				; push on stack
008B93  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
008B95  2  48           	PHA				; push on stack
008B96  2  6C 71 00     	JMP	(ut1_pl)		; return, sort of
008B99  2               
008B99  2               ; do functions
008B99  2               
008B99  2               LAB_1B78
008B99  2  A0 FF        	LDY	#$FF			; flag function
008B9B  2  68           	PLA				; pull precedence byte
008B9C  2               LAB_1B7B
008B9C  2  F0 20        	BEQ	LAB_1B9D		; exit if done
008B9E  2               
008B9E  2               LAB_1B7D
008B9E  2  C9 64        	CMP	#$64			; compare previous precedence with $64
008BA0  2  F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
008BA2  2               
008BA2  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
008BA5  2               LAB_1B84
008BA5  2  84 99        	STY	prstk			; save precedence stacked flag
008BA7  2               
008BA7  2               					; pop FAC2 and return
008BA7  2               LAB_1B86
008BA7  2  68           	PLA				; pop byte
008BA8  2  4A           	LSR				; shift out comparison evaluation lowest bit
008BA9  2  85 63        	STA	Cflag			; save comparison evaluation flag
008BAB  2  68           	PLA				; pop exponent
008BAC  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
008BAE  2  68           	PLA				; pop mantissa1
008BAF  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
008BB1  2  68           	PLA				; pop mantissa2
008BB2  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
008BB4  2  68           	PLA				; pop mantissa3
008BB5  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
008BB7  2  68           	PLA				; pop sign
008BB8  2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
008BBA  2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
008BBC  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
008BBE  2               LAB_1B9D
008BBE  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
008BC0  2  60           	RTS
008BC1  2               
008BC1  2               ; print "..." string to string util area
008BC1  2               
008BC1  2               LAB_1BC1
008BC1  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
008BC3  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
008BC5  2  69 00        	ADC	#$00			; add carry to low byte
008BC7  2  90 01        	BCC	LAB_1BCA		; branch if no overflow
008BC9  2               
008BC9  2  C8           	INY				; increment high byte
008BCA  2               LAB_1BCA
008BCA  2  20 47 91     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
008BCD  2  4C D2 94     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
008BD0  2               
008BD0  2               ; get value from line
008BD0  2               
008BD0  2               LAB_GVAL
008BD0  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
008BD3  2  B0 03        	BCS	LAB_1BAC		; branch if not numeric character
008BD5  2               
008BD5  2               					; else numeric string found (e.g. 123)
008BD5  2               LAB_1BA9
008BD5  2  4C A9 99     	JMP	LAB_2887		; get FAC1 from string and return
008BD8  2               
008BD8  2               ; get value from line .. continued
008BD8  2               
008BD8  2               					; wasn't a number so ..
008BD8  2               LAB_1BAC
008BD8  2  AA           	TAX				; set the flags
008BD9  2  30 2F        	BMI	LAB_1BD0		; if -ve go test token values
008BDB  2               
008BDB  2               					; else it is either a string, number, variable or (<expr>)
008BDB  2  C9 24        	CMP	#'$'			; compare with "$"
008BDD  2  F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
008BDF  2               
008BDF  2  C9 25        	CMP	#'%'			; else compare with "%"
008BE1  2  F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
008BE3  2               
008BE3  2  C9 2E        	CMP	#'.'			; compare with "."
008BE5  2  F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
008BE7  2               
008BE7  2               					; it wasn't any sort of number so ..
008BE7  2  C9 22        	CMP	#$22			; compare with "
008BE9  2  F0 D6        	BEQ	LAB_1BC1		; branch if open quote
008BEB  2               
008BEB  2               					; wasn't any sort of number so ..
008BEB  2               
008BEB  2               ; evaluate expression within parentheses
008BEB  2               
008BEB  2  C9 28        	CMP	#'('			; compare with "("
008BED  2  D0 4F        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
008BEF  2               
008BEF  2               LAB_1BF7
008BEF  2  20 EC 8A     	JSR	LAB_EVEZ		; evaluate expression, no decrement
008BF2  2               
008BF2  2               ; all the 'scan for' routines return the character after the sought character
008BF2  2               
008BF2  2               ; scan for ")" , else do syntax error then warm start
008BF2  2               
008BF2  2               LAB_1BFB
008BF2  2  A9 29        	LDA	#$29			; load A with ")"
008BF4  2               
008BF4  2               ; scan for CHR$(A) , else do syntax error then warm start
008BF4  2               
008BF4  2               LAB_SCCA
008BF4  2  A0 00        	LDY	#$00			; clear index
008BF6  2  D1 C3        	CMP	(Bpntrl),Y		; check next byte is = A
008BF8  2  D0 0B        	BNE	LAB_SNER		; if not do syntax error then warm start
008BFA  2               
008BFA  2  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then return
008BFD  2               
008BFD  2               ; scan for "(" , else do syntax error then warm start
008BFD  2               
008BFD  2               LAB_1BFE
008BFD  2  A9 28        	LDA	#$28			; load A with "("
008BFF  2  D0 F3        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
008C01  2               					; (branch always)
008C01  2               
008C01  2               ; scan for "," , else do syntax error then warm start
008C01  2               
008C01  2               LAB_1C01
008C01  2  A9 2C        	LDA	#$2C			; load A with ","
008C03  2  D0 EF        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
008C05  2               					; (branch always)
008C05  2               
008C05  2               ; syntax error then warm start
008C05  2               
008C05  2               LAB_SNER
008C05  2  A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
008C07  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
008C0A  2               
008C0A  2               ; get value from line .. continued
008C0A  2               ; do tokens
008C0A  2               
008C0A  2               LAB_1BD0
008C0A  2  C9 B7        	CMP	#TK_MINUS		; compare with token for -
008C0C  2  F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
008C0E  2               
008C0E  2               					; wasn't -n so ..
008C0E  2  C9 B6        	CMP	#TK_PLUS		; compare with token for +
008C10  2  F0 BE        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
008C12  2               
008C12  2  C9 B1        	CMP	#TK_NOT		; compare with token for NOT
008C14  2  D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
008C16  2               
008C16  2               					; was NOT token
008C16  2               TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
008C16  2  A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
008C18  2  D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
008C1A  2               
008C1A  2               ; do = compare
008C1A  2               
008C1A  2               LAB_EQUAL
008C1A  2  20 A9 8E     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
008C1D  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
008C1F  2  49 FF        	EOR	#$FF			; invert it
008C21  2  A8           	TAY				; copy it
008C22  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
008C24  2  49 FF        	EOR	#$FF			; invert it
008C26  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008C29  2               
008C29  2               ; get value from line .. continued
008C29  2               
008C29  2               					; wasn't +, -, or NOT so ..
008C29  2               LAB_1BE7
008C29  2  C9 AE        	CMP	#TK_FN		; compare with token for FN
008C2B  2  D0 03        	BNE	LAB_1BEE		; branch if not token for FN
008C2D  2               
008C2D  2  4C B7 90     	JMP	LAB_201E		; go evaluate FNx
008C30  2               
008C30  2               ; get value from line .. continued
008C30  2               
008C30  2               					; wasn't +, -, NOT or FN so ..
008C30  2               LAB_1BEE
008C30  2  E9 C3        	SBC	#TK_SGN		; subtract with token for SGN
008C32  2  B0 19        	BCS	LAB_1C27		; if a function token go do it
008C34  2               
008C34  2  4C 05 8C     	JMP	LAB_SNER		; else do syntax error
008C37  2               
008C37  2               ; set-up for functions
008C37  2               
008C37  2               LAB_1C11
008C37  2               TK_GT_PLUS	= TK_GT-TK_PLUS
008C37  2  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
008C39  2               LAB_1C13
008C39  2  68           	PLA				; dump return address low byte
008C3A  2  68           	PLA				; dump return address high byte
008C3B  2  4C 3D 8B     	JMP	LAB_1B1D		; execute function then continue evaluation
008C3E  2               
008C3E  2               ; variable name set-up
008C3E  2               ; get (var), return value in FAC_1 and $ flag
008C3E  2               
008C3E  2               LAB_1C18
008C3E  2  20 AD 8D     	JSR	LAB_GVAR		; get (var) address
008C41  2  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
008C43  2  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
008C45  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
008C47  2  30 03        	BMI	LAB_1C25		; if string then return (does RTS)
008C49  2               
008C49  2               LAB_1C24
008C49  2  4C 80 98     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
008C4C  2               
008C4C  2               LAB_1C25
008C4C  2  60           	RTS
008C4D  2               
008C4D  2               ; get value from line .. continued
008C4D  2               ; only functions left so ..
008C4D  2               
008C4D  2               ; set up function references
008C4D  2               
008C4D  2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
008C4D  2               ; to process function calls. now the function vector is computed and pushed on the stack
008C4D  2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
008C4D  2               ; is calculated and the routine called, if not this routine just does RTS. whichever
008C4D  2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
008C4D  2               ; the function code
008C4D  2               
008C4D  2               ; this also removes some less than elegant code that was used to bypass type checking
008C4D  2               ; for functions that returned strings
008C4D  2               
008C4D  2               LAB_1C27
008C4D  2  0A           	ASL				; *2 (2 bytes per function address)
008C4E  2  A8           	TAY				; copy to index
008C4F  2               
008C4F  2  B9 A7 A2     	LDA	LAB_FTBM,Y		; get function jump vector high byte
008C52  2  48           	PHA				; push functions jump vector high byte
008C53  2  B9 A6 A2     	LDA	LAB_FTBL,Y		; get function jump vector low byte
008C56  2  48           	PHA				; push functions jump vector low byte
008C57  2               
008C57  2  B9 61 A2     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
008C5A  2  F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
008C5C  2               
008C5C  2  48           	PHA				; push functions pre process vector high byte
008C5D  2  B9 60 A2     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
008C60  2  48           	PHA				; push functions pre process vector low byte
008C61  2               
008C61  2               LAB_1C56
008C61  2  60           	RTS				; do function, or pre process, call
008C62  2               
008C62  2               ; process string expression in parenthesis
008C62  2               
008C62  2               LAB_PPFS
008C62  2  20 EF 8B     	JSR	LAB_1BF7		; process expression in parenthesis
008C65  2  4C D5 8A     	JMP	LAB_CTST		; check if source is string then do function,
008C68  2               					; else do type mismatch
008C68  2               
008C68  2               ; process numeric expression in parenthesis
008C68  2               
008C68  2               LAB_PPFN
008C68  2  20 EF 8B     	JSR	LAB_1BF7		; process expression in parenthesis
008C6B  2  4C D3 8A     	JMP	LAB_CTNM		; check if source is numeric then do function,
008C6E  2               					; else do type mismatch
008C6E  2               
008C6E  2               ; set numeric data type and increment BASIC execute pointer
008C6E  2               
008C6E  2               LAB_PPBI
008C6E  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
008C70  2  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then do function
008C73  2               
008C73  2               ; process string for LEFT$, RIGHT$ or MID$
008C73  2               
008C73  2               LAB_LRMS
008C73  2  20 EC 8A     	JSR	LAB_EVEZ		; evaluate (should be string) expression
008C76  2  20 01 8C     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
008C79  2  20 D5 8A     	JSR	LAB_CTST		; check if source is string, else do type mismatch
008C7C  2               
008C7C  2  68           	PLA				; get function jump vector low byte
008C7D  2  AA           	TAX				; save functions jump vector low byte
008C7E  2  68           	PLA				; get function jump vector high byte
008C7F  2  A8           	TAY				; save functions jump vector high byte
008C80  2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
008C82  2  48           	PHA				; push string pointer high byte
008C83  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
008C85  2  48           	PHA				; push string pointer low byte
008C86  2  98           	TYA				; get function jump vector high byte back
008C87  2  48           	PHA				; save functions jump vector high byte
008C88  2  8A           	TXA				; get function jump vector low byte back
008C89  2  48           	PHA				; save functions jump vector low byte
008C8A  2  20 8F 94     	JSR	LAB_GTBY		; get byte parameter
008C8D  2  8A           	TXA				; copy byte parameter to A
008C8E  2  60           	RTS				; go do function
008C8F  2               
008C8F  2               ; process numeric expression(s) for BIN$ or HEX$
008C8F  2               
008C8F  2               LAB_BHSS
008C8F  2  20 EC 8A     	JSR	LAB_EVEZ		; process expression
008C92  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
008C95  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
008C97  2  C9 98        	CMP	#$98			; compare with exponent = 2^24
008C99  2  B0 20        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
008C9B  2               
008C9B  2  20 53 99     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
008C9E  2  A2 02        	LDX	#$02			; 3 bytes to do
008CA0  2               LAB_CFAC
008CA0  2  B5 AD        	LDA	FAC1_1,X		; get byte from FAC1
008CA2  2  95 11        	STA	nums_1,X		; save byte to temp
008CA4  2  CA           	DEX				; decrement index
008CA5  2  10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
008CA7  2               
008CA7  2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
008CAA  2  A2 00        	LDX	#$00			; set default to no leading "0"s
008CAC  2  C9 29        	CMP	#')'			; compare with close bracket
008CAE  2  F0 0A        	BEQ	LAB_1C54		; if ")" go do rest of function
008CB0  2               
008CB0  2  20 E1 94     	JSR	LAB_SCGB		; scan for "," and get byte
008CB3  2  20 C2 00     	JSR	LAB_GBYT		; get last byte back
008CB6  2  C9 29        	CMP	#')'			; is next character )
008CB8  2  D0 01        	BNE	LAB_BHER		; if not ")" go do error
008CBA  2               
008CBA  2               LAB_1C54
008CBA  2  60           	RTS				; else do function
008CBB  2               
008CBB  2               LAB_BHER
008CBB  2  4C 2C 8F     	JMP	LAB_FCER		; do function call error then warm start
008CBE  2               
008CBE  2               ; perform EOR
008CBE  2               
008CBE  2               ; added operator format is the same as AND or OR, precedence is the same as OR
008CBE  2               
008CBE  2               ; this bit worked first time but it took a while to sort out the operator table
008CBE  2               ; pointers and offsets afterwards!
008CBE  2               
008CBE  2               LAB_EOR
008CBE  2  20 E5 8C     	JSR	GetFirst		; get first integer expression (no sign check)
008CC1  2  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
008CC3  2  A8           	TAY				; save in Y
008CC4  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
008CC6  2  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
008CC8  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008CCB  2               
008CCB  2               ; perform OR
008CCB  2               
008CCB  2               LAB_OR
008CCB  2  20 E5 8C     	JSR	GetFirst		; get first integer expression (no sign check)
008CCE  2  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
008CD0  2  A8           	TAY				; save in Y
008CD1  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
008CD3  2  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
008CD5  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008CD8  2               
008CD8  2               ; perform AND
008CD8  2               
008CD8  2               LAB_AND
008CD8  2  20 E5 8C     	JSR	GetFirst		; get first integer expression (no sign check)
008CDB  2  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
008CDD  2  A8           	TAY				; save in Y
008CDE  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
008CE0  2  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
008CE2  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008CE5  2               
008CE5  2               ; get first value for OR, AND or EOR
008CE5  2               
008CE5  2               GetFirst
008CE5  2  20 A9 8E     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
008CE8  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
008CEA  2  85 5C        	STA	XOAw_h		; save it
008CEC  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
008CEE  2  85 5B        	STA	XOAw_l		; save it
008CF0  2  20 C6 95     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
008CF3  2  20 A9 8E     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
008CF6  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
008CF8  2               LAB_1C95
008CF8  2  60           	RTS
008CF9  2               
008CF9  2               ; perform comparisons
008CF9  2               
008CF9  2               ; do < compare
008CF9  2               
008CF9  2               LAB_LTHAN
008CF9  2  20 D6 8A     	JSR	LAB_CKTM		; type match check, set C for string
008CFC  2  B0 13        	BCS	LAB_1CAE		; branch if string
008CFE  2               
008CFE  2               					; do numeric < compare
008CFE  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
008D00  2  09 7F        	ORA	#$7F			; set all non sign bits
008D02  2  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
008D04  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
008D06  2  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
008D08  2  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
008D0A  2  20 1A 99     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
008D0D  2  AA           	TAX				; copy result
008D0E  2  4C 42 8D     	JMP	LAB_1CE1		; go evaluate result
008D11  2               
008D11  2               					; do string < compare
008D11  2               LAB_1CAE
008D11  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
008D13  2  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
008D15  2  20 41 93     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
008D18  2               					; space returns with A = length, X=pointer low byte,
008D18  2               					; Y=pointer high byte
008D18  2  85 AC        	STA	str_ln		; save length
008D1A  2  86 AD        	STX	str_pl		; save string pointer low byte
008D1C  2  84 AE        	STY	str_ph		; save string pointer high byte
008D1E  2  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
008D20  2  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
008D22  2  20 45 93     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
008D25  2               					; returns with A = length, X=pointer low byte,
008D25  2               					; Y=pointer high byte
008D25  2  86 B5        	STX	FAC2_2		; save string pointer low byte
008D27  2  84 B6        	STY	FAC2_3		; save string pointer high byte
008D29  2  AA           	TAX				; copy length
008D2A  2  38           	SEC				; set carry for subtract
008D2B  2  E5 AC        	SBC	str_ln		; subtract string 1 length
008D2D  2  F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
008D2F  2               
008D2F  2  A9 01        	LDA	#$01			; set str 1 length > string 2 length
008D31  2  90 04        	BCC	LAB_1CD6		; branch if so
008D33  2               
008D33  2  A6 AC        	LDX	str_ln		; get string 1 length
008D35  2  A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
008D37  2               LAB_1CD6
008D37  2  85 B0        	STA	FAC1_s		; save length compare
008D39  2  A0 FF        	LDY	#$FF			; set index
008D3B  2  E8           	INX				; adjust for loop
008D3C  2               LAB_1CDB
008D3C  2  C8           	INY				; increment index
008D3D  2  CA           	DEX				; decrement count
008D3E  2  D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
008D40  2               
008D40  2  A6 B0        	LDX	FAC1_s		; get length compare back
008D42  2               LAB_1CE1
008D42  2  30 0F        	BMI	LAB_1CF2		; branch if str 1 < str 2
008D44  2               
008D44  2  18           	CLC				; flag str 1 <= str 2
008D45  2  90 0C        	BCC	LAB_1CF2		; go evaluate result
008D47  2               
008D47  2               LAB_1CE6
008D47  2  B1 B5        	LDA	(FAC2_2),Y		; get string 2 byte
008D49  2  D1 AD        	CMP	(FAC1_1),Y		; compare with string 1 byte
008D4B  2  F0 EF        	BEQ	LAB_1CDB		; loop if bytes =
008D4D  2               
008D4D  2  A2 FF        	LDX	#$FF			; set str 1 < string 2
008D4F  2  B0 02        	BCS	LAB_1CF2		; branch if so
008D51  2               
008D51  2  A2 01        	LDX	#$01			;  set str 1 > string 2
008D53  2               LAB_1CF2
008D53  2  E8           	INX				; x = 0, 1 or 2
008D54  2  8A           	TXA				; copy to A
008D55  2  2A           	ROL				; *2 (1, 2 or 4)
008D56  2  25 63        	AND	Cflag			; AND with comparison evaluation flag
008D58  2  F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
008D5A  2               
008D5A  2  A9 FF        	LDA	#$FF			; else set result true
008D5C  2               LAB_1CFB
008D5C  2  4C FD 98     	JMP	LAB_27DB		; save A as integer byte and return
008D5F  2               
008D5F  2               LAB_1CFE
008D5F  2  20 01 8C     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
008D62  2               
008D62  2               ; perform DIM
008D62  2               
008D62  2               LAB_DIM
008D62  2  AA           	TAX				; copy "DIM" flag to X
008D63  2  20 B2 8D     	JSR	LAB_1D10		; search for variable
008D66  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008D69  2  D0 F4        	BNE	LAB_1CFE		; scan for "," and loop if not null
008D6B  2               
008D6B  2  60           	RTS
008D6C  2               
008D6C  2               ; perform << (left shift)
008D6C  2               
008D6C  2               LAB_LSHIFT
008D6C  2  20 A2 8D     	JSR	GetPair		; get integer expression and byte (no sign check)
008D6F  2  A5 AE        	LDA	FAC1_2		; get expression high byte
008D71  2  A6 78        	LDX	TempB			; get shift count
008D73  2  F0 22        	BEQ	NoShift		; branch if zero
008D75  2               
008D75  2  E0 10        	CPX	#$10			; compare bit count with 16d
008D77  2  B0 23        	BCS	TooBig		; branch if >=
008D79  2               
008D79  2               Ls_loop
008D79  2  06 AF        	ASL	FAC1_3		; shift low byte
008D7B  2  2A           	ROL				; shift high byte
008D7C  2  CA           	DEX				; decrement bit count
008D7D  2  D0 FA        	BNE	Ls_loop		; loop if shift not complete
008D7F  2               
008D7F  2  A4 AF        	LDY	FAC1_3		; get expression low byte
008D81  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008D84  2               
008D84  2               ; perform >> (right shift)
008D84  2               
008D84  2               LAB_RSHIFT
008D84  2  20 A2 8D     	JSR	GetPair		; get integer expression and byte (no sign check)
008D87  2  A5 AE        	LDA	FAC1_2		; get expression high byte
008D89  2  A6 78        	LDX	TempB			; get shift count
008D8B  2  F0 0A        	BEQ	NoShift		; branch if zero
008D8D  2               
008D8D  2  E0 10        	CPX	#$10			; compare bit count with 16d
008D8F  2  B0 0B        	BCS	TooBig		; branch if >=
008D91  2               
008D91  2               Rs_loop
008D91  2  4A           	LSR				; shift high byte
008D92  2  66 AF        	ROR	FAC1_3		; shift low byte
008D94  2  CA           	DEX				; decrement bit count
008D95  2  D0 FA        	BNE	Rs_loop		; loop if shift not complete
008D97  2               
008D97  2               NoShift
008D97  2  A4 AF        	LDY	FAC1_3		; get expression low byte
008D99  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008D9C  2               
008D9C  2               TooBig
008D9C  2  A9 00        	LDA	#$00			; clear high byte
008D9E  2  A8           	TAY				; copy to low byte
008D9F  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
008DA2  2               
008DA2  2               GetPair
008DA2  2  20 92 94     	JSR	LAB_EVBY		; evaluate byte expression, result in X
008DA5  2  86 78        	STX	TempB			; save it
008DA7  2  20 C6 95     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
008DAA  2  4C A9 8E     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
008DAD  2               
008DAD  2               ; search for variable
008DAD  2               
008DAD  2               ; return pointer to variable in Cvaral/Cvarah
008DAD  2               
008DAD  2               LAB_GVAR
008DAD  2  A2 00        	LDX	#$00			; set DIM flag = $00
008DAF  2  20 C2 00     	JSR	LAB_GBYT		; scan memory (1st character)
008DB2  2               LAB_1D10
008DB2  2  86 5E        	STX	Defdim		; save DIM flag
008DB4  2               LAB_1D12
008DB4  2  85 93        	STA	Varnm1		; save 1st character
008DB6  2  29 7F        	AND	#$7F			; clear FN flag bit
008DB8  2  20 21 8E     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
008DBB  2  B0 03        	BCS	LAB_1D1F		; branch if ok
008DBD  2               
008DBD  2  4C 05 8C     	JMP	LAB_SNER		; else syntax error then warm start
008DC0  2               
008DC0  2               					; was variable name so ..
008DC0  2               LAB_1D1F
008DC0  2  A2 00        	LDX	#$00			; clear 2nd character temp
008DC2  2  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
008DC4  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (2nd character)
008DC7  2  90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
008DC9  2               
008DC9  2               					; 2nd character wasn't "0" to "9" so ..
008DC9  2  20 21 8E     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
008DCC  2  90 0B        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
008DCE  2               
008DCE  2               LAB_1D2D
008DCE  2  AA           	TAX				; copy 2nd character
008DCF  2               
008DCF  2               					; ignore further (valid) characters in the variable name
008DCF  2               LAB_1D2E
008DCF  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (3rd character)
008DD2  2  90 FB        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
008DD4  2               
008DD4  2  20 21 8E     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
008DD7  2  B0 F6        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
008DD9  2               
008DD9  2               					; check if string variable
008DD9  2               LAB_1D38
008DD9  2  C9 24        	CMP	#'$'			; compare with "$"
008DDB  2  D0 0B        	BNE	LAB_1D47		; branch if not string
008DDD  2               
008DDD  2               ; to introduce a new variable type (% suffix for integers say) then this branch
008DDD  2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
008DDD  2               
008DDD  2               					; type is string
008DDD  2  A9 FF        	LDA	#$FF			; set data type = string
008DDF  2  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
008DE1  2  8A           	TXA				; get 2nd character back
008DE2  2  09 80        	ORA	#$80			; set top bit (indicate string var)
008DE4  2  AA           	TAX				; copy back to 2nd character temp
008DE5  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
008DE8  2               
008DE8  2               ; after we have determined the variable type we need to come back here to determine
008DE8  2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
008DE8  2               
008DE8  2               
008DE8  2               LAB_1D47				; gets here with character after var name in A
008DE8  2  86 94        	STX	Varnm2		; save 2nd character
008DEA  2  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
008DEC  2  C9 28        	CMP	#'('			; compare with "("
008DEE  2  D0 03        	BNE	LAB_1D53		; branch if not "("
008DF0  2               
008DF0  2  4C BB 8E     	JMP	LAB_1E17		; go find, or make, array
008DF3  2               
008DF3  2               ; either find or create var
008DF3  2               ; var name (1st two characters only!) is in Varnm1,Varnm2
008DF3  2               
008DF3  2               					; variable name wasn't var(... so look for plain var
008DF3  2               LAB_1D53
008DF3  2  A9 00        	LDA	#$00			; clear A
008DF5  2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
008DF7  2  A5 7B        	LDA	Svarl			; get start of vars low byte
008DF9  2  A6 7C        	LDX	Svarh			; get start of vars high byte
008DFB  2  A0 00        	LDY	#$00			; clear index
008DFD  2               LAB_1D5D
008DFD  2  86 AB        	STX	Vrschh		; save search address high byte
008DFF  2               LAB_1D5F
008DFF  2  85 AA        	STA	Vrschl		; save search address low byte
008E01  2  E4 7E        	CPX	Sarryh		; compare high address with var space end
008E03  2  D0 04        	BNE	LAB_1D69		; skip next compare if <>
008E05  2               
008E05  2               					; high addresses were = so compare low addresses
008E05  2  C5 7D        	CMP	Sarryl		; compare low address with var space end
008E07  2  F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
008E09  2               
008E09  2               LAB_1D69
008E09  2  A5 93        	LDA	Varnm1		; get 1st character of var to find
008E0B  2  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 1st character
008E0D  2  D0 08        	BNE	LAB_1D77		; branch if no match
008E0F  2               
008E0F  2               					; 1st characters match so compare 2nd characters
008E0F  2  A5 94        	LDA	Varnm2		; get 2nd character of var to find
008E11  2  C8           	INY				; index to point to variable name 2nd character
008E12  2  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 2nd character
008E14  2  F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
008E16  2               
008E16  2  88           	DEY				; else decrement index (now = $00)
008E17  2               LAB_1D77
008E17  2  18           	CLC				; clear carry for add
008E18  2  A5 AA        	LDA	Vrschl		; get search address low byte
008E1A  2  69 06        	ADC	#$06			; +6 (offset to next var name)
008E1C  2  90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
008E1E  2               
008E1E  2  E8           	INX				; else increment high byte
008E1F  2  D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
008E21  2               
008E21  2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
008E21  2               
008E21  2               LAB_CASC
008E21  2  C9 61        	CMP	#'a'			; compare with "a"
008E23  2  B0 0A        	BCS	LAB_1D83		; go check <"z"+1
008E25  2               
008E25  2               ; check byte, return C=0 if<"A" or >"Z"
008E25  2               
008E25  2               LAB_1D82
008E25  2  C9 41        	CMP	#'A'			; compare with "A"
008E27  2  90 05        	BCC	LAB_1D8A		; exit if less
008E29  2               
008E29  2               					; carry is set
008E29  2  E9 5B        	SBC	#$5B			; subtract "Z"+1
008E2B  2  38           	SEC				; set carry
008E2C  2  E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
008E2E  2               					; carry clear if byte>$5A
008E2E  2               LAB_1D8A
008E2E  2  60           	RTS
008E2F  2               
008E2F  2               LAB_1D83
008E2F  2  E9 7B        	SBC	#$7B			; subtract "z"+1
008E31  2  38           	SEC				; set carry
008E32  2  E9 85        	SBC	#$85			; subtract $85 (restore byte)
008E34  2               					; carry clear if byte>$7A
008E34  2  60           	RTS
008E35  2               
008E35  2               					; reached end of variable mem without match
008E35  2               					; .. so create new variable
008E35  2               LAB_1D8B
008E35  2  68           	PLA				; pop return address low byte
008E36  2  48           	PHA				; push return address low byte
008E37  2               LAB_1C18p2	= LAB_1C18+2
008E37  2  C9 40        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
008E39  2  D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
008E3B  2               
008E3B  2               ; This will only drop through if the call was from LAB_1C18 and is only called
008E3B  2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
008E3B  2               ; it prevents the creation of variables not assigned a value.
008E3B  2               
008E3B  2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
008E3B  2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
008E3B  2               
008E3B  2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
008E3B  2               
008E3B  2               ; this is where you would put the undefined variable error call e.g.
008E3B  2               
008E3B  2               ;					; variable doesn't exist so flag error
008E3B  2               ;	LDX	#$24			; error code $24 ("undefined variable" error)
008E3B  2               ;	JMP	LAB_XERR		; do error #X then warm start
008E3B  2               
008E3B  2               ; the above code has been tested and works a treat! (it replaces the three code lines
008E3B  2               ; below)
008E3B  2               
008E3B  2               					; else return dummy null value
008E3B  2  A9 E4        	LDA	#<LAB_1D96		; low byte point to $00,$00
008E3D  2               					; (uses part of misc constants table)
008E3D  2  A0 A1        	LDY	#>LAB_1D96		; high byte point to $00,$00
008E3F  2  60           	RTS
008E40  2               
008E40  2               					; create new numeric variable
008E40  2               LAB_1D98
008E40  2  A5 7D        	LDA	Sarryl		; get var mem end low byte
008E42  2  A4 7E        	LDY	Sarryh		; get var mem end high byte
008E44  2  85 AA        	STA	Ostrtl		; save old block start low byte
008E46  2  84 AB        	STY	Ostrth		; save old block start high byte
008E48  2  A5 7F        	LDA	Earryl		; get array mem end low byte
008E4A  2  A4 80        	LDY	Earryh		; get array mem end high byte
008E4C  2  85 A6        	STA	Obendl		; save old block end low byte
008E4E  2  84 A7        	STY	Obendh		; save old block end high byte
008E50  2  18           	CLC				; clear carry for add
008E51  2  69 06        	ADC	#$06			; +6 (space for one var)
008E53  2  90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
008E55  2               
008E55  2  C8           	INY				; else increment high byte
008E56  2               LAB_1DAE
008E56  2  85 A4        	STA	Nbendl		; set new block end low byte
008E58  2  84 A5        	STY	Nbendh		; set new block end high byte
008E5A  2  20 C4 80     	JSR	LAB_11CF		; open up space in memory
008E5D  2  A5 A4        	LDA	Nbendl		; get new start low byte
008E5F  2  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
008E61  2  C8           	INY				; correct high byte
008E62  2  85 7D        	STA	Sarryl		; save new var mem end low byte
008E64  2  84 7E        	STY	Sarryh		; save new var mem end high byte
008E66  2  A0 00        	LDY	#$00			; clear index
008E68  2  A5 93        	LDA	Varnm1		; get var name 1st character
008E6A  2  91 AA        	STA	(Vrschl),Y		; save var name 1st character
008E6C  2  C8           	INY				; increment index
008E6D  2  A5 94        	LDA	Varnm2		; get var name 2nd character
008E6F  2  91 AA        	STA	(Vrschl),Y		; save var name 2nd character
008E71  2  A9 00        	LDA	#$00			; clear A
008E73  2  C8           	INY				; increment index
008E74  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
008E76  2  C8           	INY				; increment index
008E77  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
008E79  2  C8           	INY				; increment index
008E7A  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
008E7C  2  C8           	INY				; increment index
008E7D  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
008E7F  2               
008E7F  2               					; found a match for var ((Vrschl) = ptr)
008E7F  2               LAB_1DD7
008E7F  2  A5 AA        	LDA	Vrschl		; get var address low byte
008E81  2  18           	CLC				; clear carry for add
008E82  2  69 02        	ADC	#$02			; +2 (offset past var name bytes)
008E84  2  A4 AB        	LDY	Vrschh		; get var address high byte
008E86  2  90 01        	BCC	LAB_1DE1		; branch if no overflow from add
008E88  2               
008E88  2  C8           	INY				; else increment high byte
008E89  2               LAB_1DE1
008E89  2  85 95        	STA	Cvaral		; save current var address low byte
008E8B  2  84 96        	STY	Cvarah		; save current var address high byte
008E8D  2  60           	RTS
008E8E  2               
008E8E  2               ; set-up array pointer (Adatal/h) to first element in array
008E8E  2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
008E8E  2               
008E8E  2               LAB_1DE6
008E8E  2  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
008E90  2  0A           	ASL				; *2 (also clears the carry !)
008E91  2  69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
008E93  2  65 AA        	ADC	Astrtl		; add array start pointer low byte
008E95  2  A4 AB        	LDY	Astrth		; get array pointer high byte
008E97  2  90 01        	BCC	LAB_1DF2		; branch if no overflow
008E99  2               
008E99  2  C8           	INY				; else increment high byte
008E9A  2               LAB_1DF2
008E9A  2  85 A4        	STA	Adatal		; save array data pointer low byte
008E9C  2  84 A5        	STY	Adatah		; save array data pointer high byte
008E9E  2  60           	RTS
008E9F  2               
008E9F  2               ; evaluate integer expression
008E9F  2               
008E9F  2               LAB_EVIN
008E9F  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
008EA2  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
008EA5  2               					; else do type mismatch
008EA5  2               
008EA5  2               ; evaluate integer expression (no check)
008EA5  2               
008EA5  2               LAB_EVPI
008EA5  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
008EA7  2  30 0D        	BMI	LAB_1E12		; do function call error if -ve
008EA9  2               
008EA9  2               ; evaluate integer expression (no sign check)
008EA9  2               
008EA9  2               LAB_EVIR
008EA9  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
008EAB  2  C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
008EAD  2  90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
008EAF  2               
008EAF  2  A9 EB        	LDA	#<LAB_1DF7		; set pointer low byte to -32768
008EB1  2  A0 A1        	LDY	#>LAB_1DF7		; set pointer high byte to -32768
008EB3  2  20 1A 99     	JSR	LAB_27F8		; compare FAC1 with (AY)
008EB6  2               LAB_1E12
008EB6  2  D0 74        	BNE	LAB_FCER		; if <> do function call error then warm start
008EB8  2               
008EB8  2               LAB_1E14
008EB8  2  4C 53 99     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
008EBB  2               
008EBB  2               ; find or make array
008EBB  2               
008EBB  2               LAB_1E17
008EBB  2  A5 5E        	LDA	Defdim		; get DIM flag
008EBD  2  48           	PHA				; push it
008EBE  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
008EC0  2  48           	PHA				; push it
008EC1  2  A0 00        	LDY	#$00			; clear dimensions count
008EC3  2               
008EC3  2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
008EC3  2               
008EC3  2               LAB_1E1F
008EC3  2  98           	TYA				; copy dimensions count
008EC4  2  48           	PHA				; save it
008EC5  2  A5 94        	LDA	Varnm2		; get array name 2nd byte
008EC7  2  48           	PHA				; save it
008EC8  2  A5 93        	LDA	Varnm1		; get array name 1st byte
008ECA  2  48           	PHA				; save it
008ECB  2  20 9F 8E     	JSR	LAB_EVIN		; evaluate integer expression
008ECE  2  68           	PLA				; pull array name 1st byte
008ECF  2  85 93        	STA	Varnm1		; restore array name 1st byte
008ED1  2  68           	PLA				; pull array name 2nd byte
008ED2  2  85 94        	STA	Varnm2		; restore array name 2nd byte
008ED4  2  68           	PLA				; pull dimensions count
008ED5  2  A8           	TAY				; restore it
008ED6  2  BA           	TSX				; copy stack pointer
008ED7  2  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
008EDA  2  48           	PHA				; push it
008EDB  2  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
008EDE  2  48           	PHA				; push it
008EDF  2  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
008EE1  2  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
008EE4  2  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
008EE6  2  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
008EE9  2  C8           	INY				; increment dimensions count
008EEA  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
008EED  2  C9 2C        	CMP	#','			; compare with ","
008EEF  2  F0 D2        	BEQ	LAB_1E1F		; if found go do next dimension
008EF1  2               
008EF1  2  84 5D        	STY	Dimcnt		; store dimensions count
008EF3  2  20 F2 8B     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
008EF6  2  68           	PLA				; pull data type flag
008EF7  2  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
008EF9  2  68           	PLA				; pull DIM flag
008EFA  2  85 5E        	STA	Defdim		; restore DIM flag
008EFC  2  A6 7D        	LDX	Sarryl		; get array mem start low byte
008EFE  2  A5 7E        	LDA	Sarryh		; get array mem start high byte
008F00  2               
008F00  2               ; now check to see if we are at the end of array memory (we would be if there were
008F00  2               ; no arrays).
008F00  2               
008F00  2               LAB_1E5C
008F00  2  86 AA        	STX	Astrtl		; save as array start pointer low byte
008F02  2  85 AB        	STA	Astrth		; save as array start pointer high byte
008F04  2  C5 80        	CMP	Earryh		; compare with array mem end high byte
008F06  2  D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
008F08  2               
008F08  2  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
008F0A  2  F0 39        	BEQ	LAB_1EA1		; go build array if not found
008F0C  2               
008F0C  2               					; search for array
008F0C  2               LAB_1E68
008F0C  2  A0 00        	LDY	#$00			; clear index
008F0E  2  B1 AA        	LDA	(Astrtl),Y		; get array name first byte
008F10  2  C8           	INY				; increment index to second name byte
008F11  2  C5 93        	CMP	Varnm1		; compare with this array name first byte
008F13  2  D0 06        	BNE	LAB_1E77		; branch if no match
008F15  2               
008F15  2  A5 94        	LDA	Varnm2		; else get this array name second byte
008F17  2  D1 AA        	CMP	(Astrtl),Y		; compare with array name second byte
008F19  2  F0 16        	BEQ	LAB_1E8D		; array found so branch
008F1B  2               
008F1B  2               					; no match
008F1B  2               LAB_1E77
008F1B  2  C8           	INY				; increment index
008F1C  2  B1 AA        	LDA	(Astrtl),Y		; get array size low byte
008F1E  2  18           	CLC				; clear carry for add
008F1F  2  65 AA        	ADC	Astrtl		; add array start pointer low byte
008F21  2  AA           	TAX				; copy low byte to X
008F22  2  C8           	INY				; increment index
008F23  2  B1 AA        	LDA	(Astrtl),Y		; get array size high byte
008F25  2  65 AB        	ADC	Astrth		; add array mem pointer high byte
008F27  2  90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
008F29  2               
008F29  2               ; do array bounds error
008F29  2               
008F29  2               LAB_1E85
008F29  2  A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
008F2B  2  2C           	.byte	$2C			; makes next bit BIT LAB_08A2
008F2C  2               
008F2C  2               ; do function call error
008F2C  2               
008F2C  2               LAB_FCER
008F2C  2  A2 08        	LDX	#$08			; error code $08 ("Function call" error)
008F2E  2               LAB_1E8A
008F2E  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
008F31  2               
008F31  2               					; found array, are we trying to dimension it?
008F31  2               LAB_1E8D
008F31  2  A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
008F33  2  A5 5E        	LDA	Defdim		; get DIM flag
008F35  2  D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
008F37  2               					; start
008F37  2               
008F37  2               ; found the array and we're not dimensioning it so we must find an element in it
008F37  2               
008F37  2  20 8E 8E     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
008F3A  2               					; (Astrtl,Astrth points to start of array)
008F3A  2  A5 5D        	LDA	Dimcnt		; get dimensions count
008F3C  2  A0 04        	LDY	#$04			; set index to array's # of dimensions
008F3E  2  D1 AA        	CMP	(Astrtl),Y		; compare with no of dimensions
008F40  2  D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
008F42  2               					; dimensions" error here .. if we want a different
008F42  2               					; error message
008F42  2               
008F42  2  4C C8 8F     	JMP	LAB_1F28		; found array so go get element
008F45  2               					; (could jump to LAB_1F28 as all LAB_1F24 does is take
008F45  2               					; Dimcnt and save it at (Astrtl),Y which is already the
008F45  2               					; same or we would have taken the BNE)
008F45  2               
008F45  2               					; array not found, so build it
008F45  2               LAB_1EA1
008F45  2  20 8E 8E     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
008F48  2               					; (Astrtl,Astrth points to start of array)
008F48  2  20 0E 81     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
008F4B  2               					; addr to check is in AY (low/high)
008F4B  2  A0 00        	LDY	#$00			; clear Y (don't need to clear A)
008F4D  2  84 BB        	STY	Aspth			; clear array data size high byte
008F4F  2  A5 93        	LDA	Varnm1		; get variable name 1st byte
008F51  2  91 AA        	STA	(Astrtl),Y		; save array name 1st byte
008F53  2  C8           	INY				; increment index
008F54  2  A5 94        	LDA	Varnm2		; get variable name 2nd byte
008F56  2  91 AA        	STA	(Astrtl),Y		; save array name 2nd byte
008F58  2  A5 5D        	LDA	Dimcnt		; get dimensions count
008F5A  2  A0 04        	LDY	#$04			; index to dimension count
008F5C  2  84 BA        	STY	Asptl			; set array data size low byte (four bytes per element)
008F5E  2  91 AA        	STA	(Astrtl),Y		; set array's dimensions count
008F60  2               
008F60  2               					; now calculate the size of the data space for the array
008F60  2  18           	CLC				; clear carry for add (clear on subsequent loops)
008F61  2               LAB_1EC0
008F61  2  A2 0B        	LDX	#$0B			; set default dimension value low byte
008F63  2  A9 00        	LDA	#$00			; set default dimension value high byte
008F65  2  24 5E        	BIT	Defdim		; test default DIM flag
008F67  2  50 07        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
008F69  2               
008F69  2  68           	PLA				; else pull dimension value low byte
008F6A  2  69 01        	ADC	#$01			; +1 (allow for zeroeth element)
008F6C  2  AA           	TAX				; copy low byte to X
008F6D  2  68           	PLA				; pull dimension value high byte
008F6E  2  69 00        	ADC	#$00			; add carry from low byte
008F70  2               
008F70  2               LAB_1ED0
008F70  2  C8           	INY				; index to dimension value high byte
008F71  2  91 AA        	STA	(Astrtl),Y		; save dimension value high byte
008F73  2  C8           	INY				; index to dimension value high byte
008F74  2  8A           	TXA				; get dimension value low byte
008F75  2  91 AA        	STA	(Astrtl),Y		; save dimension value low byte
008F77  2  20 17 90     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
008F7A  2  86 BA        	STX	Asptl			; save array data size low byte
008F7C  2  85 BB        	STA	Aspth			; save array data size high byte
008F7E  2  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
008F80  2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
008F82  2  D0 DD        	BNE	LAB_1EC0		; loop while not = 0
008F84  2               
008F84  2  65 A5        	ADC	Adatah		; add size high byte to first element high byte
008F86  2               					; (carry is always clear here)
008F86  2  B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
008F88  2               
008F88  2  85 A5        	STA	Adatah		; save end of array high byte
008F8A  2  A8           	TAY				; copy end high byte to Y
008F8B  2  8A           	TXA				; get array size low byte
008F8C  2  65 A4        	ADC	Adatal		; add array start low byte
008F8E  2  90 03        	BCC	LAB_1EF3		; branch if no carry
008F90  2               
008F90  2  C8           	INY				; else increment end of array high byte
008F91  2  F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
008F93  2               
008F93  2               					; set-up mostly complete, now zero the array
008F93  2               LAB_1EF3
008F93  2  20 0E 81     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
008F96  2               					; addr to check is in AY (low/high)
008F96  2  85 7F        	STA	Earryl		; save array mem end low byte
008F98  2  84 80        	STY	Earryh		; save array mem end high byte
008F9A  2  A9 00        	LDA	#$00			; clear byte for array clear
008F9C  2  E6 BB        	INC	Aspth			; increment array size high byte (now block count)
008F9E  2  A4 BA        	LDY	Asptl			; get array size low byte (now index to block)
008FA0  2  F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
008FA2  2               
008FA2  2               LAB_1F02
008FA2  2  88           	DEY				; decrement index (do 0 to n-1)
008FA3  2  91 A4        	STA	(Adatal),Y		; zero byte
008FA5  2  D0 FB        	BNE	LAB_1F02		; loop until this block done
008FA7  2               
008FA7  2               LAB_1F07
008FA7  2  C6 A5        	DEC	Adatah		; decrement array pointer high byte
008FA9  2  C6 BB        	DEC	Aspth			; decrement block count high byte
008FAB  2  D0 F5        	BNE	LAB_1F02		; loop until all blocks done
008FAD  2               
008FAD  2  E6 A5        	INC	Adatah		; correct for last loop
008FAF  2  38           	SEC				; set carry for subtract
008FB0  2  A0 02        	LDY	#$02			; index to array size low byte
008FB2  2  A5 7F        	LDA	Earryl		; get array mem end low byte
008FB4  2  E5 AA        	SBC	Astrtl		; subtract array start low byte
008FB6  2  91 AA        	STA	(Astrtl),Y		; save array size low byte
008FB8  2  C8           	INY				; index to array size high byte
008FB9  2  A5 80        	LDA	Earryh		; get array mem end high byte
008FBB  2  E5 AB        	SBC	Astrth		; subtract array start high byte
008FBD  2  91 AA        	STA	(Astrtl),Y		; save array size high byte
008FBF  2  A5 5E        	LDA	Defdim		; get default DIM flag
008FC1  2  D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
008FC3  2               
008FC3  2               					; else, find element
008FC3  2  C8           	INY				; index to # of dimensions
008FC4  2               
008FC4  2               LAB_1F24
008FC4  2  B1 AA        	LDA	(Astrtl),Y		; get array's dimension count
008FC6  2  85 5D        	STA	Dimcnt		; save it
008FC8  2               
008FC8  2               ; we have found, or built, the array. now we need to find the element
008FC8  2               
008FC8  2               LAB_1F28
008FC8  2  A9 00        	LDA	#$00			; clear byte
008FCA  2  85 BA        	STA	Asptl			; clear array data pointer low byte
008FCC  2               LAB_1F2C
008FCC  2  85 BB        	STA	Aspth			; save array data pointer high byte
008FCE  2  C8           	INY				; increment index (point to array bound high byte)
008FCF  2  68           	PLA				; pull array index low byte
008FD0  2  AA           	TAX				; copy to X
008FD1  2  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
008FD3  2  68           	PLA				; pull array index high byte
008FD4  2  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
008FD6  2  D1 AA        	CMP	(Astrtl),Y		; compare with array bound high byte
008FD8  2  90 0E        	BCC	LAB_1F48		; branch if within bounds
008FDA  2               
008FDA  2  D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
008FDC  2               
008FDC  2               					; else high byte was = so test low bytes
008FDC  2  C8           	INY				; index to array bound low byte
008FDD  2  8A           	TXA				; get array index low byte
008FDE  2  D1 AA        	CMP	(Astrtl),Y		; compare with array bound low byte
008FE0  2  90 07        	BCC	LAB_1F49		; branch if within bounds
008FE2  2               
008FE2  2               LAB_1F42
008FE2  2  4C 29 8F     	JMP	LAB_1E85		; else do array bounds error
008FE5  2               
008FE5  2               LAB_1F45
008FE5  2  4C 3D 81     	JMP	LAB_OMER		; do "Out of memory" error then warm start
008FE8  2               
008FE8  2               LAB_1F48
008FE8  2  C8           	INY				; index to array bound low byte
008FE9  2               LAB_1F49
008FE9  2  A5 BB        	LDA	Aspth			; get array data pointer high byte
008FEB  2  05 BA        	ORA	Asptl			; OR with array data pointer low byte
008FED  2  F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
008FEF  2               
008FEF  2  20 17 90     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
008FF2  2  8A           	TXA				; get result low byte
008FF3  2  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
008FF5  2  AA           	TAX				; save result low byte
008FF6  2  98           	TYA				; get result high byte
008FF7  2  A4 71        	LDY	ut1_pl		; restore index
008FF9  2               LAB_1F5A
008FF9  2  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
008FFB  2  86 BA        	STX	Asptl			; save array data pointer low byte
008FFD  2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
008FFF  2  D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
009001  2               
009001  2  06 BA        	ASL	Asptl			; array data pointer low byte * 2
009003  2  2A           	ROL				; array data pointer high byte * 2
009004  2  06 BA        	ASL	Asptl			; array data pointer low byte * 4
009006  2  2A           	ROL				; array data pointer high byte * 4
009007  2  A8           	TAY				; copy high byte
009008  2  A5 BA        	LDA	Asptl			; get low byte
00900A  2  65 A4        	ADC	Adatal		; add array data start pointer low byte
00900C  2  85 95        	STA	Cvaral		; save as current var address low byte
00900E  2  98           	TYA				; get high byte back
00900F  2  65 A5        	ADC	Adatah		; add array data start pointer high byte
009011  2  85 96        	STA	Cvarah		; save as current var address high byte
009013  2  A8           	TAY				; copy high byte to Y
009014  2  A5 95        	LDA	Cvaral		; get current var address low byte
009016  2               LAB_1F7B
009016  2  60           	RTS
009017  2               
009017  2               ; does XY = (Astrtl),Y * (Asptl)
009017  2               
009017  2               LAB_1F7C
009017  2  84 71        	STY	ut1_pl		; save index
009019  2  B1 AA        	LDA	(Astrtl),Y		; get dimension size low byte
00901B  2  85 76        	STA	dims_l		; save dimension size low byte
00901D  2  88           	DEY				; decrement index
00901E  2  B1 AA        	LDA	(Astrtl),Y		; get dimension size high byte
009020  2  85 77        	STA	dims_h		; save dimension size high byte
009022  2               
009022  2  A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
009024  2  85 A8        	STA	numbit		; save bit count
009026  2  A2 00        	LDX	#$00			; clear result low byte
009028  2  A0 00        	LDY	#$00			; clear result high byte
00902A  2               LAB_1F8F
00902A  2  8A           	TXA				; get result low byte
00902B  2  0A           	ASL				; *2
00902C  2  AA           	TAX				; save result low byte
00902D  2  98           	TYA				; get result high byte
00902E  2  2A           	ROL				; *2
00902F  2  A8           	TAY				; save result high byte
009030  2  B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
009032  2               
009032  2  06 BA        	ASL	Asptl			; shift multiplier low byte
009034  2  26 BB        	ROL	Aspth			; shift multiplier high byte
009036  2  90 0B        	BCC	LAB_1FA8		; skip add if no carry
009038  2               
009038  2  18           	CLC				; else clear carry for add
009039  2  8A           	TXA				; get result low byte
00903A  2  65 76        	ADC	dims_l		; add dimension size low byte
00903C  2  AA           	TAX				; save result low byte
00903D  2  98           	TYA				; get result high byte
00903E  2  65 77        	ADC	dims_h		; add dimension size high byte
009040  2  A8           	TAY				; save result high byte
009041  2  B0 A2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
009043  2               
009043  2               LAB_1FA8
009043  2  C6 A8        	DEC	numbit		; decrement bit count
009045  2  D0 E3        	BNE	LAB_1F8F		; loop until all done
009047  2               
009047  2  60           	RTS
009048  2               
009048  2               ; perform FRE()
009048  2               
009048  2               LAB_FRE
009048  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00904A  2  10 03        	BPL	LAB_1FB4		; branch if numeric
00904C  2               
00904C  2  20 41 93     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
00904F  2               					; space returns with A = length, X=$71=pointer low byte,
00904F  2               					; Y=$72=pointer high byte
00904F  2               
00904F  2               					; FRE(n) was numeric so do this
00904F  2               LAB_1FB4
00904F  2  20 E2 91     	JSR	LAB_GARB		; go do garbage collection
009052  2  38           	SEC				; set carry for subtract
009053  2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
009055  2  E5 7F        	SBC	Earryl		; subtract array mem end low byte
009057  2  A8           	TAY				; copy result to Y
009058  2  A5 82        	LDA	Sstorh		; get bottom of string space high byte
00905A  2  E5 80        	SBC	Earryh		; subtract array mem end high byte
00905C  2               
00905C  2               ; save and convert integer AY to FAC1
00905C  2               
00905C  2               LAB_AYFC
00905C  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00905E  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
009060  2  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
009062  2  A2 90        	LDX	#$90			; set exponent=2^16 (integer)
009064  2  4C 05 99     	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
009067  2               
009067  2               ; perform POS()
009067  2               
009067  2               LAB_POS
009067  2  A4 0E        	LDY	TPos			; get terminal position
009069  2               
009069  2               ; convert Y to byte in FAC1
009069  2               
009069  2               LAB_1FD0
009069  2  A9 00        	LDA	#$00			; clear high byte
00906B  2  F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
00906D  2               
00906D  2               ; check not Direct (used by DEF and INPUT)
00906D  2               
00906D  2               LAB_CKRN
00906D  2  A6 88        	LDX	Clineh		; get current line high byte
00906F  2  E8           	INX				; increment it
009070  2  D0 A4        	BNE	LAB_1F7B		; return if can continue not direct mode
009072  2               
009072  2               					; else do illegal direct error
009072  2               LAB_1FD9
009072  2  A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
009074  2               LAB_1FDB
009074  2  4C 3F 81     	JMP	LAB_XERR		; go do error #X, then warm start
009077  2               
009077  2               ; perform DEF
009077  2               
009077  2               LAB_DEF
009077  2  20 A8 90     	JSR	LAB_200B		; check FNx syntax
00907A  2  85 9C        	STA	func_l		; save function pointer low byte
00907C  2  84 9D        	STY	func_h		; save function pointer high byte
00907E  2  20 6D 90     	JSR	LAB_CKRN		; check not Direct (back here if ok)
009081  2  20 FD 8B     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
009084  2  A9 80        	LDA	#$80			; set flag for FNx
009086  2  85 61        	STA	Sufnxf		; save subscript/FNx flag
009088  2  20 AD 8D     	JSR	LAB_GVAR		; get (var) address
00908B  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00908E  2  20 F2 8B     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
009091  2  A9 C1        	LDA	#TK_EQUAL		; get = token
009093  2  20 F4 8B     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
009096  2  A5 96        	LDA	Cvarah		; get current var address high byte
009098  2  48           	PHA				; push it
009099  2  A5 95        	LDA	Cvaral		; get current var address low byte
00909B  2  48           	PHA				; push it
00909C  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00909E  2  48           	PHA				; push it
00909F  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0090A1  2  48           	PHA				; push it
0090A2  2  20 8F 86     	JSR	LAB_DATA		; go perform DATA
0090A5  2  4C 17 91     	JMP	LAB_207A		; put execute pointer and variable pointer into function
0090A8  2               					; and return
0090A8  2               
0090A8  2               ; check FNx syntax
0090A8  2               
0090A8  2               LAB_200B
0090A8  2  A9 AE        	LDA	#TK_FN		; get FN" token
0090AA  2  20 F4 8B     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
0090AD  2               					; return character after A
0090AD  2  09 80        	ORA	#$80			; set FN flag bit
0090AF  2  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
0090B1  2  20 B4 8D     	JSR	LAB_1D12		; search for FN variable
0090B4  2  4C D3 8A     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
0090B7  2               					; mismatch
0090B7  2               
0090B7  2               					; Evaluate FNx
0090B7  2               LAB_201E
0090B7  2  20 A8 90     	JSR	LAB_200B		; check FNx syntax
0090BA  2  48           	PHA				; push function pointer low byte
0090BB  2  98           	TYA				; copy function pointer high byte
0090BC  2  48           	PHA				; push function pointer high byte
0090BD  2  20 FD 8B     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
0090C0  2  20 E4 8A     	JSR	LAB_EVEX		; evaluate expression
0090C3  2  20 F2 8B     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
0090C6  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
0090C9  2  68           	PLA				; pop function pointer high byte
0090CA  2  85 9D        	STA	func_h		; restore it
0090CC  2  68           	PLA				; pop function pointer low byte
0090CD  2  85 9C        	STA	func_l		; restore it
0090CF  2  A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
0090D1  2  A0 03        	LDY	#$03			; index to variable pointer high byte
0090D3  2  B1 9C        	LDA	(func_l),Y		; get variable pointer high byte
0090D5  2  F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
0090D7  2               
0090D7  2  85 96        	STA	Cvarah		; save variable address high byte
0090D9  2  88           	DEY				; index to variable address low byte
0090DA  2  B1 9C        	LDA	(func_l),Y		; get variable address low byte
0090DC  2  85 95        	STA	Cvaral		; save variable address low byte
0090DE  2  AA           	TAX				; copy address low byte
0090DF  2               
0090DF  2               					; now stack the function variable value before use
0090DF  2  C8           	INY				; index to mantissa_3
0090E0  2               LAB_2043
0090E0  2  B1 95        	LDA	(Cvaral),Y		; get byte from variable
0090E2  2  48           	PHA				; stack it
0090E3  2  88           	DEY				; decrement index
0090E4  2  10 FA        	BPL	LAB_2043		; loop until variable stacked
0090E6  2               
0090E6  2  A4 96        	LDY	Cvarah		; get variable address high byte
0090E8  2  20 AA 98     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
0090EB  2               					; (function variable), return Y=0, always
0090EB  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0090ED  2  48           	PHA				; push it
0090EE  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0090F0  2  48           	PHA				; push it
0090F1  2  B1 9C        	LDA	(func_l),Y		; get function execute pointer low byte
0090F3  2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
0090F5  2  C8           	INY				; index to high byte
0090F6  2  B1 9C        	LDA	(func_l),Y		; get function execute pointer high byte
0090F8  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
0090FA  2  A5 96        	LDA	Cvarah		; get variable address high byte
0090FC  2  48           	PHA				; push it
0090FD  2  A5 95        	LDA	Cvaral		; get variable address low byte
0090FF  2  48           	PHA				; push it
009100  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
009103  2               					; else do type mismatch
009103  2  68           	PLA				; pull variable address low byte
009104  2  85 9C        	STA	func_l		; save variable address low byte
009106  2  68           	PLA				; pull variable address high byte
009107  2  85 9D        	STA	func_h		; save variable address high byte
009109  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00910C  2  F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
00910E  2               
00910E  2  4C 05 8C     	JMP	LAB_SNER		; else syntax error then warm start
009111  2               
009111  2               ; restore Bpntrl,Bpntrh and function variable from stack
009111  2               
009111  2               LAB_2074
009111  2  68           	PLA				; pull BASIC execute pointer low byte
009112  2  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
009114  2  68           	PLA				; pull BASIC execute pointer high byte
009115  2  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
009117  2               
009117  2               ; put execute pointer and variable pointer into function
009117  2               
009117  2               LAB_207A
009117  2  A0 00        	LDY	#$00			; clear index
009119  2  68           	PLA				; pull BASIC execute pointer low byte
00911A  2  91 9C        	STA	(func_l),Y		; save to function
00911C  2  C8           	INY				; increment index
00911D  2  68           	PLA				; pull BASIC execute pointer high byte
00911E  2  91 9C        	STA	(func_l),Y		; save to function
009120  2  C8           	INY				; increment index
009121  2  68           	PLA				; pull current var address low byte
009122  2  91 9C        	STA	(func_l),Y		; save to function
009124  2  C8           	INY				; increment index
009125  2  68           	PLA				; pull current var address high byte
009126  2  91 9C        	STA	(func_l),Y		; save to function
009128  2  60           	RTS
009129  2               
009129  2               ; perform STR$()
009129  2               
009129  2               LAB_STRS
009129  2  20 D3 8A     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00912C  2  20 98 9A     	JSR	LAB_296E		; convert FAC1 to string
00912F  2  A9 F0        	LDA	#<Decssp1		; set result string low pointer
009131  2  A0 00        	LDY	#>Decssp1		; set result string high pointer
009133  2  F0 12        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
009135  2               
009135  2               ; Do string vector
009135  2               ; copy des_pl/h to des_2l/h and make string space A bytes long
009135  2               
009135  2               LAB_209C
009135  2  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
009137  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
009139  2  86 9E        	STX	des_2l		; save descriptor pointer low byte
00913B  2  84 9F        	STY	des_2h		; save descriptor pointer high byte
00913D  2               
00913D  2               ; make string space A bytes long
00913D  2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00913D  2               
00913D  2               LAB_MSSP
00913D  2  20 B0 91     	JSR	LAB_2115		; make space in string memory for string A long
009140  2               					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009140  2  86 AD        	STX	str_pl		; save string pointer low byte
009142  2  84 AE        	STY	str_ph		; save string pointer high byte
009144  2  85 AC        	STA	str_ln		; save length
009146  2  60           	RTS
009147  2               
009147  2               ; Scan, set up string
009147  2               ; print " terminated string to Sutill/Sutilh
009147  2               
009147  2               LAB_20AE
009147  2  A2 22        	LDX	#$22			; set terminator to "
009149  2  86 5B        	STX	Srchc			; set search character (terminator 1)
00914B  2  86 5C        	STX	Asrch			; set terminator 2
00914D  2               
00914D  2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
00914D  2               ; source is AY
00914D  2               
00914D  2               LAB_20B4
00914D  2  85 B8        	STA	ssptr_l		; store string start low byte
00914F  2  84 B9        	STY	ssptr_h		; store string start high byte
009151  2  85 AD        	STA	str_pl		; save string pointer low byte
009153  2  84 AE        	STY	str_ph		; save string pointer high byte
009155  2  A0 FF        	LDY	#$FF			; set length to -1
009157  2               LAB_20BE
009157  2  C8           	INY				; increment length
009158  2  B1 B8        	LDA	(ssptr_l),Y		; get byte from string
00915A  2  F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
00915C  2               
00915C  2  C5 5B        	CMP	Srchc			; compare with search character (terminator 1)
00915E  2  F0 04        	BEQ	LAB_20CB		; branch if terminator
009160  2               
009160  2  C5 5C        	CMP	Asrch			; compare with terminator 2
009162  2  D0 F3        	BNE	LAB_20BE		; loop if not terminator 2
009164  2               
009164  2               LAB_20CB
009164  2  C9 22        	CMP	#$22			; compare with "
009166  2  F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
009168  2               
009168  2               LAB_20CF
009168  2  18           	CLC				; clear carry for add (only if [EOL] terminated string)
009169  2               LAB_20D0
009169  2  84 AC        	STY	str_ln		; save length in FAC1 exponent
00916B  2  98           	TYA				; copy length to A
00916C  2  65 B8        	ADC	ssptr_l		; add string start low byte
00916E  2  85 BA        	STA	Sendl			; save string end low byte
009170  2  A6 B9        	LDX	ssptr_h		; get string start high byte
009172  2  90 01        	BCC	LAB_20DC		; branch if no low byte overflow
009174  2               
009174  2  E8           	INX				; else increment high byte
009175  2               LAB_20DC
009175  2  86 BB        	STX	Sendh			; save string end high byte
009177  2  A5 B9        	LDA	ssptr_h		; get string start high byte
009179  2  C9 05        	CMP	#>Ram_base		; compare with start of program memory
00917B  2  B0 0B        	BCS	LAB_RTST		; branch if not in utility area
00917D  2               
00917D  2               					; string in utility area, move to string memory
00917D  2  98           	TYA				; copy length to A
00917E  2  20 35 91     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
009181  2               					; long
009181  2  A6 B8        	LDX	ssptr_l		; get string start low byte
009183  2  A4 B9        	LDY	ssptr_h		; get string start high byte
009185  2  20 22 93     	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
009188  2               
009188  2               ; check for space on descriptor stack then ..
009188  2               ; put string address and length on descriptor stack and update stack pointers
009188  2               
009188  2               LAB_RTST
009188  2  A6 65        	LDX	next_s		; get string stack pointer
00918A  2  E0 71        	CPX	#des_sk+$09		; compare with max+1
00918C  2  D0 05        	BNE	LAB_20F8		; branch if space on string stack
00918E  2               
00918E  2               					; else do string too complex error
00918E  2  A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
009190  2               LAB_20F5
009190  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
009193  2               
009193  2               ; put string address and length on descriptor stack and update stack pointers
009193  2               
009193  2               LAB_20F8
009193  2  A5 AC        	LDA	str_ln		; get string length
009195  2  95 00        	STA	PLUS_0,X		; put on string stack
009197  2  A5 AD        	LDA	str_pl		; get string pointer low byte
009199  2  95 01        	STA	PLUS_1,X		; put on string stack
00919B  2  A5 AE        	LDA	str_ph		; get string pointer high byte
00919D  2  95 02        	STA	PLUS_2,X		; put on string stack
00919F  2  A0 00        	LDY	#$00			; clear Y
0091A1  2  86 AE        	STX	des_pl		; save string descriptor pointer low byte
0091A3  2  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
0091A5  2  88           	DEY				; Y = $FF
0091A6  2  84 5F        	STY	Dtypef		; save data type flag, $FF=string
0091A8  2  86 66        	STX	last_sl		; save old stack pointer (current top item)
0091AA  2  E8           	INX				; update stack pointer
0091AB  2  E8           	INX				; update stack pointer
0091AC  2  E8           	INX				; update stack pointer
0091AD  2  86 65        	STX	next_s		; save new top item value
0091AF  2  60           	RTS
0091B0  2               
0091B0  2               ; Build descriptor
0091B0  2               ; make space in string memory for string A long
0091B0  2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
0091B0  2               
0091B0  2               LAB_2115
0091B0  2  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
0091B2  2               
0091B2  2               					; make space for string A long
0091B2  2               LAB_2117
0091B2  2  48           	PHA				; save string length
0091B3  2  49 FF        	EOR	#$FF			; complement it
0091B5  2  38           	SEC				; set carry for subtract (twos comp add)
0091B6  2  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
0091B8  2  A4 82        	LDY	Sstorh		; get bottom of string space high byte
0091BA  2  B0 01        	BCS	LAB_2122		; skip decrement if no underflow
0091BC  2               
0091BC  2  88           	DEY				; decrement bottom of string space high byte
0091BD  2               LAB_2122
0091BD  2  C4 80        	CPY	Earryh		; compare with array mem end high byte
0091BF  2  90 11        	BCC	LAB_2137		; do out of memory error if less
0091C1  2               
0091C1  2  D0 04        	BNE	LAB_212C		; if not = skip next test
0091C3  2               
0091C3  2  C5 7F        	CMP	Earryl		; compare with array mem end low byte
0091C5  2  90 0B        	BCC	LAB_2137		; do out of memory error if less
0091C7  2               
0091C7  2               LAB_212C
0091C7  2  85 81        	STA	Sstorl		; save bottom of string space low byte
0091C9  2  84 82        	STY	Sstorh		; save bottom of string space high byte
0091CB  2  85 83        	STA	Sutill		; save string utility ptr low byte
0091CD  2  84 84        	STY	Sutilh		; save string utility ptr high byte
0091CF  2  AA           	TAX				; copy low byte to X
0091D0  2  68           	PLA				; get string length back
0091D1  2  60           	RTS
0091D2  2               
0091D2  2               LAB_2137
0091D2  2  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
0091D4  2  A5 60        	LDA	Gclctd		; get garbage collected flag
0091D6  2  30 B8        	BMI	LAB_20F5		; if set then do error code X
0091D8  2               
0091D8  2  20 E2 91     	JSR	LAB_GARB		; else go do garbage collection
0091DB  2  A9 80        	LDA	#$80			; flag for garbage collected
0091DD  2  85 60        	STA	Gclctd		; set garbage collected flag
0091DF  2  68           	PLA				; pull length
0091E0  2  D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
0091E2  2               
0091E2  2               ; garbage collection routine
0091E2  2               
0091E2  2               LAB_GARB
0091E2  2  A6 85        	LDX	Ememl			; get end of mem low byte
0091E4  2  A5 86        	LDA	Ememh			; get end of mem high byte
0091E6  2               
0091E6  2               ; re-run routine from last ending
0091E6  2               
0091E6  2               LAB_214B
0091E6  2  86 81        	STX	Sstorl		; set string storage low byte
0091E8  2  85 82        	STA	Sstorh		; set string storage high byte
0091EA  2  A0 00        	LDY	#$00			; clear index
0091EC  2  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
0091EE  2  A5 7F        	LDA	Earryl		; get array mem end low byte
0091F0  2  A6 80        	LDX	Earryh		; get array mem end high byte
0091F2  2  85 AA        	STA	Histrl		; save as highest string low byte
0091F4  2  86 AB        	STX	Histrh		; save as highest string high byte
0091F6  2  A9 68        	LDA	#des_sk		; set descriptor stack pointer
0091F8  2  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
0091FA  2  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
0091FC  2               LAB_2161
0091FC  2  C5 65        	CMP	next_s		; compare with descriptor stack pointer
0091FE  2  F0 05        	BEQ	LAB_216A		; branch if =
009200  2               
009200  2  20 66 92     	JSR	LAB_21D7		; go garbage collect descriptor stack
009203  2  F0 F7        	BEQ	LAB_2161		; loop always
009205  2               
009205  2               					; done stacked strings, now do string vars
009205  2               LAB_216A
009205  2  06 A0        	ASL	g_step		; set step size = $06
009207  2  A5 7B        	LDA	Svarl			; get start of vars low byte
009209  2  A6 7C        	LDX	Svarh			; get start of vars high byte
00920B  2  85 71        	STA	ut1_pl		; save as pointer low byte
00920D  2  86 72        	STX	ut1_ph		; save as pointer high byte
00920F  2               LAB_2176
00920F  2  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
009211  2  D0 04        	BNE	LAB_217E		; branch if no high byte match
009213  2               
009213  2  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
009215  2  F0 05        	BEQ	LAB_2183		; branch if = var mem end
009217  2               
009217  2               LAB_217E
009217  2  20 60 92     	JSR	LAB_21D1		; go garbage collect strings
00921A  2  F0 F3        	BEQ	LAB_2176		; loop always
00921C  2               
00921C  2               					; done string vars, now do string arrays
00921C  2               LAB_2183
00921C  2  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
00921E  2  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
009220  2  A9 04        	LDA	#$04			; set step size
009222  2  85 A0        	STA	g_step		; save step size
009224  2               LAB_218B
009224  2  A5 A4        	LDA	Nbendl		; get pointer low byte
009226  2  A6 A5        	LDX	Nbendh		; get pointer high byte
009228  2               LAB_218F
009228  2  E4 80        	CPX	Earryh		; compare with array mem end high byte
00922A  2  D0 04        	BNE	LAB_219A		; branch if not at end
00922C  2               
00922C  2  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
00922E  2  F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
009230  2               
009230  2               LAB_219A
009230  2  85 71        	STA	ut1_pl		; save pointer low byte
009232  2  86 72        	STX	ut1_ph		; save pointer high byte
009234  2  A0 02        	LDY	#$02			; set index
009236  2  B1 71        	LDA	(ut1_pl),Y		; get array size low byte
009238  2  65 A4        	ADC	Nbendl		; add start of this array low byte
00923A  2  85 A4        	STA	Nbendl		; save start of next array low byte
00923C  2  C8           	INY				; increment index
00923D  2  B1 71        	LDA	(ut1_pl),Y		; get array size high byte
00923F  2  65 A5        	ADC	Nbendh		; add start of this array high byte
009241  2  85 A5        	STA	Nbendh		; save start of next array high byte
009243  2  A0 01        	LDY	#$01			; set index
009245  2  B1 71        	LDA	(ut1_pl),Y		; get name second byte
009247  2  10 DB        	BPL	LAB_218B		; skip if not string array
009249  2               
009249  2               ; was string array so ..
009249  2               
009249  2  A0 04        	LDY	#$04			; set index
00924B  2  B1 71        	LDA	(ut1_pl),Y		; get # of dimensions
00924D  2  0A           	ASL				; *2
00924E  2  69 05        	ADC	#$05			; +5 (array header size)
009250  2  20 98 92     	JSR	LAB_2208		; go set up for first element
009253  2               LAB_21C4
009253  2  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
009255  2  D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
009257  2               
009257  2  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
009259  2               					; low byte
009259  2  F0 CD        	BEQ	LAB_218F		; if equal then go do next array
00925B  2               
00925B  2               LAB_21CC
00925B  2  20 66 92     	JSR	LAB_21D7		; go defrag array strings
00925E  2  F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
009260  2               
009260  2               ; defrag string variables
009260  2               ; enter with XA = variable pointer
009260  2               ; return with XA = next variable pointer
009260  2               
009260  2               LAB_21D1
009260  2  C8           	INY				; increment index (Y was $00)
009261  2  B1 71        	LDA	(ut1_pl),Y		; get var name byte 2
009263  2  10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
009265  2               
009265  2  C8           	INY				; else increment index
009266  2               LAB_21D7
009266  2  B1 71        	LDA	(ut1_pl),Y		; get string length
009268  2  F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
00926A  2               
00926A  2  C8           	INY				; else increment index
00926B  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte
00926D  2  AA           	TAX				; copy to X
00926E  2  C8           	INY				; increment index
00926F  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte
009271  2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
009273  2  90 06        	BCC	LAB_21EC		; branch if less
009275  2               
009275  2  D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
009277  2               
009277  2               					; high bytes were = so compare low bytes
009277  2  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
009279  2  B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
00927B  2               
00927B  2               					; string pointer is < string storage pointer (pos in mem)
00927B  2               LAB_21EC
00927B  2  C5 AB        	CMP	Histrh		; compare to highest string high byte
00927D  2  90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
00927F  2               
00927F  2  D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
009281  2               
009281  2               					; high bytes were = so compare low bytes
009281  2  E4 AA        	CPX	Histrl		; compare to highest string low byte
009283  2  90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
009285  2               
009285  2               					; string is in string memory space
009285  2               LAB_21F6
009285  2  86 AA        	STX	Histrl		; save as new highest string low byte
009287  2  85 AB        	STA	Histrh		; save as new highest string high byte
009289  2  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
00928B  2  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
00928D  2  85 9C        	STA	garb_l		; save as working pointer low byte
00928F  2  86 9D        	STX	garb_h		; save as working pointer high byte
009291  2  88           	DEY				; decrement index DIFFERS
009292  2  88           	DEY				; decrement index (should point to descriptor start)
009293  2  84 A2        	STY	g_indx		; save index pointer
009295  2               
009295  2               					; step pointer to next string
009295  2               LAB_2206
009295  2  18           	CLC				; clear carry for add
009296  2               LAB_2207
009296  2  A5 A0        	LDA	g_step		; get step size
009298  2               LAB_2208
009298  2  65 71        	ADC	ut1_pl		; add pointer low byte
00929A  2  85 71        	STA	ut1_pl		; save pointer low byte
00929C  2  90 02        	BCC	LAB_2211		; branch if no overflow
00929E  2               
00929E  2  E6 72        	INC	ut1_ph		; else increment high byte
0092A0  2               LAB_2211
0092A0  2  A6 72        	LDX	ut1_ph		; get pointer high byte
0092A2  2  A0 00        	LDY	#$00			; clear Y
0092A4  2  60           	RTS
0092A5  2               
0092A5  2               ; search complete, now either exit or set-up and move string
0092A5  2               
0092A5  2               LAB_2216
0092A5  2  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
0092A7  2  A6 9D        	LDX	garb_h		; get string to move high byte
0092A9  2  F0 F5        	BEQ	LAB_2211		; exit if nothing to move
0092AB  2               
0092AB  2  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
0092AD  2  18           	CLC				; clear carry for add
0092AE  2  B1 9C        	LDA	(garb_l),Y		; get string length
0092B0  2  65 AA        	ADC	Histrl		; add highest string low byte
0092B2  2  85 A6        	STA	Obendl		; save old block end low pointer
0092B4  2  A5 AB        	LDA	Histrh		; get highest string high byte
0092B6  2  69 00        	ADC	#$00			; add any carry
0092B8  2  85 A7        	STA	Obendh		; save old block end high byte
0092BA  2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
0092BC  2  A6 82        	LDX	Sstorh		; get bottom of string space high byte
0092BE  2  85 A4        	STA	Nbendl		; save new block end low byte
0092C0  2  86 A5        	STX	Nbendh		; save new block end high byte
0092C2  2  20 CB 80     	JSR	LAB_11D6		; open up space in memory, don't set array end
0092C5  2  A4 A2        	LDY	g_indx		; get index byte
0092C7  2  C8           	INY				; point to descriptor low byte
0092C8  2  A5 A4        	LDA	Nbendl		; get string pointer low byte
0092CA  2  91 9C        	STA	(garb_l),Y		; save new string pointer low byte
0092CC  2  AA           	TAX				; copy string pointer low byte
0092CD  2  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
0092CF  2  A5 A5        	LDA	Nbendh		; get new string pointer high byte
0092D1  2  C8           	INY				; point to descriptor high byte
0092D2  2  91 9C        	STA	(garb_l),Y		; save new string pointer high byte
0092D4  2  4C E6 91     	JMP	LAB_214B		; re-run routine from last ending
0092D7  2               					; (but don't collect this string)
0092D7  2               
0092D7  2               ; concatenate
0092D7  2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
0092D7  2               
0092D7  2               LAB_224D
0092D7  2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
0092D9  2  48           	PHA				; put on stack
0092DA  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
0092DC  2  48           	PHA				; put on stack
0092DD  2  20 D0 8B     	JSR	LAB_GVAL		; get value from line
0092E0  2  20 D5 8A     	JSR	LAB_CTST		; check if source is string, else do type mismatch
0092E3  2  68           	PLA				; get descriptor pointer low byte back
0092E4  2  85 B8        	STA	ssptr_l		; set pointer low byte
0092E6  2  68           	PLA				; get descriptor pointer high byte back
0092E7  2  85 B9        	STA	ssptr_h		; set pointer high byte
0092E9  2  A0 00        	LDY	#$00			; clear index
0092EB  2  B1 B8        	LDA	(ssptr_l),Y		; get length_1 from descriptor
0092ED  2  18           	CLC				; clear carry for add
0092EE  2  71 AE        	ADC	(des_pl),Y		; add length_2
0092F0  2  90 05        	BCC	LAB_226D		; branch if no overflow
0092F2  2               
0092F2  2  A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
0092F4  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
0092F7  2               
0092F7  2               LAB_226D
0092F7  2  20 35 91     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
0092FA  2               					; long
0092FA  2  20 14 93     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
0092FD  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
0092FF  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
009301  2  20 45 93     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
009304  2               					; returns with A = length, ut1_pl = pointer low byte,
009304  2               					; ut1_ph = pointer high byte
009304  2  20 26 93     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
009307  2  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
009309  2  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
00930B  2  20 45 93     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00930E  2               					; returns with A = length, X=ut1_pl=pointer low byte,
00930E  2               					; Y=ut1_ph=pointer high byte
00930E  2  20 88 91     	JSR	LAB_RTST		; check for space on descriptor stack then put string
009311  2               					; address and length on descriptor stack and update stack
009311  2               					; pointers
009311  2  4C FB 8A     	JMP	LAB_1ADB		;.continue evaluation
009314  2               
009314  2               ; copy string from descriptor (sdescr) to (Sutill)
009314  2               
009314  2               LAB_228A
009314  2  A0 00        	LDY	#$00			; clear index
009316  2  B1 B8        	LDA	(sdescr),Y		; get string length
009318  2  48           	PHA				; save on stack
009319  2  C8           	INY				; increment index
00931A  2  B1 B8        	LDA	(sdescr),Y		; get source string pointer low byte
00931C  2  AA           	TAX				; copy to X
00931D  2  C8           	INY				; increment index
00931E  2  B1 B8        	LDA	(sdescr),Y		; get source string pointer high byte
009320  2  A8           	TAY				; copy to Y
009321  2  68           	PLA				; get length back
009322  2               
009322  2               ; store string A bytes long from YX to (Sutill)
009322  2               
009322  2               LAB_2298
009322  2  86 71        	STX	ut1_pl		; save source string pointer low byte
009324  2  84 72        	STY	ut1_ph		; save source string pointer high byte
009326  2               
009326  2               ; store string A bytes long from (ut1_pl) to (Sutill)
009326  2               
009326  2               LAB_229C
009326  2  AA           	TAX				; copy length to index (don't count with Y)
009327  2  F0 14        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
009329  2               
009329  2  A0 00        	LDY	#$00			; zero pointer (copy forward)
00932B  2               LAB_22A0
00932B  2  B1 71        	LDA	(ut1_pl),Y		; get source byte
00932D  2  91 83        	STA	(Sutill),Y		; save destination byte
00932F  2               
00932F  2  C8           	INY				; increment index
009330  2  CA           	DEX				; decrement counter
009331  2  D0 F8        	BNE	LAB_22A0		; loop while <> 0
009333  2               
009333  2  98           	TYA				; restore length from Y
009334  2               LAB_22A9
009334  2  18           	CLC				; clear carry for add
009335  2  65 83        	ADC	Sutill		; add string utility ptr low byte
009337  2  85 83        	STA	Sutill		; save string utility ptr low byte
009339  2  90 02        	BCC	LAB_22B2		; branch if no carry
00933B  2               
00933B  2  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
00933D  2               LAB_22B2
00933D  2  60           	RTS
00933E  2               
00933E  2               ; evaluate string
00933E  2               
00933E  2               LAB_EVST
00933E  2  20 D5 8A     	JSR	LAB_CTST		; check if source is string, else do type mismatch
009341  2               
009341  2               ; pop string off descriptor stack, or from top of string space
009341  2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
009341  2               
009341  2               LAB_22B6
009341  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
009343  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
009345  2               
009345  2               ; pop (YA) descriptor off stack or from top of string space
009345  2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
009345  2               
009345  2               LAB_22BA
009345  2  85 71        	STA	ut1_pl		; save descriptor pointer low byte
009347  2  84 72        	STY	ut1_ph		; save descriptor pointer high byte
009349  2  20 76 93     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
00934C  2  08           	PHP				; save status flags
00934D  2  A0 00        	LDY	#$00			; clear index
00934F  2  B1 71        	LDA	(ut1_pl),Y		; get length from string descriptor
009351  2  48           	PHA				; put on stack
009352  2  C8           	INY				; increment index
009353  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
009355  2  AA           	TAX				; copy to X
009356  2  C8           	INY				; increment index
009357  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
009359  2  A8           	TAY				; copy to Y
00935A  2  68           	PLA				; get string length back
00935B  2  28           	PLP				; restore status
00935C  2  D0 13        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
00935E  2               
00935E  2  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
009360  2  D0 0F        	BNE	LAB_22E6		; branch if <>
009362  2               
009362  2  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
009364  2  D0 0B        	BNE	LAB_22E6		; branch if <>
009366  2               
009366  2  48           	PHA				; save string length
009367  2  18           	CLC				; clear carry for add
009368  2  65 81        	ADC	Sstorl		; add bottom of string space low byte
00936A  2  85 81        	STA	Sstorl		; save bottom of string space low byte
00936C  2  90 02        	BCC	LAB_22E5		; skip increment if no overflow
00936E  2               
00936E  2  E6 82        	INC	Sstorh		; increment bottom of string space high byte
009370  2               LAB_22E5
009370  2  68           	PLA				; restore string length
009371  2               LAB_22E6
009371  2  86 71        	STX	ut1_pl		; save string pointer low byte
009373  2  84 72        	STY	ut1_ph		; save string pointer high byte
009375  2  60           	RTS
009376  2               
009376  2               ; clean descriptor stack, YA = pointer
009376  2               ; checks if AY is on the descriptor stack, if so does a stack discard
009376  2               
009376  2               LAB_22EB
009376  2  C4 67        	CPY	last_sh		; compare pointer high byte
009378  2  D0 0C        	BNE	LAB_22FB		; exit if <>
00937A  2               
00937A  2  C5 66        	CMP	last_sl		; compare pointer low byte
00937C  2  D0 08        	BNE	LAB_22FB		; exit if <>
00937E  2               
00937E  2  85 65        	STA	next_s		; save descriptor stack pointer
009380  2  E9 03        	SBC	#$03			; -3
009382  2  85 66        	STA	last_sl		; save low byte -3
009384  2  A0 00        	LDY	#$00			; clear high byte
009386  2               LAB_22FB
009386  2  60           	RTS
009387  2               
009387  2               ; perform CHR$()
009387  2               
009387  2               LAB_CHRS
009387  2  20 92 94     	JSR	LAB_EVBY		; evaluate byte expression, result in X
00938A  2  8A           	TXA				; copy to A
00938B  2  48           	PHA				; save character
00938C  2  A9 01        	LDA	#$01			; string is single byte
00938E  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
009391  2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
009391  2  68           	PLA				; get character back
009392  2  A0 00        	LDY	#$00			; clear index
009394  2  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
009396  2  4C 88 91     	JMP	LAB_RTST		; check for space on descriptor stack then put string
009399  2               					; address and length on descriptor stack and update stack
009399  2               					; pointers
009399  2               
009399  2               ; perform LEFT$()
009399  2               
009399  2               LAB_LEFT
009399  2  48           	PHA				; push byte parameter
00939A  2  20 FA 93     	JSR	LAB_236F		; pull string data and byte parameter from stack
00939D  2               					; return pointer in des_2l/h, byte in A (and X), Y=0
00939D  2  D1 9E        	CMP	(des_2l),Y		; compare byte parameter with string length
00939F  2  98           	TYA				; clear A
0093A0  2  F0 09        	BEQ	LAB_2316		; go do string copy (branch always)
0093A2  2               
0093A2  2               ; perform RIGHT$()
0093A2  2               
0093A2  2               LAB_RIGHT
0093A2  2  48           	PHA				; push byte parameter
0093A3  2  20 FA 93     	JSR	LAB_236F		; pull string data and byte parameter from stack
0093A6  2               					; return pointer in des_2l/h, byte in A (and X), Y=0
0093A6  2  18           	CLC				; clear carry for add-1
0093A7  2  F1 9E        	SBC	(des_2l),Y		; subtract string length
0093A9  2  49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
0093AB  2               
0093AB  2               LAB_2316
0093AB  2  90 04        	BCC	LAB_231C		; branch if string length > byte parameter
0093AD  2               
0093AD  2  B1 9E        	LDA	(des_2l),Y		; else make parameter = length
0093AF  2  AA           	TAX				; copy to byte parameter copy
0093B0  2  98           	TYA				; clear string start offset
0093B1  2               LAB_231C
0093B1  2  48           	PHA				; save string start offset
0093B2  2               LAB_231D
0093B2  2  8A           	TXA				; copy byte parameter (or string length if <)
0093B3  2               LAB_231E
0093B3  2  48           	PHA				; save string length
0093B4  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
0093B7  2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0093B7  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
0093B9  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
0093BB  2  20 45 93     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
0093BE  2               					; returns with A = length, X=ut1_pl=pointer low byte,
0093BE  2               					; Y=ut1_ph=pointer high byte
0093BE  2  68           	PLA				; get string length back
0093BF  2  A8           	TAY				; copy length to Y
0093C0  2  68           	PLA				; get string start offset back
0093C1  2  18           	CLC				; clear carry for add
0093C2  2  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
0093C4  2  85 71        	STA	ut1_pl		; save string start pointer low byte
0093C6  2  90 02        	BCC	LAB_2335		; branch if no overflow
0093C8  2               
0093C8  2  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
0093CA  2               LAB_2335
0093CA  2  98           	TYA				; copy length to A
0093CB  2  20 26 93     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
0093CE  2  4C 88 91     	JMP	LAB_RTST		; check for space on descriptor stack then put string
0093D1  2               					; address and length on descriptor stack and update stack
0093D1  2               					; pointers
0093D1  2               
0093D1  2               ; perform MID$()
0093D1  2               
0093D1  2               LAB_MIDS
0093D1  2  48           	PHA				; push byte parameter
0093D2  2  A9 FF        	LDA	#$FF			; set default length = 255
0093D4  2  85 AF        	STA	mids_l		; save default length
0093D6  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0093D9  2  C9 29        	CMP	#')'			; compare with ")"
0093DB  2  F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
0093DD  2               
0093DD  2  20 01 8C     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
0093E0  2  20 8F 94     	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
0093E3  2               LAB_2358
0093E3  2  20 FA 93     	JSR	LAB_236F		; pull string data and byte parameter from stack
0093E6  2               					; return pointer in des_2l/h, byte in A (and X), Y=0
0093E6  2  CA           	DEX				; decrement start index
0093E7  2  8A           	TXA				; copy to A
0093E8  2  48           	PHA				; save string start offset
0093E9  2  18           	CLC				; clear carry for sub-1
0093EA  2  A2 00        	LDX	#$00			; clear output string length
0093EC  2  F1 9E        	SBC	(des_2l),Y		; subtract string length
0093EE  2  B0 C2        	BCS	LAB_231D		; if start>string length go do null string
0093F0  2               
0093F0  2  49 FF        	EOR	#$FF			; complement -length
0093F2  2  C5 AF        	CMP	mids_l		; compare byte parameter
0093F4  2  90 BD        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
0093F6  2               
0093F6  2  A5 AF        	LDA	mids_l		; get length byte
0093F8  2  B0 B9        	BCS	LAB_231E		; go do string copy (branch always)
0093FA  2               
0093FA  2               ; pull string data and byte parameter from stack
0093FA  2               ; return pointer in des_2l/h, byte in A (and X), Y=0
0093FA  2               
0093FA  2               LAB_236F
0093FA  2  20 F2 8B     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
0093FD  2  68           	PLA				; pull return address low byte (return address)
0093FE  2  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
009400  2  68           	PLA				; pull return address high byte (return address)
009401  2  85 A3        	STA	Fnxjph		; save functions jump vector high byte
009403  2  68           	PLA				; pull byte parameter
009404  2  AA           	TAX				; copy byte parameter to X
009405  2  68           	PLA				; pull string pointer low byte
009406  2  85 9E        	STA	des_2l		; save it
009408  2  68           	PLA				; pull string pointer high byte
009409  2  85 9F        	STA	des_2h		; save it
00940B  2  A0 00        	LDY	#$00			; clear index
00940D  2  8A           	TXA				; copy byte parameter
00940E  2  F0 79        	BEQ	LAB_23A8		; if null do function call error then warm start
009410  2               
009410  2  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
009412  2               					; (JSR pushes return addr-1. this is all very nice
009412  2               					; but will go tits up if either call is on a page
009412  2               					; boundary!)
009412  2  6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
009415  2               
009415  2               ; perform LCASE$()
009415  2               
009415  2               LAB_LCASE
009415  2  20 3E 93     	JSR	LAB_EVST		; evaluate string
009418  2  85 AC        	STA	str_ln		; set string length
00941A  2  A8           	TAY				; copy length to Y
00941B  2  F0 38        	BEQ	NoString		; branch if null string
00941D  2               
00941D  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long A=length,
009420  2               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009420  2  86 AD        	STX	str_pl		; save string pointer low byte
009422  2  84 AE        	STY	str_ph		; save string pointer high byte
009424  2  A8           	TAY				; get string length back
009425  2               
009425  2               LC_loop
009425  2  88           	DEY				; decrement index
009426  2  B1 71        	LDA	(ut1_pl),Y		; get byte from string
009428  2  20 25 8E     	JSR	LAB_1D82		; is character "A" to "Z"
00942B  2  90 02        	BCC	NoUcase		; branch if not upper case alpha
00942D  2               
00942D  2  09 20        	ORA	#$20			; convert upper to lower case
00942F  2               NoUcase
00942F  2  91 83        	STA	(Sutill),Y		; save byte back to string
009431  2  98           	TYA				; test index
009432  2  D0 F1        	BNE	LC_loop		; loop if not all done
009434  2               
009434  2  F0 1F        	BEQ	NoString		; tidy up and exit, branch always
009436  2               
009436  2               ; perform UCASE$()
009436  2               
009436  2               LAB_UCASE
009436  2  20 3E 93     	JSR	LAB_EVST		; evaluate string
009439  2  85 AC        	STA	str_ln		; set string length
00943B  2  A8           	TAY				; copy length to Y
00943C  2  F0 17        	BEQ	NoString		; branch if null string
00943E  2               
00943E  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long A=length,
009441  2               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
009441  2  86 AD        	STX	str_pl		; save string pointer low byte
009443  2  84 AE        	STY	str_ph		; save string pointer high byte
009445  2  A8           	TAY				; get string length back
009446  2               
009446  2               UC_loop
009446  2  88           	DEY				; decrement index
009447  2  B1 71        	LDA	(ut1_pl),Y		; get byte from string
009449  2  20 21 8E     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
00944C  2  90 02        	BCC	NoLcase		; branch if not alpha
00944E  2               
00944E  2  29 DF        	AND	#$DF			; convert lower to upper case
009450  2               NoLcase
009450  2  91 83        	STA	(Sutill),Y		; save byte back to string
009452  2  98           	TYA				; test index
009453  2  D0 F1        	BNE	UC_loop		; loop if not all done
009455  2               
009455  2               NoString
009455  2  4C 88 91     	JMP	LAB_RTST		; check for space on descriptor stack then put string
009458  2               					; address and length on descriptor stack and update stack
009458  2               					; pointers
009458  2               
009458  2               ; perform SADD()
009458  2               
009458  2               LAB_SADD
009458  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00945B  2  20 AD 8D     	JSR	LAB_GVAR		; get var address
00945E  2               
00945E  2  20 F2 8B     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
009461  2  20 D5 8A     	JSR	LAB_CTST		; check if source is string, else do type mismatch
009464  2               
009464  2  A0 02        	LDY	#$02			; index to string pointer high byte
009466  2  B1 95        	LDA	(Cvaral),Y		; get string pointer high byte
009468  2  AA           	TAX				; copy string pointer high byte to X
009469  2  88           	DEY				; index to string pointer low byte
00946A  2  B1 95        	LDA	(Cvaral),Y		; get string pointer low byte
00946C  2  A8           	TAY				; copy string pointer low byte to Y
00946D  2  8A           	TXA				; copy string pointer high byte to A
00946E  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
009471  2               
009471  2               ; perform LEN()
009471  2               
009471  2               LAB_LENS
009471  2  20 77 94     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
009474  2  4C 69 90     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
009477  2               
009477  2               ; evaluate string, get length in Y
009477  2               
009477  2               LAB_ESGL
009477  2  20 3E 93     	JSR	LAB_EVST		; evaluate string
00947A  2  A8           	TAY				; copy length to Y
00947B  2  60           	RTS
00947C  2               
00947C  2               ; perform ASC()
00947C  2               
00947C  2               LAB_ASC
00947C  2  20 77 94     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
00947F  2  F0 08        	BEQ	LAB_23A8		; if null do function call error then warm start
009481  2               
009481  2  A0 00        	LDY	#$00			; set index to first character
009483  2  B1 71        	LDA	(ut1_pl),Y		; get byte
009485  2  A8           	TAY				; copy to Y
009486  2  4C 69 90     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
009489  2               
009489  2               ; do function call error then warm start
009489  2               
009489  2               LAB_23A8
009489  2  4C 2C 8F     	JMP	LAB_FCER		; do function call error then warm start
00948C  2               
00948C  2               ; scan and get byte parameter
00948C  2               
00948C  2               LAB_SGBY
00948C  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00948F  2               
00948F  2               ; get byte parameter
00948F  2               
00948F  2               LAB_GTBY
00948F  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
009492  2               					; else do type mismatch
009492  2               
009492  2               ; evaluate byte expression, result in X
009492  2               
009492  2               LAB_EVBY
009492  2  20 A5 8E     	JSR	LAB_EVPI		; evaluate integer expression (no check)
009495  2               
009495  2  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
009497  2  D0 F0        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
009499  2               
009499  2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
00949B  2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00949E  2               
00949E  2               ; perform VAL()
00949E  2               
00949E  2               LAB_VAL
00949E  2  20 77 94     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
0094A1  2  D0 03        	BNE	LAB_23C5		; branch if not null string
0094A3  2               
0094A3  2               					; string was null so set result = $00
0094A3  2  4C 53 96     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
0094A6  2               
0094A6  2               LAB_23C5
0094A6  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
0094A8  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0094AA  2  86 BA        	STX	Btmpl			; save BASIC execute pointer low byte
0094AC  2  84 BB        	STY	Btmph			; save BASIC execute pointer high byte
0094AE  2  A6 71        	LDX	ut1_pl		; get string pointer low byte
0094B0  2  86 C3        	STX	Bpntrl		; save as BASIC execute pointer low byte
0094B2  2  18           	CLC				; clear carry
0094B3  2  65 71        	ADC	ut1_pl		; add string length
0094B5  2  85 73        	STA	ut2_pl		; save string end low byte
0094B7  2  A5 72        	LDA	ut1_ph		; get string pointer high byte
0094B9  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
0094BB  2  69 00        	ADC	#$00			; add carry to high byte
0094BD  2  85 74        	STA	ut2_ph		; save string end high byte
0094BF  2  A0 00        	LDY	#$00			; set index to $00
0094C1  2  B1 73        	LDA	(ut2_pl),Y		; get string end +1 byte
0094C3  2  48           	PHA				; push it
0094C4  2  98           	TYA				; clear A
0094C5  2  91 73        	STA	(ut2_pl),Y		; terminate string with $00
0094C7  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0094CA  2  20 A9 99     	JSR	LAB_2887		; get FAC1 from string
0094CD  2  68           	PLA				; restore string end +1 byte
0094CE  2  A0 00        	LDY	#$00			; set index to zero
0094D0  2  91 73        	STA	(ut2_pl),Y		; put string end byte back
0094D2  2               
0094D2  2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
0094D2  2               
0094D2  2               LAB_23F3
0094D2  2  A6 BA        	LDX	Btmpl			; get BASIC execute pointer low byte back
0094D4  2  A4 BB        	LDY	Btmph			; get BASIC execute pointer high byte back
0094D6  2  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
0094D8  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
0094DA  2  60           	RTS
0094DB  2               
0094DB  2               ; get two parameters for POKE or WAIT
0094DB  2               
0094DB  2               LAB_GADB
0094DB  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
0094DE  2               					; else do type mismatch
0094DE  2  20 F4 94     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
0094E1  2               
0094E1  2               ; scan for "," and get byte, else do Syntax error then warm start
0094E1  2               
0094E1  2               LAB_SCGB
0094E1  2  20 01 8C     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
0094E4  2  A5 12        	LDA	Itemph		; save temporary integer high byte
0094E6  2  48           	PHA				; on stack
0094E7  2  A5 11        	LDA	Itempl		; save temporary integer low byte
0094E9  2  48           	PHA				; on stack
0094EA  2  20 8F 94     	JSR	LAB_GTBY		; get byte parameter
0094ED  2  68           	PLA				; pull low byte
0094EE  2  85 11        	STA	Itempl		; restore temporary integer low byte
0094F0  2  68           	PLA				; pull high byte
0094F1  2  85 12        	STA	Itemph		; restore temporary integer high byte
0094F3  2  60           	RTS
0094F4  2               
0094F4  2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
0094F4  2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
0094F4  2               
0094F4  2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
0094F4  2               
0094F4  2               LAB_F2FX
0094F4  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0094F6  2  C9 98        	CMP	#$98			; compare with exponent = 2^24
0094F8  2  B0 8F        	BCS	LAB_23A8		; if >= do function call error then warm start
0094FA  2               
0094FA  2               LAB_F2FU
0094FA  2  20 53 99     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
0094FD  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0094FF  2  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
009501  2  84 11        	STY	Itempl		; save temporary integer low byte
009503  2  85 12        	STA	Itemph		; save temporary integer high byte
009505  2  60           	RTS
009506  2               
009506  2               ; perform PEEK()
009506  2               
009506  2               LAB_PEEK
009506  2  20 F4 94     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
009509  2  A2 00        	LDX	#$00			; clear index
00950B  2  A1 11        	LDA	(Itempl,X)		; get byte via temporary integer (addr)
00950D  2  A8           	TAY				; copy byte to Y
00950E  2  4C 69 90     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
009511  2               
009511  2               ; perform POKE
009511  2               
009511  2               LAB_POKE
009511  2  20 DB 94     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
009514  2  8A           	TXA				; copy byte argument to A
009515  2  A2 00        	LDX	#$00			; clear index
009517  2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
009519  2  60           	RTS
00951A  2               
00951A  2               ; perform DEEK()
00951A  2               
00951A  2               LAB_DEEK
00951A  2  20 F4 94     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
00951D  2  A2 00        	LDX	#$00			; clear index
00951F  2  A1 11        	LDA	(Itempl,X)		; PEEK low byte
009521  2  A8           	TAY				; copy to Y
009522  2  E6 11        	INC	Itempl		; increment pointer low byte
009524  2  D0 02        	BNE	Deekh			; skip high increment if no rollover
009526  2               
009526  2  E6 12        	INC	Itemph		; increment pointer high byte
009528  2               Deekh
009528  2  A1 11        	LDA	(Itempl,X)		; PEEK high byte
00952A  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00952D  2               
00952D  2               ; perform DOKE
00952D  2               
00952D  2               LAB_DOKE
00952D  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
009530  2               					; else do type mismatch
009530  2  20 F4 94     	JSR	LAB_F2FX		; convert floating-to-fixed
009533  2               
009533  2  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
009535  2  85 98        	STA	Frnxth		; save pointer high byte
009537  2               
009537  2  20 01 8C     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00953A  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00953D  2               					; else do type mismatch
00953D  2  20 F4 94     	JSR	LAB_F2FX		; convert floating-to-fixed
009540  2               
009540  2  98           	TYA				; copy value low byte (float to fixed returns word in AY)
009541  2  A2 00        	LDX	#$00			; clear index
009543  2  81 97        	STA	(Frnxtl,X)		; POKE low byte
009545  2  E6 97        	INC	Frnxtl		; increment pointer low byte
009547  2  D0 02        	BNE	Dokeh			; skip high increment if no rollover
009549  2               
009549  2  E6 98        	INC	Frnxth		; increment pointer high byte
00954B  2               Dokeh
00954B  2  A5 12        	LDA	Itemph		; get value high byte
00954D  2  81 97        	STA	(Frnxtl,X)		; POKE high byte
00954F  2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
009552  2               
009552  2               ; perform SWAP
009552  2               
009552  2               LAB_SWAP
009552  2  20 AD 8D     	JSR	LAB_GVAR		; get var1 address
009555  2  85 97        	STA	Lvarpl		; save var1 address low byte
009557  2  84 98        	STY	Lvarph		; save var1 address high byte
009559  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00955B  2  48           	PHA				; save data type flag
00955C  2               
00955C  2  20 01 8C     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00955F  2  20 AD 8D     	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
009562  2  68           	PLA				; pull var1 data type flag
009563  2  45 5F        	EOR	Dtypef		; compare with var2 data type
009565  2  10 10        	BPL	SwapErr		; exit if not both the same type
009567  2               
009567  2  A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
009569  2               SwapLp
009569  2  B1 97        	LDA	(Lvarpl),Y		; get byte from var1
00956B  2  AA           	TAX				; save var1 byte
00956C  2  B1 95        	LDA	(Cvaral),Y		; get byte from var2
00956E  2  91 97        	STA	(Lvarpl),Y		; save byte to var1
009570  2  8A           	TXA				; restore var1 byte
009571  2  91 95        	STA	(Cvaral),Y		; save byte to var2
009573  2  88           	DEY				; decrement index
009574  2  10 F3        	BPL	SwapLp		; loop until done
009576  2               
009576  2  60           	RTS
009577  2               
009577  2               SwapErr
009577  2  4C DF 8A     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
00957A  2               
00957A  2               ; perform CALL
00957A  2               
00957A  2               LAB_CALL
00957A  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00957D  2               					; else do type mismatch
00957D  2  20 F4 94     	JSR	LAB_F2FX		; convert floating-to-fixed
009580  2  A9 95        	LDA	#>CallExit		; set return address high byte
009582  2  48           	PHA				; put on stack
009583  2  A9 88        	LDA	#<CallExit-1	; set return address low byte
009585  2  48           	PHA				; put on stack
009586  2  6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
009589  2               
009589  2               ; if the called routine exits correctly then it will return to here. this will then get
009589  2               ; the next byte for the interpreter and return
009589  2               
009589  2               CallExit
009589  2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00958C  2               
00958C  2               ; perform WAIT
00958C  2               
00958C  2               LAB_WAIT
00958C  2  20 DB 94     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00958F  2  86 97        	STX	Frnxtl		; save byte
009591  2  A2 00        	LDX	#$00			; clear mask
009593  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
009596  2  F0 03        	BEQ	LAB_2441		; skip if no third argument
009598  2               
009598  2  20 E1 94     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
00959B  2               LAB_2441
00959B  2  86 98        	STX	Frnxth		; save EOR argument
00959D  2               LAB_2445
00959D  2  B1 11        	LDA	(Itempl),Y		; get byte via temporary integer (addr)
00959F  2  45 98        	EOR	Frnxth		; EOR with second argument (mask)
0095A1  2  25 97        	AND	Frnxtl		; AND with first argument (byte)
0095A3  2  F0 F8        	BEQ	LAB_2445		; loop if result is zero
0095A5  2               
0095A5  2               LAB_244D
0095A5  2  60           	RTS
0095A6  2               
0095A6  2               ; perform subtraction, FAC1 from (AY)
0095A6  2               
0095A6  2               LAB_2455
0095A6  2  20 8E 97     	JSR	LAB_264D		; unpack memory (AY) into FAC2
0095A9  2               
0095A9  2               ; perform subtraction, FAC1 from FAC2
0095A9  2               
0095A9  2               LAB_SUBTRACT
0095A9  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0095AB  2  49 FF        	EOR	#$FF			; complement it
0095AD  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0095AF  2  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
0095B1  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0095B3  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0095B5  2  4C C4 95     	JMP	LAB_ADD		; go add FAC2 to FAC1
0095B8  2               
0095B8  2               ; perform addition
0095B8  2               
0095B8  2               LAB_2467
0095B8  2  20 DD 96     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
0095BB  2  90 4D        	BCC	LAB_24A8		;.go subtract mantissas
0095BD  2               
0095BD  2               ; add 0.5 to FAC1
0095BD  2               
0095BD  2               LAB_244E
0095BD  2  A9 EC        	LDA	#<LAB_2A96		; set 0.5 pointer low byte
0095BF  2  A0 A1        	LDY	#>LAB_2A96		; set 0.5 pointer high byte
0095C1  2               
0095C1  2               ; add (AY) to FAC1
0095C1  2               
0095C1  2               LAB_246C
0095C1  2  20 8E 97     	JSR	LAB_264D		; unpack memory (AY) into FAC2
0095C4  2               
0095C4  2               ; add FAC2 to FAC1
0095C4  2               
0095C4  2               LAB_ADD
0095C4  2  D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
0095C6  2               
0095C6  2               ; copy FAC2 to FAC1
0095C6  2               
0095C6  2               LAB_279B
0095C6  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
0095C8  2               
0095C8  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
0095C8  2               
0095C8  2               LAB_279D
0095C8  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0095CA  2  A2 04        	LDX	#$04			; 4 bytes to copy
0095CC  2               LAB_27A1
0095CC  2  B5 B2        	LDA	FAC1_o,X		; get byte from FAC2,X
0095CE  2  95 AB        	STA	FAC1_e-1,X		; save byte at FAC1,X
0095D0  2  CA           	DEX				; decrement count
0095D1  2  D0 F9        	BNE	LAB_27A1		; loop if not all done
0095D3  2               
0095D3  2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
0095D5  2  60           	RTS
0095D6  2               
0095D6  2               					; FAC1 is non zero
0095D6  2               LAB_2474
0095D6  2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
0095D8  2  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
0095DA  2  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
0095DC  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
0095DE  2               LAB_247C
0095DE  2  A8           	TAY				; copy exponent
0095DF  2  F0 C4        	BEQ	LAB_244D		; exit if zero
0095E1  2               
0095E1  2  38           	SEC				; set carry for subtract
0095E2  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
0095E4  2  F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
0095E6  2               
0095E6  2  90 12        	BCC	LAB_2498		; branch if <
0095E8  2               
0095E8  2               					; FAC2>FAC1
0095E8  2  84 AC        	STY	FAC1_e		; save FAC1 exponent
0095EA  2  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
0095EC  2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
0095EE  2  49 FF        	EOR	#$FF			; complement A
0095F0  2  69 00        	ADC	#$00			; +1 (twos complement, carry is set)
0095F2  2  A0 00        	LDY	#$00			; clear Y
0095F4  2  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
0095F6  2  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
0095F8  2  D0 04        	BNE	LAB_249C		; branch always
0095FA  2               
0095FA  2               LAB_2498
0095FA  2  A0 00        	LDY	#$00			; clear Y
0095FC  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
0095FE  2               LAB_249C
0095FE  2  C9 F9        	CMP	#$F9			; compare exponent diff with $F9
009600  2  30 B6        	BMI	LAB_2467		; branch if range $79-$F8
009602  2               
009602  2  A8           	TAY				; copy exponent difference to Y
009603  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
009605  2  56 01        	LSR	PLUS_1,X		; shift FAC? mantissa1
009607  2  20 F4 96     	JSR	LAB_2592		; shift FACX Y times right
00960A  2               
00960A  2               					; exponents are equal now do mantissa subtract
00960A  2               LAB_24A8
00960A  2  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
00960C  2  10 4C        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
00960E  2               
00960E  2  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
009610  2  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
009612  2  F0 02        	BEQ	LAB_24B4		; branch if =
009614  2               
009614  2  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
009616  2               
009616  2               					; subtract smaller from bigger (take sign of bigger)
009616  2               LAB_24B4
009616  2  38           	SEC				; set carry for subtract
009617  2  49 FF        	EOR	#$FF			; ones complement A
009619  2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
00961B  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00961D  2  B9 03 00     	LDA	PLUS_3,Y		; get FACY mantissa3
009620  2  F5 03        	SBC	PLUS_3,X		; subtract FACX mantissa3
009622  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
009624  2  B9 02 00     	LDA	PLUS_2,Y		; get FACY mantissa2
009627  2  F5 02        	SBC	PLUS_2,X		; subtract FACX mantissa2
009629  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00962B  2  B9 01 00     	LDA	PLUS_1,Y		; get FACY mantissa1
00962E  2  F5 01        	SBC	PLUS_1,X		; subtract FACX mantissa1
009630  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
009632  2               
009632  2               ; do ABS and normalise FAC1
009632  2               
009632  2               LAB_24D0
009632  2  B0 03        	BCS	LAB_24D5		; branch if number is +ve
009634  2               
009634  2  20 99 96     	JSR	LAB_2537		; negate FAC1
009637  2               
009637  2               ; normalise FAC1
009637  2               
009637  2               LAB_24D5
009637  2  A0 00        	LDY	#$00			; clear Y
009639  2  98           	TYA				; clear A
00963A  2  18           	CLC				; clear carry for add
00963B  2               LAB_24D9
00963B  2  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
00963D  2  D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
00963F  2               
00963F  2  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
009641  2  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
009643  2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
009645  2  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
009647  2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
009649  2  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
00964B  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00964D  2  69 08        	ADC	#$08			; add x to exponent offset
00964F  2  C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
009651  2  D0 E8        	BNE	LAB_24D9		; loop if not max
009653  2               
009653  2               ; clear FAC1 exponent and sign
009653  2               
009653  2               LAB_24F1
009653  2  A9 00        	LDA	#$00			; clear A
009655  2               LAB_24F3
009655  2  85 AC        	STA	FAC1_e		; set FAC1 exponent
009657  2               
009657  2               ; save FAC1 sign
009657  2               
009657  2               LAB_24F5
009657  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
009659  2  60           	RTS
00965A  2               
00965A  2               ; add FAC2 mantissa to FAC1 mantissa
00965A  2               
00965A  2               LAB_24F8
00965A  2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
00965C  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00965E  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
009660  2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
009662  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
009664  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
009666  2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
009668  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00966A  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00966C  2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00966E  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
009670  2  B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
009672  2               
009672  2  60           	RTS				; else just exit
009673  2               
009673  2               LAB_2511
009673  2  69 01        	ADC	#$01			; add 1 to exponent offset
009675  2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
009677  2  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
009679  2  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
00967B  2  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
00967D  2               
00967D  2               ; normalise FAC1
00967D  2               
00967D  2               LAB_251B
00967D  2  10 F4        	BPL	LAB_2511		; loop if not normalised
00967F  2               
00967F  2  38           	SEC				; set carry for subtract
009680  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
009682  2  B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
009684  2               
009684  2  49 FF        	EOR	#$FF			; complement exponent
009686  2  69 01        	ADC	#$01			; +1 (twos complement)
009688  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00968A  2               
00968A  2               ; test and normalise FAC1 for C=0/1
00968A  2               
00968A  2               LAB_2528
00968A  2  90 0C        	BCC	LAB_2536		; exit if no overflow
00968C  2               
00968C  2               ; normalise FAC1 for C=1
00968C  2               
00968C  2               LAB_252A
00968C  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
00968E  2  F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
009690  2               
009690  2  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
009692  2  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
009694  2  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
009696  2  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
009698  2               LAB_2536
009698  2  60           	RTS
009699  2               
009699  2               ; negate FAC1
009699  2               
009699  2               LAB_2537
009699  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00969B  2  49 FF        	EOR	#$FF			; complement it
00969D  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00969F  2               
00969F  2               ; twos complement FAC1 mantissa
00969F  2               
00969F  2               LAB_253D
00969F  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
0096A1  2  49 FF        	EOR	#$FF			; complement it
0096A3  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
0096A5  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0096A7  2  49 FF        	EOR	#$FF			; complement it
0096A9  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
0096AB  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0096AD  2  49 FF        	EOR	#$FF			; complement it
0096AF  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
0096B1  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
0096B3  2  49 FF        	EOR	#$FF			; complement it
0096B5  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
0096B7  2  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
0096B9  2  D0 0A        	BNE	LAB_2563		; exit if no overflow
0096BB  2               
0096BB  2               ; increment FAC1 mantissa
0096BB  2               
0096BB  2               LAB_2559
0096BB  2  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
0096BD  2  D0 06        	BNE	LAB_2563		; finished if no rollover
0096BF  2               
0096BF  2  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
0096C1  2  D0 02        	BNE	LAB_2563		; finished if no rollover
0096C3  2               
0096C3  2  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
0096C5  2               LAB_2563
0096C5  2  60           	RTS
0096C6  2               
0096C6  2               ; do overflow error (overflow exit)
0096C6  2               
0096C6  2               LAB_2564
0096C6  2  A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
0096C8  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
0096CB  2               
0096CB  2               ; shift FCAtemp << A+8 times
0096CB  2               
0096CB  2               LAB_2569
0096CB  2  A2 74        	LDX	#FACt_1-1		; set offset to FACtemp
0096CD  2               LAB_256B
0096CD  2  B4 03        	LDY	PLUS_3,X		; get FACX mantissa3
0096CF  2  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
0096D1  2  B4 02        	LDY	PLUS_2,X		; get FACX mantissa2
0096D3  2  94 03        	STY	PLUS_3,X		; save FACX mantissa3
0096D5  2  B4 01        	LDY	PLUS_1,X		; get FACX mantissa1
0096D7  2  94 02        	STY	PLUS_2,X		; save FACX mantissa2
0096D9  2  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
0096DB  2  94 01        	STY	PLUS_1,X		; save FACX mantissa1
0096DD  2               
0096DD  2               ; shift FACX -A times right (> 8 shifts)
0096DD  2               
0096DD  2               LAB_257B
0096DD  2  69 08        	ADC	#$08			; add 8 to shift count
0096DF  2  30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
0096E1  2               
0096E1  2  F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
0096E3  2               
0096E3  2  E9 08        	SBC	#$08			; else subtract 8 again
0096E5  2  A8           	TAY				; save count to Y
0096E6  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
0096E8  2  B0 12        	BCS	LAB_259A		;.
0096EA  2               
0096EA  2               LAB_2588
0096EA  2  16 01        	ASL	PLUS_1,X		; shift FACX mantissa1
0096EC  2  90 02        	BCC	LAB_258E		; branch if +ve
0096EE  2               
0096EE  2  F6 01        	INC	PLUS_1,X		; this sets b7 eventually
0096F0  2               LAB_258E
0096F0  2  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
0096F2  2  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
0096F4  2               
0096F4  2               ; shift FACX Y times right
0096F4  2               
0096F4  2               LAB_2592
0096F4  2  76 02        	ROR	PLUS_2,X		; shift FACX mantissa2
0096F6  2  76 03        	ROR	PLUS_3,X		; shift FACX mantissa3
0096F8  2  6A           	ROR				; shift FACX rounding byte
0096F9  2  C8           	INY				; increment exponent diff
0096FA  2  D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
0096FC  2               
0096FC  2               LAB_259A
0096FC  2  18           	CLC				; just clear it
0096FD  2  60           	RTS
0096FE  2               
0096FE  2               ; perform LOG()
0096FE  2               
0096FE  2               LAB_LOG
0096FE  2  20 EC 98     	JSR	LAB_27CA		; test sign and zero
009701  2  F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
009703  2               
009703  2  10 03        	BPL	LAB_25C7		; skip error if +ve
009705  2               
009705  2               LAB_25C4
009705  2  4C 2C 8F     	JMP	LAB_FCER		; do function call error then warm start (-ve)
009708  2               
009708  2               LAB_25C7
009708  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00970A  2  E9 7F        	SBC	#$7F			; normalise it
00970C  2  48           	PHA				; save it
00970D  2  A9 80        	LDA	#$80			; set exponent to zero
00970F  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
009711  2  A9 6C        	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
009713  2  A0 A1        	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
009715  2  20 C1 95     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
009718  2  A9 70        	LDA	#<LAB_25B1		; set root2 pointer low byte
00971A  2  A0 A1        	LDY	#>LAB_25B1		; set root2 pointer high byte
00971C  2  20 04 98     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00971F  2  A9 E3        	LDA	#<LAB_259C		; set 1 pointer low byte
009721  2  A0 A1        	LDY	#>LAB_259C		; set 1 pointer high byte
009723  2  20 A6 95     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
009726  2  A9 5F        	LDA	#<LAB_25A0		; set pointer low byte to counter
009728  2  A0 A1        	LDY	#>LAB_25A0		; set pointer high byte to counter
00972A  2  20 54 9C     	JSR	LAB_2B6E		; ^2 then series evaluation
00972D  2  A9 74        	LDA	#<LAB_25B5		; set -0.5 pointer low byte
00972F  2  A0 A1        	LDY	#>LAB_25B5		; set -0.5 pointer high byte
009731  2  20 C1 95     	JSR	LAB_246C		; add (AY) to FAC1
009734  2  68           	PLA				; restore FAC1 exponent
009735  2  20 48 9A     	JSR	LAB_2912		; evaluate new ASCII digit
009738  2  A9 78        	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
00973A  2  A0 A1        	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
00973C  2               
00973C  2               ; do convert AY, FCA1*(AY)
00973C  2               
00973C  2               LAB_25FB
00973C  2  20 8E 97     	JSR	LAB_264D		; unpack memory (AY) into FAC2
00973F  2               LAB_MULTIPLY
00973F  2  F0 4C        	BEQ	LAB_264C		; exit if zero
009741  2               
009741  2  20 B4 97     	JSR	LAB_2673		; test and adjust accumulators
009744  2  A9 00        	LDA	#$00			; clear A
009746  2  85 75        	STA	FACt_1		; clear temp mantissa1
009748  2  85 76        	STA	FACt_2		; clear temp mantissa2
00974A  2  85 77        	STA	FACt_3		; clear temp mantissa3
00974C  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00974E  2  20 63 97     	JSR	LAB_2622		; go do shift/add FAC2
009751  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
009753  2  20 63 97     	JSR	LAB_2622		; go do shift/add FAC2
009756  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
009758  2  20 63 97     	JSR	LAB_2622		; go do shift/add FAC2
00975B  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00975D  2  20 68 97     	JSR	LAB_2627		; go do shift/add FAC2
009760  2  4C 71 98     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
009763  2               
009763  2               LAB_2622
009763  2  D0 03        	BNE	LAB_2627		; branch if byte <> zero
009765  2               
009765  2  4C CB 96     	JMP	LAB_2569		; shift FCAtemp << A+8 times
009768  2               
009768  2               					; else do shift and add
009768  2               LAB_2627
009768  2  4A           	LSR				; shift byte
009769  2  09 80        	ORA	#$80			; set top bit (mark for 8 times)
00976B  2               LAB_262A
00976B  2  A8           	TAY				; copy result
00976C  2  90 13        	BCC	LAB_2640		; skip next if bit was zero
00976E  2               
00976E  2  18           	CLC				; clear carry for add
00976F  2  A5 77        	LDA	FACt_3		; get temp mantissa3
009771  2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
009773  2  85 77        	STA	FACt_3		; save temp mantissa3
009775  2  A5 76        	LDA	FACt_2		; get temp mantissa2
009777  2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
009779  2  85 76        	STA	FACt_2		; save temp mantissa2
00977B  2  A5 75        	LDA	FACt_1		; get temp mantissa1
00977D  2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00977F  2  85 75        	STA	FACt_1		; save temp mantissa1
009781  2               LAB_2640
009781  2  66 75        	ROR	FACt_1		; shift temp mantissa1
009783  2  66 76        	ROR	FACt_2		; shift temp mantissa2
009785  2  66 77        	ROR	FACt_3		; shift temp mantissa3
009787  2  66 B9        	ROR	FAC1_r		; shift temp rounding byte
009789  2  98           	TYA				; get byte back
00978A  2  4A           	LSR				; shift byte
00978B  2  D0 DE        	BNE	LAB_262A		; loop if all bits not done
00978D  2               
00978D  2               LAB_264C
00978D  2  60           	RTS
00978E  2               
00978E  2               ; unpack memory (AY) into FAC2
00978E  2               
00978E  2               LAB_264D
00978E  2  85 71        	STA	ut1_pl		; save pointer low byte
009790  2  84 72        	STY	ut1_ph		; save pointer high byte
009792  2  A0 03        	LDY	#$03			; 4 bytes to get (0-3)
009794  2  B1 71        	LDA	(ut1_pl),Y		; get mantissa3
009796  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
009798  2  88           	DEY				; decrement index
009799  2  B1 71        	LDA	(ut1_pl),Y		; get mantissa2
00979B  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00979D  2  88           	DEY				; decrement index
00979E  2  B1 71        	LDA	(ut1_pl),Y		; get mantissa1+sign
0097A0  2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
0097A2  2  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
0097A4  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0097A6  2  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
0097A8  2  09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
0097AA  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
0097AC  2  88           	DEY				; decrement index
0097AD  2  B1 71        	LDA	(ut1_pl),Y		; get exponent byte
0097AF  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
0097B1  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0097B3  2  60           	RTS
0097B4  2               
0097B4  2               ; test and adjust accumulators
0097B4  2               
0097B4  2               LAB_2673
0097B4  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
0097B6  2               LAB_2675
0097B6  2  F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
0097B8  2               
0097B8  2  18           	CLC				; clear carry for add
0097B9  2  65 AC        	ADC	FAC1_e		; add FAC1 exponent
0097BB  2  90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
0097BD  2               
0097BD  2  30 31        	BMI	LAB_269B		; do overflow error
0097BF  2               
0097BF  2  18           	CLC				; clear carry for the add
0097C0  2  2C           	.byte	$2C			; makes next line BIT $1410
0097C1  2               LAB_2680
0097C1  2  10 12        	BPL	LAB_2696		; if +ve go handle underflow
0097C3  2               
0097C3  2  69 80        	ADC	#$80			; adjust exponent
0097C5  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
0097C7  2  D0 03        	BNE	LAB_268B		; branch if not zero
0097C9  2               
0097C9  2  4C 57 96     	JMP	LAB_24F5		; save FAC1 sign and return
0097CC  2               
0097CC  2               LAB_268B
0097CC  2  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
0097CE  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0097D0  2               LAB_268F
0097D0  2  60           	RTS
0097D1  2               
0097D1  2               ; handle overflow and underflow
0097D1  2               
0097D1  2               LAB_2690
0097D1  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0097D3  2  10 1B        	BPL	LAB_269B		; do overflow error
0097D5  2               
0097D5  2               					; handle underflow
0097D5  2               LAB_2696
0097D5  2  68           	PLA				; pop return address low byte
0097D6  2  68           	PLA				; pop return address high byte
0097D7  2  4C 53 96     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
0097DA  2               
0097DA  2               ; multiply by 10
0097DA  2               
0097DA  2               LAB_269E
0097DA  2  20 CD 98     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
0097DD  2  AA           	TAX				; copy exponent (set the flags)
0097DE  2  F0 F0        	BEQ	LAB_268F		; exit if zero
0097E0  2               
0097E0  2  18           	CLC				; clear carry for add
0097E1  2  69 02        	ADC	#$02			; add two to exponent (*4)
0097E3  2  B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
0097E5  2               
0097E5  2  A2 00        	LDX	#$00			; clear byte
0097E7  2  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
0097E9  2  20 DE 95     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
0097EC  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
0097EE  2  D0 E0        	BNE	LAB_268F		; if non zero just do RTS
0097F0  2               
0097F0  2               LAB_269B
0097F0  2  4C C6 96     	JMP	LAB_2564		; do overflow error and warm start
0097F3  2               
0097F3  2               ; divide by 10
0097F3  2               
0097F3  2               LAB_26B9
0097F3  2  20 CD 98     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
0097F6  2  A9 F4        	LDA	#<LAB_26B5		; set pointer to 10d low addr
0097F8  2  A0 A1        	LDY	#>LAB_26B5		; set pointer to 10d high addr
0097FA  2  A2 00        	LDX	#$00			; clear sign
0097FC  2               
0097FC  2               ; divide by (AY) (X=sign)
0097FC  2               
0097FC  2               LAB_26C2
0097FC  2  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0097FE  2  20 80 98     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
009801  2  4C 07 98     	JMP	LAB_DIVIDE		; do FAC2/FAC1
009804  2               
009804  2               					; Perform divide-by
009804  2               ; convert AY and do (AY)/FAC1
009804  2               
009804  2               LAB_26CA
009804  2  20 8E 97     	JSR	LAB_264D		; unpack memory (AY) into FAC2
009807  2               
009807  2               					; Perform divide-into
009807  2               LAB_DIVIDE
009807  2  F0 63        	BEQ	LAB_2737		; if zero go do /0 error
009809  2               
009809  2  20 DC 98     	JSR	LAB_27BA		; round FAC1
00980C  2  A9 00        	LDA	#$00			; clear A
00980E  2  38           	SEC				; set carry for subtract
00980F  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
009811  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
009813  2  20 B4 97     	JSR	LAB_2673		; test and adjust accumulators
009816  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
009818  2  F0 D6        	BEQ	LAB_269B		; if zero do overflow error
00981A  2               
00981A  2  A2 FF        	LDX	#$FF			; set index for pre increment
00981C  2  A9 01        	LDA	#$01			; set bit to flag byte save
00981E  2               LAB_26E4
00981E  2  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
009820  2  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
009822  2  D0 0A        	BNE	LAB_26F4		; branch if <>
009824  2               
009824  2  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
009826  2  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
009828  2  D0 04        	BNE	LAB_26F4		; branch if <>
00982A  2               
00982A  2  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
00982C  2  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
00982E  2               LAB_26F4
00982E  2  08           	PHP				; save FAC2-FAC1 compare status
00982F  2  2A           	ROL				; shift the result byte
009830  2  90 0E        	BCC	LAB_2702		; if no carry skip the byte save
009832  2               
009832  2  A0 01        	LDY	#$01			; set bit to flag byte save
009834  2  E8           	INX				; else increment the index to FACt
009835  2  E0 02        	CPX	#$02			; compare with the index to FACt_3
009837  2  30 04        	BMI	LAB_2701		; if not last byte just go save it
009839  2               
009839  2  D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
00983B  2               					; return
00983B  2               
00983B  2  A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
00983D  2               LAB_2701
00983D  2  95 75        	STA	FACt_1,X		; write result byte to FACt_1 + index
00983F  2  98           	TYA				; copy the next save byte flag
009840  2               LAB_2702
009840  2  28           	PLP				; restore FAC2-FAC1 compare status
009841  2  90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
009843  2               
009843  2  A8           	TAY				; save FAC2-FAC1 compare status
009844  2  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
009846  2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
009848  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00984A  2  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
00984C  2  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
00984E  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
009850  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
009852  2  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
009854  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
009856  2  98           	TYA				; restore FAC2-FAC1 compare status
009857  2               
009857  2               					; FAC2 = FAC2*2
009857  2               LAB_2704
009857  2  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
009859  2  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
00985B  2  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
00985D  2  B0 CF        	BCS	LAB_26F4		; loop with no compare
00985F  2               
00985F  2  30 BD        	BMI	LAB_26E4		; loop with compare
009861  2               
009861  2  10 CB        	BPL	LAB_26F4		; loop always with no compare
009863  2               
009863  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
009863  2               
009863  2               LAB_272B
009863  2  4A           	LSR				; shift b1 - b0 ..
009864  2  6A           	ROR				; ..
009865  2  6A           	ROR				; .. to b7 - b6
009866  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
009868  2  28           	PLP				; dump FAC2-FAC1 compare status
009869  2  4C 71 98     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
00986C  2               
00986C  2               ; do "Divide by zero" error
00986C  2               
00986C  2               LAB_2737
00986C  2  A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
00986E  2  4C 3F 81     	JMP	LAB_XERR		; do error #X, then warm start
009871  2               
009871  2               ; copy temp to FAC1 and normalise
009871  2               
009871  2               LAB_273C
009871  2  A5 75        	LDA	FACt_1		; get temp mantissa1
009873  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
009875  2  A5 76        	LDA	FACt_2		; get temp mantissa2
009877  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
009879  2  A5 77        	LDA	FACt_3		; get temp mantissa3
00987B  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00987D  2  4C 37 96     	JMP	LAB_24D5		; normalise FAC1 and return
009880  2               
009880  2               ; unpack memory (AY) into FAC1
009880  2               
009880  2               LAB_UFAC
009880  2  85 71        	STA	ut1_pl		; save pointer low byte
009882  2  84 72        	STY	ut1_ph		; save pointer high byte
009884  2  A0 03        	LDY	#$03			; 4 bytes to do
009886  2  B1 71        	LDA	(ut1_pl),Y		; get last byte
009888  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00988A  2  88           	DEY				; decrement index
00988B  2  B1 71        	LDA	(ut1_pl),Y		; get last-1 byte
00988D  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00988F  2  88           	DEY				; decrement index
009890  2  B1 71        	LDA	(ut1_pl),Y		; get second byte
009892  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
009894  2  09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
009896  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
009898  2  88           	DEY				; decrement index
009899  2  B1 71        	LDA	(ut1_pl),Y		; get first byte (exponent)
00989B  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00989D  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00989F  2  60           	RTS
0098A0  2               
0098A0  2               ; pack FAC1 into Adatal
0098A0  2               
0098A0  2               LAB_276E
0098A0  2  A2 A4        	LDX	#<Adatal		; set pointer low byte
0098A2  2               LAB_2770
0098A2  2  A0 00        	LDY	#>Adatal		; set pointer high byte
0098A4  2  F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
0098A6  2               
0098A6  2               ; pack FAC1 into (Lvarpl)
0098A6  2               
0098A6  2               LAB_PFAC
0098A6  2  A6 97        	LDX	Lvarpl		; get destination pointer low byte
0098A8  2  A4 98        	LDY	Lvarph		; get destination pointer high byte
0098AA  2               
0098AA  2               ; pack FAC1 into (XY)
0098AA  2               
0098AA  2               LAB_2778
0098AA  2  20 DC 98     	JSR	LAB_27BA		; round FAC1
0098AD  2  86 71        	STX	ut1_pl		; save pointer low byte
0098AF  2  84 72        	STY	ut1_ph		; save pointer high byte
0098B1  2  A0 03        	LDY	#$03			; set index
0098B3  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0098B5  2  91 71        	STA	(ut1_pl),Y		; store in destination
0098B7  2  88           	DEY				; decrement index
0098B8  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0098BA  2  91 71        	STA	(ut1_pl),Y		; store in destination
0098BC  2  88           	DEY				; decrement index
0098BD  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0098BF  2  09 7F        	ORA	#$7F			; set bits x111 1111
0098C1  2  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
0098C3  2  91 71        	STA	(ut1_pl),Y		; store in destination
0098C5  2  88           	DEY				; decrement index
0098C6  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0098C8  2  91 71        	STA	(ut1_pl),Y		; store in destination
0098CA  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
0098CC  2  60           	RTS
0098CD  2               
0098CD  2               ; round and copy FAC1 to FAC2
0098CD  2               
0098CD  2               LAB_27AB
0098CD  2  20 DC 98     	JSR	LAB_27BA		; round FAC1
0098D0  2               
0098D0  2               ; copy FAC1 to FAC2
0098D0  2               
0098D0  2               LAB_27AE
0098D0  2  A2 05        	LDX	#$05			; 5 bytes to copy
0098D2  2               LAB_27B0
0098D2  2  B5 AB        	LDA	FAC1_e-1,X		; get byte from FAC1,X
0098D4  2  95 B2        	STA	FAC1_o,X		; save byte at FAC2,X
0098D6  2  CA           	DEX				; decrement count
0098D7  2  D0 F9        	BNE	LAB_27B0		; loop if not all done
0098D9  2               
0098D9  2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
0098DB  2               LAB_27B9
0098DB  2  60           	RTS
0098DC  2               
0098DC  2               ; round FAC1
0098DC  2               
0098DC  2               LAB_27BA
0098DC  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0098DE  2  F0 FB        	BEQ	LAB_27B9		; exit if zero
0098E0  2               
0098E0  2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
0098E2  2  90 F7        	BCC	LAB_27B9		; exit if no overflow
0098E4  2               
0098E4  2               ; round FAC1 (no check)
0098E4  2               
0098E4  2               LAB_27C2
0098E4  2  20 BB 96     	JSR	LAB_2559		; increment FAC1 mantissa
0098E7  2  D0 F2        	BNE	LAB_27B9		; branch if no overflow
0098E9  2               
0098E9  2  4C 8C 96     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
0098EC  2               
0098EC  2               ; get FAC1 sign
0098EC  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0098EC  2               
0098EC  2               LAB_27CA
0098EC  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0098EE  2  F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
0098F0  2               
0098F0  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0098F0  2               ; no = 0 check
0098F0  2               
0098F0  2               LAB_27CE
0098F0  2  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
0098F2  2               
0098F2  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0098F2  2               ; no = 0 check, sign in A
0098F2  2               
0098F2  2               LAB_27D0
0098F2  2  2A           	ROL				; move sign bit to carry
0098F3  2  A9 FF        	LDA	#$FF			; set byte for -ve result
0098F5  2  B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
0098F7  2               
0098F7  2  A9 01        	LDA	#$01			; else set byte for +ve result
0098F9  2               LAB_27D7
0098F9  2  60           	RTS
0098FA  2               
0098FA  2               ; perform SGN()
0098FA  2               
0098FA  2               LAB_SGN
0098FA  2  20 EC 98     	JSR	LAB_27CA		; get FAC1 sign
0098FD  2               					; return A=$FF/-ve A=$01/+ve
0098FD  2               ; save A as integer byte
0098FD  2               
0098FD  2               LAB_27DB
0098FD  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
0098FF  2  A9 00        	LDA	#$00			; clear A
009901  2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
009903  2  A2 88        	LDX	#$88			; set exponent
009905  2               
009905  2               ; set exp=X, clearFAC1 mantissa3 and normalise
009905  2               
009905  2               LAB_27E3
009905  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
009907  2  49 FF        	EOR	#$FF			; complement it
009909  2  2A           	ROL				; sign bit into carry
00990A  2               
00990A  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00990A  2               
00990A  2               LAB_STFA
00990A  2  A9 00        	LDA	#$00			; clear A
00990C  2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00990E  2  86 AC        	STX	FAC1_e		; set FAC1 exponent
009910  2  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
009912  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
009914  2  4C 32 96     	JMP	LAB_24D0		; do ABS and normalise FAC1
009917  2               
009917  2               ; perform ABS()
009917  2               
009917  2               LAB_ABS
009917  2  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
009919  2  60           	RTS
00991A  2               
00991A  2               ; compare FAC1 with (AY)
00991A  2               ; returns A=$00 if FAC1 = (AY)
00991A  2               ; returns A=$01 if FAC1 > (AY)
00991A  2               ; returns A=$FF if FAC1 < (AY)
00991A  2               
00991A  2               LAB_27F8
00991A  2  85 73        	STA	ut2_pl		; save pointer low byte
00991C  2               LAB_27FA
00991C  2  84 74        	STY	ut2_ph		; save pointer high byte
00991E  2  A0 00        	LDY	#$00			; clear index
009920  2  B1 73        	LDA	(ut2_pl),Y		; get exponent
009922  2  C8           	INY				; increment index
009923  2  AA           	TAX				; copy (AY) exponent to X
009924  2  F0 C6        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
009926  2               					; A=FF,C=1/-ve A=01,C=0/+ve
009926  2               
009926  2  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
009928  2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
00992A  2  30 C4        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
00992C  2               					; A=01,C=0/+ve and return
00992C  2               
00992C  2  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
00992E  2  D0 1A        	BNE	LAB_2828		; branch if different
009930  2               
009930  2  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
009932  2  09 80        	ORA	#$80			; normalise top bit
009934  2  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
009936  2  D0 12        	BNE	LAB_2828		; branch if different
009938  2               
009938  2  C8           	INY				; increment index
009939  2  B1 73        	LDA	(ut2_pl),Y		; get mantissa2
00993B  2  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
00993D  2  D0 0B        	BNE	LAB_2828		; branch if different
00993F  2               
00993F  2  C8           	INY				; increment index
009940  2  A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
009942  2  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
009944  2  B1 73        	LDA	(ut2_pl),Y		; get mantissa3
009946  2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
009948  2  F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
00994A  2               
00994A  2               ; gets here if number <> FAC1
00994A  2               
00994A  2               LAB_2828
00994A  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00994C  2  90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
00994E  2               
00994E  2  49 FF        	EOR	#$FF			; else toggle FAC1 sign
009950  2               LAB_282E
009950  2  4C F2 98     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
009953  2               
009953  2               ; convert FAC1 floating-to-fixed
009953  2               
009953  2               LAB_2831
009953  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009955  2  F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
009957  2               
009957  2  38           	SEC				; set carry for subtract
009958  2  E9 98        	SBC	#$98			; subtract maximum integer range exponent
00995A  2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
00995C  2  10 09        	BPL	LAB_2845		; branch if FAC1 +ve
00995E  2               
00995E  2               					; FAC1 was -ve
00995E  2  AA           	TAX				; copy subtracted exponent
00995F  2  A9 FF        	LDA	#$FF			; overflow for -ve number
009961  2  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
009963  2  20 9F 96     	JSR	LAB_253D		; twos complement FAC1 mantissa
009966  2  8A           	TXA				; restore subtracted exponent
009967  2               LAB_2845
009967  2  A2 AC        	LDX	#FAC1_e		; set index to FAC1
009969  2  C9 F9        	CMP	#$F9			; compare exponent result
00996B  2  10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
00996D  2               
00996D  2  20 DD 96     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
009970  2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
009972  2               LAB_2850
009972  2  60           	RTS
009973  2               
009973  2               ; shift FAC1 A times right
009973  2               
009973  2               LAB_2851
009973  2  A8           	TAY				; copy shift count
009974  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
009976  2  29 80        	AND	#$80			; mask sign bit only (x000 0000)
009978  2  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
00997A  2  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
00997C  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00997E  2  20 F4 96     	JSR	LAB_2592		; shift FAC1 Y times right
009981  2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
009983  2  60           	RTS
009984  2               
009984  2               ; perform INT()
009984  2               
009984  2               LAB_INT
009984  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009986  2  C9 98        	CMP	#$98			; compare with max int
009988  2  B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
00998A  2               
00998A  2  20 53 99     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
00998D  2  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
00998F  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
009991  2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
009993  2  49 80        	EOR	#$80			; toggle FAC1 sign
009995  2  2A           	ROL				; shift into carry
009996  2  A9 98        	LDA	#$98			; set new exponent
009998  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00999A  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00999C  2  85 5B        	STA	Temp3			; save for EXP() function
00999E  2  4C 32 96     	JMP	LAB_24D0		; do ABS and normalise FAC1
0099A1  2               
0099A1  2               ; clear FAC1 and return
0099A1  2               
0099A1  2               LAB_287F
0099A1  2  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
0099A3  2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
0099A5  2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
0099A7  2  A8           	TAY				; clear Y
0099A8  2               LAB_2886
0099A8  2  60           	RTS
0099A9  2               
0099A9  2               ; get FAC1 from string
0099A9  2               ; this routine now handles hex and binary values from strings
0099A9  2               ; starting with "$" and "%" respectively
0099A9  2               
0099A9  2               LAB_2887
0099A9  2  A0 00        	LDY	#$00			; clear Y
0099AB  2  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
0099AD  2  A2 09        	LDX	#$09			; set index
0099AF  2               LAB_288B
0099AF  2  94 A8        	STY	numexp,X		; clear byte
0099B1  2  CA           	DEX				; decrement index
0099B2  2  10 FB        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
0099B4  2               
0099B4  2  90 7F        	BCC	LAB_28FE		; branch if 1st character numeric
0099B6  2               
0099B6  2               ; get FAC1 from string .. first character wasn't numeric
0099B6  2               
0099B6  2  C9 2D        	CMP	#'-'			; else compare with "-"
0099B8  2  D0 04        	BNE	LAB_289A		; branch if not "-"
0099BA  2               
0099BA  2  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
0099BC  2  F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
0099BE  2               
0099BE  2               ; get FAC1 from string .. first character wasn't numeric or -
0099BE  2               
0099BE  2               LAB_289A
0099BE  2  C9 2B        	CMP	#'+'			; else compare with "+"
0099C0  2  D0 05        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
0099C2  2               
0099C2  2               ; was "+" or "-" to start, so get next character
0099C2  2               
0099C2  2               LAB_289C
0099C2  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0099C5  2  90 6E        	BCC	LAB_28FE		; branch if numeric character
0099C7  2               
0099C7  2               ; code here for hex and binary numbers
0099C7  2               
0099C7  2               LAB_289D
0099C7  2  C9 24        	CMP	#'$'			; else compare with "$"
0099C9  2  D0 03        	BNE	LAB_NHEX		; branch if not "$"
0099CB  2               
0099CB  2  4C 71 9E     	JMP	LAB_CHEX		; branch if "$"
0099CE  2               
0099CE  2               LAB_NHEX
0099CE  2  C9 25        	CMP	#'%'			; else compare with "%"
0099D0  2  D0 08        	BNE	LAB_28A3		; branch if not "%" (continue original code)
0099D2  2               
0099D2  2  4C 9F 9E     	JMP	LAB_CBIN		; branch if "%"
0099D5  2               
0099D5  2               LAB_289E
0099D5  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
0099D8  2               LAB_28A1
0099D8  2  90 5B        	BCC	LAB_28FE		; branch if numeric character
0099DA  2               
0099DA  2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
0099DA  2               
0099DA  2               LAB_28A3
0099DA  2  C9 2E        	CMP	#'.'			; else compare with "."
0099DC  2  F0 2E        	BEQ	LAB_28D5		; branch if "."
0099DE  2               
0099DE  2               ; get FAC1 from string .. character wasn't numeric, -, + or .
0099DE  2               
0099DE  2  C9 45        	CMP	#'E'			; else compare with "E"
0099E0  2  D0 30        	BNE	LAB_28DB		; branch if not "E"
0099E2  2               
0099E2  2               					; was "E" so evaluate exponential part
0099E2  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0099E5  2  90 17        	BCC	LAB_28C7		; branch if numeric character
0099E7  2               
0099E7  2  C9 B7        	CMP	#TK_MINUS		; else compare with token for -
0099E9  2  F0 0E        	BEQ	LAB_28C2		; branch if token for -
0099EB  2               
0099EB  2  C9 2D        	CMP	#'-'			; else compare with "-"
0099ED  2  F0 0A        	BEQ	LAB_28C2		; branch if "-"
0099EF  2               
0099EF  2  C9 B6        	CMP	#TK_PLUS		; else compare with token for +
0099F1  2  F0 08        	BEQ	LAB_28C4		; branch if token for +
0099F3  2               
0099F3  2  C9 2B        	CMP	#'+'			; else compare with "+"
0099F5  2  F0 04        	BEQ	LAB_28C4		; branch if "+"
0099F7  2               
0099F7  2  D0 07        	BNE	LAB_28C9		; branch always
0099F9  2               
0099F9  2               LAB_28C2
0099F9  2  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
0099FB  2               LAB_28C4
0099FB  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0099FE  2               LAB_28C7
0099FE  2  90 5B        	BCC	LAB_2925		; branch if numeric character
009A00  2               
009A00  2               LAB_28C9
009A00  2  24 AB        	BIT	expneg		; test exponent -ve flag
009A02  2  10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
009A04  2               
009A04  2               					; else do exponent = -exponent
009A04  2  A9 00        	LDA	#$00			; clear result
009A06  2  38           	SEC				; set carry for subtract
009A07  2  E5 A9        	SBC	expcnt		; subtract exponent byte
009A09  2  4C 14 9A     	JMP	LAB_28DD		; go evaluate exponent
009A0C  2               
009A0C  2               LAB_28D5
009A0C  2  66 AA        	ROR	numdpf		; set decimal point flag
009A0E  2  24 AA        	BIT	numdpf		; test decimal point flag
009A10  2  50 C3        	BVC	LAB_289E		; branch if only one decimal point so far
009A12  2               
009A12  2               					; evaluate exponent
009A12  2               LAB_28DB
009A12  2  A5 A9        	LDA	expcnt		; get exponent count byte
009A14  2               LAB_28DD
009A14  2  38           	SEC				; set carry for subtract
009A15  2  E5 A8        	SBC	numexp		; subtract numerator exponent
009A17  2  85 A9        	STA	expcnt		; save exponent count byte
009A19  2  F0 12        	BEQ	LAB_28F6		; branch if no adjustment
009A1B  2               
009A1B  2  10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
009A1D  2               
009A1D  2               					; else go do FAC1/10^(0-expcnt)
009A1D  2               LAB_28E6
009A1D  2  20 F3 97     	JSR	LAB_26B9		; divide by 10
009A20  2  E6 A9        	INC	expcnt		; increment exponent count byte
009A22  2  D0 F9        	BNE	LAB_28E6		; loop until all done
009A24  2               
009A24  2  F0 07        	BEQ	LAB_28F6		; branch always
009A26  2               
009A26  2               LAB_28EF
009A26  2  20 DA 97     	JSR	LAB_269E		; multiply by 10
009A29  2  C6 A9        	DEC	expcnt		; decrement exponent count byte
009A2B  2  D0 F9        	BNE	LAB_28EF		; loop until all done
009A2D  2               
009A2D  2               LAB_28F6
009A2D  2  A5 B1        	LDA	negnum		; get -ve flag
009A2F  2  30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
009A31  2               
009A31  2  60           	RTS
009A32  2               
009A32  2               ; do - FAC1 and return
009A32  2               
009A32  2               LAB_28FB
009A32  2  4C F7 9B     	JMP	LAB_GTHAN		; do - FAC1 and return
009A35  2               
009A35  2               ; do unsigned FAC1*10+number
009A35  2               
009A35  2               LAB_28FE
009A35  2  48           	PHA				; save character
009A36  2  24 AA        	BIT	numdpf		; test decimal point flag
009A38  2  10 02        	BPL	LAB_2905		; skip exponent increment if not set
009A3A  2               
009A3A  2  E6 A8        	INC	numexp		; else increment number exponent
009A3C  2               LAB_2905
009A3C  2  20 DA 97     	JSR	LAB_269E		; multiply FAC1 by 10
009A3F  2  68           	PLA				; restore character
009A40  2  29 0F        	AND	#$0F			; convert to binary
009A42  2  20 48 9A     	JSR	LAB_2912		; evaluate new ASCII digit
009A45  2  4C D5 99     	JMP	LAB_289E		; go do next character
009A48  2               
009A48  2               ; evaluate new ASCII digit
009A48  2               
009A48  2               LAB_2912
009A48  2  48           	PHA				; save digit
009A49  2  20 CD 98     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
009A4C  2  68           	PLA				; restore digit
009A4D  2  20 FD 98     	JSR	LAB_27DB		; save A as integer byte
009A50  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
009A52  2  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
009A54  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
009A56  2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
009A58  2  4C C4 95     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
009A5B  2               
009A5B  2               ; evaluate next character of exponential part of number
009A5B  2               
009A5B  2               LAB_2925
009A5B  2  A5 A9        	LDA	expcnt		; get exponent count byte
009A5D  2  C9 0A        	CMP	#$0A			; compare with 10 decimal
009A5F  2  90 09        	BCC	LAB_2934		; branch if less
009A61  2               
009A61  2  A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
009A63  2  24 AB        	BIT	expneg		; test exponent -ve flag
009A65  2  30 0E        	BMI	LAB_2942		; branch if -ve
009A67  2               
009A67  2  4C C6 96     	JMP	LAB_2564		; else do overflow error
009A6A  2               
009A6A  2               LAB_2934
009A6A  2  0A           	ASL				; * 2
009A6B  2  0A           	ASL				; * 4
009A6C  2  65 A9        	ADC	expcnt		; * 5
009A6E  2  0A           	ASL				; * 10
009A6F  2  A0 00        	LDY	#$00			; set index
009A71  2  71 C3        	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
009A73  2  E9 2F        	SBC	#'0'-1		; convert character to binary
009A75  2               LAB_2942
009A75  2  85 A9        	STA	expcnt		; save exponent count byte
009A77  2  4C FB 99     	JMP	LAB_28C4		; go get next character
009A7A  2               
009A7A  2               ; print " in line [LINE #]"
009A7A  2               
009A7A  2               LAB_2953
009A7A  2  A9 F0        	LDA	#<LAB_LMSG		; point to " in line " message low byte
009A7C  2  A0 A7        	LDY	#>LAB_LMSG		; point to " in line " message high byte
009A7E  2  20 D6 88     	JSR	LAB_18C3		; print null terminated string from memory
009A81  2               
009A81  2               					; print Basic line #
009A81  2  A5 88        	LDA	Clineh		; get current line high byte
009A83  2  A6 87        	LDX	Clinel		; get current line low byte
009A85  2               
009A85  2               ; print XA as unsigned integer
009A85  2               
009A85  2               LAB_295E
009A85  2  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
009A87  2  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
009A89  2  A2 90        	LDX	#$90			; set exponent to 16d bits
009A8B  2  38           	SEC				; set integer is +ve flag
009A8C  2  20 0A 99     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
009A8F  2  A0 00        	LDY	#$00			; clear index
009A91  2  98           	TYA				; clear A
009A92  2  20 A5 9A     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
009A95  2  4C D6 88     	JMP	LAB_18C3		; print null terminated string from memory and return
009A98  2               
009A98  2               ; convert FAC1 to ASCII string result in (AY)
009A98  2               ; not any more, moved scratchpad to page 0
009A98  2               
009A98  2               LAB_296E
009A98  2  A0 01        	LDY	#$01			; set index = 1
009A9A  2  A9 20        	LDA	#$20			; character = " " (assume +ve)
009A9C  2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
009A9E  2  10 02        	BPL	LAB_2978		; branch if +ve
009AA0  2               
009AA0  2  A9 2D        	LDA	#$2D			; else character = "-"
009AA2  2               LAB_2978
009AA2  2  99 EF 00     	STA	Decss,Y		; save leading character (" " or "-")
009AA5  2               LAB_297B
009AA5  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
009AA7  2  84 BA        	STY	Sendl			; save index
009AA9  2  C8           	INY				; increment index
009AAA  2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
009AAC  2  D0 05        	BNE	LAB_2989		; branch if FAC1<>0
009AAE  2               
009AAE  2               					; exponent was $00 so FAC1 is 0
009AAE  2  A9 30        	LDA	#'0'			; set character = "0"
009AB0  2  4C B1 9B     	JMP	LAB_2A89		; save last character, [EOT] and exit
009AB3  2               
009AB3  2               					; FAC1 is some non zero value
009AB3  2               LAB_2989
009AB3  2  A9 00        	LDA	#$00			; clear (number exponent count)
009AB5  2  E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
009AB7  2               
009AB7  2  B0 09        	BCS	LAB_299A		; branch if FAC1=>1
009AB9  2               
009AB9  2               					; FAC1<1
009AB9  2  A9 84        	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
009ABB  2  A0 A1        	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
009ABD  2  20 3C 97     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
009AC0  2  A9 FA        	LDA	#$FA			; set number exponent count (-6)
009AC2  2               LAB_299A
009AC2  2  85 A8        	STA	numexp		; save number exponent count
009AC4  2               LAB_299C
009AC4  2  A9 80        	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
009AC6  2  A0 A1        	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
009AC8  2  20 1A 99     	JSR	LAB_27F8		; compare FAC1 with (AY)
009ACB  2  F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
009ACD  2               
009ACD  2  10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
009ACF  2               
009ACF  2               					; FAC1 < (AY)
009ACF  2               LAB_29A7
009ACF  2  A9 7C        	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
009AD1  2  A0 A1        	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
009AD3  2  20 1A 99     	JSR	LAB_27F8		; compare FAC1 with (AY)
009AD6  2  F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
009AD8  2               
009AD8  2  10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
009ADA  2               
009ADA  2               					; FAC1 <= (AY)
009ADA  2               LAB_29B2
009ADA  2  20 DA 97     	JSR	LAB_269E		; multiply by 10
009ADD  2  C6 A8        	DEC	numexp		; decrement number exponent count
009ADF  2  D0 EE        	BNE	LAB_29A7		; go test again (branch always)
009AE1  2               
009AE1  2               LAB_29B9
009AE1  2  20 F3 97     	JSR	LAB_26B9		; divide by 10
009AE4  2  E6 A8        	INC	numexp		; increment number exponent count
009AE6  2  D0 DC        	BNE	LAB_299C		; go test again (branch always)
009AE8  2               
009AE8  2               ; now we have just the digits to do
009AE8  2               
009AE8  2               LAB_29C0
009AE8  2  20 BD 95     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
009AEB  2               LAB_29C3
009AEB  2  20 53 99     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
009AEE  2  A2 01        	LDX	#$01			; set default digits before dp = 1
009AF0  2  A5 A8        	LDA	numexp		; get number exponent count
009AF2  2  18           	CLC				; clear carry for add
009AF3  2  69 07        	ADC	#$07			; up to 6 digits before point
009AF5  2  30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
009AF7  2               
009AF7  2  C9 08        	CMP	#$08			; A>=8 if n>=1E6
009AF9  2  B0 06        	BCS	LAB_29D9		; branch if >= $08
009AFB  2               
009AFB  2               					; carry is clear
009AFB  2  69 FF        	ADC	#$FF			; take 1 from digit count
009AFD  2  AA           	TAX				; copy to A
009AFE  2  A9 02        	LDA	#$02			;.set exponent adjust
009B00  2               LAB_29D8
009B00  2  38           	SEC				; set carry for subtract
009B01  2               LAB_29D9
009B01  2  E9 02        	SBC	#$02			; -2
009B03  2  85 A9        	STA	expcnt		;.save exponent adjust
009B05  2  86 A8        	STX	numexp		; save digits before dp count
009B07  2  8A           	TXA				; copy to A
009B08  2  F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
009B0A  2               
009B0A  2  10 13        	BPL	LAB_29F7		; branch if digits before dp
009B0C  2               
009B0C  2               LAB_29E4
009B0C  2  A4 BA        	LDY	Sendl			; get output string index
009B0E  2  A9 2E        	LDA	#$2E			; character "."
009B10  2  C8           	INY				; increment index
009B11  2  99 EF 00     	STA	Decss,Y		; save to output string
009B14  2  8A           	TXA				;.
009B15  2  F0 06        	BEQ	LAB_29F5		;.
009B17  2               
009B17  2  A9 30        	LDA	#'0'			; character "0"
009B19  2  C8           	INY				; increment index
009B1A  2  99 EF 00     	STA	Decss,Y		; save to output string
009B1D  2               LAB_29F5
009B1D  2  84 BA        	STY	Sendl			; save output string index
009B1F  2               LAB_29F7
009B1F  2  A0 00        	LDY	#$00			; clear index (point to 100,000)
009B21  2  A2 80        	LDX	#$80			;
009B23  2               LAB_29FB
009B23  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
009B25  2  18           	CLC				; clear carry for add
009B26  2  79 FA A1     	ADC	LAB_2A9C,Y		; add -ve LSB
009B29  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
009B2B  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
009B2D  2  79 F9 A1     	ADC	LAB_2A9B,Y		; add -ve NMSB
009B30  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
009B32  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
009B34  2  79 F8 A1     	ADC	LAB_2A9A,Y		; add -ve MSB
009B37  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
009B39  2  E8           	INX				;
009B3A  2  B0 04        	BCS	LAB_2A18		;
009B3C  2               
009B3C  2  10 E5        	BPL	LAB_29FB		; not -ve so try again
009B3E  2               
009B3E  2  30 02        	BMI	LAB_2A1A		;
009B40  2               
009B40  2               LAB_2A18
009B40  2  30 E1        	BMI	LAB_29FB		;
009B42  2               
009B42  2               LAB_2A1A
009B42  2  8A           	TXA				;
009B43  2  90 04        	BCC	LAB_2A21		;
009B45  2               
009B45  2  49 FF        	EOR	#$FF			;
009B47  2  69 0A        	ADC	#$0A			;
009B49  2               LAB_2A21
009B49  2  69 2F        	ADC	#'0'-1		; add "0"-1 to result
009B4B  2  C8           	INY				; increment index ..
009B4C  2  C8           	INY				; .. to next less ..
009B4D  2  C8           	INY				; .. power of ten
009B4E  2  84 95        	STY	Cvaral		; save as current var address low byte
009B50  2  A4 BA        	LDY	Sendl			; get output string index
009B52  2  C8           	INY				; increment output string index
009B53  2  AA           	TAX				; copy character to X
009B54  2  29 7F        	AND	#$7F			; mask out top bit
009B56  2  99 EF 00     	STA	Decss,Y		; save to output string
009B59  2  C6 A8        	DEC	numexp		; decrement # of characters before the dp
009B5B  2  D0 06        	BNE	LAB_2A3B		; branch if still characters to do
009B5D  2               
009B5D  2               					; else output the point
009B5D  2  A9 2E        	LDA	#$2E			; character "."
009B5F  2  C8           	INY				; increment output string index
009B60  2  99 EF 00     	STA	Decss,Y		; save to output string
009B63  2               LAB_2A3B
009B63  2  84 BA        	STY	Sendl			; save output string index
009B65  2  A4 95        	LDY	Cvaral		; get current var address low byte
009B67  2  8A           	TXA				; get character back
009B68  2  49 FF        	EOR	#$FF			;
009B6A  2  29 80        	AND	#$80			;
009B6C  2  AA           	TAX				;
009B6D  2  C0 12        	CPY	#$12			; compare index with max
009B6F  2  D0 B2        	BNE	LAB_29FB		; loop if not max
009B71  2               
009B71  2               					; now remove trailing zeroes
009B71  2  A4 BA        	LDY	Sendl			; get output string index
009B73  2               LAB_2A4B
009B73  2  B9 EF 00     	LDA	Decss,Y		; get character from output string
009B76  2  88           	DEY				; decrement output string index
009B77  2  C9 30        	CMP	#'0'			; compare with "0"
009B79  2  F0 F8        	BEQ	LAB_2A4B		; loop until non "0" character found
009B7B  2               
009B7B  2  C9 2E        	CMP	#'.'			; compare with "."
009B7D  2  F0 01        	BEQ	LAB_2A58		; branch if was dp
009B7F  2               
009B7F  2               					; restore last character
009B7F  2  C8           	INY				; increment output string index
009B80  2               LAB_2A58
009B80  2  A9 2B        	LDA	#$2B			; character "+"
009B82  2  A6 A9        	LDX	expcnt		; get exponent count
009B84  2  F0 2E        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
009B86  2               
009B86  2               					; exponent isn't zero so write exponent
009B86  2  10 08        	BPL	LAB_2A68		; branch if exponent count +ve
009B88  2               
009B88  2  A9 00        	LDA	#$00			; clear A
009B8A  2  38           	SEC				; set carry for subtract
009B8B  2  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
009B8D  2  AA           	TAX				; copy exponent count to X
009B8E  2  A9 2D        	LDA	#'-'			; character "-"
009B90  2               LAB_2A68
009B90  2  99 F1 00     	STA	Decss+2,Y		; save to output string
009B93  2  A9 45        	LDA	#$45			; character "E"
009B95  2  99 F0 00     	STA	Decss+1,Y		; save exponent sign to output string
009B98  2  8A           	TXA				; get exponent count back
009B99  2  A2 2F        	LDX	#'0'-1		; one less than "0" character
009B9B  2  38           	SEC				; set carry for subtract
009B9C  2               LAB_2A74
009B9C  2  E8           	INX				; increment 10's character
009B9D  2  E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
009B9F  2  B0 FB        	BCS	LAB_2A74		; loop while still >= 0
009BA1  2               
009BA1  2  69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
009BA3  2  99 F3 00     	STA	Decss+4,Y		; save to output string
009BA6  2  8A           	TXA				; copy 10's character
009BA7  2  99 F2 00     	STA	Decss+3,Y		; save to output string
009BAA  2  A9 00        	LDA	#$00			; set null terminator
009BAC  2  99 F4 00     	STA	Decss+5,Y		; save to output string
009BAF  2  F0 08        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
009BB1  2               
009BB1  2               					; save last character, [EOT] and exit
009BB1  2               LAB_2A89
009BB1  2  99 EF 00     	STA	Decss,Y		; save last character to output string
009BB4  2               
009BB4  2               					; set null terminator and exit
009BB4  2               LAB_2A8C
009BB4  2  A9 00        	LDA	#$00			; set null terminator
009BB6  2  99 F0 00     	STA	Decss+1,Y		; save after last character
009BB9  2               
009BB9  2               					; set string pointer (AY) and exit
009BB9  2               LAB_2A91
009BB9  2  A9 F0        	LDA	#<Decssp1		; set result string low pointer
009BBB  2  A0 00        	LDY	#>Decssp1		; set result string high pointer
009BBD  2  60           	RTS
009BBE  2               
009BBE  2               ; perform power function
009BBE  2               
009BBE  2               LAB_POWER
009BBE  2  F0 42        	BEQ	LAB_EXP		; go do  EXP()
009BC0  2               
009BC0  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
009BC2  2  D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
009BC4  2               
009BC4  2  4C 55 96     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
009BC7  2               
009BC7  2               LAB_2ABF
009BC7  2  A2 9C        	LDX	#<func_l		; set destination pointer low byte
009BC9  2  A0 00        	LDY	#>func_l		; set destination pointer high byte
009BCB  2  20 AA 98     	JSR	LAB_2778		; pack FAC1 into (XY)
009BCE  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
009BD0  2  10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
009BD2  2               
009BD2  2               					; else FAC2 is -ve and can only be raised to an
009BD2  2               					; integer power which gives an x +j0 result
009BD2  2  20 84 99     	JSR	LAB_INT		; perform INT
009BD5  2  A9 9C        	LDA	#<func_l		; set source pointer low byte
009BD7  2  A0 00        	LDY	#>func_l		; set source pointer high byte
009BD9  2  20 1A 99     	JSR	LAB_27F8		; compare FAC1 with (AY)
009BDC  2  D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
009BDE  2               					; this will leave FAC1 -ve and cause a Function Call
009BDE  2               					; error when LOG() is called
009BDE  2               
009BDE  2  98           	TYA				; clear sign b7
009BDF  2  A4 5B        	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
009BE1  2               					; for possible later negation, b0
009BE1  2               LAB_2AD9
009BE1  2  20 C8 95     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
009BE4  2  98           	TYA				; copy sign back ..
009BE5  2  48           	PHA				; .. and save it
009BE6  2  20 FE 96     	JSR	LAB_LOG		; do LOG(n)
009BE9  2  A9 9C        	LDA	#<garb_l		; set pointer low byte
009BEB  2  A0 00        	LDY	#>garb_l		; set pointer high byte
009BED  2  20 3C 97     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
009BF0  2  20 02 9C     	JSR	LAB_EXP		; go do EXP(n)
009BF3  2  68           	PLA				; pull sign from stack
009BF4  2  4A           	LSR				; b0 is to be tested, shift to Cb
009BF5  2  90 0A        	BCC	LAB_2AF9		; if no bit then exit
009BF7  2               
009BF7  2               					; Perform negation
009BF7  2               ; do - FAC1
009BF7  2               
009BF7  2               LAB_GTHAN
009BF7  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009BF9  2  F0 06        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
009BFB  2               
009BFB  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
009BFD  2  49 FF        	EOR	#$FF			; complement it
009BFF  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
009C01  2               LAB_2AF9
009C01  2  60           	RTS
009C02  2               
009C02  2               ; perform EXP()	(x^e)
009C02  2               
009C02  2               LAB_EXP
009C02  2  A9 88        	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
009C04  2  A0 A1        	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
009C06  2  20 3C 97     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
009C09  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
009C0B  2  69 50        	ADC	#$50			; +$50/$100
009C0D  2  90 03        	BCC	LAB_2B2B		; skip rounding if no carry
009C0F  2               
009C0F  2  20 E4 98     	JSR	LAB_27C2		; round FAC1 (no check)
009C12  2               LAB_2B2B
009C12  2  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
009C14  2  20 D0 98     	JSR	LAB_27AE		; copy FAC1 to FAC2
009C17  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009C19  2  C9 88        	CMP	#$88			; compare with EXP limit (256d)
009C1B  2  90 03        	BCC	LAB_2B39		; branch if less
009C1D  2               
009C1D  2               LAB_2B36
009C1D  2  20 D1 97     	JSR	LAB_2690		; handle overflow and underflow
009C20  2               LAB_2B39
009C20  2  20 84 99     	JSR	LAB_INT		; perform INT
009C23  2  A5 5B        	LDA	Temp3			; get mantissa 3 from INT() function
009C25  2  18           	CLC				; clear carry for add
009C26  2  69 81        	ADC	#$81			; normalise +1
009C28  2  F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
009C2A  2               
009C2A  2  38           	SEC				; set carry for subtract
009C2B  2  E9 01        	SBC	#$01			; now correct for exponent
009C2D  2  48           	PHA				; save FAC2 exponent
009C2E  2               
009C2E  2               					; swap FAC1 and FAC2
009C2E  2  A2 04        	LDX	#$04			; 4 bytes to do
009C30  2               LAB_2B49
009C30  2  B5 B3        	LDA	FAC2_e,X		; get FAC2,X
009C32  2  B4 AC        	LDY	FAC1_e,X		; get FAC1,X
009C34  2  95 AC        	STA	FAC1_e,X		; save FAC1,X
009C36  2  94 B3        	STY	FAC2_e,X		; save FAC2,X
009C38  2  CA           	DEX				; decrement count/index
009C39  2  10 F5        	BPL	LAB_2B49		; loop if not all done
009C3B  2               
009C3B  2  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
009C3D  2  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
009C3F  2  20 A9 95     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
009C42  2  20 F7 9B     	JSR	LAB_GTHAN		; do - FAC1
009C45  2  A9 8C        	LDA	#<LAB_2AFE		; set counter pointer low byte
009C47  2  A0 A1        	LDY	#>LAB_2AFE		; set counter pointer high byte
009C49  2  20 6A 9C     	JSR	LAB_2B84		; go do series evaluation
009C4C  2  A9 00        	LDA	#$00			; clear A
009C4E  2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
009C50  2  68           	PLA				;.get saved FAC2 exponent
009C51  2  4C B6 97     	JMP	LAB_2675		; test and adjust accumulators and return
009C54  2               
009C54  2               ; ^2 then series evaluation
009C54  2               
009C54  2               LAB_2B6E
009C54  2  85 BA        	STA	Cptrl			; save count pointer low byte
009C56  2  84 BB        	STY	Cptrh			; save count pointer high byte
009C58  2  20 A0 98     	JSR	LAB_276E		; pack FAC1 into Adatal
009C5B  2  A9 A4        	LDA	#<Adatal		; set pointer low byte (Y already $00)
009C5D  2  20 3C 97     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
009C60  2  20 6E 9C     	JSR	LAB_2B88		; go do series evaluation
009C63  2  A9 A4        	LDA	#<Adatal		; pointer to original # low byte
009C65  2  A0 00        	LDY	#>Adatal		; pointer to original # high byte
009C67  2  4C 3C 97     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
009C6A  2               
009C6A  2               ; series evaluation
009C6A  2               
009C6A  2               LAB_2B84
009C6A  2  85 BA        	STA	Cptrl			; save count pointer low byte
009C6C  2  84 BB        	STY	Cptrh			; save count pointer high byte
009C6E  2               LAB_2B88
009C6E  2  A2 A8        	LDX	#<numexp		; set pointer low byte
009C70  2  20 A2 98     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
009C73  2  B1 BA        	LDA	(Cptrl),Y		; get constants count
009C75  2  85 B1        	STA	numcon		; save constants count
009C77  2  A4 BA        	LDY	Cptrl			; get count pointer low byte
009C79  2  C8           	INY				; increment it (now constants pointer)
009C7A  2  98           	TYA				; copy it
009C7B  2  D0 02        	BNE	LAB_2B97		; skip next if no overflow
009C7D  2               
009C7D  2  E6 BB        	INC	Cptrh			; else increment high byte
009C7F  2               LAB_2B97
009C7F  2  85 BA        	STA	Cptrl			; save low byte
009C81  2  A4 BB        	LDY	Cptrh			; get high byte
009C83  2               LAB_2B9B
009C83  2  20 3C 97     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
009C86  2  A5 BA        	LDA	Cptrl			; get constants pointer low byte
009C88  2  A4 BB        	LDY	Cptrh			; get constants pointer high byte
009C8A  2  18           	CLC				; clear carry for add
009C8B  2  69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
009C8D  2  90 01        	BCC	LAB_2BA8		; skip next if no overflow
009C8F  2               
009C8F  2  C8           	INY				; increment high byte
009C90  2               LAB_2BA8
009C90  2  85 BA        	STA	Cptrl			; save pointer low byte
009C92  2  84 BB        	STY	Cptrh			; save pointer high byte
009C94  2  20 C1 95     	JSR	LAB_246C		; add (AY) to FAC1
009C97  2  A9 A8        	LDA	#<numexp		; set pointer low byte to partial @ numexp
009C99  2  A0 00        	LDY	#>numexp		; set pointer high byte to partial @ numexp
009C9B  2  C6 B1        	DEC	numcon		; decrement constants count
009C9D  2  D0 E4        	BNE	LAB_2B9B		; loop until all done
009C9F  2               
009C9F  2  60           	RTS
009CA0  2               
009CA0  2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
009CA0  2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
009CA0  2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
009CA0  2               
009CA0  2               ; Entropy = 7.997442 bits per byte
009CA0  2               ; Optimum compression would reduce these 65536 bytes by 0 percent
009CA0  2               
009CA0  2               ; Chi square distribution for 65536 samples is 232.01, and
009CA0  2               ; randomly would exceed this value 75.00 percent of the time
009CA0  2               
009CA0  2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
009CA0  2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
009CA0  2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
009CA0  2               
009CA0  2               LAB_RND
009CA0  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009CA2  2  F0 07        	BEQ	NextPRN		; do next random # if zero
009CA4  2               
009CA4  2               					; else get seed into random number store
009CA4  2  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
009CA6  2  A0 00        	LDY	#$00			; set PRNG pointer high byte
009CA8  2  20 AA 98     	JSR	LAB_2778		; pack FAC1 into (XY)
009CAB  2               NextPRN
009CAB  2  A2 AF        	LDX	#$AF			; set EOR byte
009CAD  2  A0 13        	LDY	#$13			; do this nineteen times
009CAF  2               LoopPRN
009CAF  2  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
009CB1  2  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
009CB3  2  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
009CB5  2  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
009CB7  2  90 05        	BCC	Ninc1			; branch if bit 32 clear
009CB9  2               
009CB9  2  8A           	TXA				; set EOR byte
009CBA  2  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
009CBC  2  85 D9        	STA	Rbyte1		; save new PRNG extra byte
009CBE  2               Ninc1
009CBE  2  88           	DEY				; decrement loop count
009CBF  2  D0 EE        	BNE	LoopPRN		; loop if not all done
009CC1  2               
009CC1  2  A2 02        	LDX	#$02			; three bytes to copy
009CC3  2               CopyPRNG
009CC3  2  B5 D9        	LDA	Rbyte1,X		; get PRNG byte
009CC5  2  95 AD        	STA	FAC1_1,X		; save FAC1 byte
009CC7  2  CA           	DEX
009CC8  2  10 F9        	BPL	CopyPRNG		; loop if not complete
009CCA  2               
009CCA  2  A9 80        	LDA	#$80			; set the exponent
009CCC  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
009CCE  2               
009CCE  2  0A           	ASL				; clear A
009CCF  2  85 B0        	STA	FAC1_s		; save FAC1 sign
009CD1  2               
009CD1  2  4C 37 96     	JMP	LAB_24D5		; normalise FAC1 and return
009CD4  2               
009CD4  2               ; perform COS()
009CD4  2               
009CD4  2               LAB_COS
009CD4  2  A9 A9        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
009CD6  2  A0 A1        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
009CD8  2  20 C1 95     	JSR	LAB_246C		; add (AY) to FAC1
009CDB  2               
009CDB  2               ; perform SIN()
009CDB  2               
009CDB  2               LAB_SIN
009CDB  2  20 CD 98     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
009CDE  2  A9 BE        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
009CE0  2  A0 A1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
009CE2  2  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
009CE4  2  20 FC 97     	JSR	LAB_26C2		; divide by (AY) (X=sign)
009CE7  2  20 CD 98     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
009CEA  2  20 84 99     	JSR	LAB_INT		; perform INT
009CED  2  A9 00        	LDA	#$00			; clear byte
009CEF  2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
009CF1  2  20 A9 95     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
009CF4  2  A9 F0        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
009CF6  2  A0 A1        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
009CF8  2  20 A6 95     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
009CFB  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
009CFD  2  48           	PHA				; save FAC1 sign
009CFE  2  10 0D        	BPL	LAB_2C35		; branch if +ve
009D00  2               
009D00  2               					; FAC1 sign was -ve
009D00  2  20 BD 95     	JSR	LAB_244E		; add 0.5 to FAC1
009D03  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
009D05  2  30 09        	BMI	LAB_2C38		; branch if -ve
009D07  2               
009D07  2  A5 63        	LDA	Cflag			; get comparison evaluation flag
009D09  2  49 FF        	EOR	#$FF			; toggle flag
009D0B  2  85 63        	STA	Cflag			; save comparison evaluation flag
009D0D  2               LAB_2C35
009D0D  2  20 F7 9B     	JSR	LAB_GTHAN		; do - FAC1
009D10  2               LAB_2C38
009D10  2  A9 F0        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
009D12  2  A0 A1        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
009D14  2  20 C1 95     	JSR	LAB_246C		; add (AY) to FAC1
009D17  2  68           	PLA				; restore FAC1 sign
009D18  2  10 03        	BPL	LAB_2C45		; branch if was +ve
009D1A  2               
009D1A  2               					; else correct FAC1
009D1A  2  20 F7 9B     	JSR	LAB_GTHAN		; do - FAC1
009D1D  2               LAB_2C45
009D1D  2  A9 AD        	LDA	#<LAB_2C84		; set pointer low byte to counter
009D1F  2  A0 A1        	LDY	#>LAB_2C84		; set pointer high byte to counter
009D21  2  4C 54 9C     	JMP	LAB_2B6E		; ^2 then series evaluation and return
009D24  2               
009D24  2               ; perform TAN()
009D24  2               
009D24  2               LAB_TAN
009D24  2  20 A0 98     	JSR	LAB_276E		; pack FAC1 into Adatal
009D27  2  A9 00        	LDA	#$00			; clear byte
009D29  2  85 63        	STA	Cflag			; clear comparison evaluation flag
009D2B  2  20 DB 9C     	JSR	LAB_SIN		; go do SIN(n)
009D2E  2  A2 9C        	LDX	#<func_l		; set sin(n) pointer low byte
009D30  2  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
009D32  2  20 AA 98     	JSR	LAB_2778		; pack FAC1 into (XY)
009D35  2  A9 A4        	LDA	#<Adatal		; set n pointer low addr
009D37  2  A0 00        	LDY	#>Adatal		; set n pointer high addr
009D39  2  20 80 98     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
009D3C  2  A9 00        	LDA	#$00			; clear byte
009D3E  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
009D40  2  A5 63        	LDA	Cflag			; get comparison evaluation flag
009D42  2  20 4C 9D     	JSR	LAB_2C74		; save flag and go do series evaluation
009D45  2               
009D45  2  A9 9C        	LDA	#<func_l		; set sin(n) pointer low byte
009D47  2  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
009D49  2  4C 04 98     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
009D4C  2               
009D4C  2               LAB_2C74
009D4C  2  48           	PHA				; save comparison evaluation flag
009D4D  2  4C 0D 9D     	JMP	LAB_2C35		; go do series evaluation
009D50  2               
009D50  2               ; perform USR()
009D50  2               
009D50  2               LAB_USR
009D50  2  20 0A 00     	JSR	Usrjmp		; call user code
009D53  2  4C F2 8B     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
009D56  2               
009D56  2               ; perform ATN()
009D56  2               
009D56  2               LAB_ATN
009D56  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
009D58  2  48           	PHA				; save sign
009D59  2  10 03        	BPL	LAB_2CA1		; branch if +ve
009D5B  2               
009D5B  2  20 F7 9B     	JSR	LAB_GTHAN		; else do - FAC1
009D5E  2               LAB_2CA1
009D5E  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009D60  2  48           	PHA				; push exponent
009D61  2  C9 81        	CMP	#$81			; compare with 1
009D63  2  90 07        	BCC	LAB_2CAF		; branch if FAC1<1
009D65  2               
009D65  2  A9 E3        	LDA	#<LAB_259C		; set 1 pointer low byte
009D67  2  A0 A1        	LDY	#>LAB_259C		; set 1 pointer high byte
009D69  2  20 04 98     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
009D6C  2               LAB_2CAF
009D6C  2  A9 C2        	LDA	#<LAB_2CC9		; set pointer low byte to counter
009D6E  2  A0 A1        	LDY	#>LAB_2CC9		; set pointer high byte to counter
009D70  2  20 54 9C     	JSR	LAB_2B6E		; ^2 then series evaluation
009D73  2  68           	PLA				; restore old FAC1 exponent
009D74  2  C9 81        	CMP	#$81			; compare with 1
009D76  2  90 07        	BCC	LAB_2CC2		; branch if FAC1<1
009D78  2               
009D78  2  A9 A9        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
009D7A  2  A0 A1        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
009D7C  2  20 A6 95     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
009D7F  2               LAB_2CC2
009D7F  2  68           	PLA				; restore FAC1 sign
009D80  2  10 16        	BPL	LAB_2D04		; exit if was +ve
009D82  2               
009D82  2  4C F7 9B     	JMP	LAB_GTHAN		; else do - FAC1 and return
009D85  2               
009D85  2               ; perform BITSET
009D85  2               
009D85  2               LAB_BITSET
009D85  2  20 DB 94     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
009D88  2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
009D8A  2  B0 20        	BCS	FCError		; branch if > 7
009D8C  2               
009D8C  2  A9 00        	LDA	#$00			; clear A
009D8E  2  38           	SEC				; set the carry
009D8F  2               S_Bits
009D8F  2  2A           	ROL				; shift bit
009D90  2  CA           	DEX				; decrement bit number
009D91  2  10 FC        	BPL	S_Bits		; loop if still +ve
009D93  2               
009D93  2  E8           	INX				; make X = $00
009D94  2  01 11        	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
009D96  2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
009D98  2               LAB_2D04
009D98  2  60           	RTS
009D99  2               
009D99  2               ; perform BITCLR
009D99  2               
009D99  2               LAB_BITCLR
009D99  2  20 DB 94     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
009D9C  2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
009D9E  2  B0 0C        	BCS	FCError		; branch if > 7
009DA0  2               
009DA0  2  A9 FF        	LDA	#$FF			; set A
009DA2  2               S_Bitc
009DA2  2  2A           	ROL				; shift bit
009DA3  2  CA           	DEX				; decrement bit number
009DA4  2  10 FC        	BPL	S_Bitc		; loop if still +ve
009DA6  2               
009DA6  2  E8           	INX				; make X = $00
009DA7  2  21 11        	AND	(Itempl,X)		; and with byte via temporary integer (addr)
009DA9  2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
009DAB  2  60           	RTS
009DAC  2               
009DAC  2               FCError
009DAC  2  4C 2C 8F     	JMP	LAB_FCER		; do function call error then warm start
009DAF  2               
009DAF  2               ; perform BITTST()
009DAF  2               
009DAF  2               LAB_BTST
009DAF  2  20 BC 00     	JSR	LAB_IGBY		; increment BASIC pointer
009DB2  2  20 DB 94     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
009DB5  2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
009DB7  2  B0 F3        	BCS	FCError		; branch if > 7
009DB9  2               
009DB9  2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
009DBC  2  C9 29        	CMP	#')'			; is next character ")"
009DBE  2  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
009DC0  2               
009DC0  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
009DC3  2               
009DC3  2               TST_OK
009DC3  2  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
009DC6  2  A9 00        	LDA	#$00			; clear A
009DC8  2  38           	SEC				; set the carry
009DC9  2               T_Bits
009DC9  2  2A           	ROL				; shift bit
009DCA  2  CA           	DEX				; decrement bit number
009DCB  2  10 FC        	BPL	T_Bits		; loop if still +ve
009DCD  2               
009DCD  2  E8           	INX				; make X = $00
009DCE  2  21 11        	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
009DD0  2  F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
009DD2  2               
009DD2  2  A9 FF        	LDA	#$FF			; set for -1 result
009DD4  2               LAB_NOTT
009DD4  2  4C FD 98     	JMP	LAB_27DB		; go do SGN tail
009DD7  2               
009DD7  2               ; perform BIN$()
009DD7  2               
009DD7  2               LAB_BINS
009DD7  2  E0 19        	CPX	#$19			; max + 1
009DD9  2  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
009DDB  2               
009DDB  2  86 78        	STX	TempB			; save # of characters ($00 = leading zero remove)
009DDD  2  A9 18        	LDA	#$18			; need A byte long space
009DDF  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long
009DE2  2  A0 17        	LDY	#$17			; set index
009DE4  2  A2 18        	LDX	#$18			; character count
009DE6  2               NextB1
009DE6  2  46 11        	LSR	nums_1		; shift highest byte
009DE8  2  66 12        	ROR	nums_2		; shift middle byte
009DEA  2  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
009DEC  2  8A           	TXA				; load with "0"/2
009DED  2  2A           	ROL				; shift in carry
009DEE  2  91 AD        	STA	(str_pl),Y		; save to temp string + index
009DF0  2  88           	DEY				; decrement index
009DF1  2  10 F3        	BPL	NextB1		; loop if not done
009DF3  2               
009DF3  2  A5 78        	LDA	TempB			; get # of characters
009DF5  2  F0 0A        	BEQ	EndBHS		; branch if truncate
009DF7  2               
009DF7  2  AA           	TAX				; copy length to X
009DF8  2  38           	SEC				; set carry for add !
009DF9  2  49 FF        	EOR	#$FF			; 1's complement
009DFB  2  69 18        	ADC	#$18			; add 24d
009DFD  2  F0 1C        	BEQ	GoPr2			; if zero print whole string
009DFF  2               
009DFF  2  D0 0F        	BNE	GoPr1			; else go make output string
009E01  2               
009E01  2               ; this is the exit code and is also used by HEX$()
009E01  2               ; truncate string to remove leading "0"s
009E01  2               
009E01  2               EndBHS
009E01  2  A8           	TAY				; clear index (A=0, X=length here)
009E02  2               NextB2
009E02  2  B1 AD        	LDA	(str_pl),Y		; get character from string
009E04  2  C9 30        	CMP	#'0'			; compare with "0"
009E06  2  D0 07        	BNE	GoPr			; if not "0" then go print string from here
009E08  2               
009E08  2  CA           	DEX				; decrement character count
009E09  2  F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
009E0B  2               
009E0B  2  C8           	INY				; else increment index
009E0C  2  10 F4        	BPL	NextB2		; loop always
009E0E  2               
009E0E  2               ; make fixed length output string - ignore overflows!
009E0E  2               
009E0E  2               GoPr3
009E0E  2  E8           	INX				; need at least 1 character
009E0F  2               GoPr
009E0F  2  98           	TYA				; copy result
009E10  2               GoPr1
009E10  2  18           	CLC				; clear carry for add
009E11  2  65 AD        	ADC	str_pl		; add low address
009E13  2  85 AD        	STA	str_pl		; save low address
009E15  2  A9 00        	LDA	#$00			; do high byte
009E17  2  65 AE        	ADC	str_ph		; add high address
009E19  2  85 AE        	STA	str_ph		; save high address
009E1B  2               GoPr2
009E1B  2  86 AC        	STX	str_ln		; X holds string length
009E1D  2  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
009E20  2  4C 88 91     	JMP	LAB_RTST		; check for space on descriptor stack then put address
009E23  2               					; and length on descriptor stack and update stack pointers
009E23  2               
009E23  2               BinFErr
009E23  2  4C 2C 8F     	JMP	LAB_FCER		; do function call error then warm start
009E26  2               
009E26  2               ; perform HEX$()
009E26  2               
009E26  2               LAB_HEXS
009E26  2  E0 07        	CPX	#$07			; max + 1
009E28  2  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
009E2A  2               
009E2A  2  86 78        	STX	TempB			; save # of characters
009E2C  2               
009E2C  2  A9 06        	LDA	#$06			; need 6 bytes for string
009E2E  2  20 3D 91     	JSR	LAB_MSSP		; make string space A bytes long
009E31  2  A0 05        	LDY	#$05			; set string index
009E33  2               
009E33  2  F8           	SED				; need decimal mode for nibble convert
009E34  2  A5 13        	LDA	nums_3		; get lowest byte
009E36  2  20 54 9E     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
009E39  2  A5 12        	LDA	nums_2		; get middle byte
009E3B  2  20 54 9E     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
009E3E  2  A5 11        	LDA	nums_1		; get highest byte
009E40  2  20 54 9E     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
009E43  2  D8           	CLD				; back to binary
009E44  2               
009E44  2  A2 06        	LDX	#$06			; character count
009E46  2  A5 78        	LDA	TempB			; get # of characters
009E48  2  F0 B7        	BEQ	EndBHS		; branch if truncate
009E4A  2               
009E4A  2  AA           	TAX				; copy length to X
009E4B  2  38           	SEC				; set carry for add !
009E4C  2  49 FF        	EOR	#$FF			; 1's complement
009E4E  2  69 06        	ADC	#$06			; add 6d
009E50  2  F0 C9        	BEQ	GoPr2			; if zero print whole string
009E52  2               
009E52  2  D0 BC        	BNE	GoPr1			; else go make output string (branch always)
009E54  2               
009E54  2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
009E54  2               
009E54  2               LAB_A2HX
009E54  2  AA           	TAX				; save byte
009E55  2  29 0F        	AND	#$0F			; mask off top bits
009E57  2  20 5F 9E     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
009E5A  2  8A           	TXA				; get byte back
009E5B  2  4A           	LSR				; /2	shift high nibble to low nibble
009E5C  2  4A           	LSR				; /4
009E5D  2  4A           	LSR				; /8
009E5E  2  4A           	LSR				; /16
009E5F  2               LAB_AL2X
009E5F  2  C9 0A        	CMP	#$0A			; set carry for +1 if >9
009E61  2  69 30        	ADC	#'0'			; add ASCII "0"
009E63  2  91 AD        	STA	(str_pl),Y		; save to temp string
009E65  2  88           	DEY				; decrement counter
009E66  2  60           	RTS
009E67  2               
009E67  2               LAB_NLTO
009E67  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
009E69  2  A9 00        	LDA	#$00			; clear sign compare
009E6B  2               LAB_MLTE
009E6B  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
009E6D  2  8A           	TXA				; restore character
009E6E  2  20 48 9A     	JSR	LAB_2912		; evaluate new ASCII digit
009E71  2               
009E71  2               ; gets here if the first character was "$" for hex
009E71  2               ; get hex number
009E71  2               
009E71  2               LAB_CHEX
009E71  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
009E74  2  90 0A        	BCC	LAB_ISHN		; branch if numeric character
009E76  2               
009E76  2  09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
009E78  2  E9 61        	SBC	#'a'			; subtract "a" (carry set here)
009E7A  2  C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
009E7C  2  B0 2A        	BCS	LAB_EXCH		; exit if >"f" or <"0"
009E7E  2               
009E7E  2  69 0A        	ADC	#$0A			; convert to nibble
009E80  2               LAB_ISHN
009E80  2  29 0F        	AND	#$0F			; convert to binary
009E82  2  AA           	TAX				; save nibble
009E83  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009E85  2  F0 E4        	BEQ	LAB_MLTE		; skip multiply if zero
009E87  2               
009E87  2  69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
009E89  2  90 DC        	BCC	LAB_NLTO		; if no overflow do evaluate digit
009E8B  2               
009E8B  2               LAB_MLTO
009E8B  2  4C C6 96     	JMP	LAB_2564		; do overflow error and warm start
009E8E  2               
009E8E  2               LAB_NXCH
009E8E  2  AA           	TAX				; save bit
009E8F  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009E91  2  F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
009E93  2               
009E93  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
009E95  2  F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
009E97  2               
009E97  2  A9 00        	LDA	#$00			; clear sign compare
009E99  2               LAB_MLBT
009E99  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
009E9B  2  8A           	TXA				; restore bit
009E9C  2  20 48 9A     	JSR	LAB_2912		; evaluate new ASCII digit
009E9F  2               
009E9F  2               ; gets here if the first character was  "%" for binary
009E9F  2               ; get binary number
009E9F  2               
009E9F  2               LAB_CBIN
009E9F  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
009EA2  2  49 30        	EOR	#'0'			; convert "0" to 0 etc.
009EA4  2  C9 02        	CMP	#$02			; compare with max+1
009EA6  2  90 E6        	BCC	LAB_NXCH		; branch exit if < 2
009EA8  2               
009EA8  2               LAB_EXCH
009EA8  2  4C 2D 9A     	JMP	LAB_28F6		; evaluate -ve flag and return
009EAB  2               
009EAB  2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
009EAB  2               ; now also the code that checks to see if an interrupt has occurred
009EAB  2               
009EAB  2               CTRLC
009EAB  2  AD 00 03     	LDA	ccflag		; get [CTRL-C] check flag
009EAE  2  D0 18        	BNE	LAB_FBA2		; exit if inhibited
009EB0  2               
009EB0  2  20 ED A0     	JSR	V_INPT		; scan input device
009EB3  2  90 0B        	BCC	LAB_FBA0		; exit if buffer empty
009EB5  2               
009EB5  2  8D 01 03     	STA	ccbyte		; save received byte
009EB8  2  A2 20        	LDX	#$20			; "life" timer for bytes
009EBA  2  8E 02 03     	STX	ccnull		; set countdown
009EBD  2  4C 1A 85     	JMP	LAB_1636		; return to BASIC
009EC0  2               
009EC0  2               LAB_FBA0
009EC0  2  AE 02 03     	LDX	ccnull		; get countdown byte
009EC3  2  F0 03        	BEQ	LAB_FBA2		; exit if finished
009EC5  2               
009EC5  2  CE 02 03     	DEC	ccnull		; else decrement countdown
009EC8  2               LAB_FBA2
009EC8  2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
009ECA  2  20 D3 9E     	JSR	LAB_CKIN		; go check interrupt
009ECD  2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
009ECF  2  20 D3 9E     	JSR	LAB_CKIN		; go check interrupt
009ED2  2               LAB_CRTS
009ED2  2  60           	RTS
009ED3  2               
009ED3  2               ; check whichever interrupt is indexed by X
009ED3  2               
009ED3  2               LAB_CKIN
009ED3  2  B5 00        	LDA	PLUS_0,X		; get interrupt flag byte
009ED5  2  10 FB        	BPL	LAB_CRTS		; branch if interrupt not enabled
009ED7  2               
009ED7  2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
009ED7  2               ; automatically enable the interrupt when we exit
009ED7  2               
009ED7  2  0A           	ASL				; move happened bit to setup bit
009ED8  2  29 40        	AND	#$40			; mask happened bits
009EDA  2  F0 F6        	BEQ	LAB_CRTS		; if no interrupt then exit
009EDC  2               
009EDC  2  95 00        	STA	PLUS_0,X		; save interrupt flag byte
009EDE  2               
009EDE  2  8A           	TXA				; copy index ..
009EDF  2  A8           	TAY				; .. to Y
009EE0  2               
009EE0  2  68           	PLA				; dump return address low byte, call from CTRL-C
009EE1  2  68           	PLA				; dump return address high byte
009EE2  2               
009EE2  2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
009EE4  2  20 06 81     	JSR	LAB_1212		; check room on stack for A bytes
009EE7  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
009EE9  2  48           	PHA				; push on stack
009EEA  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
009EEC  2  48           	PHA				; push on stack
009EED  2  A5 88        	LDA	Clineh		; get current line high byte
009EEF  2  48           	PHA				; push on stack
009EF0  2  A5 87        	LDA	Clinel		; get current line low byte
009EF2  2  48           	PHA				; push on stack
009EF3  2  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
009EF5  2  48           	PHA				; push on stack
009EF6  2               
009EF6  2  B9 01 00     	LDA	PLUS_1,Y		; get interrupt code pointer low byte
009EF9  2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
009EFB  2  B9 02 00     	LDA	PLUS_2,Y		; get interrupt code pointer high byte
009EFE  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
009F00  2               
009F00  2  4C BF 84     	JMP	LAB_15C2		; go do interpreter inner loop
009F03  2               					; can't RTS, we used the stack! the RTS from the ctrl-c
009F03  2               					; check will be taken when the RETIRQ/RETNMI/RETURN is
009F03  2               					; executed at the end of the subroutine
009F03  2               
009F03  2               ; get byte from input device, no waiting
009F03  2               ; returns with carry set if byte in A
009F03  2               
009F03  2               INGET
009F03  2  20 ED A0     	JSR	V_INPT		; call scan input device
009F06  2  B0 09        	BCS	LAB_FB95		; if byte go reset timer
009F08  2               
009F08  2  AD 02 03     	LDA	ccnull		; get countdown
009F0B  2  F0 09        	BEQ	LAB_FB96		; exit if empty
009F0D  2               
009F0D  2  AD 01 03     	LDA	ccbyte		; get last received byte
009F10  2  38           	SEC				; flag we got a byte
009F11  2               LAB_FB95
009F11  2  A2 00        	LDX	#$00			; clear X
009F13  2  8E 02 03     	STX	ccnull		; clear timer because we got a byte
009F16  2               LAB_FB96
009F16  2  60           	RTS
009F17  2               
009F17  2               ; these routines only enable the interrupts if the set-up flag is set
009F17  2               ; if not they have no effect
009F17  2               
009F17  2               ; perform IRQ {ON|OFF|CLEAR}
009F17  2               
009F17  2               LAB_IRQ
009F17  2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
009F19  2  2C           	.byte	$2C			; make next line BIT abs.
009F1A  2               
009F1A  2               ; perform NMI {ON|OFF|CLEAR}
009F1A  2               
009F1A  2               LAB_NMI
009F1A  2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
009F1C  2  C9 93        	CMP	#TK_ON		; compare with token for ON
009F1E  2  F0 11        	BEQ	LAB_INON		; go turn on interrupt
009F20  2               
009F20  2  C9 B5        	CMP	#TK_OFF		; compare with token for OFF
009F22  2  F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
009F24  2               
009F24  2  49 A2        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
009F26  2  F0 0E        	BEQ	LAB_INEX		; go clear interrupt flags and return
009F28  2               
009F28  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
009F2B  2               
009F2B  2               LAB_IOFF
009F2B  2  A9 7F        	LDA	#$7F			; clear A
009F2D  2  35 00        	AND	PLUS_0,X		; AND with interrupt setup flag
009F2F  2  10 05        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
009F31  2               
009F31  2               LAB_INON
009F31  2  B5 00        	LDA	PLUS_0,X		; get interrupt setup flag
009F33  2  0A           	ASL				; Shift bit to enabled flag
009F34  2  15 00        	ORA	PLUS_0,X		; OR with flag byte
009F36  2               LAB_INEX
009F36  2  95 00        	STA	PLUS_0,X		; save interrupt flag byte
009F38  2  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
009F3B  2               
009F3B  2               ; these routines set up the pointers and flags for the interrupt routines
009F3B  2               ; note that the interrupts are also enabled by these commands
009F3B  2               
009F3B  2               ; perform ON IRQ
009F3B  2               
009F3B  2               LAB_SIRQ
009F3B  2  58           	CLI				; enable interrupts
009F3C  2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
009F3E  2  2C           	.byte	$2C			; make next line BIT abs.
009F3F  2               
009F3F  2               ; perform ON NMI
009F3F  2               
009F3F  2               LAB_SNMI
009F3F  2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
009F41  2               
009F41  2  86 78        	STX	TempB			; save interrupt pointer
009F43  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (past token)
009F46  2  20 58 87     	JSR	LAB_GFPN		; get fixed-point number into temp integer
009F49  2  A5 79        	LDA	Smeml			; get start of mem low byte
009F4B  2  A6 7A        	LDX	Smemh			; get start of mem high byte
009F4D  2  20 2B 83     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
009F50  2  B0 03        	BCS	LAB_LFND		; if carry set go set-up interrupt
009F52  2               
009F52  2  4C 75 86     	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
009F55  2               
009F55  2               LAB_LFND
009F55  2  A6 78        	LDX	TempB			; get interrupt pointer
009F57  2  A5 AA        	LDA	Baslnl		; get pointer low byte
009F59  2  E9 01        	SBC	#$01			; -1 (carry already set for subtract)
009F5B  2  95 01        	STA	PLUS_1,X		; save as interrupt pointer low byte
009F5D  2  A5 AB        	LDA	Baslnh		; get pointer high byte
009F5F  2  E9 00        	SBC	#$00			; subtract carry
009F61  2  95 02        	STA	PLUS_2,X		; save as interrupt pointer high byte
009F63  2               
009F63  2  A9 C0        	LDA	#$C0			; set interrupt enabled/setup bits
009F65  2  95 00        	STA	PLUS_0,X		; set interrupt flags
009F67  2               LAB_IRTS
009F67  2  60           	RTS
009F68  2               
009F68  2               ; return from IRQ service, restores the enabled flag.
009F68  2               
009F68  2               ; perform RETIRQ
009F68  2               
009F68  2               LAB_RETIRQ
009F68  2  D0 FD        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
009F6A  2               
009F6A  2  A5 DF        	LDA	IrqBase		; get interrupt flags
009F6C  2  0A           	ASL				; copy setup to enabled (b7)
009F6D  2  05 DF        	ORA	IrqBase		; OR in setup flag
009F6F  2  85 DF        	STA	IrqBase		; save enabled flag
009F71  2  4C 7C 86     	JMP	LAB_16E8		; go do rest of RETURN
009F74  2               
009F74  2               ; return from NMI service, restores the enabled flag.
009F74  2               
009F74  2               ; perform RETNMI
009F74  2               
009F74  2               LAB_RETNMI
009F74  2  D0 F1        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
009F76  2               
009F76  2  A5 DC        	LDA	NmiBase		; get set-up flag
009F78  2  0A           	ASL				; copy setup to enabled (b7)
009F79  2  05 DC        	ORA	NmiBase		; OR in setup flag
009F7B  2  85 DC        	STA	NmiBase		; save enabled flag
009F7D  2  4C 7C 86     	JMP	LAB_16E8		; go do rest of RETURN
009F80  2               
009F80  2               ; MAX() MIN() pre process
009F80  2               
009F80  2               LAB_MMPP
009F80  2  20 EC 8A     	JSR	LAB_EVEZ		; process expression
009F83  2  4C D3 8A     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
009F86  2               
009F86  2               ; perform MAX()
009F86  2               
009F86  2               LAB_MAX
009F86  2  20 B4 9F     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
009F89  2               					; pull FAC2 and compare with FAC1
009F89  2  10 FB        	BPL	LAB_MAX		; branch if no swap to do
009F8B  2               
009F8B  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
009F8D  2  09 80        	ORA	#$80			; set top bit (clear sign from compare)
009F8F  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
009F91  2  20 C6 95     	JSR	LAB_279B		; copy FAC2 to FAC1
009F94  2  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
009F96  2               
009F96  2               ; perform MIN()
009F96  2               
009F96  2               LAB_MIN
009F96  2  20 B4 9F     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
009F99  2               					; pull FAC2 and compare with FAC1
009F99  2  30 FB        	BMI	LAB_MIN		; branch if no swap to do
009F9B  2               
009F9B  2  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
009F9D  2               
009F9D  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
009F9F  2  09 80        	ORA	#$80			; set top bit (clear sign from compare)
009FA1  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
009FA3  2  20 C6 95     	JSR	LAB_279B		; copy FAC2 to FAC1
009FA6  2  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
009FA8  2               
009FA8  2               ; exit routine. don't bother returning to the loop code
009FA8  2               ; check for correct exit, else so syntax error
009FA8  2               
009FA8  2               LAB_MMEC
009FA8  2  C9 29        	CMP	#')'			; is it end of function?
009FAA  2  D0 05        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
009FAC  2               
009FAC  2  68           	PLA				; dump return address low byte
009FAD  2  68           	PLA				; dump return address high byte
009FAE  2  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
009FB1  2               
009FB1  2               LAB_MMSE
009FB1  2  4C 05 8C     	JMP	LAB_SNER		; do syntax error then warm start
009FB4  2               
009FB4  2               ; check for next, evaluate and return or exit
009FB4  2               ; this is the routine that does most of the work
009FB4  2               
009FB4  2               LAB_PHFA
009FB4  2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
009FB7  2  C9 2C        	CMP	#','			; is there more ?
009FB9  2  D0 ED        	BNE	LAB_MMEC		; if not go do end check
009FBB  2               
009FBB  2               					; push FAC1
009FBB  2  20 DC 98     	JSR	LAB_27BA		; round FAC1
009FBE  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
009FC0  2  09 7F        	ORA	#$7F			; set all non sign bits
009FC2  2  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
009FC4  2  48           	PHA				; push on stack
009FC5  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
009FC7  2  48           	PHA				; push on stack
009FC8  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
009FCA  2  48           	PHA				; push on stack
009FCB  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
009FCD  2  48           	PHA				; push on stack
009FCE  2               
009FCE  2  20 BC 00     	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
009FD1  2  20 D0 8A     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
009FD4  2               					; else do type mismatch
009FD4  2               
009FD4  2               					; pop FAC2 (MAX/MIN expression so far)
009FD4  2  68           	PLA				; pop exponent
009FD5  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
009FD7  2  68           	PLA				; pop mantissa3
009FD8  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
009FDA  2  68           	PLA				; pop mantissa1
009FDB  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
009FDD  2  68           	PLA				; pop sign/mantissa1
009FDE  2  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
009FE0  2  85 B7        	STA	FAC2_s		; save FAC2 sign
009FE2  2               
009FE2  2               					; compare FAC1 with (packed) FAC2
009FE2  2  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
009FE4  2  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
009FE6  2  4C 1A 99     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
009FE9  2               					; returns A=$00 if FAC1 = (AY)
009FE9  2               					; returns A=$01 if FAC1 > (AY)
009FE9  2               					; returns A=$FF if FAC1 < (AY)
009FE9  2               
009FE9  2               ; perform WIDTH
009FE9  2               
009FE9  2               LAB_WDTH
009FE9  2  C9 2C        	CMP	#','			; is next byte ","
009FEB  2  F0 1B        	BEQ	LAB_TBSZ		; if so do tab size
009FED  2               
009FED  2  20 8F 94     	JSR	LAB_GTBY		; get byte parameter
009FF0  2  8A           	TXA				; copy width to A
009FF1  2  F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
009FF3  2               
009FF3  2  E0 10        	CPX	#$10			; else make min width = 16d
009FF5  2  90 45        	BCC	TabErr		; if less do function call error and exit
009FF7  2               
009FF7  2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
009FF7  2               ; tab size greater than the line length.
009FF7  2               
009FF7  2  E4 64        	CPX	TabSiz		; compare with tab size
009FF9  2  B0 02        	BCS	LAB_NSTT		; branch if >= tab size
009FFB  2               
009FFB  2  86 64        	STX	TabSiz		; else make tab size = terminal width
009FFD  2               LAB_NSTT
009FFD  2  86 0F        	STX	TWidth		; set the terminal width
009FFF  2  20 C2 00     	JSR	LAB_GBYT		; get BASIC byte back
00A002  2  F0 1A        	BEQ	WExit			; exit if no following
00A004  2               
00A004  2  C9 2C        	CMP	#','			; else is it ","
00A006  2  D0 A9        	BNE	LAB_MMSE		; if not do syntax error
00A008  2               
00A008  2               LAB_TBSZ
00A008  2  20 8C 94     	JSR	LAB_SGBY		; scan and get byte parameter
00A00B  2  8A           	TXA				; copy TAB size
00A00C  2  30 2E        	BMI	TabErr		; if >127 do function call error and exit
00A00E  2               
00A00E  2  E0 01        	CPX	#$01			; compare with min-1
00A010  2  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
00A012  2               
00A012  2  A5 0F        	LDA	TWidth		; set flags for width
00A014  2  F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
00A016  2               
00A016  2  E4 0F        	CPX	TWidth		; compare TAB with width
00A018  2  F0 02        	BEQ	LAB_SVTB		; ok if =
00A01A  2               
00A01A  2  B0 20        	BCS	TabErr		; branch if too big
00A01C  2               
00A01C  2               LAB_SVTB
00A01C  2  86 64        	STX	TabSiz		; save TAB size
00A01E  2               
00A01E  2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00A01E  2               ; position on a line that still has at least one whole tab width between it
00A01E  2               ; and the end of the line.
00A01E  2               
00A01E  2               WExit
00A01E  2  A5 0F        	LDA	TWidth		; get width
00A020  2  F0 06        	BEQ	LAB_SULP		; branch if infinite line
00A022  2               
00A022  2  C5 64        	CMP	TabSiz		; compare with tab size
00A024  2  B0 03        	BCS	LAB_WDLP		; branch if >= tab size
00A026  2               
00A026  2  85 64        	STA	TabSiz		; else make tab size = terminal width
00A028  2               LAB_SULP
00A028  2  38           	SEC				; set carry for subtract
00A029  2               LAB_WDLP
00A029  2  E5 64        	SBC	TabSiz		; subtract tab size
00A02B  2  B0 FC        	BCS	LAB_WDLP		; loop while no borrow
00A02D  2               
00A02D  2  65 64        	ADC	TabSiz		; add tab size back
00A02F  2  18           	CLC				; clear carry for add
00A030  2  65 64        	ADC	TabSiz		; add tab size back again
00A032  2  85 10        	STA	Iclim			; save for now
00A034  2  A5 0F        	LDA	TWidth		; get width back
00A036  2  38           	SEC				; set carry for subtract
00A037  2  E5 10        	SBC	Iclim			; subtract remainder
00A039  2  85 10        	STA	Iclim			; save tab column limit
00A03B  2               LAB_NOSQ
00A03B  2  60           	RTS
00A03C  2               
00A03C  2               TabErr
00A03C  2  4C 2C 8F     	JMP	LAB_FCER		; do function call error then warm start
00A03F  2               
00A03F  2               ; perform SQR()
00A03F  2               
00A03F  2               LAB_SQR
00A03F  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00A041  2  30 F9        	BMI	TabErr		; if -ve do function call error
00A043  2               
00A043  2  A5 AC        	LDA	FAC1_e		; get exponent
00A045  2  F0 F4        	BEQ	LAB_NOSQ		; if zero just return
00A047  2               
00A047  2               					; else do root
00A047  2  20 CD 98     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00A04A  2  A9 00        	LDA	#$00			; clear A
00A04C  2               
00A04C  2  85 77        	STA	FACt_3		; clear remainder
00A04E  2  85 76        	STA	FACt_2		; ..
00A050  2  85 75        	STA	FACt_1		; ..
00A052  2  85 78        	STA	TempB			; ..
00A054  2               
00A054  2  85 AF        	STA	FAC1_3		; clear root
00A056  2  85 AE        	STA	FAC1_2		; ..
00A058  2  85 AD        	STA	FAC1_1		; ..
00A05A  2               
00A05A  2  A2 18        	LDX	#$18			; 24 pairs of bits to do
00A05C  2  A5 B3        	LDA	FAC2_e		; get exponent
00A05E  2  4A           	LSR				; check odd/even
00A05F  2  B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
00A061  2               
00A061  2               LAB_SQE1
00A061  2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00A063  2  26 B5        	ROL	FAC2_2		; ..
00A065  2  26 B4        	ROL	FAC2_1		; ..
00A067  2  26 77        	ROL	FACt_3		; .. into remainder
00A069  2  26 76        	ROL	FACt_2		; ..
00A06B  2  26 75        	ROL	FACt_1		; ..
00A06D  2  26 78        	ROL	TempB			; .. never overflows
00A06F  2               LAB_SQE2
00A06F  2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00A071  2  26 B5        	ROL	FAC2_2		; ..
00A073  2  26 B4        	ROL	FAC2_1		; ..
00A075  2  26 77        	ROL	FACt_3		; .. into remainder
00A077  2  26 76        	ROL	FACt_2		; ..
00A079  2  26 75        	ROL	FACt_1		; ..
00A07B  2  26 78        	ROL	TempB			; .. never overflows
00A07D  2               
00A07D  2  06 AF        	ASL	FAC1_3		; root = root * 2
00A07F  2  26 AE        	ROL	FAC1_2		; ..
00A081  2  26 AD        	ROL	FAC1_1		; .. never overflows
00A083  2               
00A083  2  A5 AF        	LDA	FAC1_3		; get root low byte
00A085  2  2A           	ROL				; *2
00A086  2  85 5B        	STA	Temp3			; save partial low byte
00A088  2  A5 AE        	LDA	FAC1_2		; get root low mid byte
00A08A  2  2A           	ROL				; *2
00A08B  2  85 5C        	STA	Temp3+1		; save partial low mid byte
00A08D  2  A5 AD        	LDA	FAC1_1		; get root high mid byte
00A08F  2  2A           	ROL				; *2
00A090  2  85 5D        	STA	Temp3+2		; save partial high mid byte
00A092  2  A9 00        	LDA	#$00			; get root high byte (always $00)
00A094  2  2A           	ROL				; *2
00A095  2  85 5E        	STA	Temp3+3		; save partial high byte
00A097  2               
00A097  2               					; carry clear for subtract +1
00A097  2  A5 77        	LDA	FACt_3		; get remainder low byte
00A099  2  E5 5B        	SBC	Temp3			; subtract partial low byte
00A09B  2  85 5B        	STA	Temp3			; save partial low byte
00A09D  2               
00A09D  2  A5 76        	LDA	FACt_2		; get remainder low mid byte
00A09F  2  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
00A0A1  2  85 5C        	STA	Temp3+1		; save partial low mid byte
00A0A3  2               
00A0A3  2  A5 75        	LDA	FACt_1		; get remainder high mid byte
00A0A5  2  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
00A0A7  2  A8           	TAY				; copy partial high mid byte
00A0A8  2               
00A0A8  2  A5 78        	LDA	TempB			; get remainder high byte
00A0AA  2  E5 5E        	SBC	Temp3+3		; subtract partial high byte
00A0AC  2  90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
00A0AE  2               
00A0AE  2  85 78        	STA	TempB			; save remainder high byte
00A0B0  2               
00A0B0  2  84 75        	STY	FACt_1		; save remainder high mid byte
00A0B2  2               
00A0B2  2  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
00A0B4  2  85 76        	STA	FACt_2		; save remainder low mid byte
00A0B6  2               
00A0B6  2  A5 5B        	LDA	Temp3			; get partial low byte
00A0B8  2  85 77        	STA	FACt_3		; save remainder low byte
00A0BA  2               
00A0BA  2  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
00A0BC  2               LAB_SQNS
00A0BC  2  CA           	DEX				; decrement bit pair count
00A0BD  2  D0 A2        	BNE	LAB_SQE1		; loop if not all done
00A0BF  2               
00A0BF  2  38           	SEC				; set carry for subtract
00A0C0  2  A5 B3        	LDA	FAC2_e		; get exponent
00A0C2  2  E9 80        	SBC	#$80			; normalise
00A0C4  2  6A           	ROR				; /2 and re-bias to $80
00A0C5  2  69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
00A0C7  2  85 AC        	STA	FAC1_e		; save it
00A0C9  2  4C 37 96     	JMP	LAB_24D5		; normalise FAC1 and return
00A0CC  2               
00A0CC  2               ; perform VARPTR()
00A0CC  2               
00A0CC  2               LAB_VARPTR
00A0CC  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00A0CF  2  20 AD 8D     	JSR	LAB_GVAR		; get var address
00A0D2  2  20 F2 8B     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
00A0D5  2  A4 95        	LDY	Cvaral		; get var address low byte
00A0D7  2  A5 96        	LDA	Cvarah		; get var address high byte
00A0D9  2  4C 5C 90     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00A0DC  2               
00A0DC  2               ; perform PI
00A0DC  2               
00A0DC  2               LAB_PI
00A0DC  2  A9 BE        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
00A0DE  2  A0 A1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
00A0E0  2  20 80 98     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00A0E3  2  C6 AC        	DEC	FAC1_e		; make result = PI
00A0E5  2  60           	RTS
00A0E6  2               
00A0E6  2               ; perform TWOPI
00A0E6  2               
00A0E6  2               LAB_TWOPI
00A0E6  2  A9 BE        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
00A0E8  2  A0 A1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
00A0EA  2  4C 80 98     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
00A0ED  2               
00A0ED  2               ; system dependant i/o vectors
00A0ED  2               ; these are in RAM and are set by the monitor at start-up
00A0ED  2               
00A0ED  2               V_INPT
00A0ED  2  6C 05 03     	JMP	(VEC_IN)		; non halting scan input device
00A0F0  2               V_OUTP
00A0F0  2  6C 07 03     	JMP	(VEC_OUT)		; send byte to output device
00A0F3  2               V_LOAD
00A0F3  2  6C 09 03     	JMP	(VEC_LD)		; load BASIC program
00A0F6  2               V_SAVE
00A0F6  2  6C 0B 03     	JMP	(VEC_SV)		; save BASIC program
00A0F9  2               
00A0F9  2               ; The rest are tables messages and code for RAM
00A0F9  2               
00A0F9  2               ; the rest of the code is tables and BASIC start-up code
00A0F9  2               
00A0F9  2               PG2_TABS
00A0F9  2  00           	.byte	$00			; ctrl-c flag		-	$00 = enabled
00A0FA  2  00           	.byte	$00			; ctrl-c byte		-	GET needs this
00A0FB  2  00           	.byte	$00			; ctrl-c byte timeout	-	GET needs this
00A0FC  2  AB 9E        	.word	CTRLC			; ctrl c check vector
00A0FE  2               ;	.word	xxxx			; non halting key input	-	monitor to set this
00A0FE  2               ;	.word	xxxx			; output vector		-	monitor to set this
00A0FE  2               ;	.word	xxxx			; load vector		-	monitor to set this
00A0FE  2               ;	.word	xxxx			; save vector		-	monitor to set this
00A0FE  2               PG2_TABE
00A0FE  2               
00A0FE  2               ; character get subroutine for zero page
00A0FE  2               
00A0FE  2               ; For a 1.8432MHz 6502 including the JSR and RTS
00A0FE  2               ; fastest (>=":")	=  29 cycles =  15.7uS
00A0FE  2               ; slowest (<":")	=  40 cycles =  21.7uS
00A0FE  2               ; space skip	= +21 cycles = +11.4uS
00A0FE  2               ; inc across page	=  +4 cycles =  +2.2uS
00A0FE  2               
00A0FE  2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00A0FE  2               ; block is copied to it's destination, any non zero page address will do at assembly
00A0FE  2               ; time, to assemble a three byte instruction.
00A0FE  2               
00A0FE  2               ; page 0 initialisation table from $BC
00A0FE  2               ; increment and scan memory
00A0FE  2               
00A0FE  2               LAB_2CEE
00A0FE  2  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
00A100  2  D0 02        	BNE	LAB_2CF4		; branch if no carry
00A102  2               					; else
00A102  2  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
00A104  2               
00A104  2               ; page 0 initialisation table from $C2
00A104  2               ; scan memory
00A104  2               
00A104  2               LAB_2CF4
00A104  2  AD FF FF     	LDA	$FFFF			; get byte to scan (addr set by call routine)
00A107  2  C9 AC        	CMP	#TK_ELSE		; compare with the token for ELSE
00A109  2  F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
00A10B  2               
00A10B  2  C9 3A        	CMP	#':'			; compare with ":"
00A10D  2  B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
00A10F  2               
00A10F  2  C9 20        	CMP	#' '			; compare with " "
00A111  2  F0 EB        	BEQ	LAB_2CEE		; if " " go do next
00A113  2               
00A113  2  38           	SEC				; set carry for SBC
00A114  2  E9 30        	SBC	#'0'			; subtract "0"
00A116  2  38           	SEC				; set carry for SBC
00A117  2  E9 D0        	SBC	#$D0			; subtract -"0"
00A119  2               					; clear carry if byte = "0"-"9"
00A119  2               LAB_2D05
00A119  2  60           	RTS
00A11A  2               
00A11A  2               ; page zero initialisation table $00-$12 inclusive
00A11A  2               
00A11A  2               StrTab
00A11A  2  4C           	.byte	$4C			; JMP opcode
00A11B  2  03 80        	.word LAB_COLD		; initial warm start vector (cold start)
00A11D  2               
00A11D  2  00           	.byte	$00			; these bytes are not used by BASIC
00A11E  2  00 00        	.word	$0000			;
00A120  2  00 00        	.word	$0000			;
00A122  2  00 00        	.word	$0000			;
00A124  2               
00A124  2  4C           	.byte	$4C			; JMP opcode
00A125  2  2C 8F        	.word	LAB_FCER		; initial user function vector ("Function call" error)
00A127  2  00           	.byte	$00			; default NULL count
00A128  2  00           	.byte	$00			; clear terminal position
00A129  2  00           	.byte	$00			; default terminal width byte
00A12A  2  F2           	.byte	$F2			; default limit for TAB = 14
00A12B  2  00 05        	.word	Ram_base		; start of user RAM
00A12D  2               EndTab
00A12D  2               
00A12D  2               LAB_MSZM
00A12D  2  0D 0A 4D 65  	.byte	$0D,$0A,"Memory size ",$00
00A131  2  6D 6F 72 79  
00A135  2  20 73 69 7A  
00A13C  2               
00A13C  2               LAB_SMSG
00A13C  2  20 42 79 74  	.byte	" Bytes free",$0D,$0A,$0A
00A140  2  65 73 20 66  
00A144  2  72 65 65 0D  
00A14A  2  45 6E 68 61  	.byte	"Enhanced BASIC 2.22",$0A,$00
00A14E  2  6E 63 65 64  
00A152  2  20 42 41 53  
00A15F  2               
00A15F  2               ; numeric constants and series
00A15F  2               
00A15F  2               					; constants and series for LOG(n)
00A15F  2               LAB_25A0
00A15F  2  02           	.byte	$02			; counter
00A160  2  80 19 56 62  	.byte	$80,$19,$56,$62	; 0.59898
00A164  2  80 76 22 F3  	.byte	$80,$76,$22,$F3	; 0.96147
00A168  2               ;##	.byte	$80,$76,$22,$F1	; 0.96147
00A168  2  82 38 AA 40  	.byte	$82,$38,$AA,$40	; 2.88539
00A16C  2               ;##	.byte	$82,$38,$AA,$45	; 2.88539
00A16C  2               
00A16C  2               LAB_25AD
00A16C  2  80 35 04 F3  	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
00A170  2               LAB_25B1
00A170  2  81 35 04 F3  	.byte	$81,$35,$04,$F3	; 1.41421	root 2
00A174  2               LAB_25B5
00A174  2  80 80 00 00  	.byte	$80,$80,$00,$00	; -0.5
00A178  2               LAB_25B9
00A178  2  80 31 72 18  	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
00A17C  2               
00A17C  2               					; numeric PRINT constants
00A17C  2               LAB_2947
00A17C  2  91 43 4F F8  	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
00A180  2               LAB_294B
00A180  2  94 74 23 F7  	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
00A184  2               LAB_294F
00A184  2  94 74 24 00  	.byte	$94,$74,$24,$00	; 1000000
00A188  2               
00A188  2               					; EXP(n) constants and series
00A188  2               LAB_2AFA
00A188  2  81 38 AA 3B  	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
00A18C  2               LAB_2AFE
00A18C  2  06           	.byte	$06			; counter
00A18D  2  74 63 90 8C  	.byte	$74,$63,$90,$8C	; 2.17023e-4
00A191  2  77 23 0C AB  	.byte	$77,$23,$0C,$AB	; 0.00124
00A195  2  7A 1E 94 00  	.byte	$7A,$1E,$94,$00	; 0.00968
00A199  2  7C 63 42 80  	.byte	$7C,$63,$42,$80	; 0.05548
00A19D  2  7E 75 FE D0  	.byte	$7E,$75,$FE,$D0	; 0.24023
00A1A1  2  80 31 72 15  	.byte	$80,$31,$72,$15	; 0.69315
00A1A5  2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.00000
00A1A9  2               
00A1A9  2               ;##	.byte	$07			; counter
00A1A9  2               ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
00A1A9  2               ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
00A1A9  2               ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
00A1A9  2               ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
00A1A9  2               ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
00A1A9  2               ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
00A1A9  2               ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
00A1A9  2               ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
00A1A9  2               
00A1A9  2               					; trigonometric constants and series
00A1A9  2               LAB_2C78
00A1A9  2  81 49 0F DB  	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
00A1AD  2               LAB_2C84
00A1AD  2  04           	.byte	$04			; counter
00A1AE  2  86 1E D7 FB  	.byte	$86,$1E,$D7,$FB	; 39.7109
00A1B2  2               ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
00A1B2  2  87 99 26 65  	.byte	$87,$99,$26,$65	;-76.575
00A1B6  2               ;##	.byte	$87,$99,$26,$64	;-76.575
00A1B6  2  87 23 34 58  	.byte	$87,$23,$34,$58	; 81.6022
00A1BA  2  86 A5 5D E1  	.byte	$86,$A5,$5D,$E1	;-41.3417
00A1BE  2               ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
00A1BE  2               LAB_2C7C
00A1BE  2  83 49 0F DB  	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
00A1C2  2               ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
00A1C2  2               
00A1C2  2               LAB_2CC9
00A1C2  2  08           	.byte	$08			; counter
00A1C3  2  78 3A C5 37  	.byte	$78,$3A,$C5,$37	; 0.00285
00A1C7  2  7B 83 A2 5C  	.byte	$7B,$83,$A2,$5C	;-0.0160686
00A1CB  2  7C 2E DD 4D  	.byte	$7C,$2E,$DD,$4D	; 0.0426915
00A1CF  2  7D 99 B0 1E  	.byte	$7D,$99,$B0,$1E	;-0.0750429
00A1D3  2  7D 59 ED 24  	.byte	$7D,$59,$ED,$24	; 0.106409
00A1D7  2  7E 91 72 00  	.byte	$7E,$91,$72,$00	;-0.142036
00A1DB  2  7E 4C B9 73  	.byte	$7E,$4C,$B9,$73	; 0.199926
00A1DF  2  7F AA AA 53  	.byte	$7F,$AA,$AA,$53	;-0.333331
00A1E3  2               
00A1E3  2               ;##	.byte	$08			; counter
00A1E3  2               ;##	.byte	$78,$3B,$D7,$4A	; 1/17
00A1E3  2               ;##	.byte	$7B,$84,$6E,$02	;-1/15
00A1E3  2               ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
00A1E3  2               ;##	.byte	$7D,$9A,$31,$74	;-1/11
00A1E3  2               ;##	.byte	$7D,$5A,$3D,$84	; 1/9
00A1E3  2               ;##	.byte	$7E,$91,$7F,$C8	;-1/7
00A1E3  2               ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
00A1E3  2               ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
00A1E3  2               
00A1E3  2               LAB_1D96	= *+1			; $00,$00 used for undefined variables
00A1E3  2               LAB_259C
00A1E3  2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.000000, used for INC
00A1E7  2               LAB_2AFD
00A1E7  2  81 80 00 00  	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
00A1EB  2               
00A1EB  2               					; misc constants
00A1EB  2               LAB_1DF7
00A1EB  2  90           	.byte	$90			;-32768 (uses first three bytes from 0.5)
00A1EC  2               LAB_2A96
00A1EC  2  80 00 00 00  	.byte	$80,$00,$00,$00	; 0.5
00A1F0  2               LAB_2C80
00A1F0  2  7F 00 00 00  	.byte	$7F,$00,$00,$00	; 0.25
00A1F4  2               LAB_26B5
00A1F4  2  84 20 00 00  	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
00A1F8  2               
00A1F8  2               ; This table is used in converting numbers to ASCII.
00A1F8  2               
00A1F8  2               LAB_2A9A
00A1F8  2               LAB_2A9B = LAB_2A9A+1
00A1F8  2               LAB_2A9C = LAB_2A9B+1
00A1F8  2  FE 79 60     	.byte	$FE,$79,$60		; -100000
00A1FB  2  00 27 10     	.byte	$00,$27,$10		; 10000
00A1FE  2  FF FC 18     	.byte	$FF,$FC,$18		; -1000
00A201  2  00 00 64     	.byte	$00,$00,$64		; 100
00A204  2  FF FF F6     	.byte	$FF,$FF,$F6		; -10
00A207  2  00 00 01     	.byte	$00,$00,$01		; 1
00A20A  2               
00A20A  2               LAB_CTBL
00A20A  2  1D 85        	.word	LAB_END-1		; END
00A20C  2  5A 84        	.word	LAB_FOR-1		; FOR
00A20E  2  67 8A        	.word	LAB_NEXT-1		; NEXT
00A210  2  8E 86        	.word	LAB_DATA-1		; DATA
00A212  2  49 89        	.word	LAB_INPUT-1		; INPUT
00A214  2  61 8D        	.word	LAB_DIM-1		; DIM
00A216  2  69 89        	.word	LAB_READ-1		; READ
00A218  2  B6 87        	.word	LAB_LET-1		; LET
00A21A  2  88 87        	.word	LAB_DEC-1		; DEC			new command
00A21C  2  ED 85        	.word	LAB_GOTO-1		; GOTO
00A21E  2  AC 85        	.word	LAB_RUN-1		; RUN
00A220  2  BC 86        	.word	LAB_IF-1		; IF
00A222  2  44 85        	.word	LAB_RESTORE-1	; RESTORE		modified command
00A224  2  D0 85        	.word	LAB_GOSUB-1		; GOSUB
00A226  2  67 9F        	.word	LAB_RETIRQ-1	; RETIRQ		new command
00A228  2  73 9F        	.word	LAB_RETNMI-1	; RETNMI		new command
00A22A  2  79 86        	.word	LAB_RETURN-1	; RETURN
00A22C  2  20 87        	.word	LAB_REM-1		; REM
00A22E  2  1B 85        	.word	LAB_STOP-1		; STOP
00A230  2  29 87        	.word	LAB_ON-1		; ON			modified command
00A232  2  82 85        	.word	LAB_NULL-1		; NULL		modified command
00A234  2  8B 87        	.word	LAB_INC-1		; INC			new command
00A236  2  8B 95        	.word	LAB_WAIT-1		; WAIT
00A238  2  F2 A0        	.word	V_LOAD-1		; LOAD
00A23A  2  F5 A0        	.word	V_SAVE-1		; SAVE
00A23C  2  76 90        	.word	LAB_DEF-1		; DEF
00A23E  2  10 95        	.word	LAB_POKE-1		; POKE
00A240  2  2C 95        	.word	LAB_DOKE-1		; DOKE		new command
00A242  2  79 95        	.word	LAB_CALL-1		; CALL		new command
00A244  2  B6 85        	.word	LAB_DO-1		; DO			new command
00A246  2  1F 86        	.word	LAB_LOOP-1		; LOOP		new command
00A248  2  57 88        	.word	LAB_PRINT-1		; PRINT
00A24A  2  88 85        	.word	LAB_CONT-1		; CONT
00A24C  2  A5 83        	.word	LAB_LIST-1		; LIST
00A24E  2  A2 83        	.word	LAB_CLEAR-1		; CLEAR
00A250  2  50 83        	.word	LAB_NEW-1		; NEW
00A252  2  E8 9F        	.word	LAB_WDTH-1		; WIDTH		new command
00A254  2  26 88        	.word	LAB_GET-1		; GET			new command
00A256  2  51 95        	.word	LAB_SWAP-1		; SWAP		new command
00A258  2  84 9D        	.word	LAB_BITSET-1	; BITSET		new command
00A25A  2  98 9D        	.word	LAB_BITCLR-1	; BITCLR		new command
00A25C  2  16 9F        	.word	LAB_IRQ-1		; IRQ			new command
00A25E  2  19 9F        	.word	LAB_NMI-1		; NMI			new command
00A260  2               
00A260  2               ; function pre process routine table
00A260  2               
00A260  2               LAB_FTPL
00A260  2               LAB_FTPM	= LAB_FTPL+$01
00A260  2  67 8C        	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
00A262  2  67 8C        	.word	LAB_PPFN-1		; INT(n)		"
00A264  2  67 8C        	.word	LAB_PPFN-1		; ABS(n)		"
00A266  2  EB 8A        	.word	LAB_EVEZ-1		; USR(x)	process any expression
00A268  2  EE 8B        	.word	LAB_1BF7-1		; FRE(x)		"
00A26A  2  EE 8B        	.word	LAB_1BF7-1		; POS(x)		"
00A26C  2  67 8C        	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
00A26E  2  67 8C        	.word	LAB_PPFN-1		; RND(n)		"
00A270  2  67 8C        	.word	LAB_PPFN-1		; LOG(n)		"
00A272  2  67 8C        	.word	LAB_PPFN-1		; EXP(n)		"
00A274  2  67 8C        	.word	LAB_PPFN-1		; COS(n)		"
00A276  2  67 8C        	.word	LAB_PPFN-1		; SIN(n)		"
00A278  2  67 8C        	.word	LAB_PPFN-1		; TAN(n)		"
00A27A  2  67 8C        	.word	LAB_PPFN-1		; ATN(n)		"
00A27C  2  67 8C        	.word	LAB_PPFN-1		; PEEK(n)		"
00A27E  2  67 8C        	.word	LAB_PPFN-1		; DEEK(n)		"
00A280  2  00 00        	.word	$0000			; SADD()	none
00A282  2  61 8C        	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
00A284  2  67 8C        	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
00A286  2  61 8C        	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
00A288  2  61 8C        	.word	LAB_PPFS-1		; ASC($)		"
00A28A  2  61 8C        	.word	LAB_PPFS-1		; UCASE$($)		"
00A28C  2  61 8C        	.word	LAB_PPFS-1		; LCASE$($)		"
00A28E  2  67 8C        	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
00A290  2  8E 8C        	.word	LAB_BHSS-1		; HEX$(n)		"
00A292  2  8E 8C        	.word	LAB_BHSS-1		; BIN$(n)		"
00A294  2  00 00        	.word	$0000			; BITTST()	none
00A296  2  7F 9F        	.word	LAB_MMPP-1		; MAX()	process numeric expression
00A298  2  7F 9F        	.word	LAB_MMPP-1		; MIN()		"
00A29A  2  6D 8C        	.word	LAB_PPBI-1		; PI		advance pointer
00A29C  2  6D 8C        	.word	LAB_PPBI-1		; TWOPI		"
00A29E  2  00 00        	.word	$0000			; VARPTR()	none
00A2A0  2  72 8C        	.word	LAB_LRMS-1		; LEFT$()	process string expression
00A2A2  2  72 8C        	.word	LAB_LRMS-1		; RIGHT$()		"
00A2A4  2  72 8C        	.word	LAB_LRMS-1		; MID$()		"
00A2A6  2               
00A2A6  2               ; action addresses for functions
00A2A6  2               
00A2A6  2               LAB_FTBL
00A2A6  2               LAB_FTBM	= LAB_FTBL+$01
00A2A6  2  F9 98        	.word	LAB_SGN-1		; SGN()
00A2A8  2  83 99        	.word	LAB_INT-1		; INT()
00A2AA  2  16 99        	.word	LAB_ABS-1		; ABS()
00A2AC  2  4F 9D        	.word	LAB_USR-1		; USR()
00A2AE  2  47 90        	.word	LAB_FRE-1		; FRE()
00A2B0  2  66 90        	.word	LAB_POS-1		; POS()
00A2B2  2  3E A0        	.word	LAB_SQR-1		; SQR()
00A2B4  2  9F 9C        	.word	LAB_RND-1		; RND()		modified function
00A2B6  2  FD 96        	.word	LAB_LOG-1		; LOG()
00A2B8  2  01 9C        	.word	LAB_EXP-1		; EXP()
00A2BA  2  D3 9C        	.word	LAB_COS-1		; COS()
00A2BC  2  DA 9C        	.word	LAB_SIN-1		; SIN()
00A2BE  2  23 9D        	.word	LAB_TAN-1		; TAN()
00A2C0  2  55 9D        	.word	LAB_ATN-1		; ATN()
00A2C2  2  05 95        	.word	LAB_PEEK-1		; PEEK()
00A2C4  2  19 95        	.word	LAB_DEEK-1		; DEEK()		new function
00A2C6  2  57 94        	.word	LAB_SADD-1		; SADD()		new function
00A2C8  2  70 94        	.word	LAB_LENS-1		; LEN()
00A2CA  2  28 91        	.word	LAB_STRS-1		; STR$()
00A2CC  2  9D 94        	.word	LAB_VAL-1		; VAL()
00A2CE  2  7B 94        	.word	LAB_ASC-1		; ASC()
00A2D0  2  35 94        	.word	LAB_UCASE-1		; UCASE$()		new function
00A2D2  2  14 94        	.word	LAB_LCASE-1		; LCASE$()		new function
00A2D4  2  86 93        	.word	LAB_CHRS-1		; CHR$()
00A2D6  2  25 9E        	.word	LAB_HEXS-1		; HEX$()		new function
00A2D8  2  D6 9D        	.word	LAB_BINS-1		; BIN$()		new function
00A2DA  2  AE 9D        	.word	LAB_BTST-1		; BITTST()		new function
00A2DC  2  85 9F        	.word	LAB_MAX-1		; MAX()		new function
00A2DE  2  95 9F        	.word	LAB_MIN-1		; MIN()		new function
00A2E0  2  DB A0        	.word	LAB_PI-1		; PI			new function
00A2E2  2  E5 A0        	.word	LAB_TWOPI-1		; TWOPI		new function
00A2E4  2  CB A0        	.word	LAB_VARPTR-1	; VARPTR()		new function
00A2E6  2  98 93        	.word	LAB_LEFT-1		; LEFT$()
00A2E8  2  A1 93        	.word	LAB_RIGHT-1		; RIGHT$()
00A2EA  2  D0 93        	.word	LAB_MIDS-1		; MID$()
00A2EC  2               
00A2EC  2               ; hierarchy and action addresses for operator
00A2EC  2               
00A2EC  2               LAB_OPPT
00A2EC  2  79           	.byte	$79			; +
00A2ED  2  C3 95        	.word	LAB_ADD-1
00A2EF  2  79           	.byte	$79			; -
00A2F0  2  A8 95        	.word	LAB_SUBTRACT-1
00A2F2  2  7B           	.byte	$7B			; *
00A2F3  2  3E 97        	.word	LAB_MULTIPLY-1
00A2F5  2  7B           	.byte	$7B			; /
00A2F6  2  06 98        	.word	LAB_DIVIDE-1
00A2F8  2  7F           	.byte	$7F			; ^
00A2F9  2  BD 9B        	.word	LAB_POWER-1
00A2FB  2  50           	.byte	$50			; AND
00A2FC  2  D7 8C        	.word	LAB_AND-1
00A2FE  2  46           	.byte	$46			; EOR			new operator
00A2FF  2  BD 8C        	.word	LAB_EOR-1
00A301  2  46           	.byte	$46			; OR
00A302  2  CA 8C        	.word	LAB_OR-1
00A304  2  56           	.byte	$56			; >>			new operator
00A305  2  83 8D        	.word	LAB_RSHIFT-1
00A307  2  56           	.byte	$56			; <<			new operator
00A308  2  6B 8D        	.word	LAB_LSHIFT-1
00A30A  2  7D           	.byte	$7D			; >
00A30B  2  F6 9B        	.word	LAB_GTHAN-1
00A30D  2  5A           	.byte	$5A			; =
00A30E  2  19 8C        	.word	LAB_EQUAL-1
00A310  2  64           	.byte	$64			; <
00A311  2  F8 8C        	.word	LAB_LTHAN-1
00A313  2               
00A313  2               ; keywords start with ..
00A313  2               ; this is the first character table and must be in alphabetic order
00A313  2               
00A313  2               TAB_1STC
00A313  2  2A           	.byte	"*"
00A314  2  2B           	.byte	"+"
00A315  2  2D           	.byte	"-"
00A316  2  2F           	.byte	"/"
00A317  2  3C           	.byte	"<"
00A318  2  3D           	.byte	"="
00A319  2  3E           	.byte	">"
00A31A  2  3F           	.byte	"?"
00A31B  2  41           	.byte	"A"
00A31C  2  42           	.byte	"B"
00A31D  2  43           	.byte	"C"
00A31E  2  44           	.byte	"D"
00A31F  2  45           	.byte	"E"
00A320  2  46           	.byte	"F"
00A321  2  47           	.byte	"G"
00A322  2  48           	.byte	"H"
00A323  2  49           	.byte	"I"
00A324  2  4C           	.byte	"L"
00A325  2  4D           	.byte	"M"
00A326  2  4E           	.byte	"N"
00A327  2  4F           	.byte	"O"
00A328  2  50           	.byte	"P"
00A329  2  52           	.byte	"R"
00A32A  2  53           	.byte	"S"
00A32B  2  54           	.byte	"T"
00A32C  2  55           	.byte	"U"
00A32D  2  56           	.byte	"V"
00A32E  2  57           	.byte	"W"
00A32F  2  5E           	.byte	"^"
00A330  2  00           	.byte	$00			; table terminator
00A331  2               
00A331  2               ; pointers to keyword tables
00A331  2               
00A331  2               TAB_CHRT
00A331  2  6B A3        	.word	TAB_STAR		; table for "*"
00A333  2  6D A3        	.word	TAB_PLUS		; table for "+"
00A335  2  6F A3        	.word	TAB_MNUS		; table for "-"
00A337  2  71 A3        	.word	TAB_SLAS		; table for "/"
00A339  2  73 A3        	.word	TAB_LESS		; table for "<"
00A33B  2  77 A3        	.word	TAB_EQUL		; table for "="
00A33D  2  79 A3        	.word	TAB_MORE		; table for ">"
00A33F  2  7D A3        	.word	TAB_QEST		; table for "?"
00A341  2  7F A3        	.word	TAB_ASCA		; table for "A"
00A343  2  8F A3        	.word	TAB_ASCB		; table for "B"
00A345  2  A8 A3        	.word	TAB_ASCC		; table for "C"
00A347  2  BF A3        	.word	TAB_ASCD		; table for "D"
00A349  2  D8 A3        	.word	TAB_ASCE		; table for "E"
00A34B  2  E7 A3        	.word	TAB_ASCF		; table for "F"
00A34D  2  F1 A3        	.word	TAB_ASCG		; table for "G"
00A34F  2  FE A3        	.word	TAB_ASCH		; table for "H"
00A351  2  04 A4        	.word	TAB_ASCI		; table for "I"
00A353  2  16 A4        	.word	TAB_ASCL		; table for "L"
00A355  2  3B A4        	.word	TAB_ASCM		; table for "M"
00A357  2  49 A4        	.word	TAB_ASCN		; table for "N"
00A359  2  5B A4        	.word	TAB_ASCO		; table for "O"
00A35B  2  63 A4        	.word	TAB_ASCP		; table for "P"
00A35D  2  78 A4        	.word	TAB_ASCR		; table for "R"
00A35F  2  A7 A4        	.word	TAB_ASCS		; table for "S"
00A361  2  D2 A4        	.word	TAB_ASCT		; table for "T"
00A363  2  E6 A4        	.word	TAB_ASCU		; table for "U"
00A365  2  F7 A4        	.word	TAB_ASCV		; table for "V"
00A367  2  03 A5        	.word	TAB_ASCW		; table for "W"
00A369  2  12 A5        	.word	TAB_POWR		; table for "^"
00A36B  2               
00A36B  2               ; tables for each start character, note if a longer keyword with the same start
00A36B  2               ; letters as a shorter one exists then it must come first, else the list is in
00A36B  2               ; alphabetical order as follows ..
00A36B  2               
00A36B  2               ; [keyword,token
00A36B  2               ; [keyword,token]]
00A36B  2               ; end marker (#$00)
00A36B  2               
00A36B  2               TAB_STAR
00A36B  2  B8 00        	.byte TK_MUL,$00		; *
00A36D  2               TAB_PLUS
00A36D  2  B6 00        	.byte TK_PLUS,$00		; +
00A36F  2               TAB_MNUS
00A36F  2  B7 00        	.byte TK_MINUS,$00	; -
00A371  2               TAB_SLAS
00A371  2  B9 00        	.byte TK_DIV,$00		; /
00A373  2               TAB_LESS
00A373  2               LBB_LSHIFT
00A373  2  3C BF        	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
00A375  2  C2           	.byte TK_LT			; <
00A376  2  00           	.byte	$00
00A377  2               TAB_EQUL
00A377  2  C1 00        	.byte TK_EQUAL,$00	; =
00A379  2               TAB_MORE
00A379  2               LBB_RSHIFT
00A379  2  3E BE        	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
00A37B  2  C0           	.byte TK_GT			; >
00A37C  2  00           	.byte	$00
00A37D  2               TAB_QEST
00A37D  2  9F 00        	.byte TK_PRINT,$00	; ?
00A37F  2               TAB_ASCA
00A37F  2               LBB_ABS
00A37F  2  42 53 28 C5  	.byte	"BS(",TK_ABS	; ABS(
00A383  2               LBB_AND
00A383  2  4E 44 BB     	.byte	"ND",TK_AND		; AND
00A386  2               LBB_ASC
00A386  2  53 43 28 D7  	.byte	"SC(",TK_ASC	; ASC(
00A38A  2               LBB_ATN
00A38A  2  54 4E 28 D0  	.byte	"TN(",TK_ATN	; ATN(
00A38E  2  00           	.byte	$00
00A38F  2               TAB_ASCB
00A38F  2               LBB_BINS
00A38F  2  49 4E 24 28  	.byte	"IN$(",TK_BINS	; BIN$(
00A393  2  DC           
00A394  2               LBB_BITCLR
00A394  2  49 54 43 4C  	.byte	"ITCLR",TK_BITCLR	; BITCLR
00A398  2  52 A8        
00A39A  2               LBB_BITSET
00A39A  2  49 54 53 45  	.byte	"ITSET",TK_BITSET	; BITSET
00A39E  2  54 A7        
00A3A0  2               LBB_BITTST
00A3A0  2  49 54 54 53  	.byte	"ITTST(",TK_BITTST
00A3A4  2  54 28 DD     
00A3A7  2               					; BITTST(
00A3A7  2  00           	.byte	$00
00A3A8  2               TAB_ASCC
00A3A8  2               LBB_CALL
00A3A8  2  41 4C 4C 9C  	.byte	"ALL",TK_CALL	; CALL
00A3AC  2               LBB_CHRS
00A3AC  2  48 52 24 28  	.byte	"HR$(",TK_CHRS	; CHR$(
00A3B0  2  DA           
00A3B1  2               LBB_CLEAR
00A3B1  2  4C 45 41 52  	.byte	"LEAR",TK_CLEAR	; CLEAR
00A3B5  2  A2           
00A3B6  2               LBB_CONT
00A3B6  2  4F 4E 54 A0  	.byte	"ONT",TK_CONT	; CONT
00A3BA  2               LBB_COS
00A3BA  2  4F 53 28 CD  	.byte	"OS(",TK_COS	; COS(
00A3BE  2  00           	.byte	$00
00A3BF  2               TAB_ASCD
00A3BF  2               LBB_DATA
00A3BF  2  41 54 41 83  	.byte	"ATA",TK_DATA	; DATA
00A3C3  2               LBB_DEC
00A3C3  2  45 43 88     	.byte	"EC",TK_DEC		; DEC
00A3C6  2               LBB_DEEK
00A3C6  2  45 45 4B 28  	.byte	"EEK(",TK_DEEK	; DEEK(
00A3CA  2  D2           
00A3CB  2               LBB_DEF
00A3CB  2  45 46 99     	.byte	"EF",TK_DEF		; DEF
00A3CE  2               LBB_DIM
00A3CE  2  49 4D 85     	.byte	"IM",TK_DIM		; DIM
00A3D1  2               LBB_DOKE
00A3D1  2  4F 4B 45 9B  	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
00A3D5  2               LBB_DO
00A3D5  2  4F 9D        	.byte	"O",TK_DO		; DO
00A3D7  2  00           	.byte	$00
00A3D8  2               TAB_ASCE
00A3D8  2               LBB_ELSE
00A3D8  2  4C 53 45 AC  	.byte	"LSE",TK_ELSE	; ELSE
00A3DC  2               LBB_END
00A3DC  2  4E 44 80     	.byte	"ND",TK_END		; END
00A3DF  2               LBB_EOR
00A3DF  2  4F 52 BC     	.byte	"OR",TK_EOR		; EOR
00A3E2  2               LBB_EXP
00A3E2  2  58 50 28 CC  	.byte	"XP(",TK_EXP	; EXP(
00A3E6  2  00           	.byte	$00
00A3E7  2               TAB_ASCF
00A3E7  2               LBB_FN
00A3E7  2  4E AE        	.byte	"N",TK_FN		; FN
00A3E9  2               LBB_FOR
00A3E9  2  4F 52 81     	.byte	"OR",TK_FOR		; FOR
00A3EC  2               LBB_FRE
00A3EC  2  52 45 28 C7  	.byte	"RE(",TK_FRE	; FRE(
00A3F0  2  00           	.byte	$00
00A3F1  2               TAB_ASCG
00A3F1  2               LBB_GET
00A3F1  2  45 54 A5     	.byte	"ET",TK_GET		; GET
00A3F4  2               LBB_GOSUB
00A3F4  2  4F 53 55 42  	.byte	"OSUB",TK_GOSUB	; GOSUB
00A3F8  2  8D           
00A3F9  2               LBB_GOTO
00A3F9  2  4F 54 4F 89  	.byte	"OTO",TK_GOTO	; GOTO
00A3FD  2  00           	.byte	$00
00A3FE  2               TAB_ASCH
00A3FE  2               LBB_HEXS
00A3FE  2  45 58 24 28  	.byte	"EX$(",TK_HEXS	; HEX$(
00A402  2  DB           
00A403  2  00           	.byte	$00
00A404  2               TAB_ASCI
00A404  2               LBB_IF
00A404  2  46 8B        	.byte	"F",TK_IF		; IF
00A406  2               LBB_INC
00A406  2  4E 43 95     	.byte	"NC",TK_INC		; INC
00A409  2               LBB_INPUT
00A409  2  4E 50 55 54  	.byte	"NPUT",TK_INPUT	; INPUT
00A40D  2  84           
00A40E  2               LBB_INT
00A40E  2  4E 54 28 C4  	.byte	"NT(",TK_INT	; INT(
00A412  2               LBB_IRQ
00A412  2  52 51 A9     	.byte	"RQ",TK_IRQ		; IRQ
00A415  2  00           	.byte	$00
00A416  2               TAB_ASCL
00A416  2               LBB_LCASES
00A416  2  43 41 53 45  	.byte	"CASE$(",TK_LCASES
00A41A  2  24 28 D9     
00A41D  2               					; LCASE$(
00A41D  2               LBB_LEFTS
00A41D  2  45 46 54 24  	.byte	"EFT$(",TK_LEFTS	; LEFT$(
00A421  2  28 E3        
00A423  2               LBB_LEN
00A423  2  45 4E 28 D4  	.byte	"EN(",TK_LEN	; LEN(
00A427  2               LBB_LET
00A427  2  45 54 87     	.byte	"ET",TK_LET		; LET
00A42A  2               LBB_LIST
00A42A  2  49 53 54 A1  	.byte	"IST",TK_LIST	; LIST
00A42E  2               LBB_LOAD
00A42E  2  4F 41 44 97  	.byte	"OAD",TK_LOAD	; LOAD
00A432  2               LBB_LOG
00A432  2  4F 47 28 CB  	.byte	"OG(",TK_LOG	; LOG(
00A436  2               LBB_LOOP
00A436  2  4F 4F 50 9E  	.byte	"OOP",TK_LOOP	; LOOP
00A43A  2  00           	.byte	$00
00A43B  2               TAB_ASCM
00A43B  2               LBB_MAX
00A43B  2  41 58 28 DE  	.byte	"AX(",TK_MAX	; MAX(
00A43F  2               LBB_MIDS
00A43F  2  49 44 24 28  	.byte	"ID$(",TK_MIDS	; MID$(
00A443  2  E5           
00A444  2               LBB_MIN
00A444  2  49 4E 28 DF  	.byte	"IN(",TK_MIN	; MIN(
00A448  2  00           	.byte	$00
00A449  2               TAB_ASCN
00A449  2               LBB_NEW
00A449  2  45 57 A3     	.byte	"EW",TK_NEW		; NEW
00A44C  2               LBB_NEXT
00A44C  2  45 58 54 82  	.byte	"EXT",TK_NEXT	; NEXT
00A450  2               LBB_NMI
00A450  2  4D 49 AA     	.byte	"MI",TK_NMI		; NMI
00A453  2               LBB_NOT
00A453  2  4F 54 B1     	.byte	"OT",TK_NOT		; NOT
00A456  2               LBB_NULL
00A456  2  55 4C 4C 94  	.byte	"ULL",TK_NULL	; NULL
00A45A  2  00           	.byte	$00
00A45B  2               TAB_ASCO
00A45B  2               LBB_OFF
00A45B  2  46 46 B5     	.byte	"FF",TK_OFF		; OFF
00A45E  2               LBB_ON
00A45E  2  4E 93        	.byte	"N",TK_ON		; ON
00A460  2               LBB_OR
00A460  2  52 BD        	.byte	"R",TK_OR		; OR
00A462  2  00           	.byte	$00
00A463  2               TAB_ASCP
00A463  2               LBB_PEEK
00A463  2  45 45 4B 28  	.byte	"EEK(",TK_PEEK	; PEEK(
00A467  2  D1           
00A468  2               LBB_PI
00A468  2  49 E0        	.byte	"I",TK_PI		; PI
00A46A  2               LBB_POKE
00A46A  2  4F 4B 45 9A  	.byte	"OKE",TK_POKE	; POKE
00A46E  2               LBB_POS
00A46E  2  4F 53 28 C8  	.byte	"OS(",TK_POS	; POS(
00A472  2               LBB_PRINT
00A472  2  52 49 4E 54  	.byte	"RINT",TK_PRINT	; PRINT
00A476  2  9F           
00A477  2  00           	.byte	$00
00A478  2               TAB_ASCR
00A478  2               LBB_READ
00A478  2  45 41 44 86  	.byte	"EAD",TK_READ	; READ
00A47C  2               LBB_REM
00A47C  2  45 4D 91     	.byte	"EM",TK_REM		; REM
00A47F  2               LBB_RESTORE
00A47F  2  45 53 54 4F  	.byte	"ESTORE",TK_RESTORE
00A483  2  52 45 8C     
00A486  2               					; RESTORE
00A486  2               LBB_RETIRQ
00A486  2  45 54 49 52  	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
00A48A  2  51 8E        
00A48C  2               LBB_RETNMI
00A48C  2  45 54 4E 4D  	.byte	"ETNMI",TK_RETNMI	; RETNMI
00A490  2  49 8F        
00A492  2               LBB_RETURN
00A492  2  45 54 55 52  	.byte	"ETURN",TK_RETURN	; RETURN
00A496  2  4E 90        
00A498  2               LBB_RIGHTS
00A498  2  49 47 48 54  	.byte	"IGHT$(",TK_RIGHTS
00A49C  2  24 28 E4     
00A49F  2               					; RIGHT$(
00A49F  2               LBB_RND
00A49F  2  4E 44 28 CA  	.byte	"ND(",TK_RND	; RND(
00A4A3  2               LBB_RUN
00A4A3  2  55 4E 8A     	.byte	"UN",TK_RUN		; RUN
00A4A6  2  00           	.byte	$00
00A4A7  2               TAB_ASCS
00A4A7  2               LBB_SADD
00A4A7  2  41 44 44 28  	.byte	"ADD(",TK_SADD	; SADD(
00A4AB  2  D3           
00A4AC  2               LBB_SAVE
00A4AC  2  41 56 45 98  	.byte	"AVE",TK_SAVE	; SAVE
00A4B0  2               LBB_SGN
00A4B0  2  47 4E 28 C3  	.byte	"GN(",TK_SGN	; SGN(
00A4B4  2               LBB_SIN
00A4B4  2  49 4E 28 CE  	.byte	"IN(",TK_SIN	; SIN(
00A4B8  2               LBB_SPC
00A4B8  2  50 43 28 AF  	.byte	"PC(",TK_SPC	; SPC(
00A4BC  2               LBB_SQR
00A4BC  2  51 52 28 C9  	.byte	"QR(",TK_SQR	; SQR(
00A4C0  2               LBB_STEP
00A4C0  2  54 45 50 B2  	.byte	"TEP",TK_STEP	; STEP
00A4C4  2               LBB_STOP
00A4C4  2  54 4F 50 92  	.byte	"TOP",TK_STOP	; STOP
00A4C8  2               LBB_STRS
00A4C8  2  54 52 24 28  	.byte	"TR$(",TK_STRS	; STR$(
00A4CC  2  D5           
00A4CD  2               LBB_SWAP
00A4CD  2  57 41 50 A6  	.byte	"WAP",TK_SWAP	; SWAP
00A4D1  2  00           	.byte	$00
00A4D2  2               TAB_ASCT
00A4D2  2               LBB_TAB
00A4D2  2  41 42 28 AB  	.byte	"AB(",TK_TAB	; TAB(
00A4D6  2               LBB_TAN
00A4D6  2  41 4E 28 CF  	.byte	"AN(",TK_TAN	; TAN(
00A4DA  2               LBB_THEN
00A4DA  2  48 45 4E B0  	.byte	"HEN",TK_THEN	; THEN
00A4DE  2               LBB_TO
00A4DE  2  4F AD        	.byte	"O",TK_TO		; TO
00A4E0  2               LBB_TWOPI
00A4E0  2  57 4F 50 49  	.byte	"WOPI",TK_TWOPI	; TWOPI
00A4E4  2  E1           
00A4E5  2  00           	.byte	$00
00A4E6  2               TAB_ASCU
00A4E6  2               LBB_UCASES
00A4E6  2  43 41 53 45  	.byte	"CASE$(",TK_UCASES
00A4EA  2  24 28 D8     
00A4ED  2               					; UCASE$(
00A4ED  2               LBB_UNTIL
00A4ED  2  4E 54 49 4C  	.byte	"NTIL",TK_UNTIL	; UNTIL
00A4F1  2  B3           
00A4F2  2               LBB_USR
00A4F2  2  53 52 28 C6  	.byte	"SR(",TK_USR	; USR(
00A4F6  2  00           	.byte	$00
00A4F7  2               TAB_ASCV
00A4F7  2               LBB_VAL
00A4F7  2  41 4C 28 D6  	.byte	"AL(",TK_VAL	; VAL(
00A4FB  2               LBB_VPTR
00A4FB  2  41 52 50 54  	.byte	"ARPTR(",TK_VPTR	; VARPTR(
00A4FF  2  52 28 E2     
00A502  2  00           	.byte	$00
00A503  2               TAB_ASCW
00A503  2               LBB_WAIT
00A503  2  41 49 54 96  	.byte	"AIT",TK_WAIT	; WAIT
00A507  2               LBB_WHILE
00A507  2  48 49 4C 45  	.byte	"HILE",TK_WHILE	; WHILE
00A50B  2  B4           
00A50C  2               LBB_WIDTH
00A50C  2  49 44 54 48  	.byte	"IDTH",TK_WIDTH	; WIDTH
00A510  2  A4           
00A511  2  00           	.byte	$00
00A512  2               TAB_POWR
00A512  2  BA 00        	.byte	TK_POWER,$00	; ^
00A514  2               
00A514  2               ; new decode table for LIST
00A514  2               ; Table is ..
00A514  2               ; byte - keyword length, keyword first character
00A514  2               ; word - pointer to rest of keyword from dictionary
00A514  2               
00A514  2               ; note if length is 1 then the pointer is ignored
00A514  2               
00A514  2               LAB_KEYT
00A514  2  03 45        	.byte	3,'E'
00A516  2  DC A3        	.word	LBB_END		; END
00A518  2  03 46        	.byte	3,'F'
00A51A  2  E9 A3        	.word	LBB_FOR		; FOR
00A51C  2  04 4E        	.byte	4,'N'
00A51E  2  4C A4        	.word	LBB_NEXT		; NEXT
00A520  2  04 44        	.byte	4,'D'
00A522  2  BF A3        	.word	LBB_DATA		; DATA
00A524  2  05 49        	.byte	5,'I'
00A526  2  09 A4        	.word	LBB_INPUT		; INPUT
00A528  2  03 44        	.byte	3,'D'
00A52A  2  CE A3        	.word	LBB_DIM		; DIM
00A52C  2  04 52        	.byte	4,'R'
00A52E  2  78 A4        	.word	LBB_READ		; READ
00A530  2  03 4C        	.byte	3,'L'
00A532  2  27 A4        	.word	LBB_LET		; LET
00A534  2  03 44        	.byte	3,'D'
00A536  2  C3 A3        	.word	LBB_DEC		; DEC
00A538  2  04 47        	.byte	4,'G'
00A53A  2  F9 A3        	.word	LBB_GOTO		; GOTO
00A53C  2  03 52        	.byte	3,'R'
00A53E  2  A3 A4        	.word	LBB_RUN		; RUN
00A540  2  02 49        	.byte	2,'I'
00A542  2  04 A4        	.word	LBB_IF		; IF
00A544  2  07 52        	.byte	7,'R'
00A546  2  7F A4        	.word	LBB_RESTORE		; RESTORE
00A548  2  05 47        	.byte	5,'G'
00A54A  2  F4 A3        	.word	LBB_GOSUB		; GOSUB
00A54C  2  06 52        	.byte	6,'R'
00A54E  2  86 A4        	.word	LBB_RETIRQ		; RETIRQ
00A550  2  06 52        	.byte	6,'R'
00A552  2  8C A4        	.word	LBB_RETNMI		; RETNMI
00A554  2  06 52        	.byte	6,'R'
00A556  2  92 A4        	.word	LBB_RETURN		; RETURN
00A558  2  03 52        	.byte	3,'R'
00A55A  2  7C A4        	.word	LBB_REM		; REM
00A55C  2  04 53        	.byte	4,'S'
00A55E  2  C4 A4        	.word	LBB_STOP		; STOP
00A560  2  02 4F        	.byte	2,'O'
00A562  2  5E A4        	.word	LBB_ON		; ON
00A564  2  04 4E        	.byte	4,'N'
00A566  2  56 A4        	.word	LBB_NULL		; NULL
00A568  2  03 49        	.byte	3,'I'
00A56A  2  06 A4        	.word	LBB_INC		; INC
00A56C  2  04 57        	.byte	4,'W'
00A56E  2  03 A5        	.word	LBB_WAIT		; WAIT
00A570  2  04 4C        	.byte	4,'L'
00A572  2  2E A4        	.word	LBB_LOAD		; LOAD
00A574  2  04 53        	.byte	4,'S'
00A576  2  AC A4        	.word	LBB_SAVE		; SAVE
00A578  2  03 44        	.byte	3,'D'
00A57A  2  CB A3        	.word	LBB_DEF		; DEF
00A57C  2  04 50        	.byte	4,'P'
00A57E  2  6A A4        	.word	LBB_POKE		; POKE
00A580  2  04 44        	.byte	4,'D'
00A582  2  D1 A3        	.word	LBB_DOKE		; DOKE
00A584  2  04 43        	.byte	4,'C'
00A586  2  A8 A3        	.word	LBB_CALL		; CALL
00A588  2  02 44        	.byte	2,'D'
00A58A  2  D5 A3        	.word	LBB_DO		; DO
00A58C  2  04 4C        	.byte	4,'L'
00A58E  2  36 A4        	.word	LBB_LOOP		; LOOP
00A590  2  05 50        	.byte	5,'P'
00A592  2  72 A4        	.word	LBB_PRINT		; PRINT
00A594  2  04 43        	.byte	4,'C'
00A596  2  B6 A3        	.word	LBB_CONT		; CONT
00A598  2  04 4C        	.byte	4,'L'
00A59A  2  2A A4        	.word	LBB_LIST		; LIST
00A59C  2  05 43        	.byte	5,'C'
00A59E  2  B1 A3        	.word	LBB_CLEAR		; CLEAR
00A5A0  2  03 4E        	.byte	3,'N'
00A5A2  2  49 A4        	.word	LBB_NEW		; NEW
00A5A4  2  05 57        	.byte	5,'W'
00A5A6  2  0C A5        	.word	LBB_WIDTH		; WIDTH
00A5A8  2  03 47        	.byte	3,'G'
00A5AA  2  F1 A3        	.word	LBB_GET		; GET
00A5AC  2  04 53        	.byte	4,'S'
00A5AE  2  CD A4        	.word	LBB_SWAP		; SWAP
00A5B0  2  06 42        	.byte	6,'B'
00A5B2  2  9A A3        	.word	LBB_BITSET		; BITSET
00A5B4  2  06 42        	.byte	6,'B'
00A5B6  2  94 A3        	.word	LBB_BITCLR		; BITCLR
00A5B8  2  03 49        	.byte	3,'I'
00A5BA  2  12 A4        	.word	LBB_IRQ		; IRQ
00A5BC  2  03 4E        	.byte	3,'N'
00A5BE  2  50 A4        	.word	LBB_NMI		; NMI
00A5C0  2               
00A5C0  2               ; secondary commands (can't start a statement)
00A5C0  2               
00A5C0  2  04 54        	.byte	4,'T'
00A5C2  2  D2 A4        	.word	LBB_TAB		; TAB
00A5C4  2  04 45        	.byte	4,'E'
00A5C6  2  D8 A3        	.word	LBB_ELSE		; ELSE
00A5C8  2  02 54        	.byte	2,'T'
00A5CA  2  DE A4        	.word	LBB_TO		; TO
00A5CC  2  02 46        	.byte	2,'F'
00A5CE  2  E7 A3        	.word	LBB_FN		; FN
00A5D0  2  04 53        	.byte	4,'S'
00A5D2  2  B8 A4        	.word	LBB_SPC		; SPC
00A5D4  2  04 54        	.byte	4,'T'
00A5D6  2  DA A4        	.word	LBB_THEN		; THEN
00A5D8  2  03 4E        	.byte	3,'N'
00A5DA  2  53 A4        	.word	LBB_NOT		; NOT
00A5DC  2  04 53        	.byte	4,'S'
00A5DE  2  C0 A4        	.word	LBB_STEP		; STEP
00A5E0  2  05 55        	.byte	5,'U'
00A5E2  2  ED A4        	.word	LBB_UNTIL		; UNTIL
00A5E4  2  05 57        	.byte	5,'W'
00A5E6  2  07 A5        	.word	LBB_WHILE		; WHILE
00A5E8  2  03 4F        	.byte	3,'O'
00A5EA  2  5B A4        	.word	LBB_OFF		; OFF
00A5EC  2               
00A5EC  2               ; opperators
00A5EC  2               
00A5EC  2  01 2B        	.byte	1,'+'
00A5EE  2  00 00        	.word	$0000			; +
00A5F0  2  01 2D        	.byte	1,'-'
00A5F2  2  00 00        	.word	$0000			; -
00A5F4  2  01 2A        	.byte	1,'*'
00A5F6  2  00 00        	.word	$0000			; *
00A5F8  2  01 2F        	.byte	1,'/'
00A5FA  2  00 00        	.word	$0000			; /
00A5FC  2  01 5E        	.byte	1,'^'
00A5FE  2  00 00        	.word	$0000			; ^
00A600  2  03 41        	.byte	3,'A'
00A602  2  83 A3        	.word	LBB_AND		; AND
00A604  2  03 45        	.byte	3,'E'
00A606  2  DF A3        	.word	LBB_EOR		; EOR
00A608  2  02 4F        	.byte	2,'O'
00A60A  2  60 A4        	.word	LBB_OR		; OR
00A60C  2  02 3E        	.byte	2,'>'
00A60E  2  79 A3        	.word	LBB_RSHIFT		; >>
00A610  2  02 3C        	.byte	2,'<'
00A612  2  73 A3        	.word	LBB_LSHIFT		; <<
00A614  2  01 3E        	.byte	1,'>'
00A616  2  00 00        	.word	$0000			; >
00A618  2  01 3D        	.byte	1,'='
00A61A  2  00 00        	.word	$0000			; =
00A61C  2  01 3C        	.byte	1,'<'
00A61E  2  00 00        	.word	$0000			; <
00A620  2               
00A620  2               ; functions
00A620  2               
00A620  2  04 53        	.byte	4,'S'			;
00A622  2  B0 A4        	.word	LBB_SGN		; SGN
00A624  2  04 49        	.byte	4,'I'			;
00A626  2  0E A4        	.word	LBB_INT		; INT
00A628  2  04 41        	.byte	4,'A'			;
00A62A  2  7F A3        	.word	LBB_ABS		; ABS
00A62C  2  04 55        	.byte	4,'U'			;
00A62E  2  F2 A4        	.word	LBB_USR		; USR
00A630  2  04 46        	.byte	4,'F'			;
00A632  2  EC A3        	.word	LBB_FRE		; FRE
00A634  2  04 50        	.byte	4,'P'			;
00A636  2  6E A4        	.word	LBB_POS		; POS
00A638  2  04 53        	.byte	4,'S'			;
00A63A  2  BC A4        	.word	LBB_SQR		; SQR
00A63C  2  04 52        	.byte	4,'R'			;
00A63E  2  9F A4        	.word	LBB_RND		; RND
00A640  2  04 4C        	.byte	4,'L'			;
00A642  2  32 A4        	.word	LBB_LOG		; LOG
00A644  2  04 45        	.byte	4,'E'			;
00A646  2  E2 A3        	.word	LBB_EXP		; EXP
00A648  2  04 43        	.byte	4,'C'			;
00A64A  2  BA A3        	.word	LBB_COS		; COS
00A64C  2  04 53        	.byte	4,'S'			;
00A64E  2  B4 A4        	.word	LBB_SIN		; SIN
00A650  2  04 54        	.byte	4,'T'			;
00A652  2  D6 A4        	.word	LBB_TAN		; TAN
00A654  2  04 41        	.byte	4,'A'			;
00A656  2  8A A3        	.word	LBB_ATN		; ATN
00A658  2  05 50        	.byte	5,'P'			;
00A65A  2  63 A4        	.word	LBB_PEEK		; PEEK
00A65C  2  05 44        	.byte	5,'D'			;
00A65E  2  C6 A3        	.word	LBB_DEEK		; DEEK
00A660  2  05 53        	.byte	5,'S'			;
00A662  2  A7 A4        	.word	LBB_SADD		; SADD
00A664  2  04 4C        	.byte	4,'L'			;
00A666  2  23 A4        	.word	LBB_LEN		; LEN
00A668  2  05 53        	.byte	5,'S'			;
00A66A  2  C8 A4        	.word	LBB_STRS		; STR$
00A66C  2  04 56        	.byte	4,'V'			;
00A66E  2  F7 A4        	.word	LBB_VAL		; VAL
00A670  2  04 41        	.byte	4,'A'			;
00A672  2  86 A3        	.word	LBB_ASC		; ASC
00A674  2  07 55        	.byte	7,'U'			;
00A676  2  E6 A4        	.word	LBB_UCASES		; UCASE$
00A678  2  07 4C        	.byte	7,'L'			;
00A67A  2  16 A4        	.word	LBB_LCASES		; LCASE$
00A67C  2  05 43        	.byte	5,'C'			;
00A67E  2  AC A3        	.word	LBB_CHRS		; CHR$
00A680  2  05 48        	.byte	5,'H'			;
00A682  2  FE A3        	.word	LBB_HEXS		; HEX$
00A684  2  05 42        	.byte	5,'B'			;
00A686  2  8F A3        	.word	LBB_BINS		; BIN$
00A688  2  07 42        	.byte	7,'B'			;
00A68A  2  A0 A3        	.word	LBB_BITTST		; BITTST
00A68C  2  04 4D        	.byte	4,'M'			;
00A68E  2  3B A4        	.word	LBB_MAX		; MAX
00A690  2  04 4D        	.byte	4,'M'			;
00A692  2  44 A4        	.word	LBB_MIN		; MIN
00A694  2  02 50        	.byte	2,'P'			;
00A696  2  68 A4        	.word	LBB_PI		; PI
00A698  2  05 54        	.byte	5,'T'			;
00A69A  2  E0 A4        	.word	LBB_TWOPI		; TWOPI
00A69C  2  07 56        	.byte	7,'V'			;
00A69E  2  FB A4        	.word	LBB_VPTR		; VARPTR
00A6A0  2  06 4C        	.byte	6,'L'			;
00A6A2  2  1D A4        	.word	LBB_LEFTS		; LEFT$
00A6A4  2  07 52        	.byte	7,'R'			;
00A6A6  2  98 A4        	.word	LBB_RIGHTS		; RIGHT$
00A6A8  2  05 4D        	.byte	5,'M'			;
00A6AA  2  3F A4        	.word	LBB_MIDS		; MID$
00A6AC  2               
00A6AC  2               ; BASIC messages, mostly error messages
00A6AC  2               
00A6AC  2               LAB_BAER
00A6AC  2  D0 A6        	.word	ERR_NF		;$00 NEXT without FOR
00A6AE  2  E1 A6        	.word	ERR_SN		;$02 syntax
00A6B0  2  E8 A6        	.word	ERR_RG		;$04 RETURN without GOSUB
00A6B2  2  FD A6        	.word	ERR_OD		;$06 out of data
00A6B4  2  09 A7        	.word	ERR_FC		;$08 function call
00A6B6  2  17 A7        	.word	ERR_OV		;$0A overflow
00A6B8  2  20 A7        	.word	ERR_OM		;$0C out of memory
00A6BA  2  2E A7        	.word	ERR_US		;$0E undefined statement
00A6BC  2  42 A7        	.word	ERR_BS		;$10 array bounds
00A6BE  2  4F A7        	.word	ERR_DD		;$12 double dimension array
00A6C0  2  60 A7        	.word	ERR_D0		;$14 divide by 0
00A6C2  2  6F A7        	.word	ERR_ID		;$16 illegal direct
00A6C4  2  7E A7        	.word	ERR_TM		;$18 type mismatch
00A6C6  2  8C A7        	.word	ERR_LS		;$1A long string
00A6C8  2  9C A7        	.word	ERR_ST		;$1C string too complex
00A6CA  2  AF A7        	.word	ERR_CN		;$1E continue error
00A6CC  2  BE A7        	.word	ERR_UF		;$20 undefined function
00A6CE  2  D1 A7        	.word ERR_LD		;$22 LOOP without DO
00A6D0  2               
00A6D0  2               ; I may implement these two errors to force definition of variables and
00A6D0  2               ; dimensioning of arrays before use.
00A6D0  2               
00A6D0  2               ;	.word ERR_UV		;$24 undefined variable
00A6D0  2               
00A6D0  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00A6D0  2               
00A6D0  2               ;	.word ERR_UA		;$26 undimensioned array
00A6D0  2               
00A6D0  2  4E 45 58 54  ERR_NF	.byte	"NEXT without FOR",$00
00A6D4  2  20 77 69 74  
00A6D8  2  68 6F 75 74  
00A6E1  2  53 79 6E 74  ERR_SN	.byte	"Syntax",$00
00A6E5  2  61 78 00     
00A6E8  2  52 45 54 55  ERR_RG	.byte	"RETURN without GOSUB",$00
00A6EC  2  52 4E 20 77  
00A6F0  2  69 74 68 6F  
00A6FD  2  4F 75 74 20  ERR_OD	.byte	"Out of DATA",$00
00A701  2  6F 66 20 44  
00A705  2  41 54 41 00  
00A709  2  46 75 6E 63  ERR_FC	.byte	"Function call",$00
00A70D  2  74 69 6F 6E  
00A711  2  20 63 61 6C  
00A717  2  4F 76 65 72  ERR_OV	.byte	"Overflow",$00
00A71B  2  66 6C 6F 77  
00A71F  2  00           
00A720  2  4F 75 74 20  ERR_OM	.byte	"Out of memory",$00
00A724  2  6F 66 20 6D  
00A728  2  65 6D 6F 72  
00A72E  2  55 6E 64 65  ERR_US	.byte	"Undefined statement",$00
00A732  2  66 69 6E 65  
00A736  2  64 20 73 74  
00A742  2  41 72 72 61  ERR_BS	.byte	"Array bounds",$00
00A746  2  79 20 62 6F  
00A74A  2  75 6E 64 73  
00A74F  2  44 6F 75 62  ERR_DD	.byte	"Double dimension",$00
00A753  2  6C 65 20 64  
00A757  2  69 6D 65 6E  
00A760  2  44 69 76 69  ERR_D0	.byte	"Divide by zero",$00
00A764  2  64 65 20 62  
00A768  2  79 20 7A 65  
00A76F  2  49 6C 6C 65  ERR_ID	.byte	"Illegal direct",$00
00A773  2  67 61 6C 20  
00A777  2  64 69 72 65  
00A77E  2  54 79 70 65  ERR_TM	.byte	"Type mismatch",$00
00A782  2  20 6D 69 73  
00A786  2  6D 61 74 63  
00A78C  2  53 74 72 69  ERR_LS	.byte	"String too long",$00
00A790  2  6E 67 20 74  
00A794  2  6F 6F 20 6C  
00A79C  2  53 74 72 69  ERR_ST	.byte	"String too complex",$00
00A7A0  2  6E 67 20 74  
00A7A4  2  6F 6F 20 63  
00A7AF  2  43 61 6E 27  ERR_CN	.byte	"Can't continue",$00
00A7B3  2  74 20 63 6F  
00A7B7  2  6E 74 69 6E  
00A7BE  2  55 6E 64 65  ERR_UF	.byte	"Undefined function",$00
00A7C2  2  66 69 6E 65  
00A7C6  2  64 20 66 75  
00A7D1  2  4C 4F 4F 50  ERR_LD	.byte	"LOOP without DO",$00
00A7D5  2  20 77 69 74  
00A7D9  2  68 6F 75 74  
00A7E1  2               
00A7E1  2               ;ERR_UV	.byte	"Undefined variable",$00
00A7E1  2               
00A7E1  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00A7E1  2               
00A7E1  2               ;ERR_UA	.byte	"Undimensioned array",$00
00A7E1  2               
00A7E1  2  0D 0A 42 72  LAB_BMSG	.byte	$0D,$0A,"Break",$00
00A7E5  2  65 61 6B 00  
00A7E9  2  20 45 72 72  LAB_EMSG	.byte	" Error",$00
00A7ED  2  6F 72 00     
00A7F0  2  20 69 6E 20  LAB_LMSG	.byte	" in line ",$00
00A7F4  2  6C 69 6E 65  
00A7F8  2  20 00        
00A7FA  2  0D 0A 52 65  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
00A7FE  2  61 64 79 0D  
00A802  2  0A 00        
00A804  2               
00A804  2  20 45 78 74  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
00A808  2  72 61 20 69  
00A80C  2  67 6E 6F 72  
00A815  2  20 52 65 64  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
00A819  2  6F 20 66 72  
00A81D  2  6F 6D 20 73  
00A828  2               
00A828  2               AA_end_basic
00A828  2               
00A828  1               	.include "acia.s"
00A828  2               ; ACIA Ports
00A828  2               ACIA_BASE = $0220
00A828  2               ACIA_TX_RX_DATA = ACIA_BASE + $0
00A828  2               ACIA_STATUS = ACIA_BASE + $1
00A828  2               ACIA_RESET = ACIA_BASE + $1
00A828  2               ACIA_COMMAND = ACIA_BASE + $2
00A828  2               ACIA_CONTROL = ACIA_BASE + $3
00A828  2               
00A828  2               ; ACIA Status Register
00A828  2               ACIA_INT_ENABLE       = %10000000
00A828  2               ACIA_DSR_NOT_READY    = %01000000
00A828  2               ACIA_DCD_NOT_DETECTED = %00100000
00A828  2               ACIA_TX_DR_EMPTY      = %00010000
00A828  2               ACIA_RX_DR_FULL       = %00001000
00A828  2               ACIA_OVERFLOW_ERROR   = %00000100
00A828  2               ACIA_FRAMING_ERROR    = %00000010
00A828  2               ACIA_PARITY_ERROR     = %00000001
00A828  2               
00A828  2               ; ACIA Control Register
00A828  2               ; Stop Bit Number (SBN) bit 7
00A828  2               ACIA_1_SBN = %00000000
00A828  2               ACIA_2_SBN = %10000000
00A828  2               ; Word Length (WL) bits 6-5
00A828  2               ACIA_WL_8 = %00000000
00A828  2               ACIA_WL_7 = %00100000
00A828  2               ACIA_WL_6 = %01000000
00A828  2               ACIA_WL_5 = %01100000
00A828  2               ; Receiver Clock Source (RCS) bit 4
00A828  2               ACIA_RX_CLOCK_EXTERNAL  = %00000000
00A828  2               ACIA_RX_CLOCK_BAUD_RATE = %00010000
00A828  2               ; Selected Baud Rate (SBR) bits 3-0
00A828  2               ACIA_BAUD_115200   = %00000000
00A828  2               ACIA_BAUD_50       = %00000001
00A828  2               ACIA_BAUD_75       = %00000010
00A828  2               ACIA_BAUD_109_92   = %00000011
00A828  2               ACIA_BAUD_134_58   = %00000100
00A828  2               ACIA_BAUD_150      = %00000101
00A828  2               ACIA_BAUD_300      = %00000110
00A828  2               ACIA_BAUD_600      = %00000111
00A828  2               ACIA_BAUD_1200     = %00001000
00A828  2               ACIA_BAUD_1800     = %00001001
00A828  2               ACIA_BAUD_2400     = %00001010
00A828  2               ACIA_BAUD_3600     = %00001011
00A828  2               ACIA_BAUD_4800     = %00001100
00A828  2               ACIA_BAUD_7200     = %00001101
00A828  2               ACIA_BAUD_9600     = %00001110
00A828  2               ACIA_BAUD_19200    = %00001111
00A828  2               
00A828  2               ; ACIA Command Register
00A828  2               ACIA_NO_PARITY      = %00000000
00A828  2               ACIA_NO_ECHO        = %00000000
00A828  2               ACIA_ECHO_MODE      = %00010000
00A828  2               ; Transmitter Interrupt Control (TIC)
00A828  2               ACIA_RTSB_H_TX_INT_DISABLED          = %00000000
00A828  2               ACIA_RTSB_L_TX_INT_DISABLED          = %00001000
00A828  2               ACIA_RTSB_L_TX_INT_DISABLED_TX_BREAK = %00001100
00A828  2               ; Receiver Interrupt Request Disabled (IRD)
00A828  2               ACIA_RX_IRQB_DISABLED = %00000010
00A828  2               ; Data Terminal Ready (DTR)
00A828  2               ACIA_DTR = %00000001
00A828  2               
00A828  2               acia_init:
00A828  2  48             pha
00A829  2  9C 21 02       stz ACIA_RESET
00A82C  2  A9 1E          lda #(ACIA_1_SBN | ACIA_WL_8 | ACIA_RX_CLOCK_BAUD_RATE | ACIA_BAUD_9600)
00A82E  2                 ; lda #%00011111
00A82E  2  8D 23 02       sta ACIA_CONTROL
00A831  2               
00A831  2  A9 0B          lda #(ACIA_NO_PARITY | ACIA_NO_ECHO | ACIA_RTSB_L_TX_INT_DISABLED | ACIA_RX_IRQB_DISABLED| ACIA_DTR)
00A833  2                 ; lda #%00001011
00A833  2  8D 22 02       sta ACIA_COMMAND
00A836  2  68             pla
00A837  2  60             rts
00A838  2               
00A838  2               ; acia_send:
00A838  2               ; .write:
00A838  2               ;   ldx #0
00A838  2               
00A838  2               ; .send_loop:
00A838  2               ;   lda acia_text,x
00A838  2               ;   sta ACIA_TX_RX_DATA
00A838  2               ;   ; lda #1
00A838  2               ;   ; jsr wait_ms
00A838  2               ;   jsr delay_6551
00A838  2               ;   txa
00A838  2               ;   sbc #11
00A838  2               ;   beq acia_send
00A838  2               ;   inx
00A838  2               ;   lda ACIA_STATUS
00A838  2               ;   lda ACIA_TX_RX_DATA
00A838  2               ;   jmp .send_loop
00A838  2               
00A838  2               
00A838  2               
00A838  2               acia_write:
00A838  2  8D 20 02       sta ACIA_TX_RX_DATA
00A83B  2  20 58 A8       jsr delay_6551
00A83E  2  60             rts
00A83F  2               
00A83F  2               ; reads byte into A register and blocks until byte is available
00A83F  2               acia_read:
00A83F  2  AD 21 02       lda ACIA_STATUS
00A842  2  29 08          and #ACIA_RX_DR_FULL
00A844  2  F0 F9          beq acia_read
00A846  2  AD 20 02       lda ACIA_TX_RX_DATA
00A849  2  60             rts
00A84A  2               
00A84A  2               ; checks for byte and loads into A register. Carry set if byte is available, cleard if no byte
00A84A  2               acia_check:
00A84A  2  AD 21 02     	lda	ACIA_STATUS
00A84D  2  29 08        	and	#ACIA_RX_DR_FULL
00A84F  2  F0 05        	beq	acia_check_no_data
00A851  2  AD 20 02     	lda	ACIA_TX_RX_DATA
00A854  2  38           	sec		; Carry set if key available
00A855  2  60           	rts
00A856  2               acia_check_no_data:
00A856  2  18           	clc		; Carry clear if no key pressed
00A857  2  60           	rts
00A858  2               
00A858  2               
00A858  2               ; Latest WDC 65C51 has a bug - Xmit bit in status register is stuck on
00A858  2               ; IRQ driven transmit is not possible as a result - interrupts are endlessly triggered
00A858  2               ; Polled I/O mode also doesn't work as the Xmit bit is polled - delay routine is the only option
00A858  2               ; The following delay routine kills time to allow W65C51 to complete a character transmit
00A858  2               ; 0.523 milliseconds required loop time for 19,200 baud rate
00A858  2               ; .mini_delay routine takes 524 clock cycles to complete - X Reg is used for the count loop
00A858  2               ; Y Reg is loaded with the CPU clock rate in MHz (whole increments only) and used as a multiplier
00A858  2               ;
00A858  2               delay_6551:
00A858  2  5A             phy      ;Save Y Reg
00A859  2  DA             phx      ;Save X Reg
00A85A  2  A0 08          ldy   #8    ;Get delay value (clock rate in MHz 2 clock cycles)
00A85C  2                 ; ldy   #1    ;Get delay value (clock rate in MHz 1 clock cycles)
00A85C  2               
00A85C  2               delay_clock_multiplier_loop:
00A85C  2  A2 CC          ldx   #$CC      ;Seed X reg, $11 works for 115200 baud, $66 for 19200, $CC for 9600
00A85E  2               delay_baud_loop:
00A85E  2  CA             dex         ;Decrement low index
00A85F  2  D0 FD          bne   delay_baud_loop   ;Loop back until done
00A861  2  88             dey         ;Decrease by one
00A862  2  D0 F8          bne   delay_clock_multiplier_loop   ;Loop until done
00A864  2  FA             plx         ;Restore X Reg
00A865  2  7A             ply         ;Restore Y Reg
00A866  2               delay_done:
00A866  2  60             rts         ;Delay done, return
00A867  2               
00A867  1               	.include "via.s"
00A867  2               ; VIA Ports
00A867  2               VIA1_BASE = $0200
00A867  2               VIA2_BASE = $0210
00A867  2               VIA1_PORTB = VIA1_BASE + $0
00A867  2               VIA1_PORTA = VIA1_BASE + $1
00A867  2               VIA1_DDRB  = VIA1_BASE + $2
00A867  2               VIA1_DDRA  = VIA1_BASE + $3
00A867  2               VIA1_PRC = VIA1_BASE + $C
00A867  2               VIA1_IFR = VIA1_BASE + $D
00A867  2               VIA1_IER = VIA1_BASE + $E
00A867  2               VIA2_PORTB = VIA2_BASE + $0
00A867  2               VIA2_PORTA = VIA2_BASE + $1
00A867  2               VIA2_DDRB  = VIA2_BASE + $2
00A867  2               VIA2_DDRA  = VIA2_BASE + $3
00A867  2               VIA2_PRC = VIA2_BASE + $C
00A867  2               VIA2_IFR = VIA2_BASE + $D
00A867  2               VIA2_IER = VIA2_BASE + $E
00A867  2               
00A867  2               ; VIA Interrupt Control
00A867  2               VIA_INT_CA2 = $00000001
00A867  2               VIA_INT_CA1 = %00000010
00A867  2               VIA_INT_SR  = %00000100
00A867  2               VIA_INT_CB2 = %00001000
00A867  2               VIA_INT_CB1 = %00010000
00A867  2               VIA_INT_T2  = %00100000
00A867  2               VIA_INT_T1  = %01000000
00A867  2               VIA_INT_SET = %10000000
00A867  2               
00A867  2               ; VIA Peripheral Control Register
00A867  2               VIA_CB2_INT_LOW = %00000000
00A867  2               VIA_CB2_INDEPENDENT_INT_LOW = %00100000
00A867  2               VIA_CB2_INT_HIGH = %01000000
00A867  2               VIA_CB2_INDEPENDENT_INT_HIGH = %01100000
00A867  2               VIA_CB2_HANDSHAKE_OUT = %10000000
00A867  2               VIA_CB2_PULSE_OUT = %10100000
00A867  2               VIA_CB2_LOW_OUT = %11000000
00A867  2               VIA_CB2_HIGH_OUT = %11100000
00A867  2               VIA_CB1_INT_LOW = %00000000
00A867  2               VIA_CB1_INT_HIGH = %00010000
00A867  2               VIA_CA2_INT_LOW = %00000000
00A867  2               VIA_CA2_INDEPENDENT_INT_LOW = %00000010
00A867  2               VIA_CA2_INT_HIGH = %00000100
00A867  2               VIA_CA2_INDEPENDENT_INT_HIGH = %00000110
00A867  2               VIA_CA2_HANDSHAKE_OUT = %00001000
00A867  2               VIA_CA2_PULSE_OUT = %00001010
00A867  2               VIA_CA2_LOW_OUT = %00001100
00A867  2               VIA_CA2_HIGH_OUT = %00001110
00A867  2               VIA_CA1_INT_LOW = %00000000
00A867  2               VIA_CA1_INT_HIGH = %0000001
00A867  2               
00A867  2               via_init:
00A867  2  48             pha
00A868  2  A9 82          lda #VIA_INT_SET | VIA_INT_CA1
00A86A  2  8D 0E 02       sta VIA1_IER
00A86D  2               
00A86D  2  A9 01          lda #VIA_CA1_INT_HIGH
00A86F  2  8D 0C 02       sta VIA1_PRC
00A872  2               
00A872  2  A9 FF          lda #%11111111 ; Set all pins on port B to output
00A874  2  8D 02 02       sta VIA1_DDRB
00A877  2  9C 00 02       stz VIA1_PORTB
00A87A  2  68             pla
00A87B  2  60             rts
00A87C  2               
00A87C  1               	.include "lcd.s"
00A87C  2               SET_DDRAM_ADDR       = %10000000
00A87C  2               
00A87C  2               SET_CGRAM_ADDR       = %01000000
00A87C  2               
00A87C  2               FUNCTION_SET         = %00100000
00A87C  2               FUNCTION_8_BIT       = %00010000
00A87C  2               FUNCTION_2_LINE      = %00001000
00A87C  2               FUNCTION_5x10_FONT   = %00000100
00A87C  2               
00A87C  2               CD_SHIFT             = %00010000
00A87C  2               CD_SHIFT_DISPLAY     = %00001000
00A87C  2               CD_SHIFT_RIGHT       = %00000100
00A87C  2               
00A87C  2               
00A87C  2               DISPLAY_CONTROL      = %00001000
00A87C  2               DISPLAY_ON           = %00000100
00A87C  2               DISPLAY_CURSOR_ON    = %00000010
00A87C  2               DISPLAY_CURSOR_BLINK = %00000001
00A87C  2               
00A87C  2               ENTRY_MODE_SET       = %00000100
00A87C  2               ENTRY_MODE_INCREMENT = %00000010
00A87C  2               ENTRY_MODE_SHIFT     = %00000001
00A87C  2               
00A87C  2               RETURN_HOME          = %00000010
00A87C  2               
00A87C  2               CLEAR_DISPLAY        = %00000001
00A87C  2               
00A87C  2               
00A87C  2               E  = %10000000
00A87C  2               RW = %01000000
00A87C  2               RS = %00100000
00A87C  2               
00A87C  2               string_ptr = r0
00A87C  2               
00A87C  2               lcd_init:
00A87C  2  48             pha
00A87D  2  A9 78          lda #120
00A87F  2  20 86 A9       jsr wait_ms
00A882  2  A9 03          lda #%00000011 ; Sets to 8-bit mode; 1-line display; 5x8 font
00A884  2  20 BE A8       jsr lcd_instruction_send_command
00A887  2  A9 21          lda #33
00A889  2  20 86 A9       jsr wait_ms
00A88C  2  A9 03          lda #%00000011 ; Sets to 8-bit mode; 1-line display; 5x8 font
00A88E  2  20 BE A8       jsr lcd_instruction_send_command
00A891  2  A9 01          lda #1
00A893  2  20 86 A9       jsr wait_ms
00A896  2  A9 03          lda #%00000011 ; Sets to 8-bit mode; 1-line display; 5x8 font
00A898  2  20 BE A8       jsr lcd_instruction_send_command
00A89B  2  A9 01          lda #1
00A89D  2  20 86 A9       jsr wait_ms
00A8A0  2  A9 02          lda #%00000010 ; Sets to 4-bit mode
00A8A2  2  20 BE A8       jsr lcd_instruction_send_command
00A8A5  2  A9 28          lda #(FUNCTION_SET | FUNCTION_2_LINE) ; Sets to 4-bit mode; 2-line display; 5x8 font
00A8A7  2  20 BB A8       jsr lcd_instruction
00A8AA  2  A9 06          lda #(ENTRY_MODE_SET | ENTRY_MODE_INCREMENT) ; Entry mode set; increment and shift cursor; no scroll
00A8AC  2  20 BB A8       jsr lcd_instruction
00A8AF  2  A9 01          lda #CLEAR_DISPLAY ; Clear display
00A8B1  2  20 BB A8       jsr lcd_instruction
00A8B4  2  A9 0E          lda #(DISPLAY_CONTROL | DISPLAY_ON | DISPLAY_CURSOR_ON) ; Display on; cursor on; blink off
00A8B6  2  20 BB A8       jsr lcd_instruction
00A8B9  2  68             pla
00A8BA  2  60             rts
00A8BB  2               
00A8BB  2               lcd_instruction:
00A8BB  2  20 DB A8       jsr lcd_wait
00A8BE  2               lcd_instruction_send_command:
00A8BE  2  48             pha
00A8BF  2  4A             lsr            ; shift high nibble to low 4 bits
00A8C0  2  4A             lsr
00A8C1  2  4A             lsr
00A8C2  2  4A             lsr
00A8C3  2  09 80          ora #E         ; Sets E bit
00A8C5  2  8D 00 02       sta VIA1_PORTB
00A8C8  2               
00A8C8  2  49 80          eor #E         ; Clear E bit
00A8CA  2  8D 00 02       sta VIA1_PORTB
00A8CD  2               
00A8CD  2  68             pla
00A8CE  2  29 0F          and #%00001111 ; Mask high nibble
00A8D0  2  09 80          ora #E         ; Sets E bit
00A8D2  2  8D 00 02       sta VIA1_PORTB
00A8D5  2               
00A8D5  2  49 80          eor #E         ; Clear E bit
00A8D7  2  8D 00 02       sta VIA1_PORTB
00A8DA  2  60             rts
00A8DB  2               
00A8DB  2               lcd_wait:
00A8DB  2  48             pha
00A8DC  2  A9 F0          lda #%11110000 ; Port B D0-D3 are input
00A8DE  2  8D 02 02       sta VIA1_DDRB
00A8E1  2               lcd_wait_loop:
00A8E1  2  A9 40          lda #RW ; Set RW and pulse E to read LCD address
00A8E3  2  8D 00 02       sta VIA1_PORTB
00A8E6  2  A9 C0          lda #(RW | E)
00A8E8  2  8D 00 02       sta VIA1_PORTB
00A8EB  2  AD 00 02       lda VIA1_PORTB ; Read high bits from LCD
00A8EE  2  0A             asl
00A8EF  2  0A             asl
00A8F0  2  0A             asl
00A8F1  2  0A             asl
00A8F2  2  85 E2          sta lcd_addr ; Shift bits into high bits of byte
00A8F4  2  A9 40          lda #RW ; Set RW and pulse E to read LCD address
00A8F6  2  8D 00 02       sta VIA1_PORTB
00A8F9  2  A9 C0          lda #(RW | E)
00A8FB  2  8D 00 02       sta VIA1_PORTB
00A8FE  2  AD 00 02       lda VIA1_PORTB ; Read low bits from LCD
00A901  2  29 0F          and #%00001111 ; Mask off high bits which are not part of address
00A903  2  05 E2          ora lcd_addr ; Combine bits read with high bits and store complete address with busy flag
00A905  2  85 E2          sta lcd_addr
00A907  2  29 80          and #%10000000 ; Check busy flag
00A909  2  D0 D6          bne lcd_wait_loop
00A90B  2               
00A90B  2  A9 40          lda #RW
00A90D  2  8D 00 02       sta VIA1_PORTB
00A910  2  A9 FF          lda #%11111111 ; Port B is output
00A912  2  8D 02 02       sta VIA1_DDRB
00A915  2  68             pla
00A916  2  60             rts
00A917  2               
00A917  2               
00A917  2               lcd_clear:
00A917  2  A9 01          lda #CLEAR_DISPLAY ; Clear
00A919  2  20 BB A8       jsr lcd_instruction
00A91C  2               
00A91C  2               lcd_home:
00A91C  2  A9 02          lda #RETURN_HOME
00A91E  2  20 BB A8       jsr lcd_instruction
00A921  2  60             rts
00A922  2               
00A922  2               lcd_cursor_left:
00A922  2  A9 10          lda #CD_SHIFT
00A924  2  20 BB A8       jsr lcd_instruction
00A927  2  60             rts
00A928  2               
00A928  2               lcd_cursor_right:
00A928  2  A9 14          lda #(CD_SHIFT | CD_SHIFT_RIGHT)
00A92A  2  20 BB A8       jsr lcd_instruction
00A92D  2  60             rts
00A92E  2               
00A92E  2               lcd_screen_left:
00A92E  2  A9 18          lda #(CD_SHIFT | CD_SHIFT_DISPLAY)
00A930  2  20 BB A8       jsr lcd_instruction
00A933  2  60             rts
00A934  2               
00A934  2               lcd_screen_right:
00A934  2  A9 1C          lda #(CD_SHIFT | CD_SHIFT_DISPLAY | CD_SHIFT_RIGHT)
00A936  2  20 BB A8       jsr lcd_instruction
00A939  2  60             rts
00A93A  2               
00A93A  2               lcd_set_ddram_addr: ; Sets cursor position to value in A register
00A93A  2  09 80          ora #SET_DDRAM_ADDR
00A93C  2  20 BB A8       jsr lcd_instruction
00A93F  2  60             rts
00A940  2               
00A940  2               lcd_print_char:
00A940  2  48             pha
00A941  2  20 DB A8       jsr lcd_wait
00A944  2  4A             lsr            ; shift high nibble to low 4 bits
00A945  2  4A             lsr
00A946  2  4A             lsr
00A947  2  4A             lsr
00A948  2  09 20          ora #RS        ; Set RS, clear RW/E bits
00A94A  2  8D 00 02       sta VIA1_PORTB
00A94D  2               
00A94D  2  09 80          ora #E         ; Set E
00A94F  2  8D 00 02       sta VIA1_PORTB
00A952  2               
00A952  2  49 80          eor #E         ; Clear E
00A954  2  8D 00 02       sta VIA1_PORTB
00A957  2               
00A957  2  68             pla
00A958  2  48             pha
00A959  2  29 0F          and #%00001111 ; Mask high nibble
00A95B  2  09 20          ora #RS        ; Set RS, clear RW/E bits
00A95D  2  8D 00 02       sta VIA1_PORTB
00A960  2               
00A960  2  09 80          ora #E         ; Set E
00A962  2  8D 00 02       sta VIA1_PORTB
00A965  2               
00A965  2  49 80          eor #E         ; Clear E
00A967  2  8D 00 02       sta VIA1_PORTB
00A96A  2               
00A96A  2  68             pla
00A96B  2  60             rts
00A96C  2               
00A96C  2               lcd_new_line:
00A96C  2  48             pha
00A96D  2  A5 E2          lda lcd_addr
00A96F  2  69 40          adc #$40
00A971  2  29 40          and #$40
00A973  2  20 3A A9       jsr lcd_set_ddram_addr
00A976  2  68             pla
00A977  2  60             rts
00A978  2               
00A978  2               
00A978  2               
00A978  2               ; lcd_print_screen_buf
00A978  2               ;   ldx #0
00A978  2               ; lcd_print_screen_buf_loop:
00A978  2               ;   lda screen_buf,x
00A978  2               ;   beq lcd_print_screen_buf_return
00A978  2               ;   jsr lcd_print_char
00A978  2               ;   inx
00A978  2               ;   jmp lcd_print_screen_buf_loop
00A978  2               ; lcd_print_screen_buf_return
00A978  2               ;   rts
00A978  2               
00A978  2               ; print null terminated string located at address contained in s0
00A978  2               ; input r0
00A978  2               lcd_print:
00A978  2  A0 00          ldy #0
00A97A  2               lcd_print_loop:
00A97A  2  B1 E8          lda (string_ptr),y
00A97C  2  F0 07          beq lcd_print_return
00A97E  2  20 40 A9       jsr lcd_print_char
00A981  2  C8             iny
00A982  2  4C 7A A9       jmp lcd_print_loop
00A985  2               lcd_print_return:
00A985  2  60             rts
00A986  2               
00A986  2               ; push_char_screen_buf:
00A986  2               ;   pha
00A986  2               ;   ldx #0
00A986  2               
00A986  2               ; push_char_screen_buf_char_loop:
00A986  2               ;   lda screen_buf,x
00A986  2               ;   beq push_char_screen_buf_add_char
00A986  2               ;   inx
00A986  2               ;   jmp push_char_screen_buf_char_loop
00A986  2               
00A986  2               ; push_char_screen_buf_add_char:
00A986  2               ;   pla
00A986  2               ;   sta screen_buf,x
00A986  2               ;   inx
00A986  2               ;   stz screen_buf,x
00A986  2               ;   rts
00A986  2               
00A986  2               
00A986  1               	.include "utils.s"
00A986  2               wait_ms:
00A986  2  85 E8          sta r0
00A988  2  DA             phx
00A989  2  5A             phy
00A98A  2  A6 E8          ldx r0
00A98C  2               
00A98C  2  A0 BE          ldy #190
00A98E  2               wait_ms_loop1:
00A98E  2  EA             nop ; spin 2 cycles
00A98F  2  65 00          adc $00 ; spin 3 cycles
00A991  2  88             dey
00A992  2  D0 FA          bne wait_ms_loop1
00A994  2               
00A994  2               wait_ms_loop2:
00A994  2  CA             dex
00A995  2  F0 0C          beq wait_ms_return
00A997  2               
00A997  2  EA             nop
00A998  2  A0 C6          ldy #198
00A99A  2               wait_ms_loop3:
00A99A  2  EA             nop ; spin 2 cycles
00A99B  2  65 00          adc $00 ; spin 3 cycles
00A99D  2  88             dey
00A99E  2  D0 FA          bne wait_ms_loop3
00A9A0  2               
00A9A0  2  4C 94 A9       jmp wait_ms_loop2
00A9A3  2               
00A9A3  2               wait_ms_return:
00A9A3  2  7A             ply
00A9A4  2  FA             plx
00A9A5  2  A5 E8          lda r0
00A9A7  2  60             rts
00A9A8  2               
00A9A8  1               	.include "keyboard.s"
00A9A8  2               RELEASE   = %00000001
00A9A8  2               EXTENDED  = %00000010
00A9A8  2               CAPS_LOCK = %10000000
00A9A8  2               
00A9A8  2               L_SHIFT     = %00000001
00A9A8  2               R_SHIFT     = %00000010
00A9A8  2               L_ALT       = %00000100
00A9A8  2               R_ALT       = %00001000
00A9A8  2               L_CTRL      = %00010000
00A9A8  2               R_CTRL      = %00100000
00A9A8  2               L_GUI       = %01000000
00A9A8  2               R_GUI       = %10000000
00A9A8  2               
00A9A8  2               kb_init:
00A9A8  2  64 E3          stz kb_wptr
00A9AA  2  64 E4          stz kb_rptr
00A9AC  2  64 E5          stz kb_flags
00A9AE  2  64 E6          stz kb_modifiers
00A9B0  2  60             rts
00A9B1  2               
00A9B1  2               kb_handle:
00A9B1  2  DA             phx
00A9B2  2               
00A9B2  2  A5 E5          lda kb_flags
00A9B4  2  29 02          and #EXTENDED
00A9B6  2  D0 1A          bne read_byte_extended
00A9B8  2               
00A9B8  2  A5 E5          lda kb_flags
00A9BA  2  29 01          and #RELEASE
00A9BC  2  F0 3C          beq read_key
00A9BE  2               
00A9BE  2  A5 E5          lda kb_flags
00A9C0  2  49 01          eor #RELEASE
00A9C2  2  85 E5          sta kb_flags
00A9C4  2  AD 01 02       lda VIA1_PORTA
00A9C7  2  C9 12          cmp #$12
00A9C9  2  F0 1D          beq l_shfit_up
00A9CB  2  C9 59          cmp #$59
00A9CD  2  F0 22          beq r_shfit_up
00A9CF  2  4C B4 AA       jmp kb_handle_return
00A9D2  2               
00A9D2  2               read_byte_extended
00A9D2  2  A5 E5          lda kb_flags
00A9D4  2  49 02          eor #EXTENDED
00A9D6  2  85 E5          sta kb_flags
00A9D8  2  29 01          and #RELEASE
00A9DA  2  F0 69          beq read_key_extended
00A9DC  2  A5 E5          lda kb_flags
00A9DE  2  49 01          eor #RELEASE
00A9E0  2  85 E5          sta kb_flags
00A9E2  2  AD 01 02       lda VIA1_PORTA
00A9E5  2  4C B4 AA       jmp kb_handle_return
00A9E8  2               
00A9E8  2               l_shfit_up:
00A9E8  2  A5 E6          lda kb_modifiers
00A9EA  2  49 01          eor #L_SHIFT
00A9EC  2  85 E6          sta kb_modifiers
00A9EE  2  4C B4 AA       jmp kb_handle_return
00A9F1  2               r_shfit_up:
00A9F1  2  A5 E6          lda kb_modifiers
00A9F3  2  49 02          eor #R_SHIFT
00A9F5  2  85 E6          sta kb_modifiers
00A9F7  2  4C B4 AA       jmp kb_handle_return
00A9FA  2               
00A9FA  2               read_key:
00A9FA  2  AD 01 02       lda VIA1_PORTA
00A9FD  2  C9 F0          cmp #$F0
00A9FF  2  F0 3B          beq key_released
00AA01  2  C9 E0          cmp #$E0
00AA03  2  F0 56          beq extended
00AA05  2  C9 12          cmp #$12
00AA07  2  F0 5B          beq l_shift_down
00AA09  2  C9 59          cmp #$59
00AA0B  2  F0 60          beq r_shift_down
00AA0D  2  C9 58          cmp #$58
00AA0F  2  F0 65          beq caps_lock_down
00AA11  2                 ; cmp #$76
00AA11  2                 ; beq esc_down
00AA11  2                 ; cmp #$66
00AA11  2                 ; beq backspace_down
00AA11  2                 ; cmp #$5A
00AA11  2                 ; beq enter_down
00AA11  2               
00AA11  2  AA             tax
00AA12  2  A5 E6          lda kb_modifiers
00AA14  2  29 01          and #L_SHIFT
00AA16  2  D0 17          bne shifted_key
00AA18  2  A5 E6          lda kb_modifiers
00AA1A  2  29 02          and #R_SHIFT
00AA1C  2  D0 11          bne shifted_key
00AA1E  2  A5 E5          lda kb_flags
00AA20  2  29 80          and #CAPS_LOCK
00AA22  2  D0 70          bne caps_lock_key
00AA24  2               
00AA24  2  BD 00 AB       lda keymap,x
00AA27  2  4C 32 AA       jmp push_key
00AA2A  2               
00AA2A  2               char_is_a_to_z
00AA2A  2  E9 20          sbc #$20
00AA2C  2  4C 32 AA       jmp push_key
00AA2F  2               
00AA2F  2               shifted_key:
00AA2F  2  BD 00 AC       lda keymap_shifted,x
00AA32  2               
00AA32  2               push_key:
00AA32  2  A6 E3          ldx kb_wptr
00AA34  2  9D 00 04       sta kb_buffer,x
00AA37  2  E6 E3          inc kb_wptr
00AA39  2  4C B4 AA       jmp kb_handle_return
00AA3C  2               
00AA3C  2               key_released:
00AA3C  2  A5 E5          lda kb_flags
00AA3E  2  09 01          ora #RELEASE
00AA40  2  85 E5          sta kb_flags
00AA42  2  4C B4 AA       jmp kb_handle_return
00AA45  2               
00AA45  2               read_key_extended:
00AA45  2  AD 01 02       lda VIA1_PORTA
00AA48  2  C9 F0          cmp #$F0
00AA4A  2  F0 F0          beq key_released
00AA4C  2  C9 6B          cmp #$6B
00AA4E  2  F0 53          beq left_down
00AA50  2  C9 74          cmp #$74
00AA52  2  F0 55          beq right_down
00AA54  2  C9 71          cmp #$71
00AA56  2  F0 57          beq del_down
00AA58  2  4C B4 AA       jmp kb_handle_return
00AA5B  2               
00AA5B  2               extended:
00AA5B  2  A5 E5          lda kb_flags
00AA5D  2  09 02          ora #EXTENDED
00AA5F  2  85 E5          sta kb_flags
00AA61  2  4C B4 AA       jmp kb_handle_return
00AA64  2               
00AA64  2               l_shift_down:
00AA64  2  A5 E6          lda kb_modifiers
00AA66  2  09 01          ora #L_SHIFT
00AA68  2  85 E6          sta kb_modifiers
00AA6A  2  4C B4 AA       jmp kb_handle_return
00AA6D  2               
00AA6D  2               r_shift_down:
00AA6D  2  A5 E6          lda kb_modifiers
00AA6F  2  09 02          ora #R_SHIFT
00AA71  2  85 E6          sta kb_modifiers
00AA73  2  4C B4 AA       jmp kb_handle_return
00AA76  2               
00AA76  2               caps_lock_down:
00AA76  2  A5 E5          lda kb_flags
00AA78  2  49 80          eor #CAPS_LOCK
00AA7A  2  85 E5          sta kb_flags
00AA7C  2  4C B4 AA       jmp kb_handle_return
00AA7F  2               
00AA7F  2               ; esc_down:
00AA7F  2               ;   jsr lcd_clear
00AA7F  2               ;   jmp kb_handle_return
00AA7F  2               
00AA7F  2               ; backspace_down:
00AA7F  2               ;   jsr lcd_cursor_left
00AA7F  2               ;   lda #' '
00AA7F  2               ;   jsr lcd_print_char
00AA7F  2               ;   jsr lcd_cursor_left
00AA7F  2               ;   jmp kb_handle_return
00AA7F  2               
00AA7F  2               enter_down:
00AA7F  2  A9 0A          lda #$0A
00AA81  2  A6 E3          ldx kb_wptr
00AA83  2  9D 00 04       sta kb_buffer,x
00AA86  2  E6 E3          inc kb_wptr
00AA88  2  A9 0D          lda #$0D
00AA8A  2  A6 E3          ldx kb_wptr
00AA8C  2  9D 00 04       sta kb_buffer,x
00AA8F  2  E6 E3          inc kb_wptr
00AA91  2  4C B4 AA       jmp kb_handle_return
00AA94  2               
00AA94  2               ;   jsr lcd_new_line
00AA94  2               ;   jmp kb_handle_return
00AA94  2               
00AA94  2               caps_lock_key:
00AA94  2  BD 00 AB       lda keymap,x
00AA97  2  AA             tax
00AA98  2  18             clc
00AA99  2  69 85          adc #($FF - 'z')
00AA9B  2  69 1A          adc #('z' - 'a' + 1)
00AA9D  2  8A             txa
00AA9E  2  B0 8A          bcs char_is_a_to_z
00AAA0  2  4C 32 AA       jmp push_key
00AAA3  2               
00AAA3  2               left_down:
00AAA3  2  20 34 A9       jsr lcd_screen_right
00AAA6  2  4C B4 AA       jmp kb_handle_return
00AAA9  2               
00AAA9  2               right_down:
00AAA9  2  20 2E A9       jsr lcd_screen_left
00AAAC  2  4C B4 AA       jmp kb_handle_return
00AAAF  2               
00AAAF  2               del_down:
00AAAF  2  A9 7F          lda #$7F
00AAB1  2  4C 32 AA       jmp push_key
00AAB4  2               
00AAB4  2               kb_handle_return:
00AAB4  2  FA             plx
00AAB5  2  60             rts
00AAB6  2               
00AAB6  2  xx xx xx xx  .align 256
00AABA  2  xx xx xx xx  
00AABE  2  xx xx xx xx  
00AB00  2               keymap:
00AB00  2                 ;      0123456789ABCDEF
00AB00  2  3F 3F 3F 3F    .byte "?????????????"
00AB04  2  3F 3F 3F 3F  
00AB08  2  3F 3F 3F 3F  
00AB0D  2  09             .byte $09 ; 0D TAB
00AB0E  2  60 3F          .byte               "`?" ; 0
00AB10  2  3F 3F 3F 3F    .byte "?????q1???zsaw2?" ; 1
00AB14  2  3F 71 31 3F  
00AB18  2  3F 3F 7A 73  
00AB20  2  3F 63 78 64    .byte "?cxde43?? vftr5?" ; 2
00AB24  2  65 34 33 3F  
00AB28  2  3F 20 76 66  
00AB30  2  3F 6E 62 68    .byte "?nbhgy6???mju78?" ; 3
00AB34  2  67 79 36 3F  
00AB38  2  3F 3F 6D 6A  
00AB40  2  3F 2C 6B 69    .byte "?,kio09??./l;p-?" ; 4
00AB44  2  6F 30 39 3F  
00AB48  2  3F 2E 2F 6C  
00AB50  2  3F 3F 27 3F    .byte "??'?[=????"       ; 5
00AB54  2  5B 3D 3F 3F  
00AB58  2  3F 3F        
00AB5A  2  0D             .byte $0D ; 5A ENT
00AB5B  2  5D 3F 5C 3F    .byte            "]?\??" ; 5
00AB5F  2  3F           
00AB60  2  3F 3F 3F 3F    .byte "??????"
00AB64  2  3F 3F        
00AB66  2  08             .byte $08 ; 66 BS
00AB67  2  3F 3F 31 3F    .byte        "??1?47???" ; 6
00AB6B  2  34 37 3F 3F  
00AB6F  2  3F           
00AB70  2  30 2E 32 35    .byte "0.2568"
00AB74  2  36 38        
00AB76  2  1B             .byte $1B ; 76 ESC
00AB77  2  3F 3F 2B 33    .byte        "??+3-*9??" ; 7
00AB7B  2  2D 2A 39 3F  
00AB7F  2  3F           
00AB80  2  3F 3F 3F 3F    .byte "????????????????" ; 8
00AB84  2  3F 3F 3F 3F  
00AB88  2  3F 3F 3F 3F  
00AB90  2  3F 3F 3F 3F    .byte "????????????????" ; 9
00AB94  2  3F 3F 3F 3F  
00AB98  2  3F 3F 3F 3F  
00ABA0  2  3F 3F 3F 3F    .byte "????????????????" ; A
00ABA4  2  3F 3F 3F 3F  
00ABA8  2  3F 3F 3F 3F  
00ABB0  2  3F 3F 3F 3F    .byte "????????????????" ; B
00ABB4  2  3F 3F 3F 3F  
00ABB8  2  3F 3F 3F 3F  
00ABC0  2  3F 3F 3F 3F    .byte "????????????????" ; C
00ABC4  2  3F 3F 3F 3F  
00ABC8  2  3F 3F 3F 3F  
00ABD0  2  3F 3F 3F 3F    .byte "????????????????" ; D
00ABD4  2  3F 3F 3F 3F  
00ABD8  2  3F 3F 3F 3F  
00ABE0  2  3F 3F 3F 3F    .byte "????????????????" ; E
00ABE4  2  3F 3F 3F 3F  
00ABE8  2  3F 3F 3F 3F  
00ABF0  2  3F 3F 3F 3F    .byte "????????????????" ; F
00ABF4  2  3F 3F 3F 3F  
00ABF8  2  3F 3F 3F 3F  
00AC00  2               keymap_shifted:
00AC00  2                 ;      0123456789ABCDEF
00AC00  2  3F 3F 3F 3F    .byte "?????????????"
00AC04  2  3F 3F 3F 3F  
00AC08  2  3F 3F 3F 3F  
00AC0D  2  09             .byte $09 ; 0D TAB
00AC0E  2  7E 3F          .byte               "~?" ; 0
00AC10  2  3F 3F 3F 3F    .byte "?????Q!???ZSAW@?" ; 1
00AC14  2  3F 51 21 3F  
00AC18  2  3F 3F 5A 53  
00AC20  2  3F 43 58 44    .byte "?CXDE$#?? VFTR%?" ; 2
00AC24  2  45 24 23 3F  
00AC28  2  3F 20 56 46  
00AC30  2  3F 4E 42 48    .byte "?NBHGY^???MJU&*?" ; 3
00AC34  2  47 59 5E 3F  
00AC38  2  3F 3F 4D 4A  
00AC40  2  3F 3C 4B 49    .byte "?<KIO)(??>?L:P_?" ; 4
00AC44  2  4F 29 28 3F  
00AC48  2  3F 3E 3F 4C  
00AC50  2  3F 3F          .byte "??"               ; 5
00AC52  2  22             .byte   '"'              ; 5
00AC53  2  3F 7B 2B 3F    .byte    "?{+????"       ; 5
00AC57  2  3F 3F 3F     
00AC5A  2  0D             .byte $0D ; 5A ENT
00AC5B  2  7D 3F 7C 3F    .byte            "}?|??" ; 5
00AC5F  2  3F           
00AC60  2  3F 3F 3F 3F    .byte "??????"
00AC64  2  3F 3F        
00AC66  2  08             .byte $08 ; 66 BS
00AC67  2  3F 3F 31 3F    .byte        "??1?47???" ; 6
00AC6B  2  34 37 3F 3F  
00AC6F  2  3F           
00AC70  2  30 2E 32 35    .byte "0.2568"
00AC74  2  36 38        
00AC76  2  1B             .byte $1B ; 76 ESC
00AC77  2  3F 3F 2B 33    .byte        "??+3-*9??" ; 7
00AC7B  2  2D 2A 39 3F  
00AC7F  2  3F           
00AC80  2  3F 3F 3F 3F    .byte "????????????????" ; 8
00AC84  2  3F 3F 3F 3F  
00AC88  2  3F 3F 3F 3F  
00AC90  2  3F 3F 3F 3F    .byte "????????????????" ; 9
00AC94  2  3F 3F 3F 3F  
00AC98  2  3F 3F 3F 3F  
00ACA0  2  3F 3F 3F 3F    .byte "????????????????" ; A
00ACA4  2  3F 3F 3F 3F  
00ACA8  2  3F 3F 3F 3F  
00ACB0  2  3F 3F 3F 3F    .byte "????????????????" ; B
00ACB4  2  3F 3F 3F 3F  
00ACB8  2  3F 3F 3F 3F  
00ACC0  2  3F 3F 3F 3F    .byte "????????????????" ; C
00ACC4  2  3F 3F 3F 3F  
00ACC8  2  3F 3F 3F 3F  
00ACD0  2  3F 3F 3F 3F    .byte "????????????????" ; D
00ACD4  2  3F 3F 3F 3F  
00ACD8  2  3F 3F 3F 3F  
00ACE0  2  3F 3F 3F 3F    .byte "????????????????" ; E
00ACE4  2  3F 3F 3F 3F  
00ACE8  2  3F 3F 3F 3F  
00ACF0  2  3F 3F 3F 3F    .byte "????????????????" ; F
00ACF4  2  3F 3F 3F 3F  
00ACF8  2  3F 3F 3F 3F  
00AD00  2               
00AD00  1               
00AD00  1               ; ; Defines
00AD00  1               ; r0 = $E2 ; 2 bytes
00AD00  1               ; r0L = $E2 ; low byte
00AD00  1               ; r0H = $E3 ; high byte
00AD00  1               ; r1 = $E4 ; 2 bytes
00AD00  1               ; r1L = $E4 ; low byte
00AD00  1               ; r1H = $E5 ; high byte
00AD00  1               ; r2 = $E6 ; 2 bytes
00AD00  1               ; r2L = $E6 ; low byte
00AD00  1               ; r2H = $E7 ; high byte
00AD00  1               ; r3 = $E8 ; 2 bytes
00AD00  1               ; r3L = $E8 ; low byte
00AD00  1               ; r3H = $E9 ; high byte
00AD00  1               ; lcd_addr = $EA ; 1 byte, lcd busy flag and address
00AD00  1               ; kb_wptr = $EB ; 1 byte
00AD00  1               ; kb_rptr = $EC ; 1 byte
00AD00  1               ; kb_flags = $ED ; 1 byte
00AD00  1               ; kb_modifiers = $EE ; 1 byte
00AD00  1               ; ACIA := $0220
00AD00  1               ; ACIAData := ACIA+0
00AD00  1               ; ACIAStatus := ACIA+1
00AD00  1               ; ACIAReset := ACIA+1
00AD00  1               ; ACIACommand := ACIA+2
00AD00  1               ; ACIAControl := ACIA+3
00AD00  1               kb_buffer = $0400 ; 256 bytes 0x0400-0x04ff
00AD00  1               
00AD00  1               ; Put the IRQ and NMI code in RAM so that it can be changed
00AD00  1               
00AD00  1               IRQ_vec	= VEC_SV+2	; IRQ code vector
00AD00  1               NMI_vec	= IRQ_vec+$0A	; NMI code vector
00AD00  1               
00AD00  1               ; Now the code. all this does is set up the vectors and interrupt code
00AD00  1               ; and wait for the user to select [C]old or [W]arm start. Nothing else.
00AD00  1               ; Fits in less than 128 bytes
00AD00  1               
00AD00  1               ; Reset vector points here
00AD00  1               
00AD00  1               RES_vec
00AD00  1  D8           	CLD				; clear decimal mode
00AD01  1  A2 FF        	LDX	#$FF			; empty stack
00AD03  1  9A           	TXS				; set the stack
00AD04  1               
00AD04  1  20 67 A8     	jsr via_init
00AD07  1  20 7C A8     	jsr lcd_init
00AD0A  1  20 28 A8     	jsr acia_init
00AD0D  1  20 A8 A9     	jsr kb_init
00AD10  1  58           	cli
00AD11  1               
00AD11  1  A2 00        	ldx #0
00AD13  1               PrintWelcome
00AD13  1  BD B4 AD     	lda WELCOME_mess,x
00AD16  1  F0 07        	beq print_next
00AD18  1  20 40 A9     	jsr lcd_print_char
00AD1B  1  E8           	inx
00AD1C  1  4C 13 AD     	jmp PrintWelcome
00AD1F  1               print_next
00AD1F  1  20 6C A9     	jsr lcd_new_line
00AD22  1  A2 00        	ldx #0
00AD24  1               PrintBASIC
00AD24  1  BD C5 AD     	lda BASIC_mess,x
00AD27  1  F0 07        	beq PrintDone
00AD29  1  20 40 A9     	jsr lcd_print_char
00AD2C  1  E8           	inx
00AD2D  1  4C 24 AD     	jmp PrintBASIC
00AD30  1               PrintDone
00AD30  1               
00AD30  1                   ; STZ ACIAReset
00AD30  1               
00AD30  1               	; LDA #$10		; Set ACIA baud rate, word size and Rx interrupt (to control RTS)
00AD30  1               	; STA	ACIAControl
00AD30  1               
00AD30  1                   ; LDA #$0B
00AD30  1                   ; STA ACIACommand
00AD30  1               
00AD30  1               ; Set up vectors and interrupt code, copy them to page 2.
00AD30  1               
00AD30  1  A0 1F        	LDY	#END_CODE-LAB_vec	; set index/count
00AD32  1               LAB_stlp
00AD32  1  B9 75 AD     	LDA	LAB_vec-1,Y		; get byte from interrupt code
00AD35  1  99 04 03     	STA	VEC_IN-1,Y		; save to RAM
00AD38  1  88           	DEY				; decrement index/count
00AD39  1  D0 F7        	BNE	LAB_stlp		; loop if more to do
00AD3B  1               
00AD3B  1               ; Now do the signon message, Y = $00 here
00AD3B  1               
00AD3B  1               LAB_signon
00AD3B  1  B9 95 AD     	LDA	LAB_mess,Y		; get byte from sign on message
00AD3E  1  F0 06        	BEQ	LAB_nokey		; exit loop if done
00AD40  1               
00AD40  1  20 F0 A0     	JSR	V_OUTP		        ; output character
00AD43  1  C8           	INY				; increment index
00AD44  1  D0 F5        	BNE	LAB_signon		; loop, branch always
00AD46  1               
00AD46  1               LAB_nokey
00AD46  1  20 ED A0     	JSR	V_INPT                  ; call scan input device
00AD49  1  90 FB        	BCC	LAB_nokey		; loop if no key
00AD4B  1               
00AD4B  1  29 DF        	AND	#$DF			; mask xx0x xxxx, ensure upper case
00AD4D  1               
00AD4D  1  C9 57        	CMP	#'W'			; compare with [W]arm start
00AD4F  1  F0 07        	BEQ	LAB_dowarm		; branch if [W]arm start
00AD51  1               
00AD51  1  C9 43        	CMP	#'C'			; compare with [C]old start
00AD53  1  D0 AB        	BNE	RES_vec		        ; loop if not [C]old start
00AD55  1               
00AD55  1  4C 03 80     	JMP	LAB_COLD		; do EhBASIC cold start
00AD58  1               
00AD58  1               LAB_dowarm
00AD58  1  4C 00 00     	JMP	LAB_WARM		; do EhBASIC warm start
00AD5B  1               
00AD5B  1               ; Byte out to serial console
00AD5B  1               
00AD5B  1               SCRNout
00AD5B  1  20 38 A8     	jsr acia_write
00AD5E  1  60           	rts
00AD5F  1               
00AD5F  1               ; Byte in from serial console
00AD5F  1               
00AD5F  1               KBDin
00AD5F  1               	; jsr acia_check
00AD5F  1               	; rts
00AD5F  1  78           	sei
00AD60  1  A5 E4        	lda kb_rptr
00AD62  1  C5 E3        	cmp kb_wptr
00AD64  1  58           	cli
00AD65  1  F0 09        	beq NoDataIn
00AD67  1  A6 E4        	ldx kb_rptr
00AD69  1  BD 00 04     	lda kb_buffer,x
00AD6C  1  E6 E4        	inc kb_rptr
00AD6E  1  38           	sec
00AD6F  1  60           	rts
00AD70  1               NoDataIn:
00AD70  1  20 4A A8     	jsr acia_check
00AD73  1               	; CLC		                ; Carry clear if no key pressed
00AD73  1  60           	RTS
00AD74  1               
00AD74  1               
00AD74  1               ; LOAD - currently does nothing.
00AD74  1               SBCload				        ; load vector for EhBASIC
00AD74  1  60           	RTS
00AD75  1               
00AD75  1               ; SAVE - currently does nothing.
00AD75  1               SBCsave				        ; save vector for EhBASIC
00AD75  1  60           	RTS
00AD76  1               
00AD76  1               ; vector tables
00AD76  1               
00AD76  1               LAB_vec
00AD76  1  5F AD        	.word	KBDin                   ; byte in from keyboard
00AD78  1  5B AD        	.word	SCRNout		        ; byte out to screen
00AD7A  1  74 AD        	.word	SBCload		        ; load vector for EhBASIC
00AD7C  1  75 AD        	.word	SBCsave		        ; save vector for EhBASIC
00AD7E  1               
00AD7E  1               ; EhBASIC IRQ support
00AD7E  1               
00AD7E  1               IRQ_CODE
00AD7E  1  48           	PHA				; save A
00AD7F  1  20 B1 A9     	jsr kb_handle
00AD82  1  A5 DF        	LDA	IrqBase		        ; get the IRQ flag byte
00AD84  1  4A           	LSR				; shift the set b7 to b6, and on down ...
00AD85  1  05 DF        	ORA	IrqBase		        ; OR the original back in
00AD87  1  85 DF        	STA	IrqBase		        ; save the new IRQ flag byte
00AD89  1  68           	PLA				; restore A
00AD8A  1  40           	RTI
00AD8B  1               
00AD8B  1               ; EhBASIC NMI support
00AD8B  1               
00AD8B  1               NMI_CODE
00AD8B  1  48           	PHA				; save A
00AD8C  1  A5 DC        	LDA	NmiBase		        ; get the NMI flag byte
00AD8E  1  4A           	LSR				; shift the set b7 to b6, and on down ...
00AD8F  1  05 DC        	ORA	NmiBase		        ; OR the original back in
00AD91  1  85 DC        	STA	NmiBase		        ; save the new NMI flag byte
00AD93  1  68           	PLA				; restore A
00AD94  1  40           	RTI
00AD95  1               
00AD95  1               END_CODE
00AD95  1               
00AD95  1               LAB_mess
00AD95  1  0D 0A 36 35  	.byte	$0D,$0A,"6502 EhBASIC",$0D,$0A, "[C]old/[W]arm?",$00
00AD99  1  30 32 20 45  
00AD9D  1  68 42 41 53  
00ADB4  1               					; sign on string
00ADB4  1               
00ADB4  1               WELCOME_mess
00ADB4  1  20 57 65 6C  	.byte	" Welcome:  6502 ",$00
00ADB8  1  63 6F 6D 65  
00ADBC  1  3A 20 20 36  
00ADC5  1               					; Welcome string
00ADC5  1               
00ADC5  1               BASIC_mess
00ADC5  1  20 45 68 42  	.byte	" EhBASIC  v2.22 ",$00
00ADC9  1  41 53 49 43  
00ADCD  1  20 20 76 32  
00ADD6  1               					; EhBASIC v string
00ADD6  1               
00ADD6  1               ; system vectors
00ADD6  1               
00ADD6  1                       ; .res    $FFFA-*
00ADD6  1               .segment "VECTORS"
00ADD6  1  17 03        	.word	NMI_vec		; NMI vector
00ADD8  1  00 AD        	.word	RES_vec		; RESET vector
00ADDA  1  0D 03        	.word	IRQ_vec		; IRQ vector
00ADDA  1               
