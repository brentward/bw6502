ca65 V2.18 - N/A
Main file   : bw6502.s
Current file: bw6502.s

000000r 1               
000000r 1               ; Minimal monitor for my 6502 Single Board Computer.
000000r 1               .setcpu "65C02"
000000r 1               .code
000000r 1               
000000r 1               	.include "basic22p5.s"
000000r 2               ;
000000r 2               ; Enhanced BASIC for the C02 Pocket SBC, Version 2.22p5C02
000000r 2               ; Original version/source by Lee Davison w/updates to Version 2.22
000000r 2               ; Patches and updates by Klaus Dorman Version 2.22p4 - see below
000000r 2               ; "C" is appended to define CMOS instructions/addressing modes used
000000r 2               ; "C02" is appemded to define CMOS only and working with C02Monitor/C02BIOS
000000r 2               ; Modified source code to assemble with WDC Tools package
000000r 2               ; Changes by K. E. Maier - July-November 2018
000000r 2               ;   minor changes and cleanup as of 13th November 2018
000000r 2               ;
000000r 2               ; Additional functions added 25th September 2019
000000r 2               ;   LOAD/SAVE functions via Xmodem-CRC routines in C02Monitor Version 2.03
000000r 2               ;
000000r 2               ; Additional patches added. Klaus provided a 2.22p5 patched version 13th January 2020
000000r 2               ; those patches are included here, albeit not in identical code for all patches
000000r 2               ;
000000r 2               ; NOTE: a couple patches to correct p5 patches on 27th February 2020 - oops
000000r 2               ;
000000r 2               ; NOTE: startup code is now contained here. Any Monitor or OS can now call the
000000r 2               ; ROM start location of EhBasic. Five Monitor/OS routines are required for the
000000r 2               ; core functions required: CHRIN, CHROUT, LOAD, SAVE, EXIT.
000000r 2               ; These are defined below. - 31st March, 2020
000000r 2               ;
000000r 2               ; Several of the Basic messages have been abbreviated to keep ROM space below $2700 bytes.
000000r 2               ; Well, We blew past $2700 on size after including all the startup code, so Basic messages
000000r 2               ; have been restored to their original text... sniff. It's still less than 10KB, so yeah!
000000r 2               ; Latest version shows as version 2.22p5C02 - 23rd May, 2020
000000r 2               ;
000000r 2               ;       Assembler/Linker directives for WDC Tools
000000r 2               ;
000000r 2                       ; PL      66      ;Page Length
000000r 2                       ; PW      132     ;Page Width (# of char/line)
000000r 2                       ; CHIP    W65C02S ;Enable WDC 65C02 instructions/addressing modes
000000r 2                       ; INCLIST ON      ;Include listing file
000000r 2                       ; PASS1   OFF     ;Set ON when used for debug
000000r 2               ;
000000r 2               ; Code changes include:
000000r 2               ;  Use ROM based CHRGET/CHRGOT routine with Page Zero pointer
000000r 2               ;  All Page zero usage is from the bottom ($00) up ($AF is max available)
000000r 2               ;  CMOS opcodes/addressing modes are used! tested with WDC65C02 only!
000000r 2               ;  Note: new instructions used include SMBx, RMBx, BBSx, BBRx! Note that
000000r 2               ;  this version will NOT run on a W65C816 in emulation mode!!
000000r 2               ;  Version renamed to Ver 2.22p5C02 (concurrency with Klaus' patched version)
000000r 2               ;
000000r 2               ; The following functions and all associated code (interrupt related)
000000r 2               ;  have been removed as they aren't needed with the C02 Pocket SBC:
000000r 2               ; - IRQ
000000r 2               ; - RETIRQ
000000r 2               ; - NMI
000000r 2               ; - RETNMI
000000r 2               ; - OFF
000000r 2               ; It is known that the interrupt functions above were not fully implemented
000000r 2               ; and didn't really work without additional coding. As the NMI routine is a
000000r 2               ; Panic routine on the C02 Pocket SBC, there's no need to support this one.
000000r 2               ; Also, the C02 Pocket SBC has a full IRQ code stack that is extendable. It
000000r 2               ; provides full support for the SCC2691 UART for Transmit, Receive, Break,
000000r 2               ; a 10ms jiffy-clock plus delays and a benchmark timer. These routines can
000000r 2               ; be called via JMP table entries in the C02 BIOS and Monitor. They could
000000r 2               ; also be added as additional Basic Commands, but I don't have any current
000000r 2               ; plan to do so as of now.
000000r 2               ;
000000r 2               ; NOTE: BASIC Tokens are NOT the same due to removal of the above commands!!
000000r 2               ; This would only be a problem if someone did a binary save of a BASIC program
000000r 2               ; from the original code and then loaded it to this version of Basic. This is
000000r 2               ; unlikely however, as the original Enhanced Basic had NO Load or Save functions
000000r 2               ; implemented! Also note that Lee (when asked) recommended that Load and Save be
000000r 2               ; implemented using the LIST function redirected to Save and Basic Entry for Load.
000000r 2               ;
000000r 2               ; NOTE: The LOAD and SAVE functions implemented in this version are done as Binary!
000000r 2               ; The actual Load and Save routines are contained in the C02 Monitor code and called
000000r 2               ; via vectors. The C02 Monitor uses Xmodem-CRC for transferring data to and from
000000r 2               ; the host machine running the terminal emulator. Serial (OSX) and ExtraPutty have
000000r 2               ; been tested and work properly.
000000r 2               ;
000000r 2               ; An EXIT primary command has been added
000000r 2               ;  The EXIT command performs a JMP to the C02Monitor Warm start vector
000000r 2               ;  EhBasic can be re-entered via Warm start unless pages zero/four are changed
000000r 2               ;
000000r 2               ; 2.00      new revision numbers start here
000000r 2               ; 2.01      fixed LCASE$() and UCASE$()
000000r 2               ; 2.02      new get value routine done
000000r 2               ; 2.03      changed RND() to galoise method
000000r 2               ; 2.04      fixed SPC()
000000r 2               ; 2.05      new get value routine fixed
000000r 2               ; 2.06      changed USR() code
000000r 2               ; 2.07      fixed STR$()
000000r 2               ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09      fixed RND()
000000r 2               ; 2.10      integrated missed changes from an earlier version
000000r 2               ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21      fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22      fixed RND() breaking the get byte routine
000000r 2               ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
000000r 2               ;              (bugsnquirks.txt notes 2, 4 and 5)
000000r 2               ;              tabs converted to spaces, tabwidth=6
000000r 2               ; 2.22p2    fixed can't continue error on 1st statement after direct mode
000000r 2               ;              changed INPUT to throw "break in line ##" on empty line input
000000r 2               ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
000000r 2               ;              fix provided by github user mgcaret
000000r 2               ;              fixed string compare of equal strings in direct mode returns FALSE
000000r 2               ; 2.22p4    fixed FALSE stored to a variable after a string compare
000000r 2               ;                 is > 0 and < 1E-16
000000r 2               ;              added additional stack floor protection for background interrupts
000000r 2               ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
000000r 2               ; 2.22p4C   Port to C02 Pocket SBC - SCC2691 UART Console, 32KB RAM / 32KB ROM, 6MHz CPU
000000r 2               ;
000000r 2               ; 2.22p5C   Updates from Klaus for specific bug fixes added to the CMOS version
000000r 2               ;
000000r 2               ZPSTART         = $00        ; Start of zero page workspace
000000r 2               ;
000000r 2               LAB_WARM        = ZPSTART    ; $00=BASIC warm start entry point
000000r 2               Wrmjpl          = LAB_WARM+1 ; BASIC warm start vector jump low byte
000000r 2               Wrmjph          = LAB_WARM+2 ; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp          = Wrmjph+1   ; USR function JMP address
000000r 2               Usrjpl          = Usrjmp+1   ; USR function JMP vector low byte
000000r 2               Usrjph          = Usrjmp+2   ; USR function JMP vector high byte
000000r 2               
000000r 2               Nullct          = Usrjph+1   ; nulls output after each line
000000r 2               TPos            = Nullct+1   ; BASIC terminal position byte
000000r 2               TWidth          = TPos+1     ; BASIC terminal width byte
000000r 2               Iclim           = TWidth+1   ; input column limit
000000r 2               Itempl          = Iclim+1    ; temporary integer low byte
000000r 2               Itemph          = Itempl+1   ; temporary integer high byte
000000r 2               
000000r 2               nums_1          = Itempl     ; number to bin/hex string convert MSB
000000r 2               nums_2          = nums_1+1   ; number to bin/hex string convert
000000r 2               nums_3          = nums_1+2   ; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc           = nums_3+1   ; search character
000000r 2               Temp3           = Srchc      ; temp byte used in number routines
000000r 2               Scnquo          = Srchc+1    ; scan-between-quotes flag
000000r 2               Asrch           = Scnquo     ; alt search character
000000r 2               
000000r 2               XOAw_l          = Srchc      ; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h          = Scnquo     ; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr           = Scnquo+1   ; input buffer pointer
000000r 2               Dimcnt          = Ibptr      ; # of dimensions
000000r 2               Tindx           = Ibptr      ; token index
000000r 2               
000000r 2               Defdim          = Ibptr+1    ; default DIM flag
000000r 2               Dtypef          = Defdim+1   ; data type flag, $FF=string, $00=numeric
000000r 2               Oquote          = Dtypef+1   ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd          = Oquote     ; garbage collected flag
000000r 2               Sufnxf          = Gclctd+1   ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode           = Sufnxf+1   ; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag           = Imode+1    ; comparison evaluation flag
000000r 2               
000000r 2               TabSiz          = Cflag+1    ; TAB step size (was input flag)
000000r 2               
000000r 2               next_s          = TabSiz+1   ; next descriptor stack address
000000r 2               
000000r 2               ; these two bytes form a word pointer to the item
000000r 2               ; currently on top of the descriptor stack
000000r 2               
000000r 2               last_sl         = next_s+1   ; last descriptor stack address low byte
000000r 2               last_sh         = last_sl+1  ; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk          = last_sh+1  ; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ut1_pl          = des_sk+9   ; utility pointer 1 low byte
000000r 2               ut1_ph          = ut1_pl+1   ; utility pointer 1 high byte
000000r 2               ut2_pl          = ut1_ph+1   ; utility pointer 2 low byte
000000r 2               ut2_ph          = ut2_pl+1   ; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2          = ut1_pl     ; temp byte for block move
000000r 2               
000000r 2               FACt_1          = ut2_ph+1   ; FAC temp mantissa1
000000r 2               FACt_2          = FACt_1+1   ; FAC temp mantissa2
000000r 2               FACt_3          = FACt_2+1   ; FAC temp mantissa3
000000r 2               
000000r 2               dims_l          = FACt_2     ; array dimension size low byte
000000r 2               dims_h          = FACt_3     ; array dimension size high byte
000000r 2               
000000r 2               TempB           = FACt_1+3   ; temp page 0 byte
000000r 2               
000000r 2               Smeml           = TempB+1    ; start of mem low byte         (Start-of-Basic)
000000r 2               Smemh           = Smeml+1    ; start of mem high byte        (Start-of-Basic)
000000r 2               Svarl           = Smemh+1    ; start of vars low byte        (Start-of-Variables)
000000r 2               Svarh           = Svarl+1    ; start of vars high byte       (Start-of-Variables)
000000r 2               Sarryl          = Svarh+1    ; var mem end low byte          (Start-of-Arrays)
000000r 2               Sarryh          = Sarryl+1   ; var mem end high byte         (Start-of-Arrays)
000000r 2               Earryl          = Sarryh+1   ; array mem end low byte        (End-of-Arrays)
000000r 2               Earryh          = Earryl+1   ; array mem end high byte       (End-of-Arrays)
000000r 2               Sstorl          = Earryh+1   ; string storage low byte       (String storage (moving down))
000000r 2               Sstorh          = Sstorl+1   ; string storage high byte      (String storage (moving down))
000000r 2               Sutill          = Sstorh+1   ; string utility ptr low byte
000000r 2               Sutilh          = Sutill+1   ; string utility ptr high byte
000000r 2               Ememl           = Sutilh+1   ; end of mem low byte           (Limit-of-memory)
000000r 2               Ememh           = Ememl+1    ; end of mem high byte          (Limit-of-memory)
000000r 2               Clinel          = Ememh+1    ; current line low byte         (Basic line number)
000000r 2               Clineh          = Clinel+1   ; current line high byte        (Basic line number)
000000r 2               Blinel          = Clineh+1   ; break line low byte           (Previous Basic line number)
000000r 2               Blineh          = Blinel+1   ; break line high byte          (Previous Basic line number)
000000r 2               
000000r 2               Cpntrl          = Blineh+1   ; continue pointer low byte
000000r 2               Cpntrh          = Cpntrl+1   ; continue pointer high byte
000000r 2               
000000r 2               Dlinel          = Cpntrh+1   ; current DATA line low byte
000000r 2               Dlineh          = Dlinel+1   ; current DATA line high byte
000000r 2               
000000r 2               Dptrl           = Dlineh+1   ; DATA pointer low byte
000000r 2               Dptrh           = Dptrl+1    ; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl          = Dptrh+1    ; read pointer low byte
000000r 2               Rdptrh          = Rdptrl+1   ; read pointer high byte
000000r 2               
000000r 2               Varnm1          = Rdptrh+1   ; current var name 1st byte
000000r 2               Varnm2          = Varnm1+1   ; current var name 2nd byte
000000r 2               
000000r 2               Cvaral          = Varnm2+1   ; current var address low byte
000000r 2               Cvarah          = Cvaral+1   ; current var address high byte
000000r 2               
000000r 2               Frnxtl          = Cvarah+1   ; var pointer for FOR/NEXT low byte
000000r 2               Frnxth          = Frnxtl+1   ; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1           = Frnxtl     ; temp line index
000000r 2               
000000r 2               Lvarpl          = Frnxtl     ; let var pointer low byte
000000r 2               Lvarph          = Frnxth     ; let var pointer high byte
000000r 2               
000000r 2               prstk           = Frnxtl+2   ; precedence stacked flag
000000r 2               
000000r 2               comp_f          = prstk+2    ; compare function flag, bits 0,1 and 2 used
000000r 2                                               ; bit 2 set if >
000000r 2                                               ; bit 1 set if =
000000r 2                                               ; bit 0 set if <
000000r 2               
000000r 2               func_l          = comp_f+1   ; function pointer low byte
000000r 2               func_h          = func_l+1   ; function pointer high byte
000000r 2               
000000r 2               garb_l          = func_l     ; garbage collection working pointer low byte
000000r 2               garb_h          = func_h     ; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l          = func_h+1   ; string descriptor_2 pointer low byte
000000r 2               des_2h          = des_2l+1   ; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step          = des_2l+2   ; garbage collect step size
000000r 2               
000000r 2               Fnxjmp          = g_step+1   ; jump vector for functions
000000r 2               Fnxjpl          = Fnxjmp+1   ; functions jump vector low byte
000000r 2               Fnxjph          = Fnxjmp+2   ; functions jump vector high byte
000000r 2               
000000r 2               g_indx          = Fnxjpl     ; garbage collect temp index
000000r 2               
000000r 2               FAC2_r          = Fnxjmp+2   ; FAC2 rounding byte
000000r 2               
000000r 2               Adatal          = FAC2_r+1   ; array data pointer low byte
000000r 2               Adatah          = Adatal+1   ; array data pointer high byte
000000r 2               
000000r 2               Nbendl          = Adatal     ; new block end pointer low byte
000000r 2               Nbendh          = Adatah     ; new block end pointer high byte
000000r 2               
000000r 2               Obendl          = Adatah+1   ; old block end pointer low byte
000000r 2               Obendh          = Obendl+1   ; old block end pointer high byte
000000r 2               
000000r 2               numexp          = Obendh+1   ; string to float number exponent count
000000r 2               expcnt          = numexp+1   ; string to float exponent count
000000r 2               
000000r 2               numbit          = numexp     ; bit count for array element calculations
000000r 2               
000000r 2               numdpf          = expcnt+1   ; string to float decimal point flag
000000r 2               expneg          = numdpf+1   ; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl          = numdpf     ; array start pointer low byte
000000r 2               Astrth          = expneg     ; array start pointer high byte
000000r 2               
000000r 2               Histrl          = numdpf     ; highest string low byte
000000r 2               Histrh          = expneg     ; highest string high byte
000000r 2               
000000r 2               Baslnl          = numdpf     ; BASIC search line pointer low byte
000000r 2               Baslnh          = expneg     ; BASIC search line pointer high byte
000000r 2               
000000r 2               Fvar_l          = numdpf     ; find/found variable pointer low byte
000000r 2               Fvar_h          = expneg     ; find/found variable pointer high byte
000000r 2               
000000r 2               Ostrtl          = numdpf     ; old block start pointer low byte
000000r 2               Ostrth          = expneg     ; old block start pointer high byte
000000r 2               
000000r 2               Vrschl          = numdpf     ; variable search pointer low byte
000000r 2               Vrschh          = expneg     ; variable search pointer high byte
000000r 2               
000000r 2               FAC1_e          = expneg+1   ; FAC1 exponent
000000r 2               FAC1_1          = FAC1_e+1   ; FAC1 mantissa1
000000r 2               FAC1_2          = FAC1_e+2   ; FAC1 mantissa2
000000r 2               FAC1_3          = FAC1_e+3   ; FAC1 mantissa3
000000r 2               FAC1_s          = FAC1_e+4   ; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln          = FAC1_e     ; string length
000000r 2               str_pl          = FAC1_1     ; string pointer low byte
000000r 2               str_ph          = FAC1_2     ; string pointer high byte
000000r 2               
000000r 2               des_pl          = FAC1_2     ; string descriptor pointer low byte
000000r 2               des_ph          = FAC1_3     ; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l          = FAC1_3     ; MID$ string temp length byte
000000r 2               
000000r 2               negnum          = FAC1_e+5   ; string to float eval -ve flag
000000r 2               numcon          = negnum     ; series evaluation constant count
000000r 2               
000000r 2               FAC1_o          = negnum+1   ; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e          = FAC1_o+1   ; FAC2 exponent
000000r 2               FAC2_1          = FAC2_e+1   ; FAC2 mantissa1
000000r 2               FAC2_2          = FAC2_e+2   ; FAC2 mantissa2
000000r 2               FAC2_3          = FAC2_e+3   ; FAC2 mantissa3
000000r 2               FAC2_s          = FAC2_e+4   ; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc          = FAC2_e+5   ; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r          = FAC_sc+1   ; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l         = FAC_sc     ; string start pointer low byte
000000r 2               ssptr_h         = FAC1_r     ; string start pointer high byte
000000r 2               
000000r 2               sdescr          = FAC_sc     ; string descriptor pointer
000000r 2               
000000r 2               csidx           = FAC1_r+1   ; line crunch save index
000000r 2               Asptl           = csidx      ; array size/pointer low byte
000000r 2               Aspth           = csidx+1    ; array size/pointer high byte
000000r 2               
000000r 2               Btmpl           = Asptl      ; BASIC pointer temp low byte
000000r 2               Btmph           = Aspth      ; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl           = Asptl      ; BASIC pointer temp low byte
000000r 2               Cptrh           = Aspth      ; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl           = Asptl      ; BASIC pointer temp low byte
000000r 2               Sendh           = Aspth      ; BASIC pointer temp low byte
000000r 2               ;
000000r 2               ; CHRGET/CHRGOT routine now located in ROM
000000r 2               ; The two pointers below are accessed via ROM
000000r 2               ; Reduces Page zero usage by quite a bit with a minor performance penalty
000000r 2               ; CMOS addressing mode used, saves memory and execution time
000000r 2               ;
000000r 2               Bpntrl          = Sendh+1    ; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh          = Bpntrl+1   ; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               Rbyte4          = Bpntrh+1   ; extra PRNG byte
000000r 2               
000000r 2               Rbyte1          = Rbyte4+1   ; most significant PRNG byte
000000r 2               Rbyte2          = Rbyte4+2   ; middle PRNG byte
000000r 2               Rbyte3          = Rbyte4+3   ; least significant PRNG byte
000000r 2               
000000r 2               Decss           = Rbyte3+1   ; number to decimal string start
000000r 2               Decssp1         = Decss+1    ; number to decimal string start
000000r 2               ZPLastByte      = Decss+17   ; last declared byte in Page Zero
000000r 2               
000000r 2               ; Note: C02BIOS uses Page Zero locations from $E0 - $FF
000000r 2               ; C02Monitor uses Page Zero locations from $B0 - $DF
000000r 2               lcd_addr		= $E2	; 1 byte, lcd busy flag and address
000000r 2               in_wptr			= $E3	; 1 byte
000000r 2               in_rptr			= $E4	; 1 byte
000000r 2               kb_flags		= $E5	; 1 byte
000000r 2               kb_modifiers 	= $E6	; 1 byte
000000r 2               r0				= $E8	; 2 bytes
000000r 2               r0L				= $E8	; low byte
000000r 2               r0H				= $E9	; high byte
000000r 2               r1				= $EA	; 2 bytes
000000r 2               r1L				= $EA	; low byte
000000r 2               r1H				= $EB	; high byte
000000r 2               r2				= $EC	; 2 bytes
000000r 2               r2L				= $EC	; low byte
000000r 2               r2H				= $ED	; high byte
000000r 2               icnt                    = $EE ;Input buffer count
000000r 2               ihead			      = $EF	;input buffer head pointer
000000r 2               itail			      = $F0	;input buffer tail pointer
000000r 2               ocnt			      = $F1	;output buffer count
000000r 2               ohead			      = $F2	;output buffer head pointer
000000r 2               otail			      = $F4	;output buffer tail pointer
000000r 2               
000000r 2               ; add page zero variables for Xmodem transfer using the C02 Monitor routines
000000r 2               
000000r 2               PGZERO_ST       = $B0               ; Start of Page Zero usage (C02 Monitor)
000000r 2               
000000r 2               PROMPTL         = PGZERO_ST+22      ; Prompt string address
000000r 2               PROMPTH         = PGZERO_ST+23
000000r 2               SRCL            = PGZERO_ST+24      ; Source address for memory operations
000000r 2               SRCH            = PGZERO_ST+25
000000r 2               TGTL            = PGZERO_ST+26      ; Target address for memory operations
000000r 2               TGTH            = PGZERO_ST+27
000000r 2               LENL            = PGZERO_ST+28      ; Length address for memory operations
000000r 2               LENH            = PGZERO_ST+29
000000r 2               
000000r 2               OPXMDM          = PGZERO_ST+38      ; Saved Opcode/Xmodem Flag variable
000000r 2               PTRL            = PGZERO_ST+42      ; Data pointer lo byte
000000r 2               PTRH            = PGZERO_ST+43      ; Data pointer hi byte
000000r 2               BLKNO           = PGZERO_ST+44      ; Block number
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END            = $80             ; END token
000000r 2               TK_FOR            = TK_END+1        ; FOR token
000000r 2               TK_NEXT           = TK_FOR+1        ; NEXT token
000000r 2               TK_DATA           = TK_NEXT+1       ; DATA token
000000r 2               TK_INPUT          = TK_DATA+1       ; INPUT token
000000r 2               TK_DIM            = TK_INPUT+1      ; DIM token
000000r 2               TK_READ           = TK_DIM+1        ; READ token
000000r 2               TK_LET            = TK_READ+1       ; LET token
000000r 2               TK_DEC            = TK_LET+1        ; DEC token
000000r 2               TK_GOTO           = TK_DEC+1        ; GOTO token
000000r 2               TK_RUN            = TK_GOTO+1       ; RUN token
000000r 2               TK_IF             = TK_RUN+1        ; IF token
000000r 2               TK_RESTORE        = TK_IF+1         ; RESTORE token
000000r 2               TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
000000r 2               TK_RETURN         = TK_GOSUB+1      ; RETURN token
000000r 2               TK_REM            = TK_RETURN+1     ; REM token
000000r 2               TK_STOP           = TK_REM+1        ; STOP token
000000r 2               TK_ON             = TK_STOP+1       ; ON token
000000r 2               TK_NULL           = TK_ON+1         ; NULL token
000000r 2               TK_INC            = TK_NULL+1       ; INC token
000000r 2               TK_WAIT           = TK_INC+1        ; WAIT token
000000r 2               TK_LOAD           = TK_WAIT+1       ; LOAD token
000000r 2               TK_SAVE           = TK_LOAD+1       ; SAVE token
000000r 2               TK_DEF            = TK_SAVE+1       ; DEF token
000000r 2               TK_POKE           = TK_DEF+1        ; POKE token
000000r 2               TK_DOKE           = TK_POKE+1       ; DOKE token
000000r 2               TK_CALL           = TK_DOKE+1       ; CALL token
000000r 2               TK_DO             = TK_CALL+1       ; DO token
000000r 2               TK_LOOP           = TK_DO+1         ; LOOP token
000000r 2               TK_PRINT          = TK_LOOP+1       ; PRINT token
000000r 2               TK_CONT           = TK_PRINT+1      ; CONT token
000000r 2               TK_LIST           = TK_CONT+1       ; LIST token
000000r 2               TK_CLEAR          = TK_LIST+1       ; CLEAR token
000000r 2               TK_NEW            = TK_CLEAR+1      ; NEW token
000000r 2               TK_WIDTH          = TK_NEW+1        ; WIDTH token
000000r 2               TK_GET            = TK_WIDTH+1      ; GET token
000000r 2               TK_SWAP           = TK_GET+1        ; SWAP token
000000r 2               TK_BITSET         = TK_SWAP+1       ; BITSET token
000000r 2               TK_BITCLR         = TK_BITSET+1     ; BITCLR token
000000r 2               TK_EXIT           = TK_BITCLR+1     ; EXIT token
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB            = TK_EXIT+1       ; TAB token
000000r 2               TK_ELSE           = TK_TAB+1        ; ELSE token
000000r 2               TK_TO             = TK_ELSE+1       ; TO token
000000r 2               TK_FN             = TK_TO+1         ; FN token
000000r 2               TK_SPC            = TK_FN+1         ; SPC token
000000r 2               TK_THEN           = TK_SPC+1        ; THEN token
000000r 2               TK_NOT            = TK_THEN+1       ; NOT token
000000r 2               TK_STEP           = TK_NOT+1        ; STEP token
000000r 2               TK_UNTIL          = TK_STEP+1       ; UNTIL token
000000r 2               TK_WHILE          = TK_UNTIL+1      ; WHILE token
000000r 2               
000000r 2               ; operator tokens
000000r 2               
000000r 2               TK_PLUS           = TK_WHILE+1      ; + token
000000r 2               TK_MINUS          = TK_PLUS+1       ; - token
000000r 2               TK_MUL            = TK_MINUS+1      ; * token
000000r 2               TK_DIV            = TK_MUL+1        ; / token
000000r 2               TK_POWER          = TK_DIV+1        ; ^ token
000000r 2               TK_AND            = TK_POWER+1      ; AND token
000000r 2               TK_EOR            = TK_AND+1        ; EOR token
000000r 2               TK_OR             = TK_EOR+1        ; OR token
000000r 2               TK_RSHIFT         = TK_OR+1         ; RSHIFT token
000000r 2               TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
000000r 2               TK_GT             = TK_LSHIFT+1     ; > token
000000r 2               TK_EQUAL          = TK_GT+1         ; = token
000000r 2               TK_LT             = TK_EQUAL+1      ; < token
000000r 2               
000000r 2               ; function tokens
000000r 2               
000000r 2               TK_SGN            = TK_LT+1         ; SGN token
000000r 2               TK_INT            = TK_SGN+1        ; INT token
000000r 2               TK_ABS            = TK_INT+1        ; ABS token
000000r 2               TK_USR            = TK_ABS+1        ; USR token
000000r 2               TK_FRE            = TK_USR+1        ; FRE token
000000r 2               TK_POS            = TK_FRE+1        ; POS token
000000r 2               TK_SQR            = TK_POS+1        ; SQR token
000000r 2               TK_RND            = TK_SQR+1        ; RND token
000000r 2               TK_LOG            = TK_RND+1        ; LOG token
000000r 2               TK_EXP            = TK_LOG+1        ; EXP token
000000r 2               TK_COS            = TK_EXP+1        ; COS token
000000r 2               TK_SIN            = TK_COS+1        ; SIN token
000000r 2               TK_TAN            = TK_SIN+1        ; TAN token
000000r 2               TK_ATN            = TK_TAN+1        ; ATN token
000000r 2               TK_PEEK           = TK_ATN+1        ; PEEK token
000000r 2               TK_DEEK           = TK_PEEK+1       ; DEEK token
000000r 2               TK_SADD           = TK_DEEK+1       ; SADD token
000000r 2               TK_LEN            = TK_SADD+1       ; LEN token
000000r 2               TK_STRS           = TK_LEN+1        ; STR$ token
000000r 2               TK_VAL            = TK_STRS+1       ; VAL token
000000r 2               TK_ASC            = TK_VAL+1        ; ASC token
000000r 2               TK_UCASES         = TK_ASC+1        ; UCASE$ token
000000r 2               TK_LCASES         = TK_UCASES+1     ; LCASE$ token
000000r 2               TK_CHRS           = TK_LCASES+1     ; CHR$ token
000000r 2               TK_HEXS           = TK_CHRS+1       ; HEX$ token
000000r 2               TK_BINS           = TK_HEXS+1       ; BIN$ token
000000r 2               TK_BITTST         = TK_BINS+1       ; BITTST token
000000r 2               TK_MAX            = TK_BITTST+1     ; MAX token
000000r 2               TK_MIN            = TK_MAX+1        ; MIN token
000000r 2               TK_PI             = TK_MIN+1        ; PI token
000000r 2               TK_TWOPI          = TK_PI+1         ; TWOPI token
000000r 2               TK_VPTR           = TK_TWOPI+1      ; VARPTR token
000000r 2               TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
000000r 2               TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
000000r 2               TK_MIDS           = TK_RIGHTS+1     ; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0            = $00       ; X or Y plus 0
000000r 2               PLUS_1            = $01       ; X or Y plus 1
000000r 2               PLUS_2            = $02       ; X or Y plus 2
000000r 2               PLUS_3            = $03       ; X or Y plus 3
000000r 2               
000000r 2               STACK_RES         = 20       ; reserved stack space
000000r 2               
000000r 2               LAB_STAK          = $0100     ; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE          = LAB_STAK+$FE
000000r 2                                                ; flushed stack address
000000r 2               LAB_SKFF          = LAB_STAK+$FF
000000r 2                                                ; flushed stack address
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
000000r 2               ; the input buffer must not cross a page boundary and must not overlap with
000000r 2               ; program RAM pages!
000000r 2               
000000r 2               Ibuffs          = $0300     ; Start of input buffer
000000r 2               Ibuffe          = Ibuffs+$7E ; end of input buffer (127 bytes)
000000r 2               
000000r 2               ccflag          = Ibuffe+1  ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte          = ccflag+1  ; BASIC CTRL-C byte
000000r 2               ccnull          = ccbyte+1  ; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC          = ccnull+1  ; CTRL-C check vector
000000r 2               
000000r 2               VEC_IN          = VEC_CC+2  ; input vector
000000r 2               VEC_OUT         = VEC_IN+2  ; output vector
000000r 2               VEC_LD          = VEC_OUT+2 ; load vector
000000r 2               VEC_SV          = VEC_LD+2  ; save vector
000000r 2               VEC_EXIT        = VEC_SV+2  ; exit vector
000000r 2               
000000r 2               Ram_base        = $0500     ; start of user RAM (1st 2KB used/reserved)
000000r 2               Ram_top         = $8000     ; end of user RAM+1 ($8000 is start of ROM)
000000r 2               
000000r 2               ; Host system routine addresses are defined here for convienence.
000000r 2               ; They provide the following functions required by EhBasic:
000000r 2               ; CHRIN_NW      - Character Input with no waiting - carry flag indicates data
000000r 2               ; CHROUT        - Character Output
000000r 2               ; LOAD          - Load data via Xmodem-CRC
000000r 2               ; SAVE          - Save data via Xmodem-CRC
000000r 2               ; EXIT          - Exit to warm start of C02 Monitor
000000r 2               
000000r 2               B_CHRIN_NW      =    CHRIN_NW
000000r 2               B_CHROUT        =    CHROUT
000000r 2               M_LOAD          =    LOAD
000000r 2               M_SAVE          =    SAVE
000000r 2               M_EXIT          =    EXIT
000000r 2               
000000r 2               ; The start address can be changed, noting the BIOS/Monitor locations
000000r 2               
000000r 2                     .ORG    $8000              ; Start of Basic in ROM
008000  2                                                ; C02Monitor starts at $E000
008000  2                                                ; C02BIOS starts at $F800
008000  2               
008000  2               ROM_START
008000  2               ; BASIC cold start entry point
008000  2               
008000  2  4C 68 A0           JMP   BOOT_BASIC        ; jump to Basic cold start routine
008003  2               
008003  2               ; new page $04 initialisation, copy ROM data to RAM
008003  2               ; consists of the vectors Input/Output/Load/Save/Exit
008003  2               ; and Control-C flags, pointers
008003  2               
008003  2               LAB_COLD
008003  2  A2 0E              LDX   #PG4_TABE-PG4_TABS-1 ; byte count-1
008005  2               LAB_2D13
008005  2  BD 4D A0           LDA   PG4_TABS,X        ; get byte
008008  2  9D 7F 03           STA   ccflag,X          ; store in page 4
00800B  2  CA                 DEX                     ; decrement count
00800C  2  10 F7              BPL   LAB_2D13          ; loop if not done
00800E  2               
00800E  2  9A                 TXS                     ; reset stack pointer (X Reg = $FF from above)
00800F  2  86 3A              STX   Clineh            ; set current line high byte (set immediate mode)
008011  2               
008011  2  A9 4C              LDA   #$4C              ; code for JMP
008013  2  85 53              STA   Fnxjmp            ; save for jump vector for functions
008015  2               
008015  2               ; copy block from StrTab to $0000 - $0012
008015  2               
008015  2               LAB_GMEM
008015  2  A2 0B              LDX   #EndTab-StrTab-1  ; set byte count-1
008017  2               TabLoop
008017  2  BD 5C A0           LDA   StrTab,X          ; get byte from table
00801A  2  95 00              STA   PLUS_0,X          ; save byte in page zero
00801C  2  CA                 DEX                     ; decrement count
00801D  2  10 F8              BPL   TabLoop           ; loop until done
00801F  2               
00801F  2               ; set-up start values
00801F  2               
00801F  2  64 64              STZ   FAC1_o            ; clear FAC1 overflow byte
008021  2  64 19              STZ   last_sh           ; clear descriptor stack top item pointer high byte
008023  2               
008023  2  A9 0E              LDA   #$0E              ; set default tab size
008025  2  85 16              STA   TabSiz            ; save it
008027  2  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
008029  2  85 52              STA   g_step            ; save it
00802B  2  A2 1A              LDX   #des_sk           ; descriptor stack start
00802D  2  86 17              STX   next_s            ; set descriptor stack pointer
00802F  2               
00802F  2               ; bypass user memory prompt, just test, show and go
00802F  2               ; we get here with Itempl/h = Ram_base
00802F  2               
00802F  2               LAB_2D93
00802F  2  A9 55              LDA   #$55              ; set test byte
008031  2  92 0A              STA   (Itempl)          ; save via temporary integer
008033  2  D2 0A              CMP   (Itempl)          ; compare via temporary integer
008035  2  D0 1B              BNE   LAB_2DB6          ; branch if fail
008037  2               
008037  2  0A                 ASL                     ; shift test byte left (now $AA)
008038  2  92 0A              STA   (Itempl)          ; save via temporary integer
00803A  2  D2 0A              CMP   (Itempl)          ; compare via temporary integer
00803C  2  D0 14              BNE   LAB_2DB6          ; branch if fail
00803E  2               
00803E  2  A9 00              LDA   #$00              ; get zero
008040  2  92 0A              STA   (Itempl)          ; clear tested byte
008042  2  D2 0A              CMP   (Itempl)          ; compare via temporary integer
008044  2  D0 0C              BNE   LAB_2DB6          ; branch if fail
008046  2               
008046  2  E6 0A              INC   Itempl            ; increment temporary integer low byte
008048  2  D0 E5              BNE   LAB_2D93          ; branch if no overflow
00804A  2               
00804A  2  E6 0B              INC   Itemph            ; increment temporary integer high byte
00804C  2  A5 0B              LDA   Itemph            ; get high byte
00804E  2  C9 80              CMP   #>Ram_top         ; compare with top of RAM+1
008050  2  D0 DD              BNE   LAB_2D93          ; branch and continue testing RAM
008052  2               
008052  2               LAB_2DB6
008052  2  A5 0A              LDA   Itempl            ; get temporary integer low byte
008054  2  A4 0B              LDY   Itemph            ; get temporary integer high byte ($00)
008056  2               
008056  2  85 37              STA   Ememl             ; set end of mem low byte
008058  2  84 38              STY   Ememh             ; set end of mem high byte
00805A  2  85 33              STA   Sstorl            ; set bottom of string space low byte
00805C  2  84 34              STY   Sstorh            ; set bottom of string space high byte
00805E  2               
00805E  2  A0 00              LDY   #<Ram_base        ; set start addr low byte
008060  2  A2 05              LDX   #>Ram_base        ; set start addr high byte
008062  2  C8                 INY                     ; increment Ram_base low byte
008063  2  84 2B              STY   Smeml             ; save start of mem low byte
008065  2  86 2C              STX   Smemh             ; save start of mem high byte
008067  2               
008067  2  20 32 88           JSR   LAB_CRLF          ; print CR/LF
00806A  2  20 1E 83           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00806D  2  A5 37              LDA   Ememl             ; get end of mem low byte
00806F  2  38                 SEC                     ; set carry for subtract
008070  2  E5 2B              SBC   Smeml             ; subtract start of mem low byte
008072  2  AA                 TAX                     ; copy to X
008073  2  A5 38              LDA   Ememh             ; get end of mem high byte
008075  2  E5 2C              SBC   Smemh             ; subtract start of mem high byte
008077  2  20 FB 99           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00807A  2  A9 E0              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00807C  2  A0 A0              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00807E  2  20 73 88           JSR   LAB_18C3          ; print null terminated string from memory
008081  2  6C 01 00           JMP   (Wrmjpl)          ; jump to warm start
008084  2               
008084  2               ; open up space in memory
008084  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
008084  2               
008084  2               ; Nbendl,Nbendh - new block end address (A/Y)
008084  2               ; Obendl,Obendh - old block end address
008084  2               ; Ostrtl,Ostrth - old block start address
008084  2               
008084  2               ; returns with ..
008084  2               
008084  2               ; Nbendl,Nbendh - new block start address (high byte - $100)
008084  2               ; Obendl,Obendh - old block start address (high byte - $100)
008084  2               ; Ostrtl,Ostrth - old block start address (unchanged)
008084  2               
008084  2               LAB_11CF
008084  2  20 D1 80           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
008087  2                                             ; addr to check is in AY (low/high)
008087  2  85 31              STA   Earryl            ; save new array mem end low byte
008089  2  84 32              STY   Earryh            ; save new array mem end high byte
00808B  2               
00808B  2               ; open up space in memory
00808B  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00808B  2               ; don't set array end
00808B  2               
00808B  2               LAB_11D6
00808B  2  38                 SEC                     ; set carry for subtract
00808C  2  A5 58              LDA   Obendl            ; get block end low byte
00808E  2  E5 5C              SBC   Ostrtl            ; subtract block start low byte
008090  2  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
008091  2  A5 59              LDA   Obendh            ; get block end high byte
008093  2  E5 5D              SBC   Ostrth            ; subtract block start high byte
008095  2  AA                 TAX                     ; copy block length high byte to X
008096  2  E8                 INX                     ; +1 to allow for count=0 exit
008097  2  98                 TYA                     ; copy block length low byte to A
008098  2  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00809A  2               
00809A  2                                             ; block is (X-1)*256+Y bytes, do the Y bytes first
00809A  2  38                 SEC                     ; set carry for add + 1, two's complement
00809B  2  49 FF              EOR   #$FF              ; invert low byte for subtract
00809D  2  65 58              ADC   Obendl            ; add block end low byte
00809F  2  85 58              STA   Obendl            ; save corrected old block end low byte
0080A1  2  B0 03              BCS   LAB_11F3          ; branch if no underflow
0080A3  2  C6 59              DEC   Obendh            ; else decrement block end high byte
0080A5  2  38                 SEC                     ; set carry for add + 1, two's complement
0080A6  2               LAB_11F3
0080A6  2  98                 TYA                     ; get MOD(block length/$100) byte
0080A7  2  49 FF              EOR   #$FF              ; invert low byte for subtract
0080A9  2  65 56              ADC   Nbendl            ; add destination end low byte
0080AB  2  85 56              STA   Nbendl            ; save modified new block end low byte
0080AD  2  B0 08              BCS   LAB_1203          ; branch if no underflow
0080AF  2  C6 57              DEC   Nbendh            ; else decrement block end high byte
0080B1  2  80 04              BRA   LAB_1203          ; branch always
0080B3  2               
0080B3  2               LAB_11FF
0080B3  2  B1 58              LDA   (Obendl),Y        ; get byte from source
0080B5  2  91 56              STA   (Nbendl),Y        ; copy byte to destination
0080B7  2               LAB_1203
0080B7  2  88                 DEY                     ; decrement index
0080B8  2  D0 F9              BNE   LAB_11FF          ; loop until Y=0
0080BA  2                                             ; now do Y=0 indexed byte
0080BA  2  B1 58              LDA   (Obendl),Y        ; get byte from source
0080BC  2  91 56              STA   (Nbendl),Y        ; save byte to destination
0080BE  2               LAB_120A
0080BE  2  C6 59              DEC   Obendh            ; decrement source pointer high byte
0080C0  2  C6 57              DEC   Nbendh            ; decrement destination pointer high byte
0080C2  2  CA                 DEX                     ; decrement block count
0080C3  2  D0 F2              BNE   LAB_1203          ; loop until count = $0
0080C5  2  60                 RTS
0080C6  2               
0080C6  2               ; check room on stack for A bytes
0080C6  2               ; stack too deep? do OM error
0080C6  2               
0080C6  2               LAB_1212                      ; patched for stack floor
0080C6  2  18                 CLC                     ; prep ADC
0080C7  2  69 14              ADC   #STACK_RES        ; stack pointer lower limit before interrupts
0080C9  2  85 2A              STA   TempB             ; save result in temp byte
0080CB  2  BA                 TSX                     ; copy stack
0080CC  2  E4 2A              CPX   TempB             ; compare new "limit" with stack
0080CE  2  90 2F              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
0080D0  2  60                 RTS
0080D1  2               
0080D1  2               ; check available memory, "Out of memory" error if no room
0080D1  2               ; addr to check is in AY (low/high)
0080D1  2               
0080D1  2               LAB_121F
0080D1  2  C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
0080D3  2  90 29              BCC   LAB_124B          ; if less then exit (is ok)
0080D5  2               
0080D5  2  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
0080D7  2               
0080D7  2                                             ; high byte was =, now do low byte
0080D7  2  C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
0080D9  2  90 23              BCC   LAB_124B          ; if less then exit (is ok)
0080DB  2               
0080DB  2                                             ; addr is > string storage ptr (oops!)
0080DB  2               LAB_1229
0080DB  2  48                 PHA                     ; push addr low byte
0080DC  2  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
0080DE  2  98                 TYA                     ; copy addr high byte (to push on stack)
0080DF  2               
0080DF  2                                             ; save misc numeric work area
0080DF  2               LAB_122D
0080DF  2  48                 PHA                     ; push byte
0080E0  2  B5 55              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
0080E2  2  CA                 DEX                     ; decrement index
0080E3  2  10 FA              BPL   LAB_122D          ; loop until all done
0080E5  2               
0080E5  2  20 7B 91           JSR   LAB_GARB          ; garbage collection routine
0080E8  2               
0080E8  2                                             ; restore misc numeric work area
0080E8  2  A2 00              LDX   #$00              ; clear the index to restore bytes
0080EA  2               LAB_1238
0080EA  2  68                 PLA                     ; pop byte
0080EB  2  95 56              STA   Adatal,X          ; save byte to Adatal to expneg
0080ED  2  E8                 INX                     ; increment index
0080EE  2  E0 08              CPX   #$08              ; compare with end + 1
0080F0  2  30 F8              BMI   LAB_1238          ; loop if more to do
0080F2  2               
0080F2  2  7A                 PLY                     ; pop addr high byte
0080F3  2  68                 PLA                     ; pop addr low byte
0080F4  2  C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
0080F6  2  90 06              BCC   LAB_124B          ; if less then exit (is ok)
0080F8  2               
0080F8  2  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
0080FA  2               
0080FA  2                                             ; high byte was =, now do low byte
0080FA  2  C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
0080FC  2  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
0080FE  2                                             ; ok exit, carry clear
0080FE  2               LAB_124B
0080FE  2  60                 RTS
0080FF  2               
0080FF  2               ; do "Out of memory" error then warm start
0080FF  2               
0080FF  2               LAB_OMER
0080FF  2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
008101  2               
008101  2               ; do error #X, then warm start
008101  2               
008101  2               LAB_XERR
008101  2  20 32 88           JSR   LAB_CRLF          ; print CR/LF
008104  2               
008104  2  BD 12 A6           LDA   LAB_BAER,X        ; get error message pointer low byte
008107  2  BC 13 A6           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00810A  2  20 73 88           JSR   LAB_18C3          ; print null terminated string from memory
00810D  2               
00810D  2  20 57 83           JSR   LAB_1491          ; flush stack and clear continue flag
008110  2  A9 4F              LDA   #<LAB_EMSG        ; point to " Error" low addr
008112  2  A0 A7              LDY   #>LAB_EMSG        ; point to " Error" high addr
008114  2               LAB_1269
008114  2  20 73 88           JSR   LAB_18C3          ; print null terminated string from memory
008117  2  A4 3A              LDY   Clineh            ; get current line high byte
008119  2  C8                 INY                     ; increment it
00811A  2  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00811C  2               
00811C  2                                             ; else print line number
00811C  2  20 F0 99           JSR   LAB_2953          ; print " in line [LINE #]"
00811F  2               
00811F  2               ; BASIC warm start entry point
00811F  2               ; wait for Basic command
00811F  2               
00811F  2               LAB_1274
00811F  2  A9 60              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
008121  2  A0 A7              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
008123  2               
008123  2  20 73 88           JSR   LAB_18C3          ; go do print string
008126  2               
008126  2               ; wait for Basic command (no "Ready")
008126  2               
008126  2               LAB_127D
008126  2  20 15 82           JSR   LAB_1357          ; call for BASIC input
008129  2               LAB_1280
008129  2  86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
00812B  2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
00812D  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008130  2  F0 F4              BEQ   LAB_127D          ; loop while null
008132  2               
008132  2               ; got to interpret input line now ..
008132  2               
008132  2  A2 FF              LDX   #$FF              ; current line to null value
008134  2  86 3A              STX   Clineh            ; set current line high byte
008136  2  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
008138  2               
008138  2                                             ; no line number .. immediate mode
008138  2  20 46 82           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00813B  2  4C B9 84           JMP   LAB_15F6          ; go scan and interpret code
00813E  2               
00813E  2               ; handle new BASIC line
00813E  2               
00813E  2               LAB_1295
00813E  2  20 00 87           JSR   LAB_GFPN          ; get fixed-point number into temp integer
008141  2  20 46 82           JSR   LAB_13A6          ; crunch keywords into Basic tokens
008144  2  84 0F              STY   Ibptr             ; save index pointer to end of crunched line
008146  2  20 F2 82           JSR   LAB_SSLN          ; search BASIC for temp integer line number
008149  2  90 44              BCC   LAB_12E6          ; branch if not found
00814B  2               
00814B  2                                             ; aroooogah! line # already exists! delete it
00814B  2  A0 01              LDY   #$01              ; set index to next line pointer high byte
00814D  2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
00814F  2  85 24              STA   ut1_ph            ; save it
008151  2  A5 2D              LDA   Svarl             ; get start of vars low byte
008153  2  85 23              STA   ut1_pl            ; save it
008155  2  A5 5D              LDA   Baslnh            ; get found line pointer high byte
008157  2  85 26              STA   ut2_ph            ; save it
008159  2  A5 5C              LDA   Baslnl            ; get found line pointer low byte
00815B  2  88                 DEY                     ; decrement index
00815C  2  F1 5C              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00815E  2  18                 CLC                     ; clear carry for add
00815F  2  65 2D              ADC   Svarl             ; add start of vars low byte
008161  2  85 2D              STA   Svarl             ; save new start of vars low byte
008163  2  85 25              STA   ut2_pl            ; save destination pointer low byte
008165  2  A5 2E              LDA   Svarh             ; get start of vars high byte
008167  2  69 FF              ADC   #$FF              ; -1 + carry
008169  2  85 2E              STA   Svarh             ; save start of vars high byte
00816B  2  E5 5D              SBC   Baslnh            ; subtract found line pointer high byte
00816D  2  AA                 TAX                     ; copy to block count
00816E  2  38                 SEC                     ; set carry for subtract
00816F  2  A5 5C              LDA   Baslnl            ; get found line pointer low byte
008171  2  E5 2D              SBC   Svarl             ; subtract start of vars low byte
008173  2  A8                 TAY                     ; copy to bytes in first block count
008174  2  B0 03              BCS   LAB_12D0          ; branch if overflow
008176  2               
008176  2  E8                 INX                     ; increment block count (correct for =0 loop exit)
008177  2  C6 26              DEC   ut2_ph            ; decrement destination high byte
008179  2               LAB_12D0
008179  2  18                 CLC                     ; clear carry for add
00817A  2  65 23              ADC   ut1_pl            ; add source pointer low byte
00817C  2  90 03              BCC   LAB_12D8          ; branch if no overflow
00817E  2               
00817E  2  C6 24              DEC   ut1_ph            ; else decrement source pointer high byte
008180  2  18                 CLC                     ; clear carry
008181  2               
008181  2                                             ; close up memory to delete old line
008181  2               LAB_12D8
008181  2  B1 23              LDA   (ut1_pl),Y        ; get byte from source
008183  2  91 25              STA   (ut2_pl),Y        ; copy to destination
008185  2  C8                 INY                     ; increment index
008186  2  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
008188  2               
008188  2  E6 24              INC   ut1_ph            ; increment source pointer high byte
00818A  2  E6 26              INC   ut2_ph            ; increment destination pointer high byte
00818C  2  CA                 DEX                     ; decrement block count
00818D  2  D0 F2              BNE   LAB_12D8          ; loop until all done
00818F  2               
00818F  2                                             ; got new line in buffer and no existing same #
00818F  2               LAB_12E6
00818F  2  AD 00 03           LDA   Ibuffs            ; get byte from start of input buffer
008192  2  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
008194  2               
008194  2                                             ; got new line and it isn't empty line
008194  2  A5 37              LDA   Ememl             ; get end of mem low byte
008196  2  A4 38              LDY   Ememh             ; get end of mem high byte
008198  2  85 33              STA   Sstorl            ; set bottom of string space low byte
00819A  2  84 34              STY   Sstorh            ; set bottom of string space high byte
00819C  2  A5 2D              LDA   Svarl             ; get start of vars low byte (end of BASIC)
00819E  2  85 58              STA   Obendl            ; save old block end low byte
0081A0  2  A4 2E              LDY   Svarh             ; get start of vars high byte (end of BASIC)
0081A2  2  84 59              STY   Obendh            ; save old block end high byte
0081A4  2  65 0F              ADC   Ibptr             ; add input buffer pointer (also buffer length)
0081A6  2  90 01              BCC   LAB_1301          ; branch if no overflow from add
0081A8  2  C8                 INY                     ; else increment high byte
0081A9  2               LAB_1301
0081A9  2  85 56              STA   Nbendl            ; save new block end low byte (move to, low byte)
0081AB  2  84 57              STY   Nbendh            ; save new block end high byte
0081AD  2  20 84 80           JSR   LAB_11CF          ; open up space in memory
0081B0  2                                             ; old start pointer Ostrtl,Ostrth set by the find line call
0081B0  2  A5 31              LDA   Earryl            ; get array mem end low byte
0081B2  2  A4 32              LDY   Earryh            ; get array mem end high byte
0081B4  2  85 2D              STA   Svarl             ; save start of vars low byte
0081B6  2  84 2E              STY   Svarh             ; save start of vars high byte
0081B8  2  A4 0F              LDY   Ibptr             ; get input buffer pointer (also buffer length)
0081BA  2  88                 DEY                     ; adjust for loop type
0081BB  2               LAB_1311
0081BB  2  B9 FC 02           LDA   Ibuffs-4,Y        ; get byte from crunched line
0081BE  2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0081C0  2  88                 DEY                     ; decrement count
0081C1  2  C0 03              CPY   #$03              ; compare with first byte-1
0081C3  2  D0 F6              BNE   LAB_1311          ; continue while count <> 3
0081C5  2               
0081C5  2  A5 0B              LDA   Itemph            ; get line # high byte
0081C7  2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0081C9  2  88                 DEY                     ; decrement count
0081CA  2  A5 0A              LDA   Itempl            ; get line # low byte
0081CC  2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0081CE  2  88                 DEY                     ; decrement count
0081CF  2  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
0081D1  2                                             ; byte then a zero already here would stop the chain rebuild
0081D1  2                                             ; as it would think it was the [EOT] marker.
0081D1  2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0081D3  2               
0081D3  2               LAB_1319
0081D3  2  20 33 83           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
0081D6  2  A6 2B              LDX   Smeml             ; get start of mem low byte
0081D8  2  A5 2C              LDA   Smemh             ; get start of mem high byte
0081DA  2  A0 01              LDY   #$01              ; index to high byte of next line pointer
0081DC  2               LAB_1325
0081DC  2  86 23              STX   ut1_pl            ; set line start pointer low byte
0081DE  2  85 24              STA   ut1_ph            ; set line start pointer high byte
0081E0  2  B1 23              LDA   (ut1_pl),Y        ; get it
0081E2  2  F0 18              BEQ   LAB_133E          ; exit if end of program
0081E4  2               
0081E4  2               ; rebuild chaining of Basic lines
0081E4  2               
0081E4  2  A0 04              LDY   #$04              ; point to first code byte of line
0081E6  2                                             ; there is always 1 byte + [EOL] as null entries are deleted
0081E6  2               LAB_1330
0081E6  2  C8                 INY                     ; next code byte
0081E7  2  B1 23              LDA   (ut1_pl),Y        ; get byte
0081E9  2  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
0081EB  2               
0081EB  2  38                 SEC                     ; set carry for add + 1
0081EC  2  98                 TYA                     ; copy end index
0081ED  2  65 23              ADC   ut1_pl            ; add to line start pointer low byte
0081EF  2  AA                 TAX                     ; copy to X
0081F0  2  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
0081F2  2  91 23              STA   (ut1_pl),Y        ; set next line pointer low byte
0081F4  2  98                 TYA                     ; clear A
0081F5  2  65 24              ADC   ut1_ph            ; add line start pointer high byte + carry
0081F7  2  C8                 INY                     ; increment index to high byte
0081F8  2  91 23              STA   (ut1_pl),Y        ; save next line pointer low byte
0081FA  2  80 E0              BRA   LAB_1325          ; go do next line, branch always, carry clear
0081FC  2               
0081FC  2               LAB_133E
0081FC  2  FF D6 03           BBS7  OPXMDM, DO_RDY    ; test to see if LOAD was executed
0081FF  2  4C 26 81           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
008202  2               DO_RDY
008202  2  77 D6              RMB7  OPXMDM            ; reset flag bit to zero
008204  2  4C 1F 81           JMP   LAB_1274          ; print Ready msg and wait for Basic command
008207  2               
008207  2               ; print "? " and get BASIC input
008207  2               
008207  2               LAB_INLN
008207  2  20 8C 88           JSR   LAB_18E3          ; print "?" character
00820A  2  20 88 88           JSR   LAB_18E0          ; print " "
00820D  2  80 06              BRA   LAB_1357          ; call for BASIC input and return
00820F  2               
00820F  2               ; receive line from keyboard
00820F  2               
00820F  2                                             ; $08 as delete key (BACKSPACE on standard keyboard)
00820F  2               LAB_134B
00820F  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
008212  2  CA                 DEX                     ; decrement the buffer counter (delete)
008213  2  80 02              BRA   LAB_1359          ; branch over next instruction, save 1 clock cycle
008215  2               
008215  2               ; call for BASIC input (main entry point)
008215  2               
008215  2               LAB_1357
008215  2  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
008217  2               LAB_1359
008217  2  20 3E A0           JSR   V_INPT            ; call scan input device
00821A  2  90 FB              BCC   LAB_1359          ; loop if no byte
00821C  2               
00821C  2  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
00821E  2               
00821E  2  C9 07              CMP   #$07              ; compare with [BELL]
008220  2  F0 10              BEQ   LAB_1378          ; branch if [BELL]
008222  2               
008222  2  C9 0D              CMP   #$0D              ; compare with [CR]
008224  2  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
008226  2               
008226  2  E0 00              CPX   #$00              ; compare pointer with $00
008228  2  D0 04              BNE   LAB_1374          ; branch if not empty
00822A  2               
00822A  2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
00822A  2               
00822A  2  C9 21              CMP   #$21              ; compare with [SP]+1
00822C  2  90 E9              BCC   LAB_1359          ; if < ignore character
00822E  2               
00822E  2               LAB_1374
00822E  2  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
008230  2  F0 DD              BEQ   LAB_134B          ; go delete last character
008232  2               
008232  2               LAB_1378
008232  2  E0 7E              CPX   #Ibuffe-Ibuffs    ; compare character count with max
008234  2  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
008236  2               
008236  2  9D 00 03           STA   Ibuffs,X          ; else store in buffer
008239  2  E8                 INX                     ; increment pointer
00823A  2               LAB_137F
00823A  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
00823D  2  80 D8              BRA   LAB_1359          ; always loop for next character
00823F  2               
00823F  2               LAB_1384
00823F  2  4C 2B 88           JMP   LAB_1866          ; do CR/LF exit to BASIC
008242  2               
008242  2               ; announce buffer full
008242  2               
008242  2               LAB_138E
008242  2  A9 07              LDA   #$07              ; [BELL] character into A
008244  2  80 F4              BRA   LAB_137F          ; go print the [BELL] but ignore input character
008246  2                                             ; branch always
008246  2               
008246  2               ; crunch keywords into Basic tokens
008246  2               ; position independent buffer version ..
008246  2               ; faster, dictionary search version ....
008246  2               
008246  2               LAB_13A6
008246  2  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
008248  2  38                 SEC                     ; set carry for subtract
008249  2  A5 6E              LDA   Bpntrl            ; get basic execute pointer low byte
00824B  2  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
00824D  2  AA                 TAX                     ; copy result to X (index past line # if any)
00824E  2  86 12              STX   Oquote            ; clear open quote/DATA flag
008250  2               LAB_13AC
008250  2  BD 00 03           LDA   Ibuffs,X          ; get byte from input buffer
008253  2  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
008255  2               
008255  2  C9 5F              CMP   #'_'              ; compare with "_"
008257  2  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
008259  2               
008259  2  C9 3C              CMP   #'<'              ; compare with "<"
00825B  2  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
00825D  2               
00825D  2  C9 30              CMP   #'0'              ; compare with "0"
00825F  2  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
008261  2               
008261  2  85 0E              STA   Scnquo            ; save buffer byte as search character
008263  2  C9 22              CMP   #$22              ; is it quote character?
008265  2  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
008267  2               
008267  2  C9 2A              CMP   #'*'              ; compare with "*"
008269  2  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
00826B  2                                             ; else crunch now
00826B  2               LAB_13CC
00826B  2  24 12              BIT   Oquote            ; get open quote/DATA token flag
00826D  2  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
00826F  2                                             ; go save byte then continue crunching
00826F  2  86 2A              STX   TempB             ; save buffer read index
008271  2  84 6C              STY   csidx             ; copy buffer save index
008273  2  A0 9A              LDY   #<TAB_1STC        ; get keyword first character table low address
008275  2  84 25              STY   ut2_pl            ; save pointer low byte
008277  2  A0 A2              LDY   #>TAB_1STC        ; get keyword first character table high address
008279  2  84 26              STY   ut2_ph            ; save pointer high byte
00827B  2  A0 00              LDY   #$00              ; clear table pointer
00827D  2               
00827D  2               LAB_13D0
00827D  2  D1 25              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
00827F  2  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
008281  2               
008281  2  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
008283  2                                             ; Y and save to crunched
008283  2               
008283  2  C8                 INY                     ; else increment pointer
008284  2  80 F7              BRA   LAB_13D0          ; and loop (branch always)
008286  2               
008286  2               ; have matched first character of some keyword
008286  2               
008286  2               LAB_13D1
008286  2  98                 TYA                     ; copy matching index
008287  2  0A                 ASL                     ; *2 (bytes per pointer)
008288  2  AA                 TAX                     ; copy to new index
008289  2  BD B8 A2           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
00828C  2  85 25              STA   ut2_pl            ; save pointer low byte
00828E  2  BD B9 A2           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
008291  2  85 26              STA   ut2_ph            ; save pointer high byte
008293  2  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
008295  2  A6 2A              LDX   TempB             ; restore buffer read index
008297  2               
008297  2               LAB_13D6
008297  2  C8                 INY                     ; next table byte
008298  2  B1 25              LDA   (ut2_pl),Y        ; get byte from table
00829A  2               LAB_13D8
00829A  2  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
00829C  2  E8                 INX                     ; next buffer byte
00829D  2  DD 00 03           CMP   Ibuffs,X          ; compare with byte from input buffer
0082A0  2  F0 F5              BEQ   LAB_13D6          ; go compare next if match
0082A2  2  80 2B              BRA   LAB_1417          ; branch if >< (not found keyword)
0082A4  2               
0082A4  2               LAB_13EA
0082A4  2  A4 6C              LDY   csidx             ; restore save index
0082A6  2                                             ; save crunched to output
0082A6  2               LAB_13EC
0082A6  2  E8                 INX                     ; increment buffer index (to next input byte)
0082A7  2  C8                 INY                     ; increment save index (to next output byte)
0082A8  2  99 00 03           STA   Ibuffs,Y          ; save byte to output
0082AB  2  C9 00              CMP   #$00              ; set the flags, set carry
0082AD  2  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
0082AF  2               
0082AF  2                                             ; A holds token or byte here
0082AF  2  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
0082B1  2  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
0082B3  2               
0082B3  2                                             ; A now holds token-$3A
0082B3  2  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
0082B5  2  D0 02              BNE   LAB_1401          ; branch if not DATA
0082B7  2               
0082B7  2                                             ; token was : or DATA
0082B7  2               LAB_13FF
0082B7  2  85 12              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0082B9  2               LAB_1401
0082B9  2  49 55              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
0082BB  2  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
0082BD  2  85 0E              STA   Asrch             ; else was REM so set search for [EOL]
0082BF  2                                             ; loop for REM, "..." etc.
0082BF  2               LAB_1408
0082BF  2  BD 00 03           LDA   Ibuffs,X          ; get byte from input buffer
0082C2  2  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
0082C4  2  C5 0E              CMP   Asrch             ; compare with stored character
0082C6  2  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
0082C8  2                                             ; entry for copy string in quotes, don't crunch
0082C8  2               LAB_1410
0082C8  2  C8                 INY                     ; increment buffer save index
0082C9  2  99 00 03           STA   Ibuffs,Y          ; save byte to output
0082CC  2  E8                 INX                     ; increment buffer read index
0082CD  2  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
0082CF  2                                             ; not found keyword this go
0082CF  2               LAB_1417
0082CF  2  A6 2A              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
0082D1  2               
0082D1  2                                             ; now find the end of this word in the table
0082D1  2               LAB_141B
0082D1  2  B1 25              LDA   (ut2_pl),Y        ; get table byte
0082D3  2  08                 PHP                     ; save status
0082D4  2  C8                 INY                     ; increment table index
0082D5  2  28                 PLP                     ; restore byte status
0082D6  2  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
0082D8  2               
0082D8  2  B1 25              LDA   (ut2_pl),Y        ; get byte from keyword table
0082DA  2  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
0082DC  2               
0082DC  2                                             ; reached end of table with no match
0082DC  2  BD 00 03           LDA   Ibuffs,X          ; restore byte from input buffer
0082DF  2  80 C3              BRA   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
0082E1  2                                             ; go save byte in output and continue crunching
0082E1  2                                             ; reached [EOL]
0082E1  2               LAB_142A
0082E1  2  C8                 INY                     ; increment pointer
0082E2  2  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
0082E3  2  99 00 03           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
0082E6  2  C8                 INY                     ; adjust for line copy
0082E7  2  C8                 INY                     ; adjust for line copy
0082E8  2  C8                 INY                     ; adjust for line copy
0082E9  2  A5 6E              LDA   Bpntrl            ; test for $00
0082EB  2  D0 02              BNE   LAB_142P          ; not $00
0082ED  2  C6 6F              DEC   Bpntrh            ; allow for increment when $xx00
0082EF  2               LAB_142P
0082EF  2  C6 6E              DEC   Bpntrl            ; allow for increment
0082F1  2  60                 RTS
0082F2  2               
0082F2  2               ; search Basic for temp integer line number from start of mem
0082F2  2               
0082F2  2               LAB_SSLN
0082F2  2  A5 2B              LDA   Smeml             ; get start of mem low byte
0082F4  2  A6 2C              LDX   Smemh             ; get start of mem high byte
0082F6  2               
0082F6  2               ; search Basic for temp integer line number from AX
0082F6  2               ; returns carry set if found
0082F6  2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
0082F6  2               
0082F6  2               LAB_SHLN
0082F6  2  A0 01              LDY   #$01              ; set index
0082F8  2  85 5C              STA   Baslnl            ; save low byte as current
0082FA  2  86 5D              STX   Baslnh            ; save high byte as current
0082FC  2  B1 5C              LDA   (Baslnl),Y        ; get pointer high byte from addr
0082FE  2  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
008300  2               
008300  2  A0 03              LDY   #$03              ; set index to line # high byte
008302  2  B1 5C              LDA   (Baslnl),Y        ; get line # high byte
008304  2  88                 DEY                     ; decrement index (point to low byte)
008305  2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
008307  2  D0 04              BNE   LAB_1455          ; if <> skip low byte check
008309  2               
008309  2  B1 5C              LDA   (Baslnl),Y        ; get line # low byte
00830B  2  C5 0A              CMP   Itempl            ; compare with temporary integer low byte
00830D  2               LAB_1455
00830D  2  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
00830F  2               
00830F  2               LAB_1456
00830F  2  88                 DEY                     ; decrement index to next line ptr high byte
008310  2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
008312  2  AA                 TAX                     ; copy to X
008313  2  88                 DEY                     ; decrement index to next line ptr low byte
008314  2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
008316  2  80 DE              BRA   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
008318  2                                             ; (carry always clear)
008318  2               
008318  2               LAB_145E
008318  2  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
00831A  2               
00831A  2               LAB_145F
00831A  2  18                 CLC                     ; clear found flag
00831B  2               LAB_1460
00831B  2  60                 RTS
00831C  2               
00831C  2               ; perform NEW
00831C  2               
00831C  2               LAB_NEW
00831C  2  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
00831E  2               
00831E  2               LAB_1463
00831E  2  A9 00              LDA   #$00              ; clear A
008320  2  A8                 TAY                     ; clear Y
008321  2  91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
008323  2  C8                 INY                     ; increment index
008324  2  91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
008326  2  18                 CLC                     ; clear carry
008327  2  A5 2B              LDA   Smeml             ; get start of mem low byte
008329  2  69 02              ADC   #$02              ; calculate end of BASIC low byte
00832B  2  85 2D              STA   Svarl             ; save start of vars low byte
00832D  2  A5 2C              LDA   Smemh             ; get start of mem high byte
00832F  2  69 00              ADC   #$00              ; add any carry
008331  2  85 2E              STA   Svarh             ; save start of vars high byte
008333  2               
008333  2               ; reset execution to start, clear vars and flush stack
008333  2               
008333  2               LAB_1477
008333  2  18                 CLC                     ; clear carry
008334  2  A5 2B              LDA   Smeml             ; get start of mem low byte
008336  2  69 FF              ADC   #$FF              ; -1
008338  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
00833A  2  A5 2C              LDA   Smemh             ; get start of mem high byte
00833C  2  69 FF              ADC   #$FF              ; -1+carry
00833E  2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
008340  2               
008340  2               ; "CLEAR" command gets here
008340  2               
008340  2               LAB_147A
008340  2  A5 37              LDA   Ememl             ; get end of mem low byte
008342  2  A4 38              LDY   Ememh             ; get end of mem high byte
008344  2  85 33              STA   Sstorl            ; set bottom of string space low byte
008346  2  84 34              STY   Sstorh            ; set bottom of string space high byte
008348  2  A5 2D              LDA   Svarl             ; get start of vars low byte
00834A  2  A4 2E              LDY   Svarh             ; get start of vars high byte
00834C  2  85 2F              STA   Sarryl            ; save var mem end low byte
00834E  2  84 30              STY   Sarryh            ; save var mem end high byte
008350  2  85 31              STA   Earryl            ; save array mem end low byte
008352  2  84 32              STY   Earryh            ; save array mem end high byte
008354  2  20 03 85           JSR   LAB_161A          ; perform RESTORE command
008357  2               
008357  2               ; flush stack and clear continue flag
008357  2               
008357  2               LAB_1491
008357  2  A2 1A              LDX   #des_sk           ; set descriptor stack pointer
008359  2  86 17              STX   next_s            ; save descriptor stack pointer
00835B  2  FA                 PLX                     ; pull return address low byte
00835C  2  68                 PLA                     ; pull return address high byte
00835D  2  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
008360  2  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
008363  2  A2 FD              LDX   #$FD              ; new stack pointer
008365  2  9A                 TXS                     ; reset stack
008366  2  64 13              STZ   Sufnxf            ; clear subscript/FNX flag
008368  2               LAB_14A6
008368  2  60                 RTS
008369  2               
008369  2               ; perform CLEAR
008369  2               
008369  2               LAB_CLEAR
008369  2  F0 D5              BEQ   LAB_147A          ; if no following token go do "CLEAR"
00836B  2                                             ; else there was a following token (go do syntax error)
00836B  2  60                 RTS
00836C  2               
00836C  2               ; perform LIST [n][-m]
00836C  2               ; bigger, faster version (a _lot_ faster)
00836C  2               
00836C  2               LAB_LIST
00836C  2  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
00836E  2  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
008370  2               
008370  2  C9 B3              CMP   #TK_MINUS         ; compare with token for -
008372  2  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
008374  2               
008374  2                                             ; LIST [[n][-m]]
008374  2                                             ; this bit sets the n , if present, as the start and end
008374  2               LAB_14BD
008374  2  20 00 87           JSR   LAB_GFPN          ; get fixed-point number into temp integer
008377  2  20 F2 82           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00837A  2                                             ; (pointer in Baslnl/Baslnh)
00837A  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00837D  2  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
00837F  2               
00837F  2                                             ; this bit checks the - is present
00837F  2  C9 B3              CMP   #TK_MINUS         ; compare with token for -
008381  2  D0 98              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
008383  2               
008383  2                                             ; LIST [n]-m
008383  2                                             ; the - was there so set m as the end value
008383  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008386  2  20 00 87           JSR   LAB_GFPN          ; get fixed-point number into temp integer
008389  2  D0 90              BNE   LAB_1460          ; exit if not ok
00838B  2               
00838B  2               LAB_14D4
00838B  2  A5 0A              LDA   Itempl            ; get temporary integer low byte
00838D  2  05 0B              ORA   Itemph            ; OR temporary integer high byte
00838F  2  D0 06              BNE   LAB_14E2          ; branch if start set
008391  2               
008391  2  A9 FF              LDA   #$FF              ; set for -1
008393  2  85 0A              STA   Itempl            ; set temporary integer low byte
008395  2  85 0B              STA   Itemph            ; set temporary integer high byte
008397  2               LAB_14E2
008397  2  A0 01              LDY   #$01              ; set index for line
008399  2  84 12              STY   Oquote            ; clear open quote flag
00839B  2  20 32 88           JSR   LAB_CRLF          ; print CR/LF
00839E  2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
0083A0  2                                             ; pointer initially set by search at LAB_14BD
0083A0  2  F0 3E              BEQ   LAB_152B          ; if null all done so exit
0083A2  2  20 D9 84           JSR   LAB_1629          ; do CRTL-C check vector
0083A5  2               
0083A5  2  C8                 INY                     ; increment index for line
0083A6  2  B1 5C              LDA   (Baslnl),Y        ; get line # low byte
0083A8  2  AA                 TAX                     ; copy to X
0083A9  2  C8                 INY                     ; increment index
0083AA  2  B1 5C              LDA   (Baslnl),Y        ; get line # high byte
0083AC  2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
0083AE  2  D0 04              BNE   LAB_14FF          ; branch if no high byte match
0083B0  2               
0083B0  2  E4 0A              CPX   Itempl            ; compare with temporary integer low byte
0083B2  2  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
0083B4  2               
0083B4  2               LAB_14FF                      ; else ..
0083B4  2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
0083B6  2               
0083B6  2               LAB_1501
0083B6  2  84 49              STY   Tidx1             ; save index for line
0083B8  2  20 FB 99           JSR   LAB_295E          ; print XA as unsigned integer
0083BB  2  A9 20              LDA   #$20              ; space is the next character
0083BD  2               LAB_1508
0083BD  2  A4 49              LDY   Tidx1             ; get index for line
0083BF  2  29 7F              AND   #$7F              ; mask top out bit of character
0083C1  2               LAB_150C
0083C1  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
0083C4  2  C9 22              CMP   #$22              ; was it " character
0083C6  2  D0 06              BNE   LAB_1519          ; branch if not
0083C8  2                                             ; we are either entering or leaving a pair of quotes
0083C8  2  A5 12              LDA   Oquote            ; get open quote flag
0083CA  2  49 FF              EOR   #$FF              ; toggle it
0083CC  2  85 12              STA   Oquote            ; save it back
0083CE  2               LAB_1519
0083CE  2  C8                 INY                     ; increment index
0083CF  2  B1 5C              LDA   (Baslnl),Y        ; get next byte
0083D1  2  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
0083D3  2  A8                 TAY                     ; else clear index
0083D4  2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
0083D6  2  AA                 TAX                     ; copy to X
0083D7  2  C8                 INY                     ; increment index
0083D8  2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
0083DA  2  86 5C              STX   Baslnl            ; set pointer to line low byte
0083DC  2  85 5D              STA   Baslnh            ; set pointer to line high byte
0083DE  2  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
0083E0  2                                             ; else ..
0083E0  2               LAB_152B
0083E0  2  60                 RTS
0083E1  2               
0083E1  2               LAB_152E
0083E1  2  10 DE              BPL   LAB_150C          ; just go print it if not token byte
0083E3  2                                             ; else was token byte so uncrunch it (maybe)
0083E3  2  24 12              BIT   Oquote            ; test the open quote flag
0083E5  2  30 DA              BMI   LAB_150C          ; just go print character if open quote set
0083E7  2               
0083E7  2  A2 A4              LDX   #>LAB_KEYT        ; get table address high byte
0083E9  2  0A                 ASL                     ; *2
0083EA  2  0A                 ASL                     ; *4
0083EB  2  90 02              BCC   LAB_152F          ; branch if no carry
0083ED  2               
0083ED  2  E8                 INX                     ; else increment high byte
0083EE  2  18                 CLC                     ; clear carry for add
0083EF  2               LAB_152F
0083EF  2  69 8A              ADC   #<LAB_KEYT        ; add low byte
0083F1  2  90 01              BCC   LAB_1530          ; branch if no carry
0083F3  2  E8                 INX                     ; else increment high byte
0083F4  2               
0083F4  2               LAB_1530
0083F4  2  85 25              STA   ut2_pl            ; save table pointer low byte
0083F6  2  86 26              STX   ut2_ph            ; save table pointer high byte
0083F8  2  84 49              STY   Tidx1             ; save index for line
0083FA  2  A0 00              LDY   #$00              ; clear index
0083FC  2  B1 25              LDA   (ut2_pl),Y        ; get length
0083FE  2  AA                 TAX                     ; copy length
0083FF  2  C8                 INY                     ; increment index
008400  2  B1 25              LDA   (ut2_pl),Y        ; get 1st character
008402  2  CA                 DEX                     ; decrement length
008403  2  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
008405  2               
008405  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
008408  2  C8                 INY                     ; increment index
008409  2  B1 25              LDA   (ut2_pl),Y        ; get keyword address low byte
00840B  2  48                 PHA                     ; save it for now
00840C  2  C8                 INY                     ; increment index
00840D  2  B1 25              LDA   (ut2_pl),Y        ; get keyword address high byte
00840F  2  A0 00              LDY   #$00
008411  2  85 26              STA   ut2_ph            ; save keyword pointer high byte
008413  2  68                 PLA                     ; pull low byte
008414  2  85 25              STA   ut2_pl            ; save keyword pointer low byte
008416  2               LAB_1540
008416  2  B1 25              LDA   (ut2_pl),Y        ; get character
008418  2  CA                 DEX                     ; decrement character count
008419  2  F0 A2              BEQ   LAB_1508          ; if last character exit and print
00841B  2               
00841B  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
00841E  2  C8                 INY                     ; increment index
00841F  2  D0 F5              BNE   LAB_1540          ; loop for next character
008421  2               
008421  2               ; perform FOR
008421  2               
008421  2               LAB_FOR
008421  2  F7 13              SMB7  Sufnxf            ; set Subscript/FNx flag
008423  2               ;      LDA   #$80              ; set FNX
008423  2               ;      STA   Sufnxf            ; set subscript/FNX flag
008423  2  20 5E 87           JSR   LAB_LET           ; go do LET
008426  2  68                 PLA                     ; pull return address
008427  2  68                 PLA                     ; pull return address
008428  2  A9 10              LDA   #$10              ; we need 16d bytes !
00842A  2  20 C6 80           JSR   LAB_1212          ; check room on stack for A bytes
00842D  2  20 54 86           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
008430  2  18                 CLC                     ; clear carry for add
008431  2  98                 TYA                     ; copy index to A
008432  2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
008434  2  48                 PHA                     ; push onto stack
008435  2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
008437  2  69 00              ADC   #$00              ; add carry
008439  2  48                 PHA                     ; push onto stack
00843A  2  A5 3A              LDA   Clineh            ; get current line high byte
00843C  2  48                 PHA                     ; push onto stack
00843D  2  A5 39              LDA   Clinel            ; get current line low byte
00843F  2  48                 PHA                     ; push onto stack
008440  2  A9 AA              LDA   #TK_TO            ; get "TO" token
008442  2  20 8D 8B           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
008445  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
008448  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00844B  2                                             ; else do type mismatch
00844B  2               
00844B  2  20 5E 98           JSR   LAB_27BA          ; round FAC1 First (patch 2.22p5)
00844E  2               
00844E  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
008450  2  09 7F              ORA   #$7F              ; set all non sign bits
008452  2  25 5F              AND   FAC1_1            ; and FAC1 mantissa1
008454  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
008456  2  A9 61              LDA   #<LAB_159F        ; set return address low byte
008458  2  A0 84              LDY   #>LAB_159F        ; set return address high byte
00845A  2  85 23              STA   ut1_pl            ; save return address low byte
00845C  2  84 24              STY   ut1_ph            ; save return address high byte
00845E  2  4C 23 8B           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
008461  2               
008461  2               LAB_159F
008461  2  A9 70              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
008463  2  A0 A1              LDY   #>LAB_259C        ; set 1 pointer high addr
008465  2  20 02 98           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
008468  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00846B  2  C9 AF              CMP   #TK_STEP          ; compare with STEP token
00846D  2  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
00846F  2               
00846F  2                                             ; was step so ..
00846F  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008472  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
008475  2                                             ; else do type mismatch
008475  2               LAB_15B3
008475  2  20 6E 98           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
008478  2  85 62              STA   FAC1_s            ; set FAC1 sign (b7)
00847A  2                                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
00847A  2                                             ; compare the FOR value and the TO value and return +1 if
00847A  2                                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
00847A  2                                             ; here (+/-1) is then compared to that result and if they
00847A  2                                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
00847A  2                                             ; the loop is done
00847A  2  20 11 8B           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
00847D  2  A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
00847F  2  48                 PHA                     ; push on stack
008480  2  A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
008482  2  48                 PHA                     ; push on stack
008483  2  A9 81              LDA   #TK_FOR           ; get FOR token
008485  2  48                 PHA                     ; push on stack
008486  2               
008486  2               ; interpreter inner loop
008486  2               
008486  2               LAB_15C2
008486  2  20 D9 84           JSR   LAB_1629          ; do CRTL-C check vector
008489  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
00848B  2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
00848D  2  A6 3A              LDX   Clineh            ; continue line is $FFxx for immediate mode
00848F  2                                             ; ($00xx for RUN from immediate mode)
00848F  2  E8                 INX                     ; increment it (now $00 if immediate mode)
008490  2  85 3D              STA   Cpntrl            ; save continue pointer low byte
008492  2  84 3E              STY   Cpntrh            ; save continue pointer high byte
008494  2               LAB_15D1
008494  2  B2 6E              LDA   (Bpntrl)          ; get next byte
008496  2  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
008498  2               
008498  2  C9 3A              CMP   #':'              ; compare with ":"
00849A  2  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
00849C  2               
00849C  2               LAB_15D9
00849C  2  4C 9C 8B           JMP   LAB_SNER          ; else syntax error then warm start
00849F  2                                             ; have reached [EOL]
00849F  2               LAB_15DC
00849F  2  A0 02              LDY   #$02              ; set index
0084A1  2  B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
0084A3  2  18                 CLC                     ; clear carry for no "BREAK" message
0084A4  2  F0 4F              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
0084A6  2                                             ; marker)
0084A6  2  C8                 INY                     ; increment index
0084A7  2  B1 6E              LDA   (Bpntrl),Y        ; get line # low byte
0084A9  2  85 39              STA   Clinel            ; save current line low byte
0084AB  2  C8                 INY                     ; increment index
0084AC  2  B1 6E              LDA   (Bpntrl),Y        ; get line # high byte
0084AE  2  85 3A              STA   Clineh            ; save current line high byte
0084B0  2  98                 TYA                     ; A now = 4
0084B1  2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
0084B3  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
0084B5  2  90 02              BCC   LAB_15F6          ; branch if no overflow
0084B7  2               
0084B7  2  E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
0084B9  2               LAB_15F6
0084B9  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
0084BC  2               
0084BC  2               LAB_15F9
0084BC  2  20 C1 84           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
0084BF  2               
0084BF  2               LAB_15FC
0084BF  2  80 C5              BRA   LAB_15C2          ; loop
0084C1  2               
0084C1  2               ; interpret BASIC code from (Bpntrl)
0084C1  2               
0084C1  2               LAB_15FF
0084C1  2  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
0084C3  2               
0084C3  2               LAB_1602
0084C3  2  0A                 ASL                     ; *2 bytes per vector and normalise token
0084C4  2  B0 03              BCS   LAB_1609          ; branch if was token
0084C6  2  4C 5E 87           JMP   LAB_LET           ; else go do implied LET
0084C9  2               
0084C9  2               LAB_1609
0084C9  2  C9 50              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
0084CB  2  B0 CF              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
0084CD  2                                             ; only tokens before TAB can start a line
0084CD  2  A8                 TAY                     ; copy to index
0084CE  2  B9 98 A1           LDA   LAB_CTBL+1,Y      ; get vector high byte
0084D1  2  48                 PHA                     ; onto stack
0084D2  2  B9 97 A1           LDA   LAB_CTBL,Y        ; get vector low byte
0084D5  2  48                 PHA                     ; onto stack
0084D6  2  4C B5 9F           JMP   LAB_IGBY          ; jump to increment and scan memory
0084D9  2                                             ; then "return" to vector
0084D9  2               
0084D9  2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
0084D9  2               ; key press is detected.
0084D9  2               
0084D9  2               LAB_1629
0084D9  2  6C 82 03           JMP   (VEC_CC)          ; ctrl-c check vector
0084DC  2               
0084DC  2               ; if there was a key press it gets back here ..
0084DC  2               
0084DC  2               LAB_1636
0084DC  2  C9 03              CMP   #$03              ; compare with CTRL-C
0084DE  2               
0084DE  2               ; perform STOP
0084DE  2               
0084DE  2               LAB_STOP
0084DE  2  B0 01              BCS   LAB_163B          ; branch if token follows STOP
0084E0  2                                             ; else just END
0084E0  2               ; END
0084E0  2               
0084E0  2               LAB_END
0084E0  2  18                 CLC                     ; clear the carry, indicate a normal program end
0084E1  2               LAB_163B
0084E1  2  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
0084E3  2               
0084E3  2  A5 6F              LDA   Bpntrh            ; get the BASIC execute pointer high byte
0084E5  2  A4 6E              LDY   Bpntrl            ; get BASIC execute pointer low byte
0084E7  2  84 3D              STY   Cpntrl            ; save continue pointer low byte
0084E9  2  85 3E              STA   Cpntrh            ; save continue pointer high byte
0084EB  2               LAB_1647
0084EB  2  A5 39              LDA   Clinel            ; get current line low byte
0084ED  2  A4 3A              LDY   Clineh            ; get current line high byte
0084EF  2  85 3B              STA   Blinel            ; save break line low byte
0084F1  2  84 3C              STY   Blineh            ; save break line high byte
0084F3  2               LAB_164F
0084F3  2  68                 PLA                     ; pull return address low
0084F4  2  68                 PLA                     ; pull return address high
0084F5  2               LAB_1651
0084F5  2  90 07              BCC   LAB_165E          ; if was program end just do warm start
0084F7  2                                             ; else ..
0084F7  2  A9 47              LDA   #<LAB_BMSG        ; point to "Break" low byte
0084F9  2  A0 A7              LDY   #>LAB_BMSG        ; point to "Break" high byte
0084FB  2  4C 14 81           JMP   LAB_1269          ; print "Break" and do warm start
0084FE  2               
0084FE  2               LAB_165E
0084FE  2  4C 1F 81           JMP   LAB_1274          ; go do warm start
008501  2               
008501  2               ; perform RESTORE
008501  2               
008501  2               LAB_RESTORE
008501  2  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
008503  2               
008503  2               LAB_161A
008503  2  38                 SEC                     ; set carry for subtract
008504  2  A5 2B              LDA   Smeml             ; get start of mem low byte
008506  2  E9 01              SBC   #$01              ; -1
008508  2  A4 2C              LDY   Smemh             ; get start of mem high byte
00850A  2  B0 01              BCS   LAB_1624          ; branch if no underflow
00850C  2               
00850C  2               LAB_uflow
00850C  2  88                 DEY                     ; else decrement high byte
00850D  2               LAB_1624
00850D  2  85 41              STA   Dptrl             ; save DATA pointer low byte
00850F  2  84 42              STY   Dptrh             ; save DATA pointer high byte
008511  2               LAB_1628
008511  2  60                 RTS
008512  2                                             ; is RESTORE n
008512  2               LAB_RESTOREn
008512  2  20 00 87           JSR   LAB_GFPN          ; get fixed-point number into temp integer
008515  2  20 58 86           JSR   LAB_SNBL          ; scan for next BASIC line
008518  2  A5 3A              LDA   Clineh            ; get current line high byte
00851A  2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
00851C  2  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
00851E  2               
00851E  2  98                 TYA                     ; else copy line index to A
00851F  2  38                 SEC                     ; set carry (+1)
008520  2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
008522  2  A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
008524  2  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
008526  2               
008526  2  E8                 INX                     ; increment high byte
008527  2  80 04              BRA   LAB_go_search     ; branch always (can never be carry clear)
008529  2               
008529  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
008529  2               
008529  2               LAB_reset_search
008529  2  A5 2B              LDA   Smeml             ; get start of mem low byte
00852B  2  A6 2C              LDX   Smemh             ; get start of mem high byte
00852D  2               
00852D  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00852D  2               
00852D  2               LAB_go_search
00852D  2               
00852D  2  20 F6 82           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
008530  2  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
008532  2               
008532  2  4C 29 86           JMP   LAB_16F7          ; else go do "Undefined statement" error
008535  2               
008535  2               LAB_line_found
008535  2                                             ; carry already set for subtract
008535  2  A5 5C              LDA   Baslnl            ; get pointer low byte
008537  2  E9 01              SBC   #$01              ; -1
008539  2  A4 5D              LDY   Baslnh            ; get pointer high byte
00853B  2  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
00853D  2  80 CD              BRA   LAB_uflow         ; else decrement high byte then save DATA pointer and
00853F  2                                             ; return (branch always)
00853F  2               ; perform NULL
00853F  2               
00853F  2               LAB_NULL
00853F  2  20 21 94           JSR   LAB_GTBY          ; get byte parameter
008542  2  86 06              STX   Nullct            ; save new NULL count
008544  2               LAB_167A
008544  2  60                 RTS
008545  2               
008545  2               ; perform CONT
008545  2               
008545  2               LAB_CONT
008545  2  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
008547  2               
008547  2  A4 3E              LDY   Cpntrh            ; get continue pointer high byte
008549  2  C0 03              CPY   #>Ibuffs          ; *** fix p2: test direct mode
00854B  2  D0 05              BNE   LAB_166C          ; go do continue if we can
00854D  2               
00854D  2  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
00854F  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
008552  2                                             ; we can continue so ..
008552  2               LAB_166C
008552  2  84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
008554  2  A5 3D              LDA   Cpntrl            ; get continue pointer low byte
008556  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
008558  2  A5 3B              LDA   Blinel            ; get break line low byte
00855A  2  A4 3C              LDY   Blineh            ; get break line high byte
00855C  2  85 39              STA   Clinel            ; set current line low byte
00855E  2  84 3A              STY   Clineh            ; set current line high byte
008560  2  60                 RTS
008561  2               
008561  2               ; perform RUN
008561  2               
008561  2               LAB_RUN
008561  2  D0 03              BNE   LAB_1696          ; branch if RUN n
008563  2  4C 33 83           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack, return
008566  2               
008566  2               ; does RUN n
008566  2               
008566  2               LAB_1696
008566  2  20 40 83           JSR   LAB_147A          ; go do "CLEAR"
008569  2  80 2E              BRA   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
00856B  2               
00856B  2               ; perform DO
00856B  2               
00856B  2               LAB_DO
00856B  2  A9 05              LDA   #$05              ; need 5 bytes for DO
00856D  2  20 C6 80           JSR   LAB_1212          ; check room on stack for A bytes
008570  2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
008572  2  48                 PHA                     ; push on stack
008573  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
008575  2  48                 PHA                     ; push on stack
008576  2  A5 3A              LDA   Clineh            ; get current line high byte
008578  2  48                 PHA                     ; push on stack
008579  2  A5 39              LDA   Clinel            ; get current line low byte
00857B  2  48                 PHA                     ; push on stack
00857C  2  A9 9B              LDA   #TK_DO            ; token for DO
00857E  2  48                 PHA                     ; push on stack
00857F  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008582  2  4C 86 84           JMP   LAB_15C2          ; go do interpreter inner loop
008585  2               
008585  2               ; perform GOSUB
008585  2               
008585  2               LAB_GOSUB
008585  2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
008587  2  20 C6 80           JSR   LAB_1212          ; check room on stack for A bytes
00858A  2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
00858C  2  48                 PHA                     ; push on stack
00858D  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
00858F  2  48                 PHA                     ; push on stack
008590  2  A5 3A              LDA   Clineh            ; get current line high byte
008592  2  48                 PHA                     ; push on stack
008593  2  A5 39              LDA   Clinel            ; get current line low byte
008595  2  48                 PHA                     ; push on stack
008596  2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
008598  2  48                 PHA                     ; push on stack
008599  2               LAB_16B0
008599  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00859C  2  20 A2 85           JSR   LAB_GOTO          ; perform GOTO n
00859F  2  4C 86 84           JMP   LAB_15C2          ; go do interpreter inner loop, return
0085A2  2               
0085A2  2               ; perform GOTO
0085A2  2               
0085A2  2               LAB_GOTO
0085A2  2  20 00 87           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0085A5  2  20 58 86           JSR   LAB_SNBL          ; scan for next BASIC line
0085A8  2  A5 3A              LDA   Clineh            ; get current line high byte
0085AA  2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
0085AC  2  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
0085AE  2               
0085AE  2  98                 TYA                     ; else copy line index to A
0085AF  2  38                 SEC                     ; set carry (+1)
0085B0  2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
0085B2  2  A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
0085B4  2  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
0085B6  2               
0085B6  2  E8                 INX                     ; increment high byte
0085B7  2  80 04              BRA   LAB_16D4          ; branch always (can never be carry)
0085B9  2               
0085B9  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
0085B9  2               
0085B9  2               LAB_16D0
0085B9  2  A5 2B              LDA   Smeml             ; get start of mem low byte
0085BB  2  A6 2C              LDX   Smemh             ; get start of mem high byte
0085BD  2               
0085BD  2               ; search for line # in temp (Itempl/Itemph) from (AX)
0085BD  2               
0085BD  2               LAB_16D4
0085BD  2  20 F6 82           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
0085C0  2  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
0085C2  2                                             ; (unspecified statement)
0085C2  2                                             ; carry already set for subtract
0085C2  2  A5 5C              LDA   Baslnl            ; get pointer low byte
0085C4  2  E9 01              SBC   #$01              ; -1
0085C6  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
0085C8  2  A5 5D              LDA   Baslnh            ; get pointer high byte
0085CA  2  E9 00              SBC   #$00              ; subtract carry
0085CC  2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
0085CE  2               LAB_16E5
0085CE  2  60                 RTS
0085CF  2               
0085CF  2               LAB_DONOK
0085CF  2  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
0085D1  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
0085D4  2               
0085D4  2               ; perform LOOP
0085D4  2               
0085D4  2               LAB_LOOP
0085D4  2  A8                 TAY                     ; save following token
0085D5  2  BA                 TSX                     ; copy stack pointer
0085D6  2  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
0085D9  2  C9 9B              CMP   #TK_DO            ; compare with DO token
0085DB  2  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
0085DD  2               
0085DD  2  E8                 INX                     ; dump calling routine return address
0085DE  2  E8                 INX                     ; dump calling routine return address
0085DF  2  9A                 TXS                     ; correct stack
0085E0  2  98                 TYA                     ; get saved following token back
0085E1  2  F0 20              BEQ   LoopAlways        ; if no following token loop forever
0085E3  2                                             ; (stack pointer in X)
0085E3  2               
0085E3  2  C9 3A              CMP   #':'              ; could be ':'
0085E5  2  F0 1C              BEQ   LoopAlways        ; if :... loop forever
0085E7  2               
0085E7  2  E9 B0              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
0085E9  2  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
0085EA  2  F0 04              BEQ   DoRest            ; branch if was UNTIL
0085EC  2               
0085EC  2  CA                 DEX                     ; decrement result
0085ED  2  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
0085EF  2                                             ; only if the token was WHILE will this fail
0085EF  2               
0085EF  2  CA                 DEX                     ; set invert result byte
0085F0  2               DoRest
0085F0  2  86 4A              STX   Frnxth            ; save invert result byte
0085F2  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
0085F5  2  20 7C 8A           JSR   LAB_EVEX          ; evaluate expression
0085F8  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
0085FA  2  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
0085FC  2               
0085FC  2  A9 FF              LDA   #$FF              ; else set all bits
0085FE  2               DoCmp
0085FE  2  BA                 TSX                     ; copy stack pointer
0085FF  2  45 4A              EOR   Frnxth            ; EOR with invert byte
008601  2  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
008603  2                                             ; loop condition wasn't met so do it again
008603  2               LoopAlways
008603  2  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
008606  2  85 39              STA   Clinel            ; save current line low byte
008608  2  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
00860B  2  85 3A              STA   Clineh            ; save current line high byte
00860D  2  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
008610  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
008612  2  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
008615  2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
008617  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00861A  2  4C 86 84           JMP   LAB_15C2          ; go do interpreter inner loop
00861D  2               
00861D  2                                             ; clear stack and back to interpreter loop
00861D  2               LoopDone
00861D  2  E8                 INX                     ; dump DO token
00861E  2  E8                 INX                     ; dump current line low byte
00861F  2  E8                 INX                     ; dump current line high byte
008620  2  E8                 INX                     ; dump BASIC execute pointer low byte
008621  2  E8                 INX                     ; dump BASIC execute pointer high byte
008622  2  9A                 TXS                     ; correct stack
008623  2  80 1E              BRA   LAB_DATA          ; go perform DATA (find : or [EOL])
008625  2               
008625  2               ; do the return without gosub error
008625  2               
008625  2               LAB_16F4
008625  2  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
008627  2  80 02              BRA   LAB_16F7b         ; branch around next instruction, save one clock cycle
008629  2               
008629  2               LAB_16F7                      ; do undefined statement error
008629  2  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
00862B  2               LAB_16F7b
00862B  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
00862E  2               
00862E  2               ; perform RETURN
00862E  2               
00862E  2               LAB_RETURN
00862E  2  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
008630  2               
008630  2               LAB_16E8
008630  2  68                 PLA                     ; dump calling routine return address
008631  2  68                 PLA                     ; dump calling routine return address
008632  2  68                 PLA                     ; pull token
008633  2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
008635  2  D0 EE              BNE   LAB_16F4          ; branch if no matching GOSUB
008637  2               
008637  2               LAB_16FF
008637  2  68                 PLA                     ; pull current line low byte
008638  2  85 39              STA   Clinel            ; save current line low byte
00863A  2  68                 PLA                     ; pull current line high byte
00863B  2  85 3A              STA   Clineh            ; save current line high byte
00863D  2  68                 PLA                     ; pull BASIC execute pointer low byte
00863E  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
008640  2  68                 PLA                     ; pull BASIC execute pointer high byte
008641  2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
008643  2               
008643  2                                             ; now do the DATA statement as we could be returning into
008643  2                                             ; the middle of an ON <var> GOSUB n,m,p,q line
008643  2                                             ; (the return address used by the DATA statement is the one
008643  2                                             ; pushed before the GOSUB was executed!)
008643  2               
008643  2               ; perform DATA
008643  2               
008643  2               LAB_DATA
008643  2  20 54 86           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
008646  2               
008646  2                                             ; set BASIC execute pointer
008646  2               LAB_170F
008646  2  98                 TYA                     ; copy index to A
008647  2  18                 CLC                     ; clear carry for add
008648  2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
00864A  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
00864C  2  90 02              BCC   LAB_1719          ; skip next if no carry
00864E  2               
00864E  2  E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
008650  2               LAB_1719
008650  2  60                 RTS
008651  2               
008651  2               LAB_16FC
008651  2  4C 9C 8B           JMP   LAB_SNER          ; do syntax error then warm start
008654  2               
008654  2               ; scan for next BASIC statement ([:] or [EOL])
008654  2               ; returns Y as index to [:] or [EOL]
008654  2               
008654  2               LAB_SNBS
008654  2  A2 3A              LDX   #':'              ; set look for character = ":"
008656  2  80 02              BRA   LAB_SNBLb         ; branch around next instruction, save one clock cycle
008658  2               
008658  2               ; scan for next BASIC line
008658  2               ; returns Y as index to [EOL]
008658  2               
008658  2               LAB_SNBL
008658  2  A2 00              LDX   #$00              ; set alt search character = [EOL]
00865A  2               LAB_SNBLb
00865A  2  A0 00              LDY   #$00              ; set search character = [EOL]
00865C  2  84 0E              STY   Asrch             ; store search character
00865E  2               LAB_1725
00865E  2  8A                 TXA                     ; get alt search character
00865F  2  45 0E              EOR   Asrch             ; toggle search character, effectively swap with $00
008661  2  85 0E              STA   Asrch             ; save swapped search character
008663  2               LAB_172D
008663  2  B1 6E              LDA   (Bpntrl),Y        ; get next byte
008665  2  F0 E9              BEQ   LAB_1719          ; exit if null [EOL]
008667  2               
008667  2  C5 0E              CMP   Asrch             ; compare with search character
008669  2  F0 E5              BEQ   LAB_1719          ; exit if found
00866B  2               
00866B  2  C8                 INY                     ; increment index
00866C  2  C9 22              CMP   #$22              ; compare current character with open quote
00866E  2  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
008670  2  80 EC              BRA   LAB_1725          ; if found go swap search character for alt search character
008672  2               
008672  2               ; perform IF
008672  2               
008672  2               LAB_IF
008672  2  20 7C 8A           JSR   LAB_EVEX          ; evaluate the expression
008675  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008678  2  C9 AD              CMP   #TK_THEN          ; compare with THEN token
00867A  2  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
00867C  2               
00867C  2                                             ; wasn't IF .. THEN so must be IF .. GOTO
00867C  2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
00867E  2  D0 D1              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
008680  2               
008680  2  A6 6E              LDX   Bpntrl            ; save the basic pointer low byte
008682  2  A4 6F              LDY   Bpntrh            ; save the basic pointer high byte
008684  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008687  2  B0 C8              BCS   LAB_16FC          ; if not numeric go do syntax error
008689  2               
008689  2  86 6E              STX   Bpntrl            ; restore the basic pointer low byte
00868B  2  84 6F              STY   Bpntrh            ; restore the basic pointer high byte
00868D  2               LAB_174B
00868D  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
00868F  2  F0 1C              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
008691  2               
008691  2  20 B5 9F           JSR   LAB_IGBY          ; else increment and scan memory
008694  2  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
008696  2               
008696  2               LAB_174C
008696  2  4C A2 85           JMP   LAB_GOTO          ; else was numeric so do GOTO n
008699  2               
008699  2                                             ; is var or keyword
008699  2               LAB_174D
008699  2  68                 PLA                     ; discard interpreter loop return address
00869A  2  68                 PLA                     ; so data structures are at the correct stack offset
00869B  2  20 BB 9F           JSR   LAB_GBYT          ; restore token or variable
00869E  2  20 C1 84           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
0086A1  2               
0086A1  2               ; the IF was executed and there may be a following ELSE so the code needs to return
0086A1  2               ; here to check and ignore the ELSE if present
0086A1  2               
0086A1  2  B2 6E              LDA   (Bpntrl)          ; get the next BASIC byte
0086A3  2  C9 A9              CMP   #TK_ELSE          ; compare it with the token for ELSE
0086A5  2  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
0086A7  2  20 43 86           JSR   LAB_DATA          ; yes - skip the rest of the line
0086AA  2               
0086AA  2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0086AA  2               ; following ELSE will, correctly, cause a syntax error
0086AA  2               
0086AA  2               LAB_no_ELSE
0086AA  2  4C 86 84           JMP LAB_15C2            ; return to the interpreter inner loop
0086AD  2               
0086AD  2               ; perform ELSE after IF
0086AD  2               
0086AD  2               LAB_174E
0086AD  2  A0 00              LDY   #$00              ; clear the BASIC byte index
0086AF  2  A2 01              LDX   #$01              ; clear the nesting depth
0086B1  2               LAB_1750
0086B1  2  C8                 INY                     ; increment the BASIC byte index
0086B2  2  B1 6E              LDA   (Bpntrl),Y        ; get the next BASIC byte
0086B4  2  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
0086B6  2               
0086B6  2  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
0086B8  2  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
0086BA  2               
0086BA  2  E8                 INX                     ; else increment the nesting depth,
0086BB  2  D0 F4              BNE   LAB_1750          ; and continue looking
0086BD  2               
0086BD  2               LAB_1752
0086BD  2  C9 A9              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
0086BF  2  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
0086C1  2               
0086C1  2  CA                 DEX                     ; was ELSE so decrement the nesting depth
0086C2  2  D0 ED              BNE   LAB_1750          ; loop if still nested
0086C4  2               
0086C4  2  C8                 INY                     ; increment the BASIC byte index past the ELSE
0086C5  2               
0086C5  2               ; found the matching ELSE, now do <{n|statement}>
0086C5  2               
0086C5  2               LAB_1753
0086C5  2  98                 TYA                     ; else copy line index to A
0086C6  2  18                 CLC                     ; clear carry for add
0086C7  2  65 6E              ADC   Bpntrl            ; add the BASIC execute pointer low byte
0086C9  2  85 6E              STA   Bpntrl            ; save the BASIC execute pointer low byte
0086CB  2  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
0086CD  2               
0086CD  2  E6 6F              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
0086CF  2               LAB_1754
0086CF  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
0086D2  2  90 C2              BCC   LAB_174C          ; if numeric do GOTO n
0086D4  2                                             ; the code will return to the interpreter loop at the
0086D4  2                                             ; tail end of the GOTO <n>
0086D4  2               
0086D4  2  4C C1 84           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
0086D7  2                                             ; the code will return to the interpreter loop at the
0086D7  2                                             ; tail end of the <statement>
0086D7  2               
0086D7  2               ; perform REM, skip (rest of) line
0086D7  2               
0086D7  2               LAB_REM
0086D7  2  20 58 86           JSR   LAB_SNBL          ; scan for next BASIC line
0086DA  2  4C 46 86           JMP   LAB_170F          ; go set BASIC execute pointer and return
0086DD  2               
0086DD  2               LAB_16FD
0086DD  2  4C 9C 8B           JMP   LAB_SNER          ; do syntax error then warm start
0086E0  2               
0086E0  2               ; perform ON
0086E0  2               
0086E0  2               LAB_ON
0086E0  2  20 21 94           JSR   LAB_GTBY          ; get byte parameter
0086E3  2  48                 PHA                     ; push GOTO/GOSUB token
0086E4  2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
0086E6  2  F0 04              BEQ   LAB_176B          ; branch if GOSUB
0086E8  2               
0086E8  2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
0086EA  2               LAB_1767
0086EA  2  D0 F1              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
0086EC  2               
0086EC  2               ; next character was GOTO or GOSUB
0086EC  2               
0086EC  2               LAB_176B
0086EC  2  C6 61              DEC   FAC1_3            ; decrement index (byte value)
0086EE  2  D0 04              BNE   LAB_1773          ; branch if not zero
0086F0  2               
0086F0  2  68                 PLA                     ; pull GOTO/GOSUB token
0086F1  2  4C C3 84           JMP   LAB_1602          ; go execute it
0086F4  2               
0086F4  2               LAB_1773
0086F4  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
0086F7  2  20 00 87           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
0086FA  2                                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
0086FA  2                                             ; just BNE LAB_176B for the loop. should be quicker ..
0086FA  2                                             ; no we can't, what if we meet a colon or [EOL]?)
0086FA  2  C9 2C              CMP   #$2C              ; compare next character with ","
0086FC  2  F0 EE              BEQ   LAB_176B          ; loop if ","
0086FE  2               
0086FE  2               LAB_177E
0086FE  2  68                 PLA                     ; else pull keyword token (run out of options)
0086FF  2                                             ; also dump +/-1 pointer low byte and exit
0086FF  2               LAB_177F
0086FF  2  60                 RTS
008700  2               
008700  2               ; takes n * 106 + 11 cycles where n is the number of digits
008700  2               
008700  2               ; get fixed-point number into temp integer
008700  2               
008700  2               LAB_GFPN
008700  2  A2 00              LDX   #$00              ; clear reg
008702  2  86 0A              STX   Itempl            ; clear temporary integer low byte
008704  2               LAB_1785
008704  2  86 0B              STX   Itemph            ; save temporary integer high byte
008706  2  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
008708  2                                             ; not 0-9
008708  2               
008708  2  E0 19              CPX   #$19              ; compare high byte with $19
00870A  2  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
00870B  2  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
00870D  2                                             ; bit does *$0A, = 64000, compare at target will fail
00870D  2                                             ; and do syntax error
00870D  2               
00870D  2  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
00870F  2  A8                 TAY                     ; copy binary digit
008710  2  A5 0A              LDA   Itempl            ; get temporary integer low byte
008712  2  0A                 ASL                     ; *2 low byte
008713  2  26 0B              ROL   Itemph            ; *2 high byte
008715  2  0A                 ASL                     ; *2 low byte
008716  2  26 0B              ROL   Itemph            ; *2 high byte, *4
008718  2  65 0A              ADC   Itempl            ; + low byte, *5
00871A  2  85 0A              STA   Itempl            ; save it
00871C  2  8A                 TXA                     ; get high byte copy to A
00871D  2  65 0B              ADC   Itemph            ; + high byte, *5
00871F  2  06 0A              ASL   Itempl            ; *2 low byte, *10d
008721  2  2A                 ROL                     ; *2 high byte, *10d
008722  2  AA                 TAX                     ; copy high byte back to X
008723  2  98                 TYA                     ; get binary digit back
008724  2  65 0A              ADC   Itempl            ; add number low byte
008726  2  85 0A              STA   Itempl            ; save number low byte
008728  2  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
00872A  2               
00872A  2  E8                 INX                     ; else increment high byte
00872B  2               LAB_17B3
00872B  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
00872E  2  80 D4              BRA   LAB_1785          ; loop for next character
008730  2               
008730  2               ; perform DEC
008730  2               
008730  2               LAB_DEC
008730  2  A9 74              LDA   #<LAB_2AFD        ; set -1 pointer low byte
008732  2  80 02              BRA   LAB_17B5          ; branch around next instruction, saves one clock cycle
008734  2               
008734  2               ; perform INC
008734  2               
008734  2               LAB_INC
008734  2  A9 70              LDA   #<LAB_259C        ; set 1 pointer low byte
008736  2               LAB_17B5
008736  2  48                 PHA                     ; save +/-1 pointer low byte
008737  2               LAB_17B7
008737  2  20 4C 8D           JSR   LAB_GVAR          ; get var address
00873A  2  A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00873C  2  30 1D              BMI   IncrErr           ; exit if string
00873E  2               
00873E  2  85 49              STA   Lvarpl            ; save var address low byte
008740  2  84 4A              STY   Lvarph            ; save var address high byte
008742  2  20 02 98           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
008745  2  68                 PLA                     ; get +/-1 pointer low byte
008746  2  48                 PHA                     ; save +/-1 pointer low byte
008747  2  A0 A1              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
008749  2  20 4A 95           JSR   LAB_246C          ; add (AY) to FAC1
00874C  2  20 28 98           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
00874F  2               
00874F  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008752  2  C9 2C              CMP   #','              ; compare with ","
008754  2  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
008756  2               
008756  2                                             ; was "," so another INCR variable to do
008756  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008759  2  80 DC              BRA   LAB_17B7          ; go do next var
00875B  2               
00875B  2               IncrErr
00875B  2  4C 77 8A           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
00875E  2               
00875E  2               ; perform LET
00875E  2               
00875E  2               LAB_LET
00875E  2  20 4C 8D           JSR   LAB_GVAR          ; get var address
008761  2  85 49              STA   Lvarpl            ; save var address low byte
008763  2  84 4A              STY   Lvarph            ; save var address high byte
008765  2  A9 BD              LDA   #TK_EQUAL         ; get = token
008767  2  20 8D 8B           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00876A  2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00876C  2  48                 PHA                     ; push data type flag
00876D  2  20 7C 8A           JSR   LAB_EVEX          ; evaluate expression
008770  2  68                 PLA                     ; pop data type flag
008771  2  2A                 ROL                     ; set carry if type = string
008772  2  20 6E 8A           JSR   LAB_CKTM          ; type match check, set C for string
008775  2  B0 03              BCS   LAB_17D5          ; branch if string
008777  2  4C 28 98           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
00877A  2               
00877A  2               ; string LET
00877A  2               
00877A  2               LAB_17D5
00877A  2  A0 02              LDY   #$02              ; set index to pointer high byte
00877C  2  B1 60              LDA   (des_pl),Y        ; get string pointer high byte
00877E  2  C5 34              CMP   Sstorh            ; compare bottom of string space high byte
008780  2  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
008782  2               
008782  2  D0 07              BNE   LAB_17E6          ; branch if >
008784  2                                             ; else was equal so compare low bytes
008784  2  88                 DEY                     ; decrement index
008785  2  B1 60              LDA   (des_pl),Y        ; get pointer low byte
008787  2  C5 33              CMP   Sstorl            ; compare bottom of string space low byte
008789  2  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
00878B  2               
00878B  2                                             ; pointer was >= to bottom of string space pointer
00878B  2               LAB_17E6
00878B  2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
00878D  2  C4 2E              CPY   Svarh             ; compare start of vars high byte
00878F  2  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
008791  2  D0 0C              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
008793  2                                             ; else high bytes were equal so ..
008793  2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
008795  2  C5 2D              CMP   Svarl             ; compare start of vars low byte
008797  2  B0 06              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
008799  2               
008799  2               LAB_17F4
008799  2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
00879B  2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
00879D  2  80 14              BRA   LAB_1811          ; clean stack, copy descriptor to variable and return
00879F  2               
00879F  2                                             ; make space and copy string
00879F  2               LAB_17FB
00879F  2  B2 60              LDA   (des_pl)          ; get string length
0087A1  2  20 CD 90           JSR   LAB_209C          ; copy string
0087A4  2  A5 50              LDA   des_2l            ; get descriptor pointer low byte
0087A6  2  A4 51              LDY   des_2h            ; get descriptor pointer high byte
0087A8  2  85 6A              STA   ssptr_l           ; save descriptor pointer low byte
0087AA  2  84 6B              STY   ssptr_h           ; save descriptor pointer high byte
0087AC  2  20 AD 92           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
0087AF  2  A9 5E              LDA   #<FAC1_e          ; set descriptor pointer low byte
0087B1  2  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
0087B3  2               
0087B3  2                                             ; clean stack and assign value to string variable
0087B3  2               LAB_1811
0087B3  2  85 50              STA   des_2l            ; save descriptor_2 pointer low byte
0087B5  2  84 51              STY   des_2h            ; save descriptor_2 pointer high byte
0087B7  2  20 0F 93           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
0087BA  2  A0 00              LDY   #$00              ; index to length
0087BC  2  B1 50              LDA   (des_2l),Y        ; get string length
0087BE  2  91 49              STA   (Lvarpl),Y        ; copy to let string variable
0087C0  2  C8                 INY                     ; index to string pointer low byte
0087C1  2  B1 50              LDA   (des_2l),Y        ; get string pointer low byte
0087C3  2  91 49              STA   (Lvarpl),Y        ; copy to let string variable
0087C5  2  C8                 INY                     ; index to string pointer high byte
0087C6  2  B1 50              LDA   (des_2l),Y        ; get string pointer high byte
0087C8  2  91 49              STA   (Lvarpl),Y        ; copy to let string variable
0087CA  2  60                 RTS
0087CB  2               
0087CB  2               ; perform GET
0087CB  2               
0087CB  2               LAB_GET
0087CB  2  20 4C 8D           JSR   LAB_GVAR          ; get var address
0087CE  2  85 49              STA   Lvarpl            ; save var address low byte
0087D0  2  84 4A              STY   Lvarph            ; save var address high byte
0087D2  2  20 38 9E           JSR   INGET             ; get input byte
0087D5  2  A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
0087D7  2  30 07              BMI   LAB_GETS          ; go get string character
0087D9  2                                             ; was numeric get
0087D9  2  A8                 TAY                     ; copy character to Y
0087DA  2  20 05 90           JSR   LAB_1FD0          ; convert Y to byte in FAC1
0087DD  2  4C 28 98           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
0087E0  2               
0087E0  2               LAB_GETS
0087E0  2  48                 PHA                     ; save character
0087E1  2  A9 01              LDA   #$01              ; string is single byte
0087E3  2  B0 01              BCS   LAB_IsByte        ; branch if byte received
0087E5  2               
0087E5  2  68                 PLA                     ; string is null
0087E6  2               LAB_IsByte
0087E6  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
0087E9  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0087E9  2  F0 03              BEQ   LAB_NoSt          ; skip store if null string
0087EB  2               
0087EB  2  68                 PLA                     ; get character back
0087EC  2  92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
0087EE  2               LAB_NoSt
0087EE  2  20 22 91           JSR   LAB_RTST          ; check for space on descriptor stack then put address
0087F1  2                                             ; and length on descriptor stack and update stack pointers
0087F1  2  80 87              BRA   LAB_17D5          ; do string LET and return
0087F3  2               
0087F3  2               ; perform PRINT
0087F3  2               
0087F3  2               LAB_1829
0087F3  2  20 76 88           JSR   LAB_18C6          ; print string from Sutill/Sutilh
0087F6  2               LAB_182C
0087F6  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
0087F9  2               
0087F9  2               ; PRINT
0087F9  2               
0087F9  2               LAB_PRINT
0087F9  2  F0 37              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
0087FB  2               
0087FB  2               LAB_1831
0087FB  2  C9 A8              CMP   #TK_TAB           ; compare with TAB( token
0087FD  2  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
0087FF  2               
0087FF  2  C9 AC              CMP   #TK_SPC           ; compare with SPC( token
008801  2  F0 4E              BEQ   LAB_18A2          ; go do TAB/SPC
008803  2               
008803  2  C9 2C              CMP   #','              ; compare with ","
008805  2  F0 34              BEQ   LAB_188B          ; go do move to next TAB mark
008807  2               
008807  2  C9 3B              CMP   #';'              ; compare with ";"
008809  2  F0 62              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
00880B  2               
00880B  2  20 7C 8A           JSR   LAB_EVEX          ; evaluate expression
00880E  2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
008810  2  30 E1              BMI   LAB_1829          ; branch if string
008812  2               
008812  2  20 0E 9A           JSR   LAB_296E          ; convert FAC1 to string
008815  2  20 DF 90           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
008818  2               
008818  2               ; don't check fit if terminal width byte is zero
008818  2               
008818  2  A5 08              LDA   TWidth            ; get terminal width byte
00881A  2  F0 0A              BEQ   LAB_185E          ; skip check if zero
00881C  2               
00881C  2  38                 SEC                     ; set carry for subtract
00881D  2  E5 07              SBC   TPos              ; subtract terminal position
00881F  2  F2 60              SBC   (des_pl)          ; subtract string length
008821  2  B0 03              BCS   LAB_185E          ; branch if less than terminal width
008823  2               
008823  2  20 32 88           JSR   LAB_CRLF          ; else print CR/LF
008826  2               LAB_185E
008826  2  20 76 88           JSR   LAB_18C6          ; print string from Sutill/Sutilh
008829  2  80 CB              BRA   LAB_182C          ; always go continue processing line
00882B  2               
00882B  2               ; CR/LF return to BASIC from BASIC input handler
00882B  2               
00882B  2               LAB_1866
00882B  2  9E 00 03           STZ   Ibuffs,X          ; null terminate input
00882E  2  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
008830  2  A0 03              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
008832  2               
008832  2               ; print CR/LF
008832  2               
008832  2               LAB_CRLF
008832  2  A9 0D              LDA   #$0D              ; load [CR]
008834  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
008837  2  A9 0A              LDA   #$0A              ; load [LF]
008839  2  80 53              BRA   LAB_PRNA          ; go print the character and return, branch always
00883B  2               
00883B  2               LAB_188B
00883B  2  A5 07              LDA   TPos              ; get terminal position
00883D  2  C5 09              CMP   Iclim             ; compare with input column limit
00883F  2  90 05              BCC   LAB_1897          ; branch if less
008841  2               
008841  2  20 32 88           JSR   LAB_CRLF          ; else print CR/LF (next line)
008844  2  80 27              BRA   LAB_18BD          ; continue with PRINT processing (branch always)
008846  2               
008846  2               LAB_1897
008846  2  38                 SEC                     ; set carry for subtract
008847  2               LAB_1898
008847  2  E5 16              SBC   TabSiz            ; subtract TAB size
008849  2  B0 FC              BCS   LAB_1898          ; loop if result was +ve
00884B  2               
00884B  2  49 FF              EOR   #$FF              ; complement it
00884D  2  69 01              ADC   #$01              ; +1 (twos complement)
00884F  2  80 12              BRA   LAB_18B6          ; always print A spaces (result is never $00)
008851  2               
008851  2                                             ; do TAB/SPC
008851  2               LAB_18A2
008851  2  48                 PHA                     ; save token
008852  2  20 1E 94           JSR   LAB_SGBY          ; scan and get byte parameter
008855  2  C9 29              CMP   #$29              ; is next character )
008857  2  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
008859  2               
008859  2  68                 PLA                     ; get token back
00885A  2  C9 A8              CMP   #TK_TAB           ; was it TAB ?
00885C  2  D0 06              BNE   LAB_18B7          ; if not go do SPC
00885E  2               
00885E  2                                             ; calculate TAB offset
00885E  2  8A                 TXA                     ; copy integer value to A
00885F  2  E5 07              SBC   TPos              ; subtract terminal position
008861  2  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
008863  2               
008863  2                                             ; print A spaces
008863  2               LAB_18B6
008863  2  AA                 TAX                     ; copy result to X
008864  2               LAB_18B7
008864  2  8A                 TXA                     ; set flags on size for SPC
008865  2  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
008867  2               
008867  2                                             ; print X spaces
008867  2               LAB_18BA
008867  2  20 88 88           JSR   LAB_18E0          ; print " "
00886A  2  CA                 DEX                     ; decrement count
00886B  2  D0 FA              BNE   LAB_18BA          ; loop if not all done
00886D  2               
00886D  2                                             ; continue with PRINT processing
00886D  2               LAB_18BD
00886D  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008870  2  D0 89              BNE   LAB_1831          ; if more to print go do it
008872  2               
008872  2  60                 RTS
008873  2               
008873  2               ; print null terminated string from memory
008873  2               
008873  2               LAB_18C3
008873  2  20 DF 90           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
008876  2               
008876  2               ; print string from Sutill/Sutilh
008876  2               
008876  2               LAB_18C6
008876  2  20 DA 92           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
008879  2                                             ; space returns with A = length, X=$71=pointer low byte,
008879  2                                             ; Y=$72=pointer high byte
008879  2  A0 00              LDY   #$00              ; reset index
00887B  2  AA                 TAX                     ; copy length to X
00887C  2  F0 4A              BEQ   LAB_188C          ; exit (RTS) if null string
00887E  2               
00887E  2               LAB_18CD
00887E  2               
00887E  2  B1 23              LDA   (ut1_pl),Y        ; get next byte
008880  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
008883  2  C8                 INY                     ; increment index
008884  2  CA                 DEX                     ; decrement count
008885  2  D0 F7              BNE   LAB_18CD          ; loop if not done yet
008887  2  60                 RTS
008888  2               
008888  2                                             ; Print single format character
008888  2               ; print " "
008888  2               
008888  2               LAB_18E0
008888  2  A9 20              LDA   #$20              ; load " "
00888A  2  80 02              BRA   LAB_PRNA          ; branch around next instruction, saves one clock cycle
00888C  2               
00888C  2               ; print "?" character
00888C  2               
00888C  2               LAB_18E3
00888C  2  A9 3F              LDA   #$3F              ; load "?" character
00888E  2               
00888E  2               ; print character in A
00888E  2               ; now includes the null handler
00888E  2               ; also includes infinite line length code
00888E  2               ; note! some routines expect this one to exit with Zb=0
00888E  2               
00888E  2               LAB_PRNA
00888E  2  C9 20              CMP   #' '              ; compare with " "
008890  2  90 19              BCC   LAB_18F9          ; branch if less (non printing)
008892  2               
008892  2                                             ; else printable character
008892  2  48                 PHA                     ; save the character
008893  2               
008893  2               ; don't check fit if terminal width byte is zero
008893  2               
008893  2  A5 08              LDA   TWidth            ; get terminal width
008895  2  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
008897  2               
008897  2               ; is "infinite line" so check TAB position
008897  2               
008897  2  A5 07              LDA   TPos              ; get position
008899  2  E5 16              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
00889B  2  D0 0B              BNE   LAB_18F7          ; skip reset if different
00889D  2               
00889D  2  85 07              STA   TPos              ; else reset position
00889F  2  F0 07              BEQ   LAB_18F7          ; go print character
0088A1  2               
0088A1  2               LAB_18F0
0088A1  2  C5 07              CMP   TPos              ; compare with terminal character position
0088A3  2  D0 03              BNE   LAB_18F7          ; branch if not at end of line
0088A5  2               
0088A5  2  20 32 88           JSR   LAB_CRLF          ; else print CR/LF
0088A8  2               LAB_18F7
0088A8  2  E6 07              INC   TPos              ; increment terminal position
0088AA  2  68                 PLA                     ; get character back
0088AB  2               LAB_18F9
0088AB  2  20 41 A0           JSR   V_OUTP            ; output byte via output vector
0088AE  2  C9 0D              CMP   #$0D              ; compare with [CR]
0088B0  2  D0 14              BNE   LAB_188A          ; branch if not [CR]
0088B2  2               
0088B2  2                                             ; else print nullct nulls after the [CR]
0088B2  2  86 2A              STX   TempB             ; save buffer index
0088B4  2  A6 06              LDX   Nullct            ; get null count
0088B6  2  F0 0A              BEQ   LAB_1886          ; branch if no nulls
0088B8  2               
0088B8  2  A9 00              LDA   #$00              ; load [NULL]
0088BA  2               LAB_1880
0088BA  2  20 8E 88           JSR   LAB_PRNA          ; go print the character
0088BD  2  CA                 DEX                     ; decrement count
0088BE  2  D0 FA              BNE   LAB_1880          ; loop if not all done
0088C0  2               
0088C0  2  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
0088C2  2               LAB_1886
0088C2  2  86 07              STX   TPos              ; clear terminal position (X always = zero when we get here)
0088C4  2  A6 2A              LDX   TempB             ; restore buffer index
0088C6  2               LAB_188A
0088C6  2  29 FF              AND   #$FF              ; set the flags
0088C8  2               LAB_188C
0088C8  2  60                 RTS
0088C9  2               
0088C9  2               ; handle bad input data
0088C9  2               
0088C9  2               LAB_1904
0088C9  2  7F 14 0B           BBR7  Imode,LAB_1913    ; Check input mode, branch if INPUT ($00)
0088CC  2               ;      LDA   Imode             ; get input mode flag, $00=INPUT, $80=READ
0088CC  2               ;      BPL   LAB_1913          ; branch if INPUT (go do redo)
0088CC  2               
0088CC  2  A5 3F              LDA   Dlinel            ; get current DATA line low byte
0088CE  2  A4 40              LDY   Dlineh            ; get current DATA line high byte
0088D0  2  85 39              STA   Clinel            ; save current line low byte
0088D2  2  84 3A              STY   Clineh            ; save current line high byte
0088D4  2               LAB_1910
0088D4  2  4C 9C 8B           JMP   LAB_SNER          ; do syntax error then warm start
0088D7  2               
0088D7  2                                             ; mode was INPUT
0088D7  2               LAB_1913
0088D7  2  A9 7B              LDA   #<LAB_REDO        ; point to redo message (low addr)
0088D9  2  A0 A7              LDY   #>LAB_REDO        ; point to redo message (high addr)
0088DB  2  20 73 88           JSR   LAB_18C3          ; print null terminated string from memory
0088DE  2  A5 3D              LDA   Cpntrl            ; get continue pointer low byte
0088E0  2  A4 3E              LDY   Cpntrh            ; get continue pointer high byte
0088E2  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
0088E4  2  84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
0088E6  2  60                 RTS
0088E7  2               
0088E7  2               ; perform INPUT
0088E7  2               
0088E7  2               LAB_INPUT
0088E7  2  C9 22              CMP   #$22              ; compare next byte with open quote
0088E9  2  D0 0B              BNE   LAB_1934          ; branch if no prompt string
0088EB  2               
0088EB  2  20 5A 8B           JSR   LAB_1BC1          ; print "..." string
0088EE  2  A9 3B              LDA   #$3B              ; load A with ";"
0088F0  2  20 8D 8B           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
0088F3  2  20 76 88           JSR   LAB_18C6          ; print string from Sutill/Sutilh
0088F6  2               
0088F6  2                                             ; done with prompt, now get data
0088F6  2               LAB_1934
0088F6  2  20 09 90           JSR   LAB_CKRN          ; check not Direct, back here if ok
0088F9  2  20 07 82           JSR   LAB_INLN          ; print "? " and get BASIC input
0088FC  2  A9 00              LDA   #$00              ; set mode = INPUT
0088FE  2  CD 00 03           CMP   Ibuffs            ; test first byte in buffer
008901  2  D0 09              BNE   LAB_1953          ; branch if not null input
008903  2  4C EB 84           JMP   LAB_1647          ; go do BREAK exit
008906  2               
008906  2               ; perform READ
008906  2               
008906  2               LAB_READ
008906  2  A6 41              LDX   Dptrl             ; get DATA pointer low byte
008908  2  A4 42              LDY   Dptrh             ; get DATA pointer high byte
00890A  2  A9 80              LDA   #$80              ; set mode = READ
00890C  2               
00890C  2               LAB_1953
00890C  2  85 14              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
00890E  2  86 43              STX   Rdptrl            ; save READ pointer low byte
008910  2  84 44              STY   Rdptrh            ; save READ pointer high byte
008912  2               
008912  2                                             ; READ or INPUT next variable from list
008912  2               LAB_195B
008912  2  20 4C 8D           JSR   LAB_GVAR          ; get (var) address
008915  2  85 49              STA   Lvarpl            ; save address low byte
008917  2  84 4A              STY   Lvarph            ; save address high byte
008919  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
00891B  2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
00891D  2  85 0A              STA   Itempl            ; save as temporary integer low byte
00891F  2  84 0B              STY   Itemph            ; save as temporary integer high byte
008921  2  A6 43              LDX   Rdptrl            ; get READ pointer low byte
008923  2  A4 44              LDY   Rdptrh            ; get READ pointer high byte
008925  2  86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
008927  2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
008929  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00892C  2  D0 10              BNE   LAB_1988          ; branch if not null
00892E  2               
00892E  2                                             ; pointer was to null entry
00892E  2  FF 14 64           BBS7  Imode,LAB_19DD    ; test Input mode, branch if $80=READ
008931  2               ;      BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
008931  2               ;      BMI   LAB_19DD          ; branch if READ
008931  2               
008931  2                                             ; mode was INPUT
008931  2  20 8C 88           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
008934  2  20 07 82           JSR   LAB_INLN          ; print "? " and get BASIC input
008937  2  86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
008939  2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
00893B  2               LAB_1985
00893B  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00893E  2               LAB_1988
00893E  2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
008940  2  10 23              BPL   LAB_19B0          ; branch if numeric
008942  2               
008942  2                                             ; else get string
008942  2  85 0D              STA   Srchc             ; save search character
008944  2  C9 22              CMP   #$22              ; was it " ?
008946  2  F0 07              BEQ   LAB_1999          ; branch if so
008948  2               
008948  2  A9 3A              LDA   #':'              ; else search character is ":"
00894A  2  85 0D              STA   Srchc             ; set new search character
00894C  2  A9 2C              LDA   #','              ; other search character is ","
00894E  2  18                 CLC                     ; clear carry for add
00894F  2               LAB_1999
00894F  2  85 0E              STA   Asrch             ; set second search character
008951  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
008953  2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
008955  2               
008955  2  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
008957  2  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
008959  2               
008959  2  C8                 INY                     ; else increment high byte
00895A  2               LAB_19A4
00895A  2  20 E5 90           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
00895D  2  20 5C 94           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
008960  2  20 7A 87           JSR   LAB_17D5          ; go do string LET
008963  2  80 06              BRA   LAB_19B6          ; go check string terminator
008965  2               
008965  2                                             ; get numeric INPUT
008965  2               LAB_19B0
008965  2  20 26 99           JSR   LAB_2887          ; get FAC1 from string
008968  2  20 28 98           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
00896B  2               LAB_19B6
00896B  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00896E  2  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
008970  2               
008970  2  C9 2C              CMP   #','              ; else compare with ","
008972  2  F0 03              BEQ   LAB_19C2          ; branch if ","
008974  2               
008974  2  4C C9 88           JMP   LAB_1904          ; else go handle bad input data
008977  2               
008977  2                                             ; got good input data
008977  2               LAB_19C2
008977  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
00897A  2               LAB_19C5
00897A  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
00897C  2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00897E  2  85 43              STA   Rdptrl            ; save for now
008980  2  84 44              STY   Rdptrh            ; save for now
008982  2  A5 0A              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
008984  2  A4 0B              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
008986  2  85 6E              STA   Bpntrl            ; set BASIC execute pointer low byte
008988  2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
00898A  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00898D  2  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
00898F  2               
00898F  2  20 98 8B           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
008992  2  4C 12 89           JMP   LAB_195B          ; go INPUT next variable from list
008995  2               
008995  2                                             ; find next DATA statement or do "Out of DATA" error
008995  2               LAB_19DD
008995  2  20 54 86           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
008998  2  C8                 INY                     ; increment index
008999  2  AA                 TAX                     ; copy character ([:] or [EOL])
00899A  2  D0 12              BNE   LAB_19F6          ; branch if [:]
00899C  2               
00899C  2  A2 06              LDX   #$06              ; set for "Out of DATA" error
00899E  2  C8                 INY                     ; increment index, now points to next line pointer high byte
00899F  2  B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
0089A1  2  F0 70              BEQ   LAB_1A54          ; branch if end (eventually does error X)
0089A3  2               
0089A3  2  C8                 INY                     ; increment index
0089A4  2  B1 6E              LDA   (Bpntrl),Y        ; get next line # low byte
0089A6  2  85 3F              STA   Dlinel            ; save current DATA line low byte
0089A8  2  C8                 INY                     ; increment index
0089A9  2  B1 6E              LDA   (Bpntrl),Y        ; get next line # high byte
0089AB  2  C8                 INY                     ; increment index
0089AC  2  85 40              STA   Dlineh            ; save current DATA line high byte
0089AE  2               LAB_19F6
0089AE  2  B1 6E              LDA   (Bpntrl),Y        ; get byte
0089B0  2  C8                 INY                     ; increment index
0089B1  2  AA                 TAX                     ; copy to X
0089B2  2  20 46 86           JSR   LAB_170F          ; set BASIC execute pointer
0089B5  2  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
0089B7  2  F0 82              BEQ   LAB_1985          ; was "DATA" so go do next READ
0089B9  2  80 DA              BRA   LAB_19DD          ; go find next statement if not "DATA"
0089BB  2               
0089BB  2               ; end of INPUT/READ routine
0089BB  2               
0089BB  2               LAB_1A03
0089BB  2  A5 43              LDA   Rdptrl            ; get temp READ pointer low byte
0089BD  2  A4 44              LDY   Rdptrh            ; get temp READ pointer high byte
0089BF  2  7F 14 03           BBR7  Imode,LAB_1A0E    ; test input mode, branch if $00=INPUT
0089C2  2               ;      LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
0089C2  2               ;      BPL   LAB_1A0E          ; branch if INPUT
0089C2  2  4C 0D 85           JMP   LAB_1624          ; save AY as DATA pointer and return
0089C5  2               
0089C5  2                                             ; we were getting INPUT
0089C5  2               LAB_1A0E
0089C5  2  B2 43              LDA   (Rdptrl)          ; get next byte
0089C7  2  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
0089C9  2  60                 RTS
0089CA  2               
0089CA  2                                             ; user typed too much
0089CA  2               LAB_1A1B
0089CA  2  A9 6A              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
0089CC  2  A0 A7              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
0089CE  2  4C 73 88           JMP   LAB_18C3          ; print null terminated string from memory and return
0089D1  2               
0089D1  2               ; search the stack for FOR activity
0089D1  2               ; exit with z=1 if FOR else exit with z=0
0089D1  2               
0089D1  2               LAB_11A1
0089D1  2  BA                 TSX                     ; copy stack pointer
0089D2  2  E8                 INX                     ; +1 pass return address
0089D3  2  E8                 INX                     ; +2 pass return address
0089D4  2  E8                 INX                     ; +3 pass calling routine return address
0089D5  2  E8                 INX                     ; +4 pass calling routine return address
0089D6  2               LAB_11A6
0089D6  2  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
0089D9  2  C9 81              CMP   #TK_FOR           ; is it FOR token
0089DB  2  D0 21              BNE   LAB_11CE          ; exit if not FOR token
0089DD  2               
0089DD  2                                             ; was FOR token
0089DD  2  A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
0089DF  2  D0 0A              BNE   LAB_11BB          ; branch if not null
0089E1  2               
0089E1  2  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
0089E4  2  85 49              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
0089E6  2  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
0089E9  2  85 4A              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
0089EB  2               LAB_11BB
0089EB  2  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
0089EE  2  D0 07              BNE   LAB_11C7          ; branch if no match
0089F0  2               
0089F0  2  A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
0089F2  2  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
0089F5  2  F0 07              BEQ   LAB_11CE          ; exit if match found
0089F7  2               
0089F7  2               LAB_11C7
0089F7  2  8A                 TXA                     ; copy index
0089F8  2  18                 CLC                     ; clear carry for add
0089F9  2  69 10              ADC   #$10              ; add FOR stack use size
0089FB  2  AA                 TAX                     ; copy back to index
0089FC  2  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
0089FE  2               
0089FE  2               LAB_11CE
0089FE  2  60                 RTS
0089FF  2               
0089FF  2               ; perform NEXT
0089FF  2               
0089FF  2               LAB_NEXT
0089FF  2  D0 04              BNE   LAB_1A46          ; branch if NEXT var
008A01  2               
008A01  2  A0 00              LDY   #$00              ; else clear Y
008A03  2  80 03              BRA   LAB_1A49          ; branch always (no variable to search for)
008A05  2               
008A05  2               ; NEXT var
008A05  2               
008A05  2               LAB_1A46
008A05  2  20 4C 8D           JSR   LAB_GVAR          ; get variable address
008A08  2               LAB_1A49
008A08  2  85 49              STA   Frnxtl            ; store variable pointer low byte
008A0A  2  84 4A              STY   Frnxth            ; store variable pointer high byte
008A0C  2                                             ; (both cleared if no variable defined)
008A0C  2  20 D1 89           JSR   LAB_11A1          ; search the stack for FOR activity
008A0F  2  F0 04              BEQ   LAB_1A56          ; branch if found
008A11  2               
008A11  2  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
008A13  2               LAB_1A54
008A13  2  F0 64              BEQ   LAB_1ABE          ; do error #X, then warm start
008A15  2               
008A15  2               LAB_1A56
008A15  2  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
008A16  2               
008A16  2  8A                 TXA                     ; copy stack pointer
008A17  2  38                 SEC                     ; set carry for subtract
008A18  2  E9 F7              SBC   #$F7              ; point to TO var
008A1A  2  85 25              STA   ut2_pl            ; save pointer to TO var for compare
008A1C  2  69 FB              ADC   #$FB              ; point to STEP var
008A1E  2               
008A1E  2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
008A20  2  20 02 98           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
008A23  2  BA                 TSX                     ; get stack pointer back
008A24  2  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
008A27  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
008A29  2  A5 49              LDA   Frnxtl            ; get FOR variable pointer low byte
008A2B  2  A4 4A              LDY   Frnxth            ; get FOR variable pointer high byte
008A2D  2  20 4A 95           JSR   LAB_246C          ; add (FOR variable) to FAC1
008A30  2  20 28 98           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
008A33  2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
008A35  2  20 9A 98           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
008A38  2  BA                 TSX                     ; get stack pointer back
008A39  2  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
008A3C  2  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
008A3E  2               
008A3E  2                                             ; loop back and do it all again
008A3E  2  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
008A41  2  85 39              STA   Clinel            ; save current line low byte
008A43  2  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
008A46  2  85 3A              STA   Clineh            ; save current line high byte
008A48  2  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
008A4B  2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
008A4D  2  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
008A50  2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
008A52  2               LAB_1A98
008A52  2  4C 86 84           JMP   LAB_15C2          ; go do interpreter inner loop
008A55  2               
008A55  2                                             ; loop complete so carry on
008A55  2               LAB_1A9B
008A55  2  8A                 TXA                     ; stack copy to A
008A56  2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
008A58  2  AA                 TAX                     ; copy back to index
008A59  2  9A                 TXS                     ; copy to stack pointer
008A5A  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008A5D  2  C9 2C              CMP   #','              ; compare with ","
008A5F  2  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
008A61  2               
008A61  2                                             ; was "," so another NEXT variable to do
008A61  2  20 B5 9F           JSR   LAB_IGBY          ; else increment and scan memory
008A64  2  20 05 8A           JSR   LAB_1A46          ; do NEXT (var)
008A67  2               
008A67  2               ; evaluate expression and check is numeric, else do type mismatch
008A67  2               
008A67  2               LAB_EVNM
008A67  2  20 7C 8A           JSR   LAB_EVEX          ; evaluate expression
008A6A  2               
008A6A  2               ; check if source is numeric, else do type mismatch
008A6A  2               
008A6A  2               LAB_CTNM
008A6A  2  18                 CLC                     ; destination is numeric
008A6B  2  80 01              BRA   LAB_CKTM          ; branch around SEC
008A6D  2               
008A6D  2               ; check if source is string, else do type mismatch
008A6D  2               
008A6D  2               LAB_CTST
008A6D  2  38                 SEC                     ; required type is string
008A6E  2               
008A6E  2               ; type match check, set C for string, clear C for numeric
008A6E  2               
008A6E  2               LAB_CKTM
008A6E  2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
008A70  2  30 03              BMI   LAB_1ABA          ; branch if data type is string
008A72  2                                             ; else data type was numeric
008A72  2  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
008A74  2               LAB_1AB9
008A74  2  60                 RTS
008A75  2               
008A75  2                                             ; data type was string, now check required type
008A75  2               LAB_1ABA
008A75  2  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
008A77  2               
008A77  2                                             ; else do type mismatch error
008A77  2               LAB_1ABC
008A77  2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
008A79  2               LAB_1ABE
008A79  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
008A7C  2               
008A7C  2               ; evaluate expression
008A7C  2               
008A7C  2               LAB_EVEX
008A7C  2  A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
008A7E  2  D0 02              BNE   LAB_1AC7          ; skip next if not zero
008A80  2               
008A80  2  C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
008A82  2               LAB_1AC7
008A82  2  C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
008A84  2               
008A84  2               LAB_EVEZ
008A84  2  A9 00              LDA   #$00              ; set null precedence (flag done)
008A86  2               LAB_1ACC
008A86  2  48                 PHA                     ; push precedence byte
008A87  2  A9 02              LDA   #$02              ; 2 bytes
008A89  2  20 C6 80           JSR   LAB_1212          ; check room on stack for A bytes
008A8C  2  20 69 8B           JSR   LAB_GVAL          ; get value from line
008A8F  2  64 4D              STZ   comp_f            ; clear compare function flag
008A91  2               LAB_1ADB
008A91  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008A94  2               LAB_1ADE
008A94  2  38                 SEC                     ; set carry for subtract
008A95  2  E9 BC              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
008A97  2  90 16              BCC   LAB_1AFA          ; branch if < TK_GT
008A99  2               
008A99  2  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
008A9B  2  B0 12              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
008A9D  2               
008A9D  2                                             ; was token for > = or < (A = 0, 1 or 2)
008A9D  2  C9 01              CMP   #$01              ; compare with token for =
008A9F  2  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
008AA0  2                                             ; (A = 0, 3 or 5)
008AA0  2  49 01              EOR   #$01              ; toggle b0
008AA2  2                                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
008AA2  2  45 4D              EOR   comp_f            ; EOR with compare function flag bits
008AA4  2  C5 4D              CMP   comp_f            ; compare with compare function flag
008AA6  2  90 66              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
008AA8  2                                             ; was more than one <, = or >)
008AA8  2               
008AA8  2  85 4D              STA   comp_f            ; save new compare function flag
008AAA  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008AAD  2  80 E5              BRA   LAB_1ADE          ; go do next character
008AAF  2               
008AAF  2                                             ; token is < ">" or > "<" tokens
008AAF  2               LAB_1AFA
008AAF  2  A6 4D              LDX   comp_f            ; get compare function flag
008AB1  2  D0 2C              BNE   LAB_1B2A          ; branch if compare function
008AB3  2  B0 7D              BCS   LAB_1B78          ; go do functions
008AB5  2               
008AB5  2                                             ; else was <  TK_GT so is operator or lower
008AB5  2  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
008AB7  2  90 79              BCC   LAB_1B78          ; branch if < + operator
008AB9  2                                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
008AB9  2  D0 07              BNE   LAB_1B0B          ; branch if not + token
008ABB  2               
008ABB  2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
008ABD  2  10 03              BPL   LAB_1B0B          ; branch if not string
008ABF  2               
008ABF  2                                             ; will only be $00 if type is string and token was +
008ABF  2  4C 72 92           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
008AC2  2                                             ; is in line, and return
008AC2  2               
008AC2  2               LAB_1B0B
008AC2  2  85 23              STA   ut1_pl            ; save it
008AC4  2  0A                 ASL                     ; *2
008AC5  2  65 23              ADC   ut1_pl            ; *3
008AC7  2  A8                 TAY                     ; copy to index
008AC8  2               LAB_1B13
008AC8  2  68                 PLA                     ; pull previous precedence
008AC9  2  D9 73 A2           CMP   LAB_OPPT,Y        ; compare with precedence byte
008ACC  2  B0 69              BCS   LAB_1B7D          ; branch if A >=
008ACE  2               
008ACE  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
008AD1  2               LAB_1B1C
008AD1  2  48                 PHA                     ; save precedence
008AD2  2               LAB_1B1D
008AD2  2  20 FA 8A           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
008AD5  2  68                 PLA                     ; restore precedence
008AD6  2  A4 4B              LDY   prstk             ; get precedence stacked flag
008AD8  2  10 19              BPL   LAB_1B3C          ; branch if stacked values
008ADA  2               
008ADA  2  AA                 TAX                     ; copy precedence (set flags)
008ADB  2  F0 7A              BEQ   LAB_1B9D          ; exit if done
008ADD  2  80 61              BRA   LAB_1B86          ; else pop FAC2 and return, branch always
008ADF  2               
008ADF  2               LAB_1B2A
008ADF  2  26 11              ROL   Dtypef            ; shift data type flag into Cb
008AE1  2  8A                 TXA                     ; copy compare function flag
008AE2  2  85 11              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
008AE4  2  2A                 ROL                     ; shift data type into compare function byte b0
008AE5  2  A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
008AE7  2  D0 02              BNE   LAB_1B34          ; branch if no underflow
008AE9  2               
008AE9  2  C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
008AEB  2               LAB_1B34
008AEB  2  C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
008AED  2               TK_LT_PLUS  = TK_LT-TK_PLUS
008AED  2  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
008AEF  2  85 4D              STA   comp_f            ; save new compare function flag
008AF1  2  80 D5              BRA   LAB_1B13          ; branch always
008AF3  2               
008AF3  2               LAB_1B3C
008AF3  2  D9 73 A2           CMP   LAB_OPPT,Y        ; compare with stacked function precedence
008AF6  2  B0 48              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
008AF8  2  80 D7              BRA   LAB_1B1C          ; branch always
008AFA  2               
008AFA  2               ;.get vector, execute function then continue evaluation
008AFA  2               
008AFA  2               LAB_1B43
008AFA  2  B9 75 A2           LDA   LAB_OPPT+2,Y      ; get function vector high byte
008AFD  2  48                 PHA                     ; onto stack
008AFE  2  B9 74 A2           LDA   LAB_OPPT+1,Y      ; get function vector low byte
008B01  2  48                 PHA                     ; onto stack
008B02  2                                             ; now push sign, round FAC1 and put on stack
008B02  2  20 11 8B           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
008B05  2                                             ; the function
008B05  2  A5 4D              LDA   comp_f            ; get compare function flag
008B07  2  48                 PHA                     ; push compare evaluation byte
008B08  2  B9 73 A2           LDA   LAB_OPPT,Y        ; get precedence byte
008B0B  2  4C 86 8A           JMP   LAB_1ACC          ; continue evaluating expression
008B0E  2               
008B0E  2               LAB_1B53
008B0E  2  4C 9C 8B           JMP   LAB_SNER          ; do syntax error then warm start
008B11  2               
008B11  2               ; push sign, round FAC1 and put on stack
008B11  2               
008B11  2               ; patched routine - Klaus fixed in 2.22p5 by adding NOP if needed
008B11  2               ; this fix corrects the RTS increment by one and handles high byte if needed
008B11  2               
008B11  2               LAB_1B5B
008B11  2  68                 PLA                     ; get return addr low byte
008B12  2  85 23              STA   ut1_pl            ; save it
008B14  2  68                 PLA                     ; get return addr high byte
008B15  2  85 24              STA   ut1_ph            ; save it
008B17  2               
008B17  2  E6 23              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
008B19  2  D0 02              BNE   LAB_1B5B2         ; skip high byte increment if no low byte rollover to $00
008B1B  2  E6 24              INC   ut1_ph            ; else increment high byte
008B1D  2               LAB_1B5B2
008B1D  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
008B1F  2  48                 PHA                     ; push sign
008B20  2               
008B20  2               ; round FAC1 and put on stack
008B20  2               
008B20  2               ; LAB_1B66 moved to after JSR LAB_27BA (patch 2.22p5)
008B20  2               
008B20  2  20 5E 98           JSR   LAB_27BA          ; round FAC1
008B23  2               LAB_1B66
008B23  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
008B25  2  48                 PHA                     ; push on stack
008B26  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
008B28  2  48                 PHA                     ; push on stack
008B29  2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
008B2B  2  48                 PHA                     ; push on stack
008B2C  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
008B2E  2  48                 PHA                     ; push on stack
008B2F  2  6C 23 00           JMP   (ut1_pl)          ; return, sort of
008B32  2               
008B32  2               ; do functions
008B32  2               
008B32  2               LAB_1B78
008B32  2  A0 FF              LDY   #$FF              ; flag function
008B34  2  68                 PLA                     ; pull precedence byte
008B35  2               LAB_1B7B
008B35  2  F0 20              BEQ   LAB_1B9D          ; exit if done
008B37  2               
008B37  2               LAB_1B7D
008B37  2  C9 64              CMP   #$64              ; compare previous precedence with $64
008B39  2  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
008B3B  2               
008B3B  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
008B3E  2               LAB_1B84
008B3E  2  84 4B              STY   prstk             ; save precedence stacked flag
008B40  2               
008B40  2                                             ; pop FAC2 and return
008B40  2               LAB_1B86
008B40  2  68                 PLA                     ; pop byte
008B41  2  4A                 LSR                     ; shift out comparison evaluation lowest bit
008B42  2  85 15              STA   Cflag             ; save comparison evaluation flag
008B44  2  68                 PLA                     ; pop exponent
008B45  2  85 65              STA   FAC2_e            ; save FAC2 exponent
008B47  2  68                 PLA                     ; pop mantissa1
008B48  2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
008B4A  2  68                 PLA                     ; pop mantissa2
008B4B  2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
008B4D  2  68                 PLA                     ; pop mantissa3
008B4E  2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
008B50  2  68                 PLA                     ; pop sign
008B51  2  85 69              STA   FAC2_s            ; save FAC2 sign (b7)
008B53  2  45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
008B55  2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
008B57  2               LAB_1B9D
008B57  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
008B59  2  60                 RTS
008B5A  2               
008B5A  2               ; print "..." string to string util area
008B5A  2               
008B5A  2               LAB_1BC1
008B5A  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
008B5C  2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
008B5E  2  69 00              ADC   #$00              ; add carry to low byte
008B60  2  90 01              BCC   LAB_1BCA          ; branch if no overflow
008B62  2               
008B62  2  C8                 INY                     ; increment high byte
008B63  2               LAB_1BCA
008B63  2  20 DF 90           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
008B66  2  4C 5C 94           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
008B69  2               
008B69  2               ; get value from line
008B69  2               
008B69  2               LAB_GVAL
008B69  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008B6C  2  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
008B6E  2               
008B6E  2                                             ; else numeric string found (e.g. 123)
008B6E  2               LAB_1BA9
008B6E  2  4C 26 99           JMP   LAB_2887          ; get FAC1 from string and return
008B71  2               
008B71  2               ; get value from line .. continued
008B71  2               
008B71  2                                             ; wasn't a number so ..
008B71  2               LAB_1BAC
008B71  2  AA                 TAX                     ; set the flags
008B72  2  30 2D              BMI   LAB_1BD0          ; if -ve go test token values
008B74  2               
008B74  2                                             ; else it is either a string, number, variable or (<expr>)
008B74  2  C9 24              CMP   #'$'              ; compare with "$"
008B76  2  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
008B78  2               
008B78  2  C9 25              CMP   #'%'              ; else compare with "%"
008B7A  2  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
008B7C  2               
008B7C  2  C9 2E              CMP   #'.'              ; compare with "."
008B7E  2  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
008B80  2               
008B80  2                                             ; it wasn't any sort of number so ..
008B80  2  C9 22              CMP   #$22              ; compare with "
008B82  2  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
008B84  2               
008B84  2                                             ; wasn't any sort of number so ..
008B84  2               
008B84  2               ; evaluate expression within parentheses
008B84  2               
008B84  2  C9 28              CMP   #'('              ; compare with "("
008B86  2  D0 58              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
008B88  2               
008B88  2               LAB_1BF7
008B88  2  20 84 8A           JSR   LAB_EVEZ          ; evaluate expression, no decrement
008B8B  2               
008B8B  2               ; all the 'scan for' routines return the character after the sought character
008B8B  2               
008B8B  2               ; scan for ")" , else do syntax error then warm start
008B8B  2               
008B8B  2               LAB_1BFB
008B8B  2  A9 29              LDA   #$29              ; load A with ")"
008B8D  2               
008B8D  2               ; scan for CHR$(A) , else do syntax error then warm start
008B8D  2               
008B8D  2               LAB_SCCA
008B8D  2  D2 6E              CMP   (Bpntrl)          ; check next byte is = A
008B8F  2  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
008B91  2               
008B91  2  4C B5 9F           JMP   LAB_IGBY          ; increment and scan memory then return
008B94  2               
008B94  2               ; scan for "(" , else do syntax error then warm start
008B94  2               
008B94  2               LAB_1BFE
008B94  2  A9 28              LDA   #$28              ; load A with "("
008B96  2  80 F5              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
008B98  2               
008B98  2               ; scan for "," , else do syntax error then warm start
008B98  2               
008B98  2               LAB_1C01
008B98  2  A9 2C              LDA   #$2C              ; load A with ","
008B9A  2  80 F1              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
008B9C  2               
008B9C  2               ; syntax error then warm start
008B9C  2               
008B9C  2               LAB_SNER
008B9C  2  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
008B9E  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
008BA1  2               
008BA1  2               ; get value from line .. continued
008BA1  2               ; do tokens
008BA1  2               
008BA1  2               LAB_1BD0
008BA1  2  C9 B3              CMP   #TK_MINUS         ; compare with token for -
008BA3  2  F0 28              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
008BA5  2               
008BA5  2                                             ; wasn't -n so ..
008BA5  2  C9 B2              CMP   #TK_PLUS          ; compare with token for +
008BA7  2  F0 C0              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
008BA9  2               
008BA9  2  C9 AE              CMP   #TK_NOT           ; compare with token for NOT
008BAB  2  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
008BAD  2               
008BAD  2                                             ; was NOT token
008BAD  2               TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
008BAD  2  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
008BAF  2  80 1E              BRA   LAB_1C13          ; do set-up for function then execute (branch always)
008BB1  2               
008BB1  2               ; do = compare
008BB1  2               
008BB1  2               LAB_EQUAL
008BB1  2  20 46 8E           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
008BB4  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
008BB6  2  49 FF              EOR   #$FF              ; invert it
008BB8  2  A8                 TAY                     ; copy it
008BB9  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
008BBB  2  49 FF              EOR   #$FF              ; invert it
008BBD  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008BC0  2               
008BC0  2               ; get value from line .. continued
008BC0  2               
008BC0  2                                             ; wasn't +, -, or NOT so ..
008BC0  2               LAB_1BE7
008BC0  2  C9 AB              CMP   #TK_FN            ; compare with token for FN
008BC2  2  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
008BC4  2               
008BC4  2  4C 50 90           JMP   LAB_201E          ; go evaluate FNx
008BC7  2               
008BC7  2               ; get value from line .. continued
008BC7  2               
008BC7  2                                             ; wasn't +, -, NOT or FN so ..
008BC7  2               LAB_1BEE
008BC7  2  E9 BF              SBC   #TK_SGN           ; subtract with token for SGN
008BC9  2  B0 26              BCS   LAB_1C27          ; if a function token go do it
008BCB  2  80 CF              BRA   LAB_SNER          ; else do syntax error
008BCD  2               
008BCD  2               ; set-up for functions
008BCD  2               
008BCD  2               LAB_1C11
008BCD  2               TK_GT_PLUS  = TK_GT-TK_PLUS
008BCD  2  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
008BCF  2               LAB_1C13
008BCF  2  68                 PLA                     ; dump return address low byte
008BD0  2               
008BD0  2                                             ; patch 2.22p5
008BD0  2               
008BD0  2  AA                 TAX                     ; save to trap concatenate
008BD1  2  68                 PLA                     ; dump return address high byte
008BD2  2  E0 7A              CPX   #<LAB_224Da+2   ; from concatenate low return address?
008BD4  2  D0 04              BNE   LAB_1C13b         ; No - continue!
008BD6  2  C9 94              CMP   #>LAB_224Da+2   ; from concatenate high return address?
008BD8  2  F0 03              BEQ   LAB_1C13a         ; Yes - error!
008BDA  2               LAB_1C13b
008BDA  2  4C D2 8A           JMP   LAB_1B1D          ; execute function then continue evaluation
008BDD  2               LAB_1C13a
008BDD  2  4C 77 8A           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
008BE0  2               
008BE0  2               ;      PLA                     ; dump return address high byte
008BE0  2               ;      JMP   LAB_1B1D          ; execute function then continue evaluation
008BE0  2               
008BE0  2                                              ; patch 2.22p5
008BE0  2               
008BE0  2               ; variable name set-up
008BE0  2               ; get (var), return value in FAC_1 and $ flag
008BE0  2               
008BE0  2               LAB_1C18
008BE0  2  20 4C 8D           JSR   LAB_GVAR          ; get (var) address
008BE3  2  85 60              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
008BE5  2  84 61              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
008BE7  2  A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
008BE9  2  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
008BEB  2               
008BEB  2               LAB_1C24
008BEB  2  4C 02 98           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
008BEE  2               
008BEE  2               LAB_1C25
008BEE  2               
008BEE  2  46 6B              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
008BF0  2  60                 RTS
008BF1  2               
008BF1  2               ; get value from line .. continued
008BF1  2               ; only functions left so ..
008BF1  2               
008BF1  2               ; set up function references
008BF1  2               
008BF1  2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
008BF1  2               ; to process function calls. now the function vector is computed and pushed on the stack
008BF1  2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
008BF1  2               ; is calculated and the routine called, if not this routine just does RTS. whichever
008BF1  2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
008BF1  2               ; the function code
008BF1  2               
008BF1  2               ; this also removes some less than elegant code that was used to bypass type checking
008BF1  2               ; for functions that returned strings
008BF1  2               
008BF1  2               LAB_1C27
008BF1  2  0A                 ASL                     ; *2 (2 bytes per function address)
008BF2  2  A8                 TAY                     ; copy to index
008BF3  2               
008BF3  2  B9 2E A2           LDA   LAB_FTBM,Y        ; get function jump vector high byte
008BF6  2  48                 PHA                     ; push functions jump vector high byte
008BF7  2  B9 2D A2           LDA   LAB_FTBL,Y        ; get function jump vector low byte
008BFA  2  48                 PHA                     ; push functions jump vector low byte
008BFB  2               
008BFB  2  B9 E8 A1           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
008BFE  2  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
008C00  2               
008C00  2  48                 PHA                     ; push functions pre process vector high byte
008C01  2  B9 E7 A1           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
008C04  2  48                 PHA                     ; push functions pre process vector low byte
008C05  2               
008C05  2               LAB_1C56
008C05  2  60                 RTS                     ; do function, or pre process, call
008C06  2               
008C06  2               ; process string expression in parenthesis
008C06  2               
008C06  2               LAB_PPFS
008C06  2  20 88 8B           JSR   LAB_1BF7          ; process expression in parenthesis
008C09  2  4C 6D 8A           JMP   LAB_CTST          ; check if source is string then do function,
008C0C  2                                             ; else do type mismatch
008C0C  2               
008C0C  2               ; process numeric expression in parenthesis
008C0C  2               
008C0C  2               LAB_PPFN
008C0C  2  20 88 8B           JSR   LAB_1BF7          ; process expression in parenthesis
008C0F  2  4C 6A 8A           JMP   LAB_CTNM          ; check if source is numeric then do function,
008C12  2                                             ; else do type mismatch
008C12  2               
008C12  2               ; set numeric data type and increment BASIC execute pointer
008C12  2               
008C12  2               LAB_PPBI
008C12  2  46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
008C14  2  4C B5 9F           JMP   LAB_IGBY          ; increment and scan memory then do function
008C17  2               
008C17  2               ; process string for LEFT$, RIGHT$ or MID$
008C17  2               
008C17  2               LAB_LRMS
008C17  2  20 84 8A           JSR   LAB_EVEZ          ; evaluate (should be string) expression
008C1A  2  20 98 8B           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
008C1D  2  20 6D 8A           JSR   LAB_CTST          ; check if source is string, else do type mismatch
008C20  2  FA                 PLX                     ; get function jump vector low byte
008C21  2  7A                 PLY                     ; get function jump vector high byte
008C22  2  A5 61              LDA   des_ph            ; get descriptor pointer high byte
008C24  2  48                 PHA                     ; push string pointer high byte
008C25  2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
008C27  2  48                 PHA                     ; push string pointer low byte
008C28  2  5A                 PHY                     ; save function jump vector high byte
008C29  2  DA                 PHX                     ; save function jump vector low byte
008C2A  2  20 21 94           JSR   LAB_GTBY          ; get byte parameter
008C2D  2  8A                 TXA                     ; copy byte parameter to A
008C2E  2  60                 RTS                     ; go do function
008C2F  2               
008C2F  2               ; process numeric expression(s) for BIN$ or HEX$
008C2F  2               
008C2F  2               LAB_BHSS
008C2F  2  20 84 8A           JSR   LAB_EVEZ          ; process expression
008C32  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
008C35  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
008C37  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
008C39  2  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
008C3B  2               
008C3B  2  20 D0 98           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
008C3E  2  A2 02              LDX   #$02              ; 3 bytes to do
008C40  2               LAB_CFAC
008C40  2  B5 5F              LDA   FAC1_1,X          ; get byte from FAC1
008C42  2  95 0A              STA   nums_1,X          ; save byte to temp
008C44  2  CA                 DEX                     ; decrement index
008C45  2  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
008C47  2               
008C47  2  20 BB 9F           JSR   LAB_GBYT          ; get next BASIC byte
008C4A  2  A2 00              LDX   #$00              ; set default to no leading "0"s
008C4C  2  C9 29              CMP   #')'              ; compare with close bracket
008C4E  2  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
008C50  2               
008C50  2  20 6B 94           JSR   LAB_SCGB          ; scan for "," and get byte
008C53  2  20 BB 9F           JSR   LAB_GBYT          ; get last byte back
008C56  2  C9 29              CMP   #')'              ; is next character )
008C58  2  D0 01              BNE   LAB_BHER          ; if not ")" go do error
008C5A  2               
008C5A  2               LAB_1C54
008C5A  2  60                 RTS                     ; else do function
008C5B  2               
008C5B  2               LAB_BHER
008C5B  2  4C C8 8E           JMP   LAB_FCER          ; do function call error then warm start
008C5E  2               
008C5E  2               ; perform EOR
008C5E  2               
008C5E  2               ; added operator format is the same as AND or OR, precedence is the same as OR
008C5E  2               
008C5E  2               ; this bit worked first time but it took a while to sort out the operator table
008C5E  2               ; pointers and offsets afterwards!
008C5E  2               
008C5E  2               LAB_EOR
008C5E  2  20 85 8C           JSR   GetFirst          ; get first integer expression (no sign check)
008C61  2  45 0D              EOR   XOAw_l            ; EOR with expression 1 low byte
008C63  2  A8                 TAY                     ; save in Y
008C64  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
008C66  2  45 0E              EOR   XOAw_h            ; EOR with expression 1 high byte
008C68  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008C6B  2               
008C6B  2               ; perform OR
008C6B  2               
008C6B  2               LAB_OR
008C6B  2  20 85 8C           JSR   GetFirst          ; get first integer expression (no sign check)
008C6E  2  05 0D              ORA   XOAw_l            ; OR with expression 1 low byte
008C70  2  A8                 TAY                     ; save in Y
008C71  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
008C73  2  05 0E              ORA   XOAw_h            ; OR with expression 1 high byte
008C75  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008C78  2               
008C78  2               ; perform AND
008C78  2               
008C78  2               LAB_AND
008C78  2  20 85 8C           JSR   GetFirst          ; get first integer expression (no sign check)
008C7B  2  25 0D              AND   XOAw_l            ; AND with expression 1 low byte
008C7D  2  A8                 TAY                     ; save in Y
008C7E  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
008C80  2  25 0E              AND   XOAw_h            ; AND with expression 1 high byte
008C82  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008C85  2               
008C85  2               ; get first value for OR, AND or EOR
008C85  2               
008C85  2               GetFirst
008C85  2  20 46 8E           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
008C88  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
008C8A  2  85 0E              STA   XOAw_h            ; save it
008C8C  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
008C8E  2  85 0D              STA   XOAw_l            ; save it
008C90  2  20 4F 95           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
008C93  2  20 46 8E           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
008C96  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
008C98  2               LAB_1C95
008C98  2  60                 RTS
008C99  2               
008C99  2               ; perform comparisons
008C99  2               
008C99  2               ; do < compare
008C99  2               
008C99  2               LAB_LTHAN
008C99  2  20 6E 8A           JSR   LAB_CKTM          ; type match check, set C for string
008C9C  2  B0 12              BCS   LAB_1CAE          ; branch if string
008C9E  2               
008C9E  2                                             ; do numeric < compare
008C9E  2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
008CA0  2  09 7F              ORA   #$7F              ; set all non sign bits
008CA2  2  25 66              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
008CA4  2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
008CA6  2  A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
008CA8  2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
008CAA  2  20 98 98           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
008CAD  2  AA                 TAX                     ; copy result
008CAE  2  80 31              BRA   LAB_1CE1          ; go evaluate result
008CB0  2               
008CB0  2                                             ; do string < compare
008CB0  2               LAB_1CAE
008CB0  2  46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
008CB2  2  C6 4D              DEC   comp_f            ; clear < bit in compare function flag
008CB4  2  20 DA 92           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
008CB7  2                                             ; space returns with A = length, X=pointer low byte,
008CB7  2                                             ; Y=pointer high byte
008CB7  2  85 5E              STA   str_ln            ; save length
008CB9  2  86 5F              STX   str_pl            ; save string pointer low byte
008CBB  2  84 60              STY   str_ph            ; save string pointer high byte
008CBD  2  A5 67              LDA   FAC2_2            ; get descriptor pointer low byte
008CBF  2  A4 68              LDY   FAC2_3            ; get descriptor pointer high byte
008CC1  2  20 DE 92           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
008CC4  2                                             ; returns with A = length, X=pointer low byte,
008CC4  2                                             ; Y=pointer high byte
008CC4  2  86 67              STX   FAC2_2            ; save string pointer low byte
008CC6  2  84 68              STY   FAC2_3            ; save string pointer high byte
008CC8  2  AA                 TAX                     ; copy length
008CC9  2  38                 SEC                     ; set carry for subtract
008CCA  2  E5 5E              SBC   str_ln            ; subtract string 1 length
008CCC  2  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
008CCE  2               
008CCE  2  A9 01              LDA   #$01              ; set str 1 length > string 2 length
008CD0  2  90 04              BCC   LAB_1CD6          ; branch if so
008CD2  2               
008CD2  2  A6 5E              LDX   str_ln            ; get string 1 length
008CD4  2  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
008CD6  2               LAB_1CD6
008CD6  2  85 62              STA   FAC1_s            ; save length compare
008CD8  2  A0 FF              LDY   #$FF              ; set index
008CDA  2  E8                 INX                     ; adjust for loop
008CDB  2               LAB_1CDB
008CDB  2  C8                 INY                     ; increment index
008CDC  2  CA                 DEX                     ; decrement count
008CDD  2  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
008CDF  2               
008CDF  2  A6 62              LDX   FAC1_s            ; get length compare back
008CE1  2               LAB_1CE1
008CE1  2  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
008CE3  2               
008CE3  2  18                 CLC                     ; flag str 1 <= str 2
008CE4  2  90 0C              BCC   LAB_1CF2          ; go evaluate result
008CE6  2               
008CE6  2               LAB_1CE6
008CE6  2  B1 67              LDA   (FAC2_2),Y        ; get string 2 byte
008CE8  2  D1 5F              CMP   (FAC1_1),Y        ; compare with string 1 byte
008CEA  2  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
008CEC  2               
008CEC  2  A2 FF              LDX   #$FF              ; set str 1 < string 2
008CEE  2  B0 02              BCS   LAB_1CF2          ; branch if so
008CF0  2               
008CF0  2  A2 01              LDX   #$01              ; set str 1 > string 2
008CF2  2               LAB_1CF2
008CF2  2  E8                 INX                     ; x = 0, 1 or 2
008CF3  2  8A                 TXA                     ; copy to A
008CF4  2  2A                 ROL                     ; *2 (1, 2 or 4)
008CF5  2  25 15              AND   Cflag             ; AND with comparison evaluation flag
008CF7  2  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
008CF9  2               
008CF9  2  A9 FF              LDA   #$FF              ; else set result true
008CFB  2               LAB_1CFB
008CFB  2  4C 7F 98           JMP   LAB_27DB          ; save A as integer byte and return
008CFE  2               
008CFE  2               LAB_1CFE
008CFE  2  20 98 8B           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
008D01  2               
008D01  2               ; perform DIM
008D01  2               
008D01  2               LAB_DIM
008D01  2  AA                 TAX                     ; copy "DIM" flag to X
008D02  2  20 51 8D           JSR   LAB_1D10          ; search for variable
008D05  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008D08  2  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
008D0A  2  60                 RTS
008D0B  2               
008D0B  2               ; perform << (left shift)
008D0B  2               
008D0B  2               LAB_LSHIFT
008D0B  2  20 41 8D           JSR   GetPair           ; get integer expression and byte (no sign check)
008D0E  2  A5 60              LDA   FAC1_2            ; get expression high byte
008D10  2  A6 2A              LDX   TempB             ; get shift count
008D12  2  F0 22              BEQ   NoShift           ; branch if zero
008D14  2               
008D14  2  E0 10              CPX   #$10              ; compare bit count with 16d
008D16  2  B0 23              BCS   TooBig            ; branch if >=
008D18  2               
008D18  2               Ls_loop
008D18  2  06 61              ASL   FAC1_3            ; shift low byte
008D1A  2  2A                 ROL                     ; shift high byte
008D1B  2  CA                 DEX                     ; decrement bit count
008D1C  2  D0 FA              BNE   Ls_loop           ; loop if shift not complete
008D1E  2               
008D1E  2  A4 61              LDY   FAC1_3            ; get expression low byte
008D20  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008D23  2               
008D23  2               ; perform >> (right shift)
008D23  2               
008D23  2               LAB_RSHIFT
008D23  2  20 41 8D           JSR   GetPair           ; get integer expression and byte (no sign check)
008D26  2  A5 60              LDA   FAC1_2            ; get expression high byte
008D28  2  A6 2A              LDX   TempB             ; get shift count
008D2A  2  F0 0A              BEQ   NoShift           ; branch if zero
008D2C  2               
008D2C  2  E0 10              CPX   #$10              ; compare bit count with 16d
008D2E  2  B0 0B              BCS   TooBig            ; branch if >=
008D30  2               
008D30  2               Rs_loop
008D30  2  4A                 LSR                     ; shift high byte
008D31  2  66 61              ROR   FAC1_3            ; shift low byte
008D33  2  CA                 DEX                     ; decrement bit count
008D34  2  D0 FA              BNE   Rs_loop           ; loop if shift not complete
008D36  2               
008D36  2               NoShift
008D36  2  A4 61              LDY   FAC1_3            ; get expression low byte
008D38  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008D3B  2               
008D3B  2               TooBig
008D3B  2  A9 00              LDA   #$00              ; clear high byte
008D3D  2  A8                 TAY                     ; copy to low byte
008D3E  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
008D41  2               
008D41  2               GetPair
008D41  2  20 24 94           JSR   LAB_EVBY          ; evaluate byte expression, result in X
008D44  2  86 2A              STX   TempB             ; save it
008D46  2  20 4F 95           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
008D49  2  4C 46 8E           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
008D4C  2               
008D4C  2               ; search for variable
008D4C  2               
008D4C  2               ; return pointer to variable in Cvaral/Cvarah
008D4C  2               
008D4C  2               LAB_GVAR
008D4C  2  A2 00              LDX   #$00              ; set DIM flag = $00
008D4E  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory (1st character)
008D51  2               LAB_1D10
008D51  2  86 10              STX   Defdim            ; save DIM flag
008D53  2               LAB_1D12
008D53  2  85 45              STA   Varnm1            ; save 1st character
008D55  2  29 7F              AND   #$7F              ; clear FN flag bit
008D57  2  20 BE 8D           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
008D5A  2  B0 03              BCS   LAB_1D1F          ; branch if ok
008D5C  2               
008D5C  2  4C 9C 8B           JMP   LAB_SNER          ; else syntax error then warm start
008D5F  2               
008D5F  2                                             ; was variable name so ..
008D5F  2               LAB_1D1F
008D5F  2  A2 00              LDX   #$00              ; set DIM flag = $00
008D61  2  86 11              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
008D63  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
008D66  2  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
008D68  2               
008D68  2                                             ; 2nd character wasn't "0" to "9" so ..
008D68  2  20 BE 8D           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
008D6B  2  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
008D6D  2               
008D6D  2               LAB_1D2D
008D6D  2  AA                 TAX                     ; copy 2nd character
008D6E  2               
008D6E  2                                             ; ignore further (valid) characters in the variable name
008D6E  2               LAB_1D2E
008D6E  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
008D71  2  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
008D73  2               
008D73  2  20 BE 8D           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
008D76  2  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
008D78  2               
008D78  2                                             ; check if string variable
008D78  2               LAB_1D38
008D78  2  C9 24              CMP   #'$'              ; compare with "$"
008D7A  2  D0 0B              BNE   LAB_1D47          ; branch if not string
008D7C  2               
008D7C  2               ; to introduce a new variable type (% suffix for integers say) then this branch
008D7C  2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
008D7C  2               
008D7C  2                                             ; type is string
008D7C  2  A9 FF              LDA   #$FF              ; set data type = string
008D7E  2  85 11              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
008D80  2  8A                 TXA                     ; get 2nd character back
008D81  2  09 80              ORA   #$80              ; set top bit (indicate string var)
008D83  2  AA                 TAX                     ; copy back to 2nd character temp
008D84  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008D87  2               
008D87  2               ; after we have determined the variable type we need to come back here to determine
008D87  2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
008D87  2               
008D87  2               LAB_1D47                      ; gets here with character after var name in A
008D87  2  86 46              STX   Varnm2            ; save 2nd character
008D89  2  05 13              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
008D8B  2  C9 28              CMP   #'('              ; compare with "("
008D8D  2  D0 03              BNE   LAB_1D53          ; branch if not "("
008D8F  2  4C 58 8E           JMP   LAB_1E17          ; go find, or make, array
008D92  2               
008D92  2               ; either find or create var
008D92  2               ; var name (1st two characters only!) is in Varnm1,Varnm2
008D92  2               
008D92  2                                             ; variable name wasn't var(... so look for plain var
008D92  2               LAB_1D53
008D92  2  64 13              STZ   Sufnxf            ; clear subscript/FNX flag
008D94  2  A5 2D              LDA   Svarl             ; get start of vars low byte
008D96  2  A6 2E              LDX   Svarh             ; get start of vars high byte
008D98  2  A0 00              LDY   #$00              ; clear index
008D9A  2               LAB_1D5D
008D9A  2  86 5D              STX   Vrschh            ; save search address high byte
008D9C  2               LAB_1D5F
008D9C  2  85 5C              STA   Vrschl            ; save search address low byte
008D9E  2  E4 30              CPX   Sarryh            ; compare high address with var space end
008DA0  2  D0 04              BNE   LAB_1D69          ; skip next compare if <>
008DA2  2               
008DA2  2                                             ; high addresses were = so compare low addresses
008DA2  2  C5 2F              CMP   Sarryl            ; compare low address with var space end
008DA4  2  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
008DA6  2               
008DA6  2               LAB_1D69
008DA6  2  A5 45              LDA   Varnm1            ; get 1st character of var to find
008DA8  2  D1 5C              CMP   (Vrschl),Y        ; compare with variable name 1st character
008DAA  2  D0 08              BNE   LAB_1D77          ; branch if no match
008DAC  2               
008DAC  2                                             ; 1st characters match so compare 2nd characters
008DAC  2  A5 46              LDA   Varnm2            ; get 2nd character of var to find
008DAE  2  C8                 INY                     ; index to point to variable name 2nd character
008DAF  2  D1 5C              CMP   (Vrschl),Y        ; compare with variable name 2nd character
008DB1  2  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
008DB3  2               
008DB3  2  88                 DEY                     ; else decrement index (now = $00)
008DB4  2               LAB_1D77
008DB4  2  18                 CLC                     ; clear carry for add
008DB5  2  A5 5C              LDA   Vrschl            ; get search address low byte
008DB7  2  69 06              ADC   #$06              ; +6 (offset to next var name)
008DB9  2  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
008DBB  2               
008DBB  2  E8                 INX                     ; else increment high byte
008DBC  2  80 DC              BRA   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
008DBE  2               
008DBE  2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
008DBE  2               
008DBE  2               LAB_CASC
008DBE  2  C9 61              CMP   #'a'              ; compare with "a"
008DC0  2  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
008DC2  2               
008DC2  2               ; check byte, return C=0 if<"A" or >"Z"
008DC2  2               
008DC2  2               LAB_1D82
008DC2  2  C9 41              CMP   #'A'              ; compare with "A"
008DC4  2  90 05              BCC   LAB_1D8A          ; exit if less
008DC6  2               
008DC6  2                                             ; carry is set
008DC6  2  E9 5B              SBC   #$5B              ; subtract "Z"+1
008DC8  2  38                 SEC                     ; set carry
008DC9  2  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
008DCB  2                                             ; carry clear if byte>$5A
008DCB  2               LAB_1D8A
008DCB  2  60                 RTS
008DCC  2               
008DCC  2               LAB_1D83
008DCC  2  E9 7B              SBC   #$7B              ; subtract "z"+1
008DCE  2  38                 SEC                     ; set carry
008DCF  2  E9 85              SBC   #$85              ; subtract $85 (restore byte)
008DD1  2                                             ; carry clear if byte>$7A
008DD1  2  60                 RTS
008DD2  2               
008DD2  2                                             ; reached end of variable mem without match
008DD2  2                                             ; .. so create new variable
008DD2  2               LAB_1D8B
008DD2  2  68                 PLA                     ; pop return address low byte
008DD3  2  48                 PHA                     ; push return address low byte
008DD4  2               LAB_1C18p2  = LAB_1C18+2
008DD4  2  C9 E2              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
008DD6  2  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
008DD8  2               
008DD8  2               ; This will only drop through if the call was from LAB_1C18 and is only called
008DD8  2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
008DD8  2               ; it prevents the creation of variables not assigned a value.
008DD8  2               
008DD8  2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
008DD8  2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
008DD8  2               
008DD8  2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
008DD8  2               
008DD8  2               ; this is where you would put the undefined variable error call e.g.
008DD8  2               
008DD8  2               ;                             ; variable doesn't exist so flag error
008DD8  2               ;     LDX   #$24              ; error code $24 ("undefined variable" error)
008DD8  2               ;     JMP   LAB_XERR          ; do error #X then warm start
008DD8  2               
008DD8  2               ; the above code has been tested and works a treat! (it replaces the three code lines
008DD8  2               ; below)
008DD8  2               
008DD8  2                                             ; else return dummy null value
008DD8  2  A9 71              LDA   #<LAB_1D96        ; low byte point to $00,$00
008DDA  2                                             ; (uses part of misc constants table)
008DDA  2  A0 A1              LDY   #>LAB_1D96        ; high byte point to $00,$00
008DDC  2  60                 RTS
008DDD  2               
008DDD  2                                             ; create new numeric variable
008DDD  2               LAB_1D98
008DDD  2  A5 2F              LDA   Sarryl            ; get var mem end low byte
008DDF  2  A4 30              LDY   Sarryh            ; get var mem end high byte
008DE1  2  85 5C              STA   Ostrtl            ; save old block start low byte
008DE3  2  84 5D              STY   Ostrth            ; save old block start high byte
008DE5  2  A5 31              LDA   Earryl            ; get array mem end low byte
008DE7  2  A4 32              LDY   Earryh            ; get array mem end high byte
008DE9  2  85 58              STA   Obendl            ; save old block end low byte
008DEB  2  84 59              STY   Obendh            ; save old block end high byte
008DED  2  18                 CLC                     ; clear carry for add
008DEE  2  69 06              ADC   #$06              ; +6 (space for one var)
008DF0  2  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
008DF2  2               
008DF2  2  C8                 INY                     ; else increment high byte
008DF3  2               LAB_1DAE
008DF3  2  85 56              STA   Nbendl            ; set new block end low byte
008DF5  2  84 57              STY   Nbendh            ; set new block end high byte
008DF7  2  20 84 80           JSR   LAB_11CF          ; open up space in memory
008DFA  2  A5 56              LDA   Nbendl            ; get new start low byte
008DFC  2  A4 57              LDY   Nbendh            ; get new start high byte (-$100)
008DFE  2  C8                 INY                     ; correct high byte
008DFF  2  85 2F              STA   Sarryl            ; save new var mem end low byte
008E01  2  84 30              STY   Sarryh            ; save new var mem end high byte
008E03  2  A0 00              LDY   #$00              ; clear index
008E05  2  A5 45              LDA   Varnm1            ; get var name 1st character
008E07  2  91 5C              STA   (Vrschl),Y        ; save var name 1st character
008E09  2  C8                 INY                     ; increment index
008E0A  2  A5 46              LDA   Varnm2            ; get var name 2nd character
008E0C  2  91 5C              STA   (Vrschl),Y        ; save var name 2nd character
008E0E  2  A9 00              LDA   #$00              ; clear A
008E10  2  C8                 INY                     ; increment index
008E11  2  91 5C              STA   (Vrschl),Y        ; initialise var byte
008E13  2  C8                 INY                     ; increment index
008E14  2  91 5C              STA   (Vrschl),Y        ; initialise var byte
008E16  2  C8                 INY                     ; increment index
008E17  2  91 5C              STA   (Vrschl),Y        ; initialise var byte
008E19  2  C8                 INY                     ; increment index
008E1A  2  91 5C              STA   (Vrschl),Y        ; initialise var byte
008E1C  2               
008E1C  2                                             ; found a match for var ((Vrschl) = ptr)
008E1C  2               LAB_1DD7
008E1C  2  A5 5C              LDA   Vrschl            ; get var address low byte
008E1E  2  18                 CLC                     ; clear carry for add
008E1F  2  69 02              ADC   #$02              ; +2 (offset past var name bytes)
008E21  2  A4 5D              LDY   Vrschh            ; get var address high byte
008E23  2  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
008E25  2               
008E25  2  C8                 INY                     ; else increment high byte
008E26  2               LAB_1DE1
008E26  2  85 47              STA   Cvaral            ; save current var address low byte
008E28  2  84 48              STY   Cvarah            ; save current var address high byte
008E2A  2  60                 RTS
008E2B  2               
008E2B  2               ; set-up array pointer (Adatal/h) to first element in array
008E2B  2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
008E2B  2               
008E2B  2               LAB_1DE6
008E2B  2  A5 0F              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
008E2D  2  0A                 ASL                     ; *2 (also clears the carry !)
008E2E  2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
008E30  2  65 5C              ADC   Astrtl            ; add array start pointer low byte
008E32  2  A4 5D              LDY   Astrth            ; get array pointer high byte
008E34  2  90 01              BCC   LAB_1DF2          ; branch if no overflow
008E36  2               
008E36  2  C8                 INY                     ; else increment high byte
008E37  2               LAB_1DF2
008E37  2  85 56              STA   Adatal            ; save array data pointer low byte
008E39  2  84 57              STY   Adatah            ; save array data pointer high byte
008E3B  2  60                 RTS
008E3C  2               
008E3C  2               ; evaluate integer expression
008E3C  2               
008E3C  2               LAB_EVIN
008E3C  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
008E3F  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
008E42  2                                             ; else do type mismatch
008E42  2               
008E42  2               ; evaluate integer expression (no check)
008E42  2               
008E42  2               LAB_EVPI
008E42  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
008E44  2  30 0D              BMI   LAB_1E12          ; do function call error if -ve
008E46  2               
008E46  2               ; evaluate integer expression (no sign check)
008E46  2               
008E46  2               LAB_EVIR
008E46  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
008E48  2  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
008E4A  2  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
008E4C  2               
008E4C  2  A9 78              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
008E4E  2  A0 A1              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
008E50  2  20 98 98           JSR   LAB_27F8          ; compare FAC1 with (AY)
008E53  2               LAB_1E12
008E53  2  D0 73              BNE   LAB_FCER          ; if <> do function call error then warm start
008E55  2               
008E55  2               LAB_1E14
008E55  2  4C D0 98           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
008E58  2               
008E58  2               ; find or make array
008E58  2               
008E58  2               LAB_1E17
008E58  2  A5 10              LDA   Defdim            ; get DIM flag
008E5A  2  48                 PHA                     ; push it
008E5B  2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
008E5D  2  48                 PHA                     ; push it
008E5E  2  A0 00              LDY   #$00              ; clear dimensions count
008E60  2               
008E60  2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
008E60  2               
008E60  2               LAB_1E1F
008E60  2  5A                 PHY                     ; save dimensions count
008E61  2  A5 46              LDA   Varnm2            ; get array name 2nd byte
008E63  2  48                 PHA                     ; save it
008E64  2  A5 45              LDA   Varnm1            ; get array name 1st byte
008E66  2  48                 PHA                     ; save it
008E67  2  20 3C 8E           JSR   LAB_EVIN          ; evaluate integer expression
008E6A  2  68                 PLA                     ; pull array name 1st byte
008E6B  2  85 45              STA   Varnm1            ; restore array name 1st byte
008E6D  2  68                 PLA                     ; pull array name 2nd byte
008E6E  2  85 46              STA   Varnm2            ; restore array name 2nd byte
008E70  2  7A                 PLY                     ; restore dimensions count
008E71  2  BA                 TSX                     ; copy stack pointer
008E72  2  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
008E75  2  48                 PHA                     ; push it
008E76  2  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
008E79  2  48                 PHA                     ; push it
008E7A  2  A5 60              LDA   FAC1_2            ; get this dimension size high byte
008E7C  2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
008E7F  2  A5 61              LDA   FAC1_3            ; get this dimension size low byte
008E81  2  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
008E84  2  C8                 INY                     ; increment dimensions count
008E85  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
008E88  2  C9 2C              CMP   #','              ; compare with ","
008E8A  2  F0 D4              BEQ   LAB_1E1F          ; if found go do next dimension
008E8C  2               
008E8C  2  84 0F              STY   Dimcnt            ; store dimensions count
008E8E  2  20 8B 8B           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
008E91  2  68                 PLA                     ; pull data type flag
008E92  2  85 11              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
008E94  2  68                 PLA                     ; pull DIM flag
008E95  2  85 10              STA   Defdim            ; restore DIM flag
008E97  2  A6 2F              LDX   Sarryl            ; get array mem start low byte
008E99  2  A5 30              LDA   Sarryh            ; get array mem start high byte
008E9B  2               
008E9B  2               ; now check to see if we are at the end of array memory (we would be if there were
008E9B  2               ; no arrays).
008E9B  2               
008E9B  2               LAB_1E5C
008E9B  2  86 5C              STX   Astrtl            ; save as array start pointer low byte
008E9D  2  85 5D              STA   Astrth            ; save as array start pointer high byte
008E9F  2  C5 32              CMP   Earryh            ; compare with array mem end high byte
008EA1  2  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
008EA3  2               
008EA3  2  E4 31              CPX   Earryl            ; else compare with array mem end low byte
008EA5  2  F0 3A              BEQ   LAB_1EA1          ; go build array if not found
008EA7  2               
008EA7  2                                             ; search for array
008EA7  2               LAB_1E68
008EA7  2  A0 00              LDY   #$00              ; clear index
008EA9  2  B1 5C              LDA   (Astrtl),Y        ; get array name first byte
008EAB  2  C8                 INY                     ; increment index to second name byte
008EAC  2  C5 45              CMP   Varnm1            ; compare with this array name first byte
008EAE  2  D0 06              BNE   LAB_1E77          ; branch if no match
008EB0  2               
008EB0  2  A5 46              LDA   Varnm2            ; else get this array name second byte
008EB2  2  D1 5C              CMP   (Astrtl),Y        ; compare with array name second byte
008EB4  2  F0 17              BEQ   LAB_1E8D          ; array found so branch
008EB6  2               
008EB6  2                                             ; no match
008EB6  2               LAB_1E77
008EB6  2  C8                 INY                     ; increment index
008EB7  2  B1 5C              LDA   (Astrtl),Y        ; get array size low byte
008EB9  2  18                 CLC                     ; clear carry for add
008EBA  2  65 5C              ADC   Astrtl            ; add array start pointer low byte
008EBC  2  AA                 TAX                     ; copy low byte to X
008EBD  2  C8                 INY                     ; increment index
008EBE  2  B1 5C              LDA   (Astrtl),Y        ; get array size high byte
008EC0  2  65 5D              ADC   Astrth            ; add array mem pointer high byte
008EC2  2  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
008EC4  2               
008EC4  2               ; do array bounds error
008EC4  2               
008EC4  2               LAB_1E85
008EC4  2  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
008EC6  2  80 02              BRA   LAB_1E8A          ; branch around next instruction, saves on clock cycle
008EC8  2               
008EC8  2               ; do function call error
008EC8  2               
008EC8  2               LAB_FCER
008EC8  2  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
008ECA  2               LAB_1E8A
008ECA  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
008ECD  2               
008ECD  2                                             ; found array, are we trying to dimension it?
008ECD  2               LAB_1E8D
008ECD  2  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
008ECF  2  A5 10              LDA   Defdim            ; get DIM flag
008ED1  2  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
008ED3  2                                             ; start
008ED3  2               
008ED3  2               ; found the array and we're not dimensioning it so we must find an element in it
008ED3  2               
008ED3  2  20 2B 8E           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
008ED6  2                                             ; (Astrtl,Astrth points to start of array)
008ED6  2  A5 0F              LDA   Dimcnt            ; get dimensions count
008ED8  2  A0 04              LDY   #$04              ; set index to array's # of dimensions
008EDA  2  D1 5C              CMP   (Astrtl),Y        ; compare with no of dimensions
008EDC  2  D0 E6              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
008EDE  2                                             ; dimensions" error here .. if we want a different
008EDE  2                                             ; error message
008EDE  2               
008EDE  2  4C 64 8F           JMP   LAB_1F28          ; found array so go get element
008EE1  2                                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
008EE1  2                                             ; Dimcnt and save it at (Astrtl),Y which is already the
008EE1  2                                             ; same or we would have taken the BNE)
008EE1  2               
008EE1  2                                             ; array not found, so build it
008EE1  2               LAB_1EA1
008EE1  2  20 2B 8E           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
008EE4  2                                             ; (Astrtl,Astrth points to start of array)
008EE4  2  20 D1 80           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
008EE7  2                                             ; addr to check is in AY (low/high)
008EE7  2  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
008EE9  2  84 6D              STY   Aspth             ; clear array data size high byte
008EEB  2  A5 45              LDA   Varnm1            ; get variable name 1st byte
008EED  2  91 5C              STA   (Astrtl),Y        ; save array name 1st byte
008EEF  2  C8                 INY                     ; increment index
008EF0  2  A5 46              LDA   Varnm2            ; get variable name 2nd byte
008EF2  2  91 5C              STA   (Astrtl),Y        ; save array name 2nd byte
008EF4  2  A5 0F              LDA   Dimcnt            ; get dimensions count
008EF6  2  A0 04              LDY   #$04              ; index to dimension count
008EF8  2  84 6C              STY   Asptl             ; set array data size low byte (four bytes per element)
008EFA  2  91 5C              STA   (Astrtl),Y        ; set array's dimensions count
008EFC  2               
008EFC  2                                             ; now calculate the size of the data space for the array
008EFC  2  18                 CLC                     ; clear carry for add (clear on subsequent loops)
008EFD  2               LAB_1EC0
008EFD  2  A2 0B              LDX   #$0B              ; set default dimension value low byte
008EFF  2  A9 00              LDA   #$00              ; set default dimension value high byte
008F01  2  24 10              BIT   Defdim            ; test default DIM flag
008F03  2  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
008F05  2               
008F05  2  68                 PLA                     ; else pull dimension value low byte
008F06  2  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
008F08  2  AA                 TAX                     ; copy low byte to X
008F09  2  68                 PLA                     ; pull dimension value high byte
008F0A  2  69 00              ADC   #$00              ; add carry from low byte
008F0C  2               
008F0C  2               LAB_1ED0
008F0C  2  C8                 INY                     ; index to dimension value high byte
008F0D  2  91 5C              STA   (Astrtl),Y        ; save dimension value high byte
008F0F  2  C8                 INY                     ; index to dimension value high byte
008F10  2  8A                 TXA                     ; get dimension value low byte
008F11  2  91 5C              STA   (Astrtl),Y        ; save dimension value low byte
008F13  2  20 B3 8F           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
008F16  2  86 6C              STX   Asptl             ; save array data size low byte
008F18  2  85 6D              STA   Aspth             ; save array data size high byte
008F1A  2  A4 23              LDY   ut1_pl            ; restore index (saved by subroutine)
008F1C  2  C6 0F              DEC   Dimcnt            ; decrement dimensions count
008F1E  2  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
008F20  2               
008F20  2  65 57              ADC   Adatah            ; add size high byte to first element high byte
008F22  2                                             ; (carry is always clear here)
008F22  2  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
008F24  2               
008F24  2  85 57              STA   Adatah            ; save end of array high byte
008F26  2  A8                 TAY                     ; copy end high byte to Y
008F27  2  8A                 TXA                     ; get array size low byte
008F28  2  65 56              ADC   Adatal            ; add array start low byte
008F2A  2  90 03              BCC   LAB_1EF3          ; branch if no carry
008F2C  2               
008F2C  2  C8                 INY                     ; else increment end of array high byte
008F2D  2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
008F2F  2               
008F2F  2                                             ; set-up mostly complete, now zero the array
008F2F  2               LAB_1EF3
008F2F  2  20 D1 80           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
008F32  2                                             ; addr to check is in AY (low/high)
008F32  2  85 31              STA   Earryl            ; save array mem end low byte
008F34  2  84 32              STY   Earryh            ; save array mem end high byte
008F36  2  A9 00              LDA   #$00              ; clear byte for array clear
008F38  2  E6 6D              INC   Aspth             ; increment array size high byte (now block count)
008F3A  2  A4 6C              LDY   Asptl             ; get array size low byte (now index to block)
008F3C  2  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
008F3E  2               
008F3E  2               LAB_1F02
008F3E  2  88                 DEY                     ; decrement index (do 0 to n-1)
008F3F  2  91 56              STA   (Adatal),Y        ; zero byte
008F41  2  D0 FB              BNE   LAB_1F02          ; loop until this block done
008F43  2               
008F43  2               LAB_1F07
008F43  2  C6 57              DEC   Adatah            ; decrement array pointer high byte
008F45  2  C6 6D              DEC   Aspth             ; decrement block count high byte
008F47  2  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
008F49  2               
008F49  2  E6 57              INC   Adatah            ; correct for last loop
008F4B  2  38                 SEC                     ; set carry for subtract
008F4C  2  A0 02              LDY   #$02              ; index to array size low byte
008F4E  2  A5 31              LDA   Earryl            ; get array mem end low byte
008F50  2  E5 5C              SBC   Astrtl            ; subtract array start low byte
008F52  2  91 5C              STA   (Astrtl),Y        ; save array size low byte
008F54  2  C8                 INY                     ; index to array size high byte
008F55  2  A5 32              LDA   Earryh            ; get array mem end high byte
008F57  2  E5 5D              SBC   Astrth            ; subtract array start high byte
008F59  2  91 5C              STA   (Astrtl),Y        ; save array size high byte
008F5B  2  A5 10              LDA   Defdim            ; get default DIM flag
008F5D  2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
008F5F  2               
008F5F  2                                             ; else, find element
008F5F  2  C8                 INY                     ; index to # of dimensions
008F60  2               
008F60  2               LAB_1F24
008F60  2  B1 5C              LDA   (Astrtl),Y        ; get array's dimension count
008F62  2  85 0F              STA   Dimcnt            ; save it
008F64  2               
008F64  2               ; we have found, or built, the array. now we need to find the element
008F64  2               
008F64  2               LAB_1F28
008F64  2  A9 00              LDA   #$00              ; clear byte
008F66  2  85 6C              STA   Asptl             ; clear array data pointer low byte
008F68  2               LAB_1F2C
008F68  2  85 6D              STA   Aspth             ; save array data pointer high byte
008F6A  2  C8                 INY                     ; increment index (point to array bound high byte)
008F6B  2  68                 PLA                     ; pull array index low byte
008F6C  2  AA                 TAX                     ; copy to X
008F6D  2  85 60              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
008F6F  2  68                 PLA                     ; pull array index high byte
008F70  2  85 61              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
008F72  2  D1 5C              CMP   (Astrtl),Y        ; compare with array bound high byte
008F74  2  90 0E              BCC   LAB_1F48          ; branch if within bounds
008F76  2  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
008F78  2               
008F78  2                                             ; else high byte was = so test low bytes
008F78  2  C8                 INY                     ; index to array bound low byte
008F79  2  8A                 TXA                     ; get array index low byte
008F7A  2  D1 5C              CMP   (Astrtl),Y        ; compare with array bound low byte
008F7C  2  90 07              BCC   LAB_1F49          ; branch if within bounds
008F7E  2               
008F7E  2               LAB_1F42
008F7E  2  4C C4 8E           JMP   LAB_1E85          ; else do array bounds error
008F81  2               
008F81  2               LAB_1F45
008F81  2  4C FF 80           JMP   LAB_OMER          ; do "Out of memory" error then warm start
008F84  2               
008F84  2               LAB_1F48
008F84  2  C8                 INY                     ; index to array bound low byte
008F85  2               LAB_1F49
008F85  2  A5 6D              LDA   Aspth             ; get array data pointer high byte
008F87  2  05 6C              ORA   Asptl             ; OR with array data pointer low byte
008F89  2  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
008F8B  2               
008F8B  2  20 B3 8F           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
008F8E  2  8A                 TXA                     ; get result low byte
008F8F  2  65 60              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
008F91  2  AA                 TAX                     ; save result low byte
008F92  2  98                 TYA                     ; get result high byte
008F93  2  A4 23              LDY   ut1_pl            ; restore index
008F95  2               LAB_1F5A
008F95  2  65 61              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
008F97  2  86 6C              STX   Asptl             ; save array data pointer low byte
008F99  2  C6 0F              DEC   Dimcnt            ; decrement dimensions count
008F9B  2  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
008F9D  2               
008F9D  2  06 6C              ASL   Asptl             ; array data pointer low byte * 2
008F9F  2  2A                 ROL                     ; array data pointer high byte * 2
008FA0  2  06 6C              ASL   Asptl             ; array data pointer low byte * 4
008FA2  2  2A                 ROL                     ; array data pointer high byte * 4
008FA3  2  A8                 TAY                     ; copy high byte
008FA4  2  A5 6C              LDA   Asptl             ; get low byte
008FA6  2  65 56              ADC   Adatal            ; add array data start pointer low byte
008FA8  2  85 47              STA   Cvaral            ; save as current var address low byte
008FAA  2  98                 TYA                     ; get high byte back
008FAB  2  65 57              ADC   Adatah            ; add array data start pointer high byte
008FAD  2  85 48              STA   Cvarah            ; save as current var address high byte
008FAF  2  A8                 TAY                     ; copy high byte to Y
008FB0  2  A5 47              LDA   Cvaral            ; get current var address low byte
008FB2  2               LAB_1F7B
008FB2  2  60                 RTS
008FB3  2               
008FB3  2               ; does XY = (Astrtl),Y * (Asptl)
008FB3  2               
008FB3  2               LAB_1F7C
008FB3  2  84 23              STY   ut1_pl            ; save index
008FB5  2  B1 5C              LDA   (Astrtl),Y        ; get dimension size low byte
008FB7  2  85 28              STA   dims_l            ; save dimension size low byte
008FB9  2  88                 DEY                     ; decrement index
008FBA  2  B1 5C              LDA   (Astrtl),Y        ; get dimension size high byte
008FBC  2  85 29              STA   dims_h            ; save dimension size high byte
008FBE  2               
008FBE  2  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
008FC0  2  85 5A              STA   numbit            ; save bit count
008FC2  2  A2 00              LDX   #$00              ; clear result low byte
008FC4  2  A0 00              LDY   #$00              ; clear result high byte
008FC6  2               LAB_1F8F
008FC6  2  8A                 TXA                     ; get result low byte
008FC7  2  0A                 ASL                     ; *2
008FC8  2  AA                 TAX                     ; save result low byte
008FC9  2  98                 TYA                     ; get result high byte
008FCA  2  2A                 ROL                     ; *2
008FCB  2  A8                 TAY                     ; save result high byte
008FCC  2  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
008FCE  2               
008FCE  2  06 6C              ASL   Asptl             ; shift multiplier low byte
008FD0  2  26 6D              ROL   Aspth             ; shift multiplier high byte
008FD2  2  90 0B              BCC   LAB_1FA8          ; skip add if no carry
008FD4  2               
008FD4  2  18                 CLC                     ; else clear carry for add
008FD5  2  8A                 TXA                     ; get result low byte
008FD6  2  65 28              ADC   dims_l            ; add dimension size low byte
008FD8  2  AA                 TAX                     ; save result low byte
008FD9  2  98                 TYA                     ; get result high byte
008FDA  2  65 29              ADC   dims_h            ; add dimension size high byte
008FDC  2  A8                 TAY                     ; save result high byte
008FDD  2  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
008FDF  2               
008FDF  2               LAB_1FA8
008FDF  2  C6 5A              DEC   numbit            ; decrement bit count
008FE1  2  D0 E3              BNE   LAB_1F8F          ; loop until all done
008FE3  2  60                 RTS
008FE4  2               
008FE4  2               ; perform FRE()
008FE4  2               
008FE4  2               LAB_FRE
008FE4  2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
008FE6  2  10 03              BPL   LAB_1FB4          ; branch if numeric
008FE8  2               
008FE8  2  20 DA 92           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
008FEB  2                                             ; space returns with A = length, X=$71=pointer low byte,
008FEB  2                                             ; Y=$72=pointer high byte
008FEB  2               
008FEB  2                                             ; FRE(n) was numeric so do this
008FEB  2               LAB_1FB4
008FEB  2  20 7B 91           JSR   LAB_GARB          ; go do garbage collection
008FEE  2  38                 SEC                     ; set carry for subtract
008FEF  2  A5 33              LDA   Sstorl            ; get bottom of string space low byte
008FF1  2  E5 31              SBC   Earryl            ; subtract array mem end low byte
008FF3  2  A8                 TAY                     ; copy result to Y
008FF4  2  A5 34              LDA   Sstorh            ; get bottom of string space high byte
008FF6  2  E5 32              SBC   Earryh            ; subtract array mem end high byte
008FF8  2               
008FF8  2               ; save and convert integer AY to FAC1
008FF8  2               
008FF8  2               LAB_AYFC
008FF8  2  46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
008FFA  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
008FFC  2  84 60              STY   FAC1_2            ; save FAC1 mantissa2
008FFE  2  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
009000  2  4C 85 98           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
009003  2               
009003  2               ; perform POS()
009003  2               
009003  2               LAB_POS
009003  2  A4 07              LDY   TPos              ; get terminal position
009005  2               
009005  2               ; convert Y to byte in FAC1
009005  2               
009005  2               LAB_1FD0
009005  2  A9 00              LDA   #$00              ; clear high byte
009007  2  80 EF              BRA   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
009009  2               
009009  2               ; check not Direct (used by DEF and INPUT)
009009  2               
009009  2               LAB_CKRN
009009  2  A6 3A              LDX   Clineh            ; get current line high byte
00900B  2  E8                 INX                     ; increment it
00900C  2  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
00900E  2               
00900E  2                                             ; else do illegal direct error
00900E  2               LAB_1FD9
00900E  2  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
009010  2               LAB_1FDB
009010  2  4C 01 81           JMP   LAB_XERR          ; go do error #X, then warm start
009013  2               
009013  2               ; perform DEF
009013  2               
009013  2               LAB_DEF
009013  2  20 41 90           JSR   LAB_200B          ; check FNx syntax
009016  2  85 4E              STA   func_l            ; save function pointer low byte
009018  2  84 4F              STY   func_h            ; save function pointer high byte
00901A  2  20 09 90           JSR   LAB_CKRN          ; check not Direct (back here if ok)
00901D  2  20 94 8B           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
009020  2  F7 13              SMB7  Sufnxf            ; set subscript/FNx flag
009022  2               ;      LDA   #$80              ; set flag for FNx
009022  2               ;      STA   Sufnxf            ; save subscript/FNx flag
009022  2  20 4C 8D           JSR   LAB_GVAR          ; get (var) address
009025  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
009028  2  20 8B 8B           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00902B  2  A9 BD              LDA   #TK_EQUAL         ; get = token
00902D  2  20 8D 8B           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
009030  2  A5 48              LDA   Cvarah            ; get current var address high byte
009032  2  48                 PHA                     ; push it
009033  2  A5 47              LDA   Cvaral            ; get current var address low byte
009035  2  48                 PHA                     ; push it
009036  2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
009038  2  48                 PHA                     ; push it
009039  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
00903B  2  48                 PHA                     ; push it
00903C  2  20 43 86           JSR   LAB_DATA          ; go perform DATA
00903F  2  80 6E              BRA   LAB_207A          ; put execute pointer and variable pointer into function
009041  2                                             ; and return
009041  2               
009041  2               ; check FNx syntax
009041  2               
009041  2               LAB_200B
009041  2  A9 AB              LDA   #TK_FN            ; get FN" token
009043  2  20 8D 8B           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
009046  2                                             ; return character after A
009046  2  09 80              ORA   #$80              ; set FN flag bit
009048  2  85 13              STA   Sufnxf            ; save FN flag so array variable test fails
00904A  2  20 53 8D           JSR   LAB_1D12          ; search for FN variable
00904D  2  4C 6A 8A           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
009050  2                                             ; mismatch
009050  2               
009050  2                                             ; Evaluate FNx
009050  2               LAB_201E
009050  2  20 41 90           JSR   LAB_200B          ; check FNx syntax
009053  2  48                 PHA                     ; push function pointer low byte
009054  2  5A                 PHY                     ; push function pointer high byte
009055  2  20 94 8B           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
009058  2  20 7C 8A           JSR   LAB_EVEX          ; evaluate expression
00905B  2  20 8B 8B           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00905E  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
009061  2  68                 PLA                     ; pop function pointer high byte
009062  2  85 4F              STA   func_h            ; restore it
009064  2  68                 PLA                     ; pop function pointer low byte
009065  2  85 4E              STA   func_l            ; restore it
009067  2  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
009069  2  A0 03              LDY   #$03              ; index to variable pointer high byte
00906B  2  B1 4E              LDA   (func_l),Y        ; get variable pointer high byte
00906D  2  F0 A1              BEQ   LAB_1FDB          ; if zero go do undefined function error
00906F  2               
00906F  2  85 48              STA   Cvarah            ; save variable address high byte
009071  2  88                 DEY                     ; index to variable address low byte
009072  2  B1 4E              LDA   (func_l),Y        ; get variable address low byte
009074  2  85 47              STA   Cvaral            ; save variable address low byte
009076  2  AA                 TAX                     ; copy address low byte
009077  2               
009077  2                                             ; now stack the function variable value before use
009077  2  C8                 INY                     ; index to mantissa_3
009078  2               LAB_2043
009078  2  B1 47              LDA   (Cvaral),Y        ; get byte from variable
00907A  2  48                 PHA                     ; stack it
00907B  2  88                 DEY                     ; decrement index
00907C  2  10 FA              BPL   LAB_2043          ; loop until variable stacked
00907E  2               
00907E  2  A4 48              LDY   Cvarah            ; get variable address high byte
009080  2  20 2C 98           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
009083  2                                             ; (function variable), return Y=0, always
009083  2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
009085  2  48                 PHA                     ; push it
009086  2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
009088  2  48                 PHA                     ; push it
009089  2  B1 4E              LDA   (func_l),Y        ; get function execute pointer low byte
00908B  2  85 6E              STA   Bpntrl            ; save as BASIC execute pointer low byte
00908D  2  C8                 INY                     ; index to high byte
00908E  2  B1 4E              LDA   (func_l),Y        ; get function execute pointer high byte
009090  2  85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
009092  2  A5 48              LDA   Cvarah            ; get variable address high byte
009094  2  48                 PHA                     ; push it
009095  2  A5 47              LDA   Cvaral            ; get variable address low byte
009097  2  48                 PHA                     ; push it
009098  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00909B  2                                             ; else do type mismatch
00909B  2  68                 PLA                     ; pull variable address low byte
00909C  2  85 4E              STA   func_l            ; save variable address low byte
00909E  2  68                 PLA                     ; pull variable address high byte
00909F  2  85 4F              STA   func_h            ; save variable address high byte
0090A1  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
0090A4  2  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
0090A6  2  4C 9C 8B           JMP   LAB_SNER          ; else syntax error then warm start
0090A9  2               
0090A9  2               ; restore Bpntrl,Bpntrh and function variable from stack
0090A9  2               
0090A9  2               LAB_2074
0090A9  2  68                 PLA                     ; pull BASIC execute pointer low byte
0090AA  2  85 6E              STA   Bpntrl            ; restore BASIC execute pointer low byte
0090AC  2  68                 PLA                     ; pull BASIC execute pointer high byte
0090AD  2  85 6F              STA   Bpntrh            ; restore BASIC execute pointer high byte
0090AF  2               
0090AF  2               ; put execute pointer and variable pointer into function
0090AF  2               
0090AF  2               LAB_207A
0090AF  2  A0 00              LDY   #$00              ; clear index
0090B1  2  68                 PLA                     ; pull BASIC execute pointer low byte
0090B2  2  91 4E              STA   (func_l),Y        ; save to function
0090B4  2  C8                 INY                     ; increment index
0090B5  2  68                 PLA                     ; pull BASIC execute pointer high byte
0090B6  2  91 4E              STA   (func_l),Y        ; save to function
0090B8  2  C8                 INY                     ; increment index
0090B9  2  68                 PLA                     ; pull current var address low byte
0090BA  2  91 4E              STA   (func_l),Y        ; save to function
0090BC  2  C8                 INY                     ; increment index
0090BD  2  68                 PLA                     ; pull current var address high byte
0090BE  2  91 4E              STA   (func_l),Y        ; save to function
0090C0  2  60                 RTS
0090C1  2               
0090C1  2               ; perform STR$()
0090C1  2               
0090C1  2               LAB_STRS
0090C1  2  20 6A 8A           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
0090C4  2  20 0E 9A           JSR   LAB_296E          ; convert FAC1 to string
0090C7  2  A9 75              LDA   #<Decssp1         ; set result string low pointer
0090C9  2  A0 00              LDY   #>Decssp1         ; set result string high pointer
0090CB  2  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
0090CD  2               
0090CD  2               ; Do string vector
0090CD  2               ; copy des_pl/h to des_2l/h and make string space A bytes long
0090CD  2               
0090CD  2               LAB_209C
0090CD  2  A6 60              LDX   des_pl            ; get descriptor pointer low byte
0090CF  2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
0090D1  2  86 50              STX   des_2l            ; save descriptor pointer low byte
0090D3  2  84 51              STY   des_2h            ; save descriptor pointer high byte
0090D5  2               
0090D5  2               ; make string space A bytes long
0090D5  2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0090D5  2               
0090D5  2               LAB_MSSP
0090D5  2  20 49 91           JSR   LAB_2115          ; make space in string memory for string A long
0090D8  2                                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0090D8  2  86 5F              STX   str_pl            ; save string pointer low byte
0090DA  2  84 60              STY   str_ph            ; save string pointer high byte
0090DC  2  85 5E              STA   str_ln            ; save length
0090DE  2  60                 RTS
0090DF  2               
0090DF  2               ; Scan, set up string
0090DF  2               ; print " terminated string to Sutill/Sutilh
0090DF  2               
0090DF  2               LAB_20AE
0090DF  2  A2 22              LDX   #$22              ; set terminator to "
0090E1  2  86 0D              STX   Srchc             ; set search character (terminator 1)
0090E3  2  86 0E              STX   Asrch             ; set terminator 2
0090E5  2               
0090E5  2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
0090E5  2               ; source is AY
0090E5  2               
0090E5  2               LAB_20B4
0090E5  2  85 6A              STA   ssptr_l           ; store string start low byte
0090E7  2  84 6B              STY   ssptr_h           ; store string start high byte
0090E9  2  85 5F              STA   str_pl            ; save string pointer low byte
0090EB  2  84 60              STY   str_ph            ; save string pointer high byte
0090ED  2  A0 FF              LDY   #$FF              ; set length to -1
0090EF  2               LAB_20BE
0090EF  2  C8                 INY                     ; increment length
0090F0  2  B1 6A              LDA   (ssptr_l),Y       ; get byte from string
0090F2  2  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
0090F4  2               
0090F4  2  C5 0D              CMP   Srchc             ; compare with search character (terminator 1)
0090F6  2  F0 04              BEQ   LAB_20CB          ; branch if terminator
0090F8  2               
0090F8  2  C5 0E              CMP   Asrch             ; compare with terminator 2
0090FA  2  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
0090FC  2               
0090FC  2               LAB_20CB
0090FC  2  C9 22              CMP   #$22              ; compare with "
0090FE  2  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
009100  2               
009100  2               LAB_20CF
009100  2  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
009101  2               LAB_20D0
009101  2  84 5E              STY   str_ln            ; save length in FAC1 exponent
009103  2  98                 TYA                     ; copy length to A
009104  2  65 6A              ADC   ssptr_l           ; add string start low byte
009106  2  85 6C              STA   Sendl             ; save string end low byte
009108  2  A6 6B              LDX   ssptr_h           ; get string start high byte
00910A  2  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
00910C  2               
00910C  2  E8                 INX                     ; else increment high byte
00910D  2               LAB_20DC
00910D  2  86 6D              STX   Sendh             ; save string end high byte
00910F  2  A5 6B              LDA   ssptr_h           ; get string start high byte
009111  2  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
009113  2  C9 03              CMP   #>Ibuffs          ; compare with location of input buffer page
009115  2  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
009117  2               
009117  2               LAB_MVST
009117  2                                             ; string in utility area, move to string memory
009117  2  98                 TYA                     ; copy length to A
009118  2  20 CD 90           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00911B  2                                             ; long
00911B  2  A6 6A              LDX   ssptr_l           ; get string start low byte
00911D  2  A4 6B              LDY   ssptr_h           ; get string start high byte
00911F  2  20 BB 92           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
009122  2               
009122  2               ; check for space on descriptor stack then ..
009122  2               ; put string address and length on descriptor stack and update stack pointers
009122  2               
009122  2               LAB_RTST
009122  2  A6 17              LDX   next_s            ; get string stack pointer
009124  2  E0 23              CPX   #des_sk+$09       ; compare with max+1
009126  2  D0 05              BNE   LAB_20F8          ; branch if space on string stack
009128  2               
009128  2                                             ; else do string too complex error
009128  2  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
00912A  2               LAB_20F5
00912A  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
00912D  2               
00912D  2               ; put string address and length on descriptor stack and update stack pointers
00912D  2               
00912D  2               LAB_20F8
00912D  2  A5 5E              LDA   str_ln            ; get string length
00912F  2  95 00              STA   PLUS_0,X          ; put on string stack
009131  2  A5 5F              LDA   str_pl            ; get string pointer low byte
009133  2  95 01              STA   PLUS_1,X          ; put on string stack
009135  2  A5 60              LDA   str_ph            ; get string pointer high byte
009137  2  95 02              STA   PLUS_2,X          ; put on string stack
009139  2  86 60              STX   des_pl            ; save string descriptor pointer low byte
00913B  2  64 61              STZ   des_ph            ; save string descriptor pointer high byte (always $00)
00913D  2  A0 FF              LDY   #$FF              ; Y = $FF
00913F  2  84 11              STY   Dtypef            ; save data type flag, $FF=string
009141  2  86 18              STX   last_sl           ; save old stack pointer (current top item)
009143  2  E8                 INX                     ; update stack pointer
009144  2  E8                 INX                     ; update stack pointer
009145  2  E8                 INX                     ; update stack pointer
009146  2  86 17              STX   next_s            ; save new top item value
009148  2  60                 RTS
009149  2               
009149  2               ; Build descriptor
009149  2               ; make space in string memory for string A long
009149  2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
009149  2               
009149  2               LAB_2115
009149  2  46 12              LSR   Gclctd            ; clear garbage collected flag (b7)
00914B  2               
00914B  2                                             ; make space for string A long
00914B  2               LAB_2117
00914B  2  48                 PHA                     ; save string length
00914C  2  49 FF              EOR   #$FF              ; complement it
00914E  2  38                 SEC                     ; set carry for subtract (twos comp add)
00914F  2  65 33              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
009151  2  A4 34              LDY   Sstorh            ; get bottom of string space high byte
009153  2  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
009155  2               
009155  2  88                 DEY                     ; decrement bottom of string space high byte
009156  2               LAB_2122
009156  2  C4 32              CPY   Earryh            ; compare with array mem end high byte
009158  2  90 11              BCC   LAB_2137          ; do out of memory error if less
00915A  2               
00915A  2  D0 04              BNE   LAB_212C          ; if not = skip next test
00915C  2               
00915C  2  C5 31              CMP   Earryl            ; compare with array mem end low byte
00915E  2  90 0B              BCC   LAB_2137          ; do out of memory error if less
009160  2               
009160  2               LAB_212C
009160  2  85 33              STA   Sstorl            ; save bottom of string space low byte
009162  2  84 34              STY   Sstorh            ; save bottom of string space high byte
009164  2  85 35              STA   Sutill            ; save string utility ptr low byte
009166  2  84 36              STY   Sutilh            ; save string utility ptr high byte
009168  2  AA                 TAX                     ; copy low byte to X
009169  2  68                 PLA                     ; get string length back
00916A  2  60                 RTS
00916B  2               
00916B  2               LAB_2137
00916B  2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00916D  2  A5 12              LDA   Gclctd            ; get garbage collected flag
00916F  2  30 B9              BMI   LAB_20F5          ; if set then do error code X
009171  2               
009171  2  20 7B 91           JSR   LAB_GARB          ; else go do garbage collection
009174  2  A9 80              LDA   #$80              ; flag for garbage collected
009176  2  85 12              STA   Gclctd            ; set garbage collected flag
009178  2  68                 PLA                     ; pull length
009179  2  80 D0              BRA   LAB_2117          ; go try again (loop always, length should never be = $00)
00917B  2               
00917B  2               ; garbage collection routine
00917B  2               
00917B  2               LAB_GARB
00917B  2  A6 37              LDX   Ememl             ; get end of mem low byte
00917D  2  A5 38              LDA   Ememh             ; get end of mem high byte
00917F  2               
00917F  2               ; re-run routine from last ending
00917F  2               
00917F  2               LAB_214B
00917F  2  86 33              STX   Sstorl            ; set string storage low byte
009181  2  85 34              STA   Sstorh            ; set string storage high byte
009183  2  64 4F              STZ   garb_h            ; clear working pointer high byte (flag no strings to move)
009185  2                                             ; patch 2.22p5
009185  2  64 4E              STZ   garb_l            ; clear working pointer low byte (flag no strings to move)
009187  2               
009187  2  A5 31              LDA   Earryl            ; get array mem end low byte
009189  2  A6 32              LDX   Earryh            ; get array mem end high byte
00918B  2  85 5C              STA   Histrl            ; save as highest string low byte
00918D  2  86 5D              STX   Histrh            ; save as highest string high byte
00918F  2  A9 1A              LDA   #des_sk           ; set descriptor stack pointer
009191  2  85 23              STA   ut1_pl            ; save descriptor stack pointer low byte
009193  2  64 24              STZ   ut1_ph            ; save descriptor stack pointer high byte ($00)
009195  2               LAB_2161
009195  2  C5 17              CMP   next_s            ; compare with descriptor stack pointer
009197  2  F0 05              BEQ   LAB_216A          ; branch if =
009199  2               
009199  2  20 FF 91           JSR   LAB_21D7          ; go garbage collect descriptor stack
00919C  2  80 F7              BRA   LAB_2161          ; loop always
00919E  2               
00919E  2                                             ; done stacked strings, now do string vars
00919E  2               LAB_216A
00919E  2  06 52              ASL   g_step            ; set step size = $06
0091A0  2  A5 2D              LDA   Svarl             ; get start of vars low byte
0091A2  2  A6 2E              LDX   Svarh             ; get start of vars high byte
0091A4  2  85 23              STA   ut1_pl            ; save as pointer low byte
0091A6  2  86 24              STX   ut1_ph            ; save as pointer high byte
0091A8  2               LAB_2176
0091A8  2  E4 30              CPX   Sarryh            ; compare start of arrays high byte
0091AA  2  D0 04              BNE   LAB_217E          ; branch if no high byte match
0091AC  2               
0091AC  2  C5 2F              CMP   Sarryl            ; else compare start of arrays low byte
0091AE  2  F0 05              BEQ   LAB_2183          ; branch if = var mem end
0091B0  2               
0091B0  2               LAB_217E
0091B0  2  20 F9 91           JSR   LAB_21D1          ; go garbage collect strings
0091B3  2  80 F3              BRA   LAB_2176          ; loop always
0091B5  2               
0091B5  2                                             ; done string vars, now do string arrays
0091B5  2               LAB_2183
0091B5  2  85 56              STA   Nbendl            ; save start of arrays low byte as working pointer
0091B7  2  86 57              STX   Nbendh            ; save start of arrays high byte as working pointer
0091B9  2  A9 04              LDA   #$04              ; set step size
0091BB  2  85 52              STA   g_step            ; save step size
0091BD  2               LAB_218B
0091BD  2  A5 56              LDA   Nbendl            ; get pointer low byte
0091BF  2  A6 57              LDX   Nbendh            ; get pointer high byte
0091C1  2               LAB_218F
0091C1  2  E4 32              CPX   Earryh            ; compare with array mem end high byte
0091C3  2  D0 04              BNE   LAB_219A          ; branch if not at end
0091C5  2               
0091C5  2  C5 31              CMP   Earryl            ; else compare with array mem end low byte
0091C7  2  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
0091C9  2               
0091C9  2               LAB_219A
0091C9  2  85 23              STA   ut1_pl            ; save pointer low byte
0091CB  2  86 24              STX   ut1_ph            ; save pointer high byte
0091CD  2  A0 02              LDY   #$02              ; set index
0091CF  2  B1 23              LDA   (ut1_pl),Y        ; get array size low byte
0091D1  2  65 56              ADC   Nbendl            ; add start of this array low byte
0091D3  2  85 56              STA   Nbendl            ; save start of next array low byte
0091D5  2  C8                 INY                     ; increment index
0091D6  2  B1 23              LDA   (ut1_pl),Y        ; get array size high byte
0091D8  2  65 57              ADC   Nbendh            ; add start of this array high byte
0091DA  2  85 57              STA   Nbendh            ; save start of next array high byte
0091DC  2  A0 01              LDY   #$01              ; set index
0091DE  2  B1 23              LDA   (ut1_pl),Y        ; get name second byte
0091E0  2  10 DB              BPL   LAB_218B          ; skip if not string array
0091E2  2               
0091E2  2               ; was string array so ..
0091E2  2               
0091E2  2  A0 04              LDY   #$04              ; set index
0091E4  2  B1 23              LDA   (ut1_pl),Y        ; get # of dimensions
0091E6  2  0A                 ASL                     ; *2
0091E7  2  69 05              ADC   #$05              ; +5 (array header size)
0091E9  2  20 31 92           JSR   LAB_2208          ; go set up for first element
0091EC  2               LAB_21C4
0091EC  2  E4 57              CPX   Nbendh            ; compare with start of next array high byte
0091EE  2  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
0091F0  2               
0091F0  2  C5 56              CMP   Nbendl            ; else compare element pointer low byte with next array
0091F2  2                                             ; low byte
0091F2  2  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
0091F4  2               
0091F4  2               LAB_21CC
0091F4  2  20 FF 91           JSR   LAB_21D7          ; go defrag array strings
0091F7  2  80 F3              BRA   LAB_21C4          ; go do next array string (loop always)
0091F9  2               
0091F9  2               ; defrag string variables
0091F9  2               ; enter with XA = variable pointer
0091F9  2               ; return with XA = next variable pointer
0091F9  2               
0091F9  2               LAB_21D1
0091F9  2  C8                 INY                     ; increment index (Y was $00)
0091FA  2  B1 23              LDA   (ut1_pl),Y        ; get var name byte 2
0091FC  2  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
0091FE  2               
0091FE  2  C8                 INY                     ; else increment index
0091FF  2               LAB_21D7
0091FF  2  B1 23              LDA   (ut1_pl),Y        ; get string length
009201  2  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
009203  2               
009203  2  C8                 INY                     ; else increment index
009204  2  B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte
009206  2  AA                 TAX                     ; copy to X
009207  2  C8                 INY                     ; increment index
009208  2  B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte
00920A  2  C5 34              CMP   Sstorh            ; compare bottom of string space high byte
00920C  2  90 06              BCC   LAB_21EC          ; branch if less
00920E  2  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
009210  2               
009210  2                                             ; high bytes were = so compare low bytes
009210  2  E4 33              CPX   Sstorl            ; compare bottom of string space low byte
009212  2  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
009214  2               
009214  2                                             ; string pointer is < string storage pointer (pos in mem)
009214  2               LAB_21EC
009214  2  C5 5D              CMP   Histrh            ; compare to highest string high byte
009216  2  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
009218  2               
009218  2  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
00921A  2               
00921A  2                                             ; high bytes were = so compare low bytes
00921A  2  E4 5C              CPX   Histrl            ; compare to highest string low byte
00921C  2  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
00921E  2               
00921E  2                                             ; string is in string memory space
00921E  2               LAB_21F6
00921E  2  86 5C              STX   Histrl            ; save as new highest string low byte
009220  2  85 5D              STA   Histrh            ; save as new highest string high byte
009222  2  A5 23              LDA   ut1_pl            ; get start of vars(descriptors) low byte
009224  2  A6 24              LDX   ut1_ph            ; get start of vars(descriptors) high byte
009226  2  85 4E              STA   garb_l            ; save as working pointer low byte
009228  2  86 4F              STX   garb_h            ; save as working pointer high byte
00922A  2  88                 DEY                     ; decrement index DIFFERS
00922B  2  88                 DEY                     ; decrement index (should point to descriptor start)
00922C  2  84 54              STY   g_indx            ; save index pointer
00922E  2               
00922E  2                                             ; step pointer to next string
00922E  2               LAB_2206
00922E  2  18                 CLC                     ; clear carry for add
00922F  2               LAB_2207
00922F  2  A5 52              LDA   g_step            ; get step size
009231  2               LAB_2208
009231  2  65 23              ADC   ut1_pl            ; add pointer low byte
009233  2  85 23              STA   ut1_pl            ; save pointer low byte
009235  2  90 02              BCC   LAB_2211          ; branch if no overflow
009237  2               
009237  2  E6 24              INC   ut1_ph            ; else increment high byte
009239  2               LAB_2211
009239  2  A6 24              LDX   ut1_ph            ; get pointer high byte
00923B  2  A0 00              LDY   #$00              ; clear Y
00923D  2  60                 RTS
00923E  2               
00923E  2               ; search complete, now either exit or set-up and move string
00923E  2               
00923E  2               LAB_2216
00923E  2  C6 52              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
009240  2                                             ; patch 2.22p5
009240  2  A5 4F              LDA   garb_h            ; any string to move?
009242  2  05 4E              ORA   garb_l
009244  2  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
009246  2               
009246  2  A4 54              LDY   g_indx            ; get index byte back (points to descriptor)
009248  2  18                 CLC                     ; clear carry for add
009249  2  B1 4E              LDA   (garb_l),Y        ; get string length
00924B  2  65 5C              ADC   Histrl            ; add highest string low byte
00924D  2  85 58              STA   Obendl            ; save old block end low pointer
00924F  2  A5 5D              LDA   Histrh            ; get highest string high byte
009251  2  69 00              ADC   #$00              ; add any carry
009253  2  85 59              STA   Obendh            ; save old block end high byte
009255  2  A5 33              LDA   Sstorl            ; get bottom of string space low byte
009257  2  A6 34              LDX   Sstorh            ; get bottom of string space high byte
009259  2  85 56              STA   Nbendl            ; save new block end low byte
00925B  2  86 57              STX   Nbendh            ; save new block end high byte
00925D  2  20 8B 80           JSR   LAB_11D6          ; open up space in memory, don't set array end
009260  2  A4 54              LDY   g_indx            ; get index byte
009262  2  C8                 INY                     ; point to descriptor low byte
009263  2  A5 56              LDA   Nbendl            ; get string pointer low byte
009265  2  91 4E              STA   (garb_l),Y        ; save new string pointer low byte
009267  2  AA                 TAX                     ; copy string pointer low byte
009268  2  E6 57              INC   Nbendh            ; correct high byte (move sets high byte -1)
00926A  2  A5 57              LDA   Nbendh            ; get new string pointer high byte
00926C  2  C8                 INY                     ; point to descriptor high byte
00926D  2  91 4E              STA   (garb_l),Y        ; save new string pointer high byte
00926F  2  4C 7F 91           JMP   LAB_214B          ; re-run routine from last ending
009272  2                                             ; (but don't collect this string)
009272  2               
009272  2               ; concatenate
009272  2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
009272  2               
009272  2               LAB_224D
009272  2  A5 61              LDA   des_ph            ; get descriptor pointer high byte
009274  2  48                 PHA                     ; put on stack
009275  2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
009277  2  48                 PHA                     ; put on stack
009278  2               
009278  2               LAB_224Da                     ; patch 2.22p5 - added extra label
009278  2               
009278  2  20 69 8B           JSR   LAB_GVAL          ; get value from line
00927B  2  20 6D 8A           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00927E  2  68                 PLA                     ; get descriptor pointer low byte back
00927F  2  85 6A              STA   ssptr_l           ; set pointer low byte
009281  2  68                 PLA                     ; get descriptor pointer high byte back
009282  2  85 6B              STA   ssptr_h           ; set pointer high byte
009284  2  B2 6A              LDA   (ssptr_l)         ; get length_1 from descriptor
009286  2  18                 CLC                     ; clear carry for add
009287  2  72 60              ADC   (des_pl)          ; add length_2
009289  2  90 05              BCC   LAB_226D          ; branch if no overflow
00928B  2               
00928B  2  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
00928D  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
009290  2               
009290  2               LAB_226D
009290  2  20 CD 90           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
009293  2                                             ; long
009293  2  20 AD 92           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
009296  2  A5 50              LDA   des_2l            ; get descriptor pointer low byte
009298  2  A4 51              LDY   des_2h            ; get descriptor pointer high byte
00929A  2  20 DE 92           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00929D  2                                             ; returns with A = length, ut1_pl = pointer low byte,
00929D  2                                             ; ut1_ph = pointer high byte
00929D  2  20 BF 92           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
0092A0  2  A5 6A              LDA   ssptr_l           ; set descriptor pointer low byte
0092A2  2  A4 6B              LDY   ssptr_h           ; set descriptor pointer high byte
0092A4  2  20 DE 92           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
0092A7  2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
0092A7  2                                             ; Y=ut1_ph=pointer high byte
0092A7  2  20 22 91           JSR   LAB_RTST          ; check for space on descriptor stack then put string
0092AA  2                                             ; address and length on descriptor stack and update stack
0092AA  2                                             ; pointers
0092AA  2  4C 91 8A           JMP   LAB_1ADB          ; continue evaluation
0092AD  2               
0092AD  2               ; copy string from descriptor (sdescr) to (Sutill)
0092AD  2               
0092AD  2               LAB_228A
0092AD  2  A0 00              LDY   #$00              ; clear index
0092AF  2  B1 6A              LDA   (sdescr),Y        ; get string length
0092B1  2  48                 PHA                     ; save on stack
0092B2  2  C8                 INY                     ; increment index
0092B3  2  B1 6A              LDA   (sdescr),Y        ; get source string pointer low byte
0092B5  2  AA                 TAX                     ; copy to X
0092B6  2  C8                 INY                     ; increment index
0092B7  2  B1 6A              LDA   (sdescr),Y        ; get source string pointer high byte
0092B9  2  A8                 TAY                     ; copy to Y
0092BA  2  68                 PLA                     ; get length back
0092BB  2               
0092BB  2               ; store string A bytes long from YX to (Sutill)
0092BB  2               
0092BB  2               LAB_2298
0092BB  2  86 23              STX   ut1_pl            ; save source string pointer low byte
0092BD  2  84 24              STY   ut1_ph            ; save source string pointer high byte
0092BF  2               
0092BF  2               ; store string A bytes long from (ut1_pl) to (Sutill)
0092BF  2               
0092BF  2               LAB_229C
0092BF  2  AA                 TAX                     ; copy length to index (don't count with Y)
0092C0  2  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
0092C2  2               
0092C2  2  A0 00              LDY   #$00              ; zero pointer (copy forward)
0092C4  2               LAB_22A0
0092C4  2  B1 23              LDA   (ut1_pl),Y        ; get source byte
0092C6  2  91 35              STA   (Sutill),Y        ; save destination byte
0092C8  2               
0092C8  2  C8                 INY                     ; increment index
0092C9  2  CA                 DEX                     ; decrement counter
0092CA  2  D0 F8              BNE   LAB_22A0          ; loop while <> 0
0092CC  2               
0092CC  2  98                 TYA                     ; restore length from Y
0092CD  2               LAB_22A9
0092CD  2  18                 CLC                     ; clear carry for add
0092CE  2  65 35              ADC   Sutill            ; add string utility ptr low byte
0092D0  2  85 35              STA   Sutill            ; save string utility ptr low byte
0092D2  2  90 02              BCC   LAB_22B2          ; branch if no carry
0092D4  2               
0092D4  2  E6 36              INC   Sutilh            ; else increment string utility ptr high byte
0092D6  2               LAB_22B2
0092D6  2  60                 RTS
0092D7  2               
0092D7  2               ; evaluate string
0092D7  2               
0092D7  2               LAB_EVST
0092D7  2  20 6D 8A           JSR   LAB_CTST          ; check if source is string, else do type mismatch
0092DA  2               
0092DA  2               ; pop string off descriptor stack, or from top of string space
0092DA  2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
0092DA  2               
0092DA  2               LAB_22B6
0092DA  2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
0092DC  2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
0092DE  2               
0092DE  2               ; pop (YA) descriptor off stack or from top of string space
0092DE  2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
0092DE  2               
0092DE  2               LAB_22BA
0092DE  2  85 23              STA   ut1_pl            ; save descriptor pointer low byte
0092E0  2  84 24              STY   ut1_ph            ; save descriptor pointer high byte
0092E2  2  20 0F 93           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
0092E5  2  08                 PHP                     ; save status flags
0092E6  2  A0 00              LDY   #$00              ; clear index
0092E8  2  B1 23              LDA   (ut1_pl),Y        ; get length from string descriptor
0092EA  2  48                 PHA                     ; put on stack
0092EB  2  C8                 INY                     ; increment index
0092EC  2  B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
0092EE  2  AA                 TAX                     ; copy to X
0092EF  2  C8                 INY                     ; increment index
0092F0  2  B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
0092F2  2  A8                 TAY                     ; copy to Y
0092F3  2  68                 PLA                     ; get string length back
0092F4  2  28                 PLP                     ; restore status
0092F5  2  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
0092F7  2               
0092F7  2  C4 34              CPY   Sstorh            ; compare bottom of string space high byte
0092F9  2  D0 0F              BNE   LAB_22E6          ; branch if <>
0092FB  2               
0092FB  2  E4 33              CPX   Sstorl            ; else compare bottom of string space low byte
0092FD  2  D0 0B              BNE   LAB_22E6          ; branch if <>
0092FF  2               
0092FF  2  48                 PHA                     ; save string length
009300  2  18                 CLC                     ; clear carry for add
009301  2  65 33              ADC   Sstorl            ; add bottom of string space low byte
009303  2  85 33              STA   Sstorl            ; save bottom of string space low byte
009305  2  90 02              BCC   LAB_22E5          ; skip increment if no overflow
009307  2               
009307  2  E6 34              INC   Sstorh            ; increment bottom of string space high byte
009309  2               LAB_22E5
009309  2  68                 PLA                     ; restore string length
00930A  2               LAB_22E6
00930A  2  86 23              STX   ut1_pl            ; save string pointer low byte
00930C  2  84 24              STY   ut1_ph            ; save string pointer high byte
00930E  2  60                 RTS
00930F  2               
00930F  2               ; clean descriptor stack, YA = pointer
00930F  2               ; checks if AY is on the descriptor stack, if so does a stack discard
00930F  2               
00930F  2               LAB_22EB
00930F  2  C4 19              CPY   last_sh           ; compare pointer high byte
009311  2  D0 0C              BNE   LAB_22FB          ; exit if <>
009313  2               
009313  2  C5 18              CMP   last_sl           ; compare pointer low byte
009315  2  D0 08              BNE   LAB_22FB          ; exit if <>
009317  2               
009317  2  85 17              STA   next_s            ; save descriptor stack pointer
009319  2  E9 03              SBC   #$03              ; -3
00931B  2  85 18              STA   last_sl           ; save low byte -3
00931D  2  A0 00              LDY   #$00              ; clear high byte
00931F  2               LAB_22FB
00931F  2  60                 RTS
009320  2               
009320  2               ; perform CHR$()
009320  2               
009320  2               LAB_CHRS
009320  2  20 24 94           JSR   LAB_EVBY          ; evaluate byte expression, result in X
009323  2  DA                 PHX                     ; save character to stack
009324  2  A9 01              LDA   #$01              ; string is single byte
009326  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
009329  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
009329  2  68                 PLA                     ; get character back
00932A  2  92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
00932C  2  4C 22 91           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00932F  2                                             ; address and length on descriptor stack and update stack
00932F  2                                             ; pointers
00932F  2               
00932F  2               ; perform LEFT$()
00932F  2               
00932F  2               LAB_LEFT
00932F  2  48                 PHA                     ; push byte parameter
009330  2  20 8F 93           JSR   LAB_236F          ; pull string data and byte parameter from stack
009333  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
009333  2  D1 50              CMP   (des_2l),Y        ; compare byte parameter with string length
009335  2  98                 TYA                     ; clear A
009336  2  80 09              BRA   LAB_2316          ; go do string copy (branch always)
009338  2               
009338  2               ; perform RIGHT$()
009338  2               
009338  2               LAB_RIGHT
009338  2  48                 PHA                     ; push byte parameter
009339  2  20 8F 93           JSR   LAB_236F          ; pull string data and byte parameter from stack
00933C  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00933C  2  18                 CLC                     ; clear carry for add-1
00933D  2  F1 50              SBC   (des_2l),Y        ; subtract string length
00933F  2  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
009341  2               
009341  2               LAB_2316
009341  2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
009343  2               
009343  2  B1 50              LDA   (des_2l),Y        ; else make parameter = length
009345  2  AA                 TAX                     ; copy to byte parameter copy
009346  2  98                 TYA                     ; clear string start offset
009347  2               LAB_231C
009347  2  48                 PHA                     ; save string start offset
009348  2               LAB_231D
009348  2  8A                 TXA                     ; copy byte parameter (or string length if <)
009349  2               LAB_231E
009349  2  48                 PHA                     ; save string length
00934A  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00934D  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00934D  2  A5 50              LDA   des_2l            ; get descriptor pointer low byte
00934F  2  A4 51              LDY   des_2h            ; get descriptor pointer high byte
009351  2  20 DE 92           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
009354  2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
009354  2                                             ; Y=ut1_ph=pointer high byte
009354  2  7A                 PLY                     ; get string length back
009355  2  68                 PLA                     ; get string start offset back
009356  2  18                 CLC                     ; clear carry for add
009357  2  65 23              ADC   ut1_pl            ; add start offset to string start pointer low byte
009359  2  85 23              STA   ut1_pl            ; save string start pointer low byte
00935B  2  90 02              BCC   LAB_2335          ; branch if no overflow
00935D  2               
00935D  2  E6 24              INC   ut1_ph            ; else increment string start pointer high byte
00935F  2               LAB_2335
00935F  2  98                 TYA                     ; copy length to A
009360  2  20 BF 92           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
009363  2  4C 22 91           JMP   LAB_RTST          ; check for space on descriptor stack then put string
009366  2                                             ; address and length on descriptor stack and update stack
009366  2                                             ; pointers
009366  2               
009366  2               ; perform MID$()
009366  2               
009366  2               LAB_MIDS
009366  2  48                 PHA                     ; push byte parameter
009367  2  A9 FF              LDA   #$FF              ; set default length = 255
009369  2  85 61              STA   mids_l            ; save default length
00936B  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
00936E  2  C9 29              CMP   #')'              ; compare with ")"
009370  2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
009372  2               
009372  2  20 98 8B           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
009375  2  20 21 94           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
009378  2               LAB_2358
009378  2  20 8F 93           JSR   LAB_236F          ; pull string data and byte parameter from stack
00937B  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00937B  2  CA                 DEX                     ; decrement start index
00937C  2  8A                 TXA                     ; copy to A
00937D  2  48                 PHA                     ; save string start offset
00937E  2  18                 CLC                     ; clear carry for sub-1
00937F  2  A2 00              LDX   #$00              ; clear output string length
009381  2  F1 50              SBC   (des_2l),Y        ; subtract string length
009383  2  B0 C3              BCS   LAB_231D          ; if start>string length go do null string
009385  2               
009385  2  49 FF              EOR   #$FF              ; complement -length
009387  2  C5 61              CMP   mids_l            ; compare byte parameter
009389  2  90 BE              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
00938B  2               
00938B  2  A5 61              LDA   mids_l            ; get length byte
00938D  2  80 BA              BRA   LAB_231E          ; go do string copy (branch always)
00938F  2               
00938F  2               ; pull string data and byte parameter from stack
00938F  2               ; return pointer in des_2l/h, byte in A (and X), Y=0
00938F  2               
00938F  2               LAB_236F
00938F  2  20 8B 8B           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
009392  2  68                 PLA                     ; pull return address low byte (return address)
009393  2  85 54              STA   Fnxjpl            ; save functions jump vector low byte
009395  2  68                 PLA                     ; pull return address high byte (return address)
009396  2  85 55              STA   Fnxjph            ; save functions jump vector high byte
009398  2  FA                 PLX                     ; get byte parameter
009399  2  68                 PLA                     ; pull string pointer low byte
00939A  2  85 50              STA   des_2l            ; save it
00939C  2  68                 PLA                     ; pull string pointer high byte
00939D  2  85 51              STA   des_2h            ; save it
00939F  2  A0 00              LDY   #$00              ; clear index
0093A1  2  8A                 TXA                     ; copy byte parameter
0093A2  2  F0 77              BEQ   LAB_23A8          ; if null do function call error then warm start
0093A4  2               
0093A4  2  E6 54              INC   Fnxjpl            ; increment function jump vector low byte
0093A6  2                                             ; (JSR pushes return addr-1. this is all very nice
0093A6  2                                             ; but will go tits up if either call is on a page
0093A6  2                                             ; boundary!)
0093A6  2  6C 54 00           JMP   (Fnxjpl)          ; in effect, RTS
0093A9  2               
0093A9  2               ; perform LCASE$()
0093A9  2               
0093A9  2               LAB_LCASE
0093A9  2  20 D7 92           JSR   LAB_EVST          ; evaluate string
0093AC  2  85 5E              STA   str_ln            ; set string length
0093AE  2  A8                 TAY                     ; copy length to Y
0093AF  2  F0 38              BEQ   NoString          ; branch if null string
0093B1  2               
0093B1  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long A=length,
0093B4  2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0093B4  2  86 5F              STX   str_pl            ; save string pointer low byte
0093B6  2  84 60              STY   str_ph            ; save string pointer high byte
0093B8  2  A8                 TAY                     ; get string length back
0093B9  2               
0093B9  2               LC_loop
0093B9  2  88                 DEY                     ; decrement index
0093BA  2  B1 23              LDA   (ut1_pl),Y        ; get byte from string
0093BC  2  20 C2 8D           JSR   LAB_1D82          ; is character "A" to "Z"
0093BF  2  90 02              BCC   NoUcase           ; branch if not upper case alpha
0093C1  2               
0093C1  2  09 20              ORA   #$20              ; convert upper to lower case
0093C3  2               NoUcase
0093C3  2  91 35              STA   (Sutill),Y        ; save byte back to string
0093C5  2  98                 TYA                     ; test index
0093C6  2  D0 F1              BNE   LC_loop           ; loop if not all done
0093C8  2  80 1F              BRA   NoString          ; tidy up and exit, branch always
0093CA  2               
0093CA  2               ; perform UCASE$()
0093CA  2               
0093CA  2               LAB_UCASE
0093CA  2  20 D7 92           JSR   LAB_EVST          ; evaluate string
0093CD  2  85 5E              STA   str_ln            ; set string length
0093CF  2  A8                 TAY                     ; copy length to Y
0093D0  2  F0 17              BEQ   NoString          ; branch if null string
0093D2  2               
0093D2  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long A=length,
0093D5  2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0093D5  2  86 5F              STX   str_pl            ; save string pointer low byte
0093D7  2  84 60              STY   str_ph            ; save string pointer high byte
0093D9  2  A8                 TAY                     ; get string length back
0093DA  2               
0093DA  2               UC_loop
0093DA  2  88                 DEY                     ; decrement index
0093DB  2  B1 23              LDA   (ut1_pl),Y        ; get byte from string
0093DD  2  20 BE 8D           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
0093E0  2  90 02              BCC   NoLcase           ; branch if not alpha
0093E2  2               
0093E2  2  29 DF              AND   #$DF              ; convert lower to upper case
0093E4  2               NoLcase
0093E4  2  91 35              STA   (Sutill),Y        ; save byte back to string
0093E6  2  98                 TYA                     ; test index
0093E7  2  D0 F1              BNE   UC_loop           ; loop if not all done
0093E9  2               
0093E9  2               NoString
0093E9  2  4C 22 91           JMP   LAB_RTST          ; check for space on descriptor stack then put string
0093EC  2                                             ; address and length on descriptor stack and update stack
0093EC  2                                             ; pointers
0093EC  2               
0093EC  2               ; perform SADD()
0093EC  2               
0093EC  2               LAB_SADD
0093EC  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
0093EF  2  20 4C 8D           JSR   LAB_GVAR          ; get var address
0093F2  2               
0093F2  2  20 8B 8B           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
0093F5  2  20 6D 8A           JSR   LAB_CTST          ; check if source is string, else do type mismatch
0093F8  2               
0093F8  2  A0 02              LDY   #$02              ; index to string pointer high byte
0093FA  2  B1 47              LDA   (Cvaral),Y        ; get string pointer high byte
0093FC  2  AA                 TAX                     ; copy string pointer high byte to X
0093FD  2  88                 DEY                     ; index to string pointer low byte
0093FE  2  B1 47              LDA   (Cvaral),Y        ; get string pointer low byte
009400  2  A8                 TAY                     ; copy string pointer low byte to Y
009401  2  8A                 TXA                     ; copy string pointer high byte to A
009402  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009405  2               
009405  2               ; perform LEN()
009405  2               
009405  2               LAB_LENS
009405  2  20 0B 94           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
009408  2  4C 05 90           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00940B  2               
00940B  2               ; evaluate string, get length in Y
00940B  2               
00940B  2               LAB_ESGL
00940B  2  20 D7 92           JSR   LAB_EVST          ; evaluate string
00940E  2  A8                 TAY                     ; copy length to Y
00940F  2  60                 RTS
009410  2               
009410  2               ; perform ASC()
009410  2               
009410  2               LAB_ASC
009410  2  20 0B 94           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
009413  2  F0 06              BEQ   LAB_23A8          ; if null do function call error then warm start
009415  2               
009415  2  B2 23              LDA   (ut1_pl)          ; get byte
009417  2  A8                 TAY                     ; copy to Y
009418  2  4C 05 90           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00941B  2               
00941B  2               ; do function call error then warm start
00941B  2               
00941B  2               LAB_23A8
00941B  2  4C C8 8E           JMP   LAB_FCER          ; do function call error then warm start
00941E  2               
00941E  2               ; scan and get byte parameter
00941E  2               
00941E  2               LAB_SGBY
00941E  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009421  2               
009421  2               ; get byte parameter
009421  2               
009421  2               LAB_GTBY
009421  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009424  2                                             ; else do type mismatch
009424  2               
009424  2               ; evaluate byte expression, result in X
009424  2               
009424  2               LAB_EVBY
009424  2  20 42 8E           JSR   LAB_EVPI          ; evaluate integer expression (no check)
009427  2               
009427  2  A4 60              LDY   FAC1_2            ; get FAC1 mantissa2
009429  2  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
00942B  2               
00942B  2  A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
00942D  2  4C BB 9F           JMP   LAB_GBYT          ; scan memory and return
009430  2               
009430  2               ; perform VAL()
009430  2               
009430  2               LAB_VAL
009430  2  20 0B 94           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
009433  2  D0 03              BNE   LAB_23C5          ; branch if not null string
009435  2               
009435  2                                             ; string was null so set result = $00
009435  2  4C D8 95           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
009438  2               
009438  2               LAB_23C5
009438  2                                             ; patch 2.22p5 - new routine
009438  2  48                 PHA                     ; save length
009439  2  C8                 INY                     ; string length +1
00943A  2  98                 TYA
00943B  2  20 D5 90           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
00943E  2  68                 PLA                     ; get length back
00943F  2  20 BF 92           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
009442  2  A9 00              LDA   #0                ; add delimiter to end of string
009444  2  92 35              STA   (Sutill)
009446  2  A6 6E              LDX   Bpntrl            ; save BASIC execute pointer low byte
009448  2  A4 6F              LDY   Bpntrh
00944A  2  86 6C              STX   Btmpl
00944C  2  84 6D              STY   Btmph
00944E  2  A6 5F              LDX   str_pl            ; point to temporary string
009450  2  A4 60              LDY   str_ph
009452  2  86 6E              STX   Bpntrl
009454  2  84 6F              STY   Bpntrh
009456  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
009459  2  20 26 99           JSR   LAB_2887          ; get FAC1 from string
00945C  2               
00945C  2               LAB_23F3
00945C  2  A6 6C              LDX   Btmpl             ; get BASIC execute pointer low byte back
00945E  2  A4 6D              LDY   Btmph             ; get BASIC execute pointer high byte back
009460  2  86 6E              STX   Bpntrl            ; save BASIC execute pointer low byte
009462  2  84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
009464  2  60                 RTS
009465  2               
009465  2               ; get two parameters for POKE or WAIT
009465  2               
009465  2               LAB_GADB
009465  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009468  2                                             ; else do type mismatch
009468  2  20 7E 94           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00946B  2               
00946B  2               ; scan for "," and get byte, else do Syntax error then warm start
00946B  2               
00946B  2               LAB_SCGB
00946B  2  20 98 8B           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00946E  2  A5 0B              LDA   Itemph            ; save temporary integer high byte
009470  2  48                 PHA                     ; on stack
009471  2  A5 0A              LDA   Itempl            ; save temporary integer low byte
009473  2  48                 PHA                     ; on stack
009474  2  20 21 94           JSR   LAB_GTBY          ; get byte parameter
009477  2  68                 PLA                     ; pull low byte
009478  2  85 0A              STA   Itempl            ; restore temporary integer low byte
00947A  2  68                 PLA                     ; pull high byte
00947B  2  85 0B              STA   Itemph            ; restore temporary integer high byte
00947D  2  60                 RTS
00947E  2               
00947E  2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
00947E  2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
00947E  2               
00947E  2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
00947E  2               
00947E  2               LAB_F2FX
00947E  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009480  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
009482  2  B0 97              BCS   LAB_23A8          ; if >= do function call error then warm start
009484  2               
009484  2               LAB_F2FU
009484  2  20 D0 98           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
009487  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
009489  2  A4 61              LDY   FAC1_3            ; get FAC1 mantissa3
00948B  2  84 0A              STY   Itempl            ; save temporary integer low byte
00948D  2  85 0B              STA   Itemph            ; save temporary integer high byte
00948F  2  60                 RTS
009490  2               
009490  2               ; perform PEEK()
009490  2               
009490  2               LAB_PEEK
009490  2  20 7E 94           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
009493  2  A2 00              LDX   #$00              ; clear index
009495  2  A1 0A              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
009497  2  A8                 TAY                     ; copy byte to Y
009498  2  4C 05 90           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00949B  2               
00949B  2               ; perform POKE
00949B  2               
00949B  2               LAB_POKE
00949B  2  20 65 94           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00949E  2  8A                 TXA                     ; copy byte argument to A
00949F  2  A2 00              LDX   #$00              ; clear index
0094A1  2  81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
0094A3  2  60                 RTS
0094A4  2               
0094A4  2               ; perform DEEK()
0094A4  2               
0094A4  2               LAB_DEEK
0094A4  2  20 7E 94           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
0094A7  2  A2 00              LDX   #$00              ; clear index
0094A9  2  A1 0A              LDA   (Itempl,X)        ; PEEK low byte
0094AB  2  A8                 TAY                     ; copy to Y
0094AC  2  E6 0A              INC   Itempl            ; increment pointer low byte
0094AE  2  D0 02              BNE   Deekh             ; skip high increment if no rollover
0094B0  2               
0094B0  2  E6 0B              INC   Itemph            ; increment pointer high byte
0094B2  2               Deekh
0094B2  2  A1 0A              LDA   (Itempl,X)        ; PEEK high byte
0094B4  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0094B7  2               
0094B7  2               ; perform DOKE
0094B7  2               
0094B7  2               LAB_DOKE
0094B7  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0094BA  2                                             ; else do type mismatch
0094BA  2  20 7E 94           JSR   LAB_F2FX          ; convert floating-to-fixed
0094BD  2               
0094BD  2  84 49              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
0094BF  2  85 4A              STA   Frnxth            ; save pointer high byte
0094C1  2               
0094C1  2  20 98 8B           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
0094C4  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0094C7  2                                             ; else do type mismatch
0094C7  2  20 7E 94           JSR   LAB_F2FX          ; convert floating-to-fixed
0094CA  2               
0094CA  2  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
0094CB  2  A2 00              LDX   #$00              ; clear index
0094CD  2  81 49              STA   (Frnxtl,X)        ; POKE low byte
0094CF  2  E6 49              INC   Frnxtl            ; increment pointer low byte
0094D1  2  D0 02              BNE   Dokeh             ; skip high increment if no rollover
0094D3  2               
0094D3  2  E6 4A              INC   Frnxth            ; increment pointer high byte
0094D5  2               Dokeh
0094D5  2  A5 0B              LDA   Itemph            ; get value high byte
0094D7  2  81 49              STA   (Frnxtl,X)        ; POKE high byte
0094D9  2  4C BB 9F           JMP   LAB_GBYT          ; scan memory and return
0094DC  2               
0094DC  2               ; perform SWAP
0094DC  2               
0094DC  2               LAB_SWAP
0094DC  2  20 4C 8D           JSR   LAB_GVAR          ; get var1 address
0094DF  2  85 49              STA   Lvarpl            ; save var1 address low byte
0094E1  2  84 4A              STY   Lvarph            ; save var1 address high byte
0094E3  2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
0094E5  2  48                 PHA                     ; save data type flag
0094E6  2               
0094E6  2  20 98 8B           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
0094E9  2  20 4C 8D           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
0094EC  2  68                 PLA                     ; pull var1 data type flag
0094ED  2  45 11              EOR   Dtypef            ; compare with var2 data type
0094EF  2  10 10              BPL   SwapErr           ; exit if not both the same type
0094F1  2               
0094F1  2  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
0094F3  2               SwapLp
0094F3  2  B1 49              LDA   (Lvarpl),Y        ; get byte from var1
0094F5  2  AA                 TAX                     ; save var1 byte
0094F6  2  B1 47              LDA   (Cvaral),Y        ; get byte from var2
0094F8  2  91 49              STA   (Lvarpl),Y        ; save byte to var1
0094FA  2  8A                 TXA                     ; restore var1 byte
0094FB  2  91 47              STA   (Cvaral),Y        ; save byte to var2
0094FD  2  88                 DEY                     ; decrement index
0094FE  2  10 F3              BPL   SwapLp            ; loop until done
009500  2  60                 RTS
009501  2               
009501  2               SwapErr
009501  2  4C 77 8A           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
009504  2               
009504  2               ; perform CALL
009504  2               
009504  2               LAB_CALL
009504  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009507  2                                             ; else do type mismatch
009507  2  20 7E 94           JSR   LAB_F2FX          ; convert floating-to-fixed
00950A  2  A9 95              LDA   #>CallExit        ; set return address high byte
00950C  2  48                 PHA                     ; put on stack
00950D  2  A9 12              LDA   #<CallExit-1      ; set return address low byte
00950F  2  48                 PHA                     ; put on stack
009510  2  6C 0A 00           JMP   (Itempl)          ; do indirect jump to user routine
009513  2               
009513  2               ; if the called routine exits correctly then it will return to here. this will then get
009513  2               ; the next byte for the interpreter and return
009513  2               
009513  2               CallExit
009513  2  4C BB 9F           JMP   LAB_GBYT          ; scan memory and return
009516  2               
009516  2               ; perform WAIT
009516  2               
009516  2               LAB_WAIT
009516  2  20 65 94           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
009519  2  86 49              STX   Frnxtl            ; save byte
00951B  2  A2 00              LDX   #$00              ; clear mask
00951D  2  20 BB 9F           JSR   LAB_GBYT          ; scan memory
009520  2  F0 03              BEQ   LAB_2441          ; skip if no third argument
009522  2               
009522  2  20 6B 94           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
009525  2               LAB_2441
009525  2  86 4A              STX   Frnxth            ; save EOR argument
009527  2               LAB_2445
009527  2  B1 0A              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
009529  2  45 4A              EOR   Frnxth            ; EOR with second argument (mask)
00952B  2  25 49              AND   Frnxtl            ; AND with first argument (byte)
00952D  2  F0 F8              BEQ   LAB_2445          ; loop if result is zero
00952F  2               
00952F  2               LAB_244D
00952F  2  60                 RTS
009530  2               
009530  2               ; perform subtraction, FAC1 from (AY)
009530  2               
009530  2               LAB_2455
009530  2  20 11 97           JSR   LAB_264D          ; unpack memory (AY) into FAC2
009533  2               
009533  2               ; perform subtraction, FAC1 from FAC2
009533  2               
009533  2               LAB_SUBTRACT
009533  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009535  2  49 FF              EOR   #$FF              ; complement it
009537  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
009539  2  45 69              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
00953B  2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00953D  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
00953F  2  80 0C              BRA   LAB_ADD           ; go add FAC2 to FAC1
009541  2               
009541  2               ; perform addition
009541  2               
009541  2               LAB_2467
009541  2  20 62 96           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
009544  2  90 49              BCC   LAB_24A8          ; go subtract mantissas
009546  2               
009546  2               ; add 0.5 to FAC1
009546  2               
009546  2               LAB_244E
009546  2  A9 79              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
009548  2  A0 A1              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
00954A  2               
00954A  2               ; add (AY) to FAC1
00954A  2               
00954A  2               LAB_246C
00954A  2  20 11 97           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00954D  2               
00954D  2               ; add FAC2 to FAC1
00954D  2               
00954D  2               LAB_ADD
00954D  2  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
00954F  2               
00954F  2               ; copy FAC2 to FAC1
00954F  2               
00954F  2               LAB_279B
00954F  2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
009551  2               
009551  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
009551  2               
009551  2               LAB_279D
009551  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
009553  2  A2 04              LDX   #$04              ; 4 bytes to copy
009555  2               LAB_27A1
009555  2  B5 64              LDA   FAC1_o,X          ; get byte from FAC2,X
009557  2  95 5D              STA   FAC1_e-1,X        ; save byte at FAC1,X
009559  2  CA                 DEX                     ; decrement count
00955A  2  D0 F9              BNE   LAB_27A1          ; loop if not all done
00955C  2               
00955C  2  86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
00955E  2  60                 RTS
00955F  2               
00955F  2                                             ; FAC1 is non zero
00955F  2               LAB_2474
00955F  2  A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
009561  2  86 55              STX   FAC2_r            ; save as FAC2 rounding byte
009563  2  A2 65              LDX   #FAC2_e           ; set index to FAC2 exponent addr
009565  2  A5 65              LDA   FAC2_e            ; get FAC2 exponent
009567  2               LAB_247C
009567  2  A8                 TAY                     ; copy exponent
009568  2  F0 C5              BEQ   LAB_244D          ; exit if zero
00956A  2               
00956A  2  38                 SEC                     ; set carry for subtract
00956B  2  E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
00956D  2  F0 20              BEQ   LAB_24A8          ; branch if = (go add mantissa)
00956F  2  90 10              BCC   LAB_2498          ; branch if <
009571  2               
009571  2                                             ; FAC2>FAC1
009571  2  84 5E              STY   FAC1_e            ; save FAC1 exponent
009573  2  A4 69              LDY   FAC2_s            ; get FAC2 sign (b7)
009575  2  84 62              STY   FAC1_s            ; save FAC1 sign (b7)
009577  2  49 FF              EOR   #$FF              ; complement A
009579  2  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
00957B  2  64 55              STZ   FAC2_r            ; clear FAC2 rounding byte
00957D  2  A2 5E              LDX   #FAC1_e           ; set index to FAC1 exponent addr
00957F  2  80 02              BRA   LAB_249C          ; branch always
009581  2               
009581  2               LAB_2498
009581  2  64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
009583  2               LAB_249C
009583  2  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
009585  2  30 BA              BMI   LAB_2467          ; branch if range $79-$F8
009587  2               
009587  2  A8                 TAY                     ; copy exponent difference to Y
009588  2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
00958A  2  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
00958C  2  20 79 96           JSR   LAB_2592          ; shift FACX Y times right
00958F  2               
00958F  2                                             ; exponents are equal now do mantissa subtract
00958F  2               LAB_24A8
00958F  2  24 6A              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
009591  2  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
009593  2               
009593  2  A0 5E              LDY   #FAC1_e           ; set index to FAC1 exponent addr
009595  2  E0 65              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
009597  2  F0 02              BEQ   LAB_24B4          ; branch if =
009599  2               
009599  2  A0 65              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
00959B  2               
00959B  2                                             ; subtract smaller from bigger (take sign of bigger)
00959B  2               LAB_24B4
00959B  2  38                 SEC                     ; set carry for subtract
00959C  2  49 FF              EOR   #$FF              ; ones complement A
00959E  2  65 55              ADC   FAC2_r            ; add FAC2 rounding byte
0095A0  2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
0095A2  2  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
0095A5  2  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
0095A7  2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
0095A9  2  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
0095AC  2  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
0095AE  2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
0095B0  2  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
0095B3  2  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
0095B5  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
0095B7  2               
0095B7  2               ; do ABS and normalise FAC1
0095B7  2               
0095B7  2               LAB_24D0
0095B7  2  B0 03              BCS   LAB_24D5          ; branch if number is +ve
0095B9  2               
0095B9  2  20 1E 96           JSR   LAB_2537          ; negate FAC1
0095BC  2               
0095BC  2               ; normalise FAC1
0095BC  2               
0095BC  2               LAB_24D5
0095BC  2  A9 00              LDA   #$00              ; clear A
0095BE  2  A8                 TAY                     ; clear Y
0095BF  2  18                 CLC                     ; clear carry for add
0095C0  2               LAB_24D9
0095C0  2  A6 5F              LDX   FAC1_1            ; get FAC1 mantissa1
0095C2  2  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
0095C4  2               
0095C4  2  A6 60              LDX   FAC1_2            ; get FAC1 mantissa2
0095C6  2  86 5F              STX   FAC1_1            ; save FAC1 mantissa1
0095C8  2  A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
0095CA  2  86 60              STX   FAC1_2            ; save FAC1 mantissa2
0095CC  2  A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
0095CE  2  86 61              STX   FAC1_3            ; save FAC1 mantissa3
0095D0  2  84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
0095D2  2  69 08              ADC   #$08              ; add x to exponent offset
0095D4  2  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
0095D6  2  D0 E8              BNE   LAB_24D9          ; loop if not max
0095D8  2               
0095D8  2               ; clear FAC1 exponent and sign
0095D8  2               
0095D8  2               LAB_24F1
0095D8  2  A9 00              LDA   #$00              ; clear A
0095DA  2               LAB_24F3
0095DA  2  85 5E              STA   FAC1_e            ; set FAC1 exponent
0095DC  2               
0095DC  2               ; save FAC1 sign
0095DC  2               
0095DC  2               LAB_24F5
0095DC  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
0095DE  2  60                 RTS
0095DF  2               
0095DF  2               ; add FAC2 mantissa to FAC1 mantissa
0095DF  2               
0095DF  2               LAB_24F8
0095DF  2  65 55              ADC   FAC2_r            ; add FAC2 rounding byte
0095E1  2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
0095E3  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
0095E5  2  65 68              ADC   FAC2_3            ; add FAC2 mantissa3
0095E7  2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
0095E9  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
0095EB  2  65 67              ADC   FAC2_2            ; add FAC2 mantissa2
0095ED  2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
0095EF  2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
0095F1  2  65 66              ADC   FAC2_1            ; add FAC2 mantissa1
0095F3  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
0095F5  2  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
0095F7  2  60                 RTS                     ; else just exit
0095F8  2               
0095F8  2               LAB_2511
0095F8  2  69 01              ADC   #$01              ; add 1 to exponent offset
0095FA  2  06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
0095FC  2  26 61              ROL   FAC1_3            ; shift FAC1 mantissa3
0095FE  2  26 60              ROL   FAC1_2            ; shift FAC1 mantissa2
009600  2  26 5F              ROL   FAC1_1            ; shift FAC1 mantissa1
009602  2               
009602  2               ; normalise FAC1
009602  2               
009602  2               LAB_251B
009602  2  10 F4              BPL   LAB_2511          ; loop if not normalised
009604  2               
009604  2  38                 SEC                     ; set carry for subtract
009605  2  E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
009607  2  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
009609  2               
009609  2  49 FF              EOR   #$FF              ; complement exponent
00960B  2  69 01              ADC   #$01              ; +1 (twos complement)
00960D  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
00960F  2               
00960F  2               ; test and normalise FAC1 for C=0/1
00960F  2               
00960F  2               LAB_2528
00960F  2  90 0C              BCC   LAB_2536          ; exit if no overflow
009611  2               
009611  2               ; normalise FAC1 for C=1
009611  2               
009611  2               LAB_252A
009611  2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent
009613  2  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
009615  2               
009615  2  66 5F              ROR   FAC1_1            ; shift FAC1 mantissa1
009617  2  66 60              ROR   FAC1_2            ; shift FAC1 mantissa2
009619  2  66 61              ROR   FAC1_3            ; shift FAC1 mantissa3
00961B  2  66 6B              ROR   FAC1_r            ; shift FAC1 rounding byte
00961D  2               LAB_2536
00961D  2  60                 RTS
00961E  2               
00961E  2               ; negate FAC1
00961E  2               
00961E  2               LAB_2537
00961E  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009620  2  49 FF              EOR   #$FF              ; complement it
009622  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
009624  2               
009624  2               ; twos complement FAC1 mantissa
009624  2               
009624  2               LAB_253D
009624  2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
009626  2  49 FF              EOR   #$FF              ; complement it
009628  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
00962A  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
00962C  2  49 FF              EOR   #$FF              ; complement it
00962E  2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
009630  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
009632  2  49 FF              EOR   #$FF              ; complement it
009634  2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
009636  2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
009638  2  49 FF              EOR   #$FF              ; complement it
00963A  2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
00963C  2  E6 6B              INC   FAC1_r            ; increment FAC1 rounding byte
00963E  2  D0 0A              BNE   LAB_2563          ; exit if no overflow
009640  2               
009640  2               ; increment FAC1 mantissa
009640  2               
009640  2               LAB_2559
009640  2  E6 61              INC   FAC1_3            ; increment FAC1 mantissa3
009642  2  D0 06              BNE   LAB_2563          ; finished if no rollover
009644  2               
009644  2  E6 60              INC   FAC1_2            ; increment FAC1 mantissa2
009646  2  D0 02              BNE   LAB_2563          ; finished if no rollover
009648  2               
009648  2  E6 5F              INC   FAC1_1            ; increment FAC1 mantissa1
00964A  2               LAB_2563
00964A  2  60                 RTS
00964B  2               
00964B  2               ; do overflow error (overflow exit)
00964B  2               
00964B  2               LAB_2564
00964B  2  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
00964D  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
009650  2               
009650  2               ; shift FCAtemp << A+8 times
009650  2               
009650  2               LAB_2569
009650  2  A2 26              LDX   #FACt_1-1         ; set offset to FACtemp
009652  2               LAB_256B
009652  2  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
009654  2  84 6B              STY   FAC1_r            ; save as FAC1 rounding byte
009656  2  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
009658  2  94 03              STY   PLUS_3,X          ; save FACX mantissa3
00965A  2  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
00965C  2  94 02              STY   PLUS_2,X          ; save FACX mantissa2
00965E  2  A4 64              LDY   FAC1_o            ; get FAC1 overflow byte
009660  2  94 01              STY   PLUS_1,X          ; save FACX mantissa1
009662  2               
009662  2               ; shift FACX -A times right (> 8 shifts)
009662  2               
009662  2               LAB_257B
009662  2  69 08              ADC   #$08              ; add 8 to shift count
009664  2  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
009666  2               
009666  2  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
009668  2               
009668  2  E9 08              SBC   #$08              ; else subtract 8 again
00966A  2  A8                 TAY                     ; save count to Y
00966B  2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
00966D  2  B0 12              BCS   LAB_259A          ;
00966F  2               
00966F  2               LAB_2588
00966F  2  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
009671  2  90 02              BCC   LAB_258E          ; branch if +ve
009673  2               
009673  2  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
009675  2               LAB_258E
009675  2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
009677  2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
009679  2               
009679  2               ; shift FACX Y times right
009679  2               
009679  2               LAB_2592
009679  2  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
00967B  2  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
00967D  2  6A                 ROR                     ; shift FACX rounding byte
00967E  2  C8                 INY                     ; increment exponent diff
00967F  2  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
009681  2               
009681  2               LAB_259A
009681  2  18                 CLC                     ; just clear it
009682  2  60                 RTS
009683  2               
009683  2               ; perform LOG()
009683  2               
009683  2               LAB_LOG
009683  2  20 6E 98           JSR   LAB_27CA          ; test sign and zero
009686  2  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
009688  2               
009688  2  10 03              BPL   LAB_25C7          ; skip error if +ve
00968A  2               
00968A  2               LAB_25C4
00968A  2  4C C8 8E           JMP   LAB_FCER          ; do function call error then warm start (-ve)
00968D  2               
00968D  2               LAB_25C7
00968D  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
00968F  2  E9 7F              SBC   #$7F              ; normalise it
009691  2  48                 PHA                     ; save it
009692  2  A9 80              LDA   #$80              ; set exponent to zero
009694  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
009696  2  A9 F9              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
009698  2  A0 A0              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
00969A  2  20 4A 95           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
00969D  2  A9 FD              LDA   #<LAB_25B1        ; set root2 pointer low byte
00969F  2  A0 A0              LDY   #>LAB_25B1        ; set root2 pointer high byte
0096A1  2  20 87 97           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
0096A4  2  A9 70              LDA   #<LAB_259C        ; set 1 pointer low byte
0096A6  2  A0 A1              LDY   #>LAB_259C        ; set 1 pointer high byte
0096A8  2  20 30 95           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
0096AB  2  A9 EC              LDA   #<LAB_25A0        ; set pointer low byte to counter
0096AD  2  A0 A0              LDY   #>LAB_25A0        ; set pointer high byte to counter
0096AF  2  20 C8 9B           JSR   LAB_2B6E          ; ^2 then series evaluation
0096B2  2  A9 01              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
0096B4  2  A0 A1              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
0096B6  2  20 4A 95           JSR   LAB_246C          ; add (AY) to FAC1
0096B9  2  68                 PLA                     ; restore FAC1 exponent
0096BA  2  20 C1 99           JSR   LAB_2912          ; evaluate new ASCII digit
0096BD  2  A9 05              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
0096BF  2  A0 A1              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
0096C1  2               
0096C1  2               ; do convert AY, FCA1*(AY)
0096C1  2               
0096C1  2               LAB_25FB
0096C1  2  20 11 97           JSR   LAB_264D          ; unpack memory (AY) into FAC2
0096C4  2               LAB_MULTIPLY
0096C4  2  F0 4A              BEQ   LAB_264C          ; exit if zero
0096C6  2               
0096C6  2  20 37 97           JSR   LAB_2673          ; test and adjust accumulators
0096C9  2  64 27              STZ   FACt_1            ; clear temp mantissa1
0096CB  2  64 28              STZ   FACt_2            ; clear temp mantissa2
0096CD  2  64 29              STZ   FACt_3            ; clear temp mantissa3
0096CF  2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
0096D1  2  20 E6 96           JSR   LAB_2622          ; go do shift/add FAC2
0096D4  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
0096D6  2  20 E6 96           JSR   LAB_2622          ; go do shift/add FAC2
0096D9  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
0096DB  2  20 E6 96           JSR   LAB_2622          ; go do shift/add FAC2
0096DE  2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
0096E0  2  20 EC 96           JSR   LAB_2627          ; go do shift/add FAC2
0096E3  2  4C F3 97           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
0096E6  2               
0096E6  2               LAB_2622
0096E6  2  D0 04              BNE   LAB_2627          ; branch if byte <> zero
0096E8  2                                             ; patch 2.22p5
0096E8  2  38                 SEC
0096E9  2  4C 50 96           JMP   LAB_2569          ; shift FACtemp << A+8 times
0096EC  2                                             ; else do shift and add
0096EC  2               LAB_2627
0096EC  2  38                 SEC                     ; set top bit (mark for 8 times)
0096ED  2  6A                 ROR
0096EE  2               
0096EE  2               LAB_262A
0096EE  2  A8                 TAY                     ; copy result
0096EF  2  90 13              BCC   LAB_2640          ; skip next if bit was zero
0096F1  2               
0096F1  2  18                 CLC                     ; clear carry for add
0096F2  2  A5 29              LDA   FACt_3            ; get temp mantissa3
0096F4  2  65 68              ADC   FAC2_3            ; add FAC2 mantissa3
0096F6  2  85 29              STA   FACt_3            ; save temp mantissa3
0096F8  2  A5 28              LDA   FACt_2            ; get temp mantissa2
0096FA  2  65 67              ADC   FAC2_2            ; add FAC2 mantissa2
0096FC  2  85 28              STA   FACt_2            ; save temp mantissa2
0096FE  2  A5 27              LDA   FACt_1            ; get temp mantissa1
009700  2  65 66              ADC   FAC2_1            ; add FAC2 mantissa1
009702  2  85 27              STA   FACt_1            ; save temp mantissa1
009704  2               LAB_2640
009704  2  66 27              ROR   FACt_1            ; shift temp mantissa1
009706  2  66 28              ROR   FACt_2            ; shift temp mantissa2
009708  2  66 29              ROR   FACt_3            ; shift temp mantissa3
00970A  2  66 6B              ROR   FAC1_r            ; shift temp rounding byte
00970C  2  98                 TYA                     ; get byte back
00970D  2  4A                 LSR                     ; shift byte
00970E  2  D0 DE              BNE   LAB_262A          ; loop if all bits not done
009710  2               
009710  2               LAB_264C
009710  2  60                 RTS
009711  2               
009711  2               ; unpack memory (AY) into FAC2
009711  2               
009711  2               LAB_264D
009711  2  85 23              STA   ut1_pl            ; save pointer low byte
009713  2  84 24              STY   ut1_ph            ; save pointer high byte
009715  2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
009717  2  B1 23              LDA   (ut1_pl),Y        ; get mantissa3
009719  2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
00971B  2  88                 DEY                     ; decrement index
00971C  2  B1 23              LDA   (ut1_pl),Y        ; get mantissa2
00971E  2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
009720  2  88                 DEY                     ; decrement index
009721  2  B1 23              LDA   (ut1_pl),Y        ; get mantissa1+sign
009723  2  85 69              STA   FAC2_s            ; save FAC2 sign (b7)
009725  2  45 62              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
009727  2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009729  2  A5 69              LDA   FAC2_s            ; recover FAC2 sign (b7)
00972B  2  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
00972D  2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
00972F  2  88                 DEY                     ; decrement index
009730  2  B1 23              LDA   (ut1_pl),Y        ; get exponent byte
009732  2  85 65              STA   FAC2_e            ; save FAC2 exponent
009734  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009736  2  60                 RTS
009737  2               
009737  2               ; test and adjust accumulators
009737  2               
009737  2               LAB_2673
009737  2  A5 65              LDA   FAC2_e            ; get FAC2 exponent
009739  2               LAB_2675
009739  2  F0 1E              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
00973B  2               
00973B  2  18                 CLC                     ; clear carry for add
00973C  2  65 5E              ADC   FAC1_e            ; add FAC1 exponent
00973E  2  90 05              BCC   LAB_2680          ; branch if sum of exponents <$0100
009740  2               
009740  2  30 32              BMI   LAB_269B          ; do overflow error
009742  2               
009742  2  18                 CLC                     ; clear carry for the add
009743  2  80 02              BRA   LAB_2680b         ; branch around next instruction, saves one clock cycle
009745  2               LAB_2680
009745  2  10 12              BPL   LAB_2696          ; if +ve go handle underflow
009747  2               LAB_2680b
009747  2  69 80              ADC   #$80              ; adjust exponent
009749  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
00974B  2  D0 03              BNE   LAB_268B          ; branch if not zero
00974D  2               
00974D  2  4C DC 95           JMP   LAB_24F5          ; save FAC1 sign and return
009750  2               
009750  2               LAB_268B
009750  2  A5 6A              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
009752  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
009754  2               LAB_268F
009754  2  60                 RTS
009755  2               
009755  2               ; handle overflow and underflow
009755  2               
009755  2               LAB_2690
009755  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009757  2  10 1B              BPL   LAB_269B          ; do overflow error
009759  2               
009759  2                                             ; handle underflow
009759  2               LAB_2696
009759  2  68                 PLA                     ; pop return address low byte
00975A  2  68                 PLA                     ; pop return address high byte
00975B  2  4C D8 95           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
00975E  2               
00975E  2               ; multiply by 10
00975E  2               
00975E  2               LAB_269E
00975E  2  20 4F 98           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009761  2  AA                 TAX                     ; copy exponent (set the flags)
009762  2  F0 F0              BEQ   LAB_268F          ; exit if zero
009764  2               
009764  2  18                 CLC                     ; clear carry for add
009765  2  69 02              ADC   #$02              ; add two to exponent (*4)
009767  2  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
009769  2               
009769  2  A2 00              LDX   #$00              ; clear byte
00976B  2  86 6A              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00976D  2  20 67 95           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
009770  2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*10)
009772  2  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
009774  2               
009774  2               LAB_269B
009774  2  4C 4B 96           JMP   LAB_2564          ; do overflow error and warm start
009777  2               
009777  2               ; divide by 10
009777  2               
009777  2               LAB_26B9
009777  2  20 4F 98           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00977A  2  A9 81              LDA   #<LAB_26B5        ; set pointer to 10d low addr
00977C  2  A0 A1              LDY   #>LAB_26B5        ; set pointer to 10d high addr
00977E  2  A2 00              LDX   #$00              ; clear sign
009780  2               
009780  2               ; divide by (AY) (X=sign)
009780  2               
009780  2               LAB_26C2
009780  2  86 6A              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009782  2  20 02 98           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
009785  2  80 03              BRA   LAB_DIVIDE        ; do FAC2/FAC1
009787  2               
009787  2                                             ; Perform divide-by
009787  2               ; convert AY and do (AY)/FAC1
009787  2               
009787  2               LAB_26CA
009787  2  20 11 97           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00978A  2               
00978A  2                                             ; Perform divide-into
00978A  2               LAB_DIVIDE
00978A  2  F0 62              BEQ   LAB_2737          ; if zero go do /0 error
00978C  2               
00978C  2  20 5E 98           JSR   LAB_27BA          ; round FAC1
00978F  2  A9 00              LDA   #$00              ; clear A
009791  2  38                 SEC                     ; set carry for subtract
009792  2  E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
009794  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
009796  2  20 37 97           JSR   LAB_2673          ; test and adjust accumulators
009799  2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent
00979B  2  F0 D7              BEQ   LAB_269B          ; if zero do overflow error
00979D  2               
00979D  2  A2 FF              LDX   #$FF              ; set index for pre increment
00979F  2  A9 01              LDA   #$01              ; set bit to flag byte save
0097A1  2               LAB_26E4
0097A1  2  A4 66              LDY   FAC2_1            ; get FAC2 mantissa1
0097A3  2  C4 5F              CPY   FAC1_1            ; compare FAC1 mantissa1
0097A5  2  D0 0A              BNE   LAB_26F4          ; branch if <>
0097A7  2               
0097A7  2  A4 67              LDY   FAC2_2            ; get FAC2 mantissa2
0097A9  2  C4 60              CPY   FAC1_2            ; compare FAC1 mantissa2
0097AB  2  D0 04              BNE   LAB_26F4          ; branch if <>
0097AD  2               
0097AD  2  A4 68              LDY   FAC2_3            ; get FAC2 mantissa3
0097AF  2  C4 61              CPY   FAC1_3            ; compare FAC1 mantissa3
0097B1  2               LAB_26F4
0097B1  2  08                 PHP                     ; save FAC2-FAC1 compare status
0097B2  2  2A                 ROL                     ; shift the result byte
0097B3  2  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
0097B5  2               
0097B5  2  A0 01              LDY   #$01              ; set bit to flag byte save
0097B7  2  E8                 INX                     ; else increment the index to FACt
0097B8  2  E0 02              CPX   #$02              ; compare with the index to FACt_3
0097BA  2  30 04              BMI   LAB_2701          ; if not last byte just go save it
0097BC  2               
0097BC  2  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
0097BE  2                                             ; return
0097BE  2               
0097BE  2  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
0097C0  2               LAB_2701
0097C0  2  95 27              STA   FACt_1,X          ; write result byte to FACt_1 + index
0097C2  2  98                 TYA                     ; copy the next save byte flag
0097C3  2               LAB_2702
0097C3  2  28                 PLP                     ; restore FAC2-FAC1 compare status
0097C4  2  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
0097C6  2               
0097C6  2  A8                 TAY                     ; save FAC2-FAC1 compare status
0097C7  2  A5 68              LDA   FAC2_3            ; get FAC2 mantissa3
0097C9  2  E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
0097CB  2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
0097CD  2  A5 67              LDA   FAC2_2            ; get FAC2 mantissa2
0097CF  2  E5 60              SBC   FAC1_2            ; subtract FAC1 mantissa2
0097D1  2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
0097D3  2  A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
0097D5  2  E5 5F              SBC   FAC1_1            ; subtract FAC1 mantissa1
0097D7  2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
0097D9  2  98                 TYA                     ; restore FAC2-FAC1 compare status
0097DA  2               
0097DA  2                                             ; FAC2 = FAC2*2
0097DA  2               LAB_2704
0097DA  2  06 68              ASL   FAC2_3            ; shift FAC2 mantissa3
0097DC  2  26 67              ROL   FAC2_2            ; shift FAC2 mantissa2
0097DE  2  26 66              ROL   FAC2_1            ; shift FAC2 mantissa1
0097E0  2  B0 CF              BCS   LAB_26F4          ; loop with no compare
0097E2  2               
0097E2  2  30 BD              BMI   LAB_26E4          ; loop with compare
0097E4  2  80 CB              BRA   LAB_26F4          ; loop always with no compare
0097E6  2               
0097E6  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
0097E6  2               
0097E6  2               LAB_272B
0097E6  2  4A                 LSR                     ; shift b1 - b0 ..
0097E7  2  6A                 ROR                     ; ..
0097E8  2  6A                 ROR                     ; .. to b7 - b6
0097E9  2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
0097EB  2  28                 PLP                     ; dump FAC2-FAC1 compare status
0097EC  2  80 05              BRA   LAB_273C          ; copy temp to FAC1, normalise and return
0097EE  2               
0097EE  2               ; do "Divide by zero" error
0097EE  2               
0097EE  2               LAB_2737
0097EE  2  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
0097F0  2  4C 01 81           JMP   LAB_XERR          ; do error #X, then warm start
0097F3  2               
0097F3  2               ; copy temp to FAC1 and normalise
0097F3  2               
0097F3  2               LAB_273C
0097F3  2  A5 27              LDA   FACt_1            ; get temp mantissa1
0097F5  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
0097F7  2  A5 28              LDA   FACt_2            ; get temp mantissa2
0097F9  2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
0097FB  2  A5 29              LDA   FACt_3            ; get temp mantissa3
0097FD  2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
0097FF  2  4C BC 95           JMP   LAB_24D5          ; normalise FAC1 and return
009802  2               
009802  2               ; unpack memory (AY) into FAC1
009802  2               
009802  2               LAB_UFAC
009802  2  85 23              STA   ut1_pl            ; save pointer low byte
009804  2  84 24              STY   ut1_ph            ; save pointer high byte
009806  2  A0 03              LDY   #$03              ; 4 bytes to do
009808  2  B1 23              LDA   (ut1_pl),Y        ; get last byte
00980A  2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
00980C  2  88                 DEY                     ; decrement index
00980D  2  B1 23              LDA   (ut1_pl),Y        ; get last-1 byte
00980F  2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
009811  2  88                 DEY                     ; decrement index
009812  2  B1 23              LDA   (ut1_pl),Y        ; get second byte
009814  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
009816  2  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
009818  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
00981A  2  88                 DEY                     ; decrement index
00981B  2  B1 23              LDA   (ut1_pl),Y        ; get first byte (exponent)
00981D  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
00981F  2  84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
009821  2  60                 RTS
009822  2               
009822  2               ; pack FAC1 into Adatal
009822  2               
009822  2               LAB_276E
009822  2  A2 56              LDX   #<Adatal          ; set pointer low byte
009824  2               LAB_2770
009824  2  A0 00              LDY   #>Adatal          ; set pointer high byte
009826  2  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
009828  2               
009828  2               ; pack FAC1 into (Lvarpl)
009828  2               
009828  2               LAB_PFAC
009828  2  A6 49              LDX   Lvarpl            ; get destination pointer low byte
00982A  2  A4 4A              LDY   Lvarph            ; get destination pointer high byte
00982C  2               
00982C  2               ; pack FAC1 into (XY)
00982C  2               
00982C  2               LAB_2778
00982C  2  20 5E 98           JSR   LAB_27BA          ; round FAC1
00982F  2  86 23              STX   ut1_pl            ; save pointer low byte
009831  2  84 24              STY   ut1_ph            ; save pointer high byte
009833  2  A0 03              LDY   #$03              ; set index
009835  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
009837  2  91 23              STA   (ut1_pl),Y        ; store in destination
009839  2  88                 DEY                     ; decrement index
00983A  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
00983C  2  91 23              STA   (ut1_pl),Y        ; store in destination
00983E  2  88                 DEY                     ; decrement index
00983F  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009841  2  09 7F              ORA   #$7F              ; set bits x111 1111
009843  2  25 5F              AND   FAC1_1            ; AND in FAC1 mantissa1
009845  2  91 23              STA   (ut1_pl),Y        ; store in destination
009847  2  88                 DEY                     ; decrement index
009848  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
00984A  2  91 23              STA   (ut1_pl),Y        ; store in destination
00984C  2  84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
00984E  2  60                 RTS
00984F  2               
00984F  2               ; round and copy FAC1 to FAC2
00984F  2               
00984F  2               LAB_27AB
00984F  2  20 5E 98           JSR   LAB_27BA          ; round FAC1
009852  2               
009852  2               ; copy FAC1 to FAC2
009852  2               
009852  2               LAB_27AE
009852  2  A2 05              LDX   #$05              ; 5 bytes to copy
009854  2               LAB_27B0
009854  2  B5 5D              LDA   FAC1_e-1,X        ; get byte from FAC1,X
009856  2  95 64              STA   FAC1_o,X          ; save byte at FAC2,X
009858  2  CA                 DEX                     ; decrement count
009859  2  D0 F9              BNE   LAB_27B0          ; loop if not all done
00985B  2               
00985B  2  86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
00985D  2               LAB_27B9
00985D  2  60                 RTS
00985E  2               
00985E  2               ; round FAC1
00985E  2               
00985E  2               LAB_27BA
00985E  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009860  2  F0 FB              BEQ   LAB_27B9          ; exit if zero
009862  2               
009862  2  06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
009864  2  90 F7              BCC   LAB_27B9          ; exit if no overflow
009866  2               
009866  2               ; round FAC1 (no check)
009866  2               
009866  2               LAB_27C2
009866  2  20 40 96           JSR   LAB_2559          ; increment FAC1 mantissa
009869  2  D0 F2              BNE   LAB_27B9          ; branch if no overflow
00986B  2               
00986B  2  4C 11 96           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
00986E  2               
00986E  2               ; get FAC1 sign
00986E  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00986E  2               
00986E  2               LAB_27CA
00986E  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009870  2  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
009872  2               
009872  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
009872  2               ; no = 0 check
009872  2               
009872  2               LAB_27CE
009872  2  A5 62              LDA   FAC1_s            ; else get FAC1 sign (b7)
009874  2               
009874  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
009874  2               ; no = 0 check, sign in A
009874  2               
009874  2               LAB_27D0
009874  2  2A                 ROL                     ; move sign bit to carry
009875  2  A9 FF              LDA   #$FF              ; set byte for -ve result
009877  2  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
009879  2               
009879  2  A9 01              LDA   #$01              ; else set byte for +ve result
00987B  2               LAB_27D7
00987B  2  60                 RTS
00987C  2               
00987C  2               ; perform SGN()
00987C  2               
00987C  2               LAB_SGN
00987C  2  20 6E 98           JSR   LAB_27CA          ; get FAC1 sign
00987F  2                                             ; return A=$FF/-ve A=$01/+ve
00987F  2               ; save A as integer byte
00987F  2               
00987F  2               LAB_27DB
00987F  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
009881  2  64 60              STZ   FAC1_2            ; clear FAC1 mantissa2
009883  2  A2 88              LDX   #$88              ; set exponent
009885  2               
009885  2               ; set exp=X, clearFAC1 mantissa3 and normalise
009885  2               
009885  2               LAB_27E3
009885  2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
009887  2  49 FF              EOR   #$FF              ; complement it
009889  2  2A                 ROL                     ; sign bit into carry
00988A  2               
00988A  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00988A  2               
00988A  2               LAB_STFA
00988A  2  64 61              STZ   FAC1_3            ; clear FAC1 mantissa3
00988C  2  86 5E              STX   FAC1_e            ; set FAC1 exponent
00988E  2  64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
009890  2  64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
009892  2  4C B7 95           JMP   LAB_24D0          ; do ABS and normalise FAC1
009895  2               
009895  2               ; perform ABS()
009895  2               
009895  2               LAB_ABS
009895  2  46 62              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
009897  2  60                 RTS
009898  2               
009898  2               ; compare FAC1 with (AY)
009898  2               ; returns A=$00 if FAC1 = (AY)
009898  2               ; returns A=$01 if FAC1 > (AY)
009898  2               ; returns A=$FF if FAC1 < (AY)
009898  2               
009898  2               LAB_27F8
009898  2  85 25              STA   ut2_pl            ; save pointer low byte
00989A  2               LAB_27FA
00989A  2  84 26              STY   ut2_ph            ; save pointer high byte
00989C  2  A0 00              LDY   #$00              ; clear index
00989E  2  B1 25              LDA   (ut2_pl),Y        ; get exponent
0098A0  2  C8                 INY                     ; increment index
0098A1  2  AA                 TAX                     ; copy (AY) exponent to X
0098A2  2  F0 CA              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
0098A4  2                                             ; A=FF,C=1/-ve A=01,C=0/+ve
0098A4  2               
0098A4  2  B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
0098A6  2  45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
0098A8  2  30 C8              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
0098AA  2                                             ; A=01,C=0/+ve and return
0098AA  2               
0098AA  2  E4 5E              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
0098AC  2  D0 1A              BNE   LAB_2828          ; branch if different
0098AE  2               
0098AE  2  B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
0098B0  2  09 80              ORA   #$80              ; normalise top bit
0098B2  2  C5 5F              CMP   FAC1_1            ; compare with FAC1 mantissa1
0098B4  2  D0 12              BNE   LAB_2828          ; branch if different
0098B6  2               
0098B6  2  C8                 INY                     ; increment index
0098B7  2  B1 25              LDA   (ut2_pl),Y        ; get mantissa2
0098B9  2  C5 60              CMP   FAC1_2            ; compare with FAC1 mantissa2
0098BB  2  D0 0B              BNE   LAB_2828          ; branch if different
0098BD  2               
0098BD  2  C8                 INY                     ; increment index
0098BE  2  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
0098C0  2  C5 6B              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
0098C2  2  B1 25              LDA   (ut2_pl),Y        ; get mantissa3
0098C4  2  E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
0098C6  2  F0 27              BEQ   LAB_2850          ; exit if mantissa3 equal
0098C8  2               
0098C8  2               ; gets here if number <> FAC1
0098C8  2               
0098C8  2               LAB_2828
0098C8  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
0098CA  2  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
0098CC  2               
0098CC  2  49 FF              EOR   #$FF              ; else toggle FAC1 sign
0098CE  2               LAB_282E
0098CE  2  80 A4              BRA   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
0098D0  2               
0098D0  2               ; convert FAC1 floating-to-fixed
0098D0  2               
0098D0  2               LAB_2831
0098D0  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
0098D2  2  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
0098D4  2               
0098D4  2  38                 SEC                     ; set carry for subtract
0098D5  2  E9 98              SBC   #$98              ; subtract maximum integer range exponent
0098D7  2  24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
0098D9  2  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
0098DB  2               
0098DB  2                                             ; FAC1 was -ve
0098DB  2  AA                 TAX                     ; copy subtracted exponent
0098DC  2  A9 FF              LDA   #$FF              ; overflow for -ve number
0098DE  2  85 64              STA   FAC1_o            ; set FAC1 overflow byte
0098E0  2  20 24 96           JSR   LAB_253D          ; twos complement FAC1 mantissa
0098E3  2  8A                 TXA                     ; restore subtracted exponent
0098E4  2               LAB_2845
0098E4  2  A2 5E              LDX   #FAC1_e           ; set index to FAC1
0098E6  2  C9 F9              CMP   #$F9              ; compare exponent result
0098E8  2  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
0098EA  2               
0098EA  2  20 62 96           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
0098ED  2  84 64              STY   FAC1_o            ; clear FAC1 overflow byte
0098EF  2               LAB_2850
0098EF  2  60                 RTS
0098F0  2               
0098F0  2               ; shift FAC1 A times right
0098F0  2               
0098F0  2               LAB_2851
0098F0  2  A8                 TAY                     ; copy shift count
0098F1  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
0098F3  2  29 80              AND   #$80              ; mask sign bit only (x000 0000)
0098F5  2  46 5F              LSR   FAC1_1            ; shift FAC1 mantissa1
0098F7  2  05 5F              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
0098F9  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
0098FB  2  20 79 96           JSR   LAB_2592          ; shift FAC1 Y times right
0098FE  2  84 64              STY   FAC1_o            ; clear FAC1 overflow byte
009900  2  60                 RTS
009901  2               
009901  2               ; perform INT()
009901  2               
009901  2               LAB_INT
009901  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009903  2  C9 98              CMP   #$98              ; compare with max int
009905  2  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
009907  2               
009907  2  20 D0 98           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00990A  2  84 6B              STY   FAC1_r            ; save FAC1 rounding byte
00990C  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
00990E  2  84 62              STY   FAC1_s            ; save FAC1 sign (b7)
009910  2  49 80              EOR   #$80              ; toggle FAC1 sign
009912  2  2A                 ROL                     ; shift into carry
009913  2  A9 98              LDA   #$98              ; set new exponent
009915  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
009917  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
009919  2  85 0D              STA   Temp3             ; save for EXP() function
00991B  2  4C B7 95           JMP   LAB_24D0          ; do ABS and normalise FAC1
00991E  2               
00991E  2               ; clear FAC1 and return
00991E  2               
00991E  2               LAB_287F
00991E  2  85 5F              STA   FAC1_1            ; clear FAC1 mantissa1
009920  2  85 60              STA   FAC1_2            ; clear FAC1 mantissa2
009922  2  85 61              STA   FAC1_3            ; clear FAC1 mantissa3
009924  2  A8                 TAY                     ; clear Y
009925  2               LAB_2886
009925  2  60                 RTS
009926  2               
009926  2               ; get FAC1 from string
009926  2               ; this routine now handles hex and binary values from strings
009926  2               ; starting with "$" and "%" respectively
009926  2               
009926  2               LAB_2887
009926  2  64 11              STZ   Dtypef            ; clear data type flag, $FF=string, $00=numeric
009928  2  A2 09              LDX   #$09              ; set index
00992A  2               LAB_288B
00992A  2  74 5A              STZ   numexp,X          ; clear byte
00992C  2  CA                 DEX                     ; decrement index
00992D  2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
00992F  2  90 7E              BCC   LAB_28FE          ; branch if 1st character numeric
009931  2               
009931  2               ; get FAC1 from string .. first character wasn't numeric
009931  2               
009931  2  C9 2D              CMP   #'-'              ; else compare with "-"
009933  2  D0 04              BNE   LAB_289A          ; branch if not "-"
009935  2               
009935  2  86 63              STX   negnum            ; set flag for -ve number (X = $FF)
009937  2  80 04              BRA   LAB_289C          ; branch always (go scan and check for hex/bin)
009939  2               
009939  2               ; get FAC1 from string .. first character wasn't numeric or -
009939  2               
009939  2               LAB_289A
009939  2  C9 2B              CMP   #'+'              ; else compare with "+"
00993B  2  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
00993D  2               
00993D  2               ; was "+" or "-" to start, so get next character
00993D  2               
00993D  2               LAB_289C
00993D  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009940  2  90 6D              BCC   LAB_28FE          ; branch if numeric character
009942  2               
009942  2               ; code here for hex and binary numbers
009942  2               
009942  2               LAB_289D
009942  2  C9 24              CMP   #'$'              ; else compare with "$"
009944  2  D0 03              BNE   LAB_NHEX          ; branch if not "$"
009946  2               
009946  2  4C E0 9D           JMP   LAB_CHEX          ; branch if "$"
009949  2               
009949  2               LAB_NHEX
009949  2  C9 25              CMP   #'%'              ; else compare with "%"
00994B  2  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
00994D  2               
00994D  2  4C 0E 9E           JMP   LAB_CBIN          ; branch if "%"
009950  2               
009950  2               LAB_289E
009950  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
009953  2               LAB_28A1
009953  2  90 5A              BCC   LAB_28FE          ; branch if numeric character
009955  2               
009955  2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
009955  2               
009955  2               LAB_28A3
009955  2  C9 2E              CMP   #'.'              ; else compare with "."
009957  2  F0 2D              BEQ   LAB_28D5          ; branch if "."
009959  2               
009959  2               ; get FAC1 from string .. character wasn't numeric, -, + or .
009959  2               
009959  2  C9 45              CMP   #'E'              ; else compare with "E"
00995B  2  D0 2F              BNE   LAB_28DB          ; branch if not "E"
00995D  2               
00995D  2                                             ; was "E" so evaluate exponential part
00995D  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009960  2  90 17              BCC   LAB_28C7          ; branch if numeric character
009962  2               
009962  2  C9 B3              CMP   #TK_MINUS         ; else compare with token for -
009964  2  F0 0E              BEQ   LAB_28C2          ; branch if token for -
009966  2               
009966  2  C9 2D              CMP   #'-'              ; else compare with "-"
009968  2  F0 0A              BEQ   LAB_28C2          ; branch if "-"
00996A  2               
00996A  2  C9 B2              CMP   #TK_PLUS          ; else compare with token for +
00996C  2  F0 08              BEQ   LAB_28C4          ; branch if token for +
00996E  2               
00996E  2  C9 2B              CMP   #'+'              ; else compare with "+"
009970  2  F0 04              BEQ   LAB_28C4          ; branch if "+"
009972  2  80 07              BRA   LAB_28C9          ; branch always
009974  2               
009974  2               LAB_28C2
009974  2  66 5D              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
009976  2               LAB_28C4
009976  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009979  2               LAB_28C7
009979  2  90 59              BCC   LAB_2925          ; branch if numeric character
00997B  2               
00997B  2               LAB_28C9
00997B  2  24 5D              BIT   expneg            ; test exponent -ve flag
00997D  2  10 0D              BPL   LAB_28DB          ; if +ve go evaluate exponent
00997F  2               
00997F  2                                             ; else do exponent = -exponent
00997F  2  A9 00              LDA   #$00              ; clear result
009981  2  38                 SEC                     ; set carry for subtract
009982  2  E5 5B              SBC   expcnt            ; subtract exponent byte
009984  2  80 08              BRA   LAB_28DD          ; go evaluate exponent
009986  2               
009986  2               LAB_28D5
009986  2  66 5C              ROR   numdpf            ; set decimal point flag
009988  2  24 5C              BIT   numdpf            ; test decimal point flag
00998A  2  50 C4              BVC   LAB_289E          ; branch if only one decimal point so far
00998C  2               
00998C  2                                             ; evaluate exponent
00998C  2               LAB_28DB
00998C  2  A5 5B              LDA   expcnt            ; get exponent count byte
00998E  2               LAB_28DD
00998E  2  38                 SEC                     ; set carry for subtract
00998F  2  E5 5A              SBC   numexp            ; subtract numerator exponent
009991  2  85 5B              STA   expcnt            ; save exponent count byte
009993  2  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
009995  2  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
009997  2               
009997  2                                             ; else go do FAC1/10^(0-expcnt)
009997  2               LAB_28E6
009997  2  20 77 97           JSR   LAB_26B9          ; divide by 10
00999A  2  E6 5B              INC   expcnt            ; increment exponent count byte
00999C  2  D0 F9              BNE   LAB_28E6          ; loop until all done
00999E  2  80 07              BRA   LAB_28F6          ; branch always
0099A0  2               
0099A0  2               LAB_28EF
0099A0  2  20 5E 97           JSR   LAB_269E          ; multiply by 10
0099A3  2  C6 5B              DEC   expcnt            ; decrement exponent count byte
0099A5  2  D0 F9              BNE   LAB_28EF          ; loop until all done
0099A7  2               
0099A7  2               LAB_28F6
0099A7  2  A5 63              LDA   negnum            ; get -ve flag
0099A9  2  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
0099AB  2  60                 RTS
0099AC  2               
0099AC  2               ; do - FAC1 and return
0099AC  2               
0099AC  2               LAB_28FB
0099AC  2  4C 6D 9B           JMP   LAB_GTHAN         ; do - FAC1 and return
0099AF  2               
0099AF  2               ; do unsigned FAC1*10+number
0099AF  2               
0099AF  2               LAB_28FE
0099AF  2  48                 PHA                     ; save character
0099B0  2  24 5C              BIT   numdpf            ; test decimal point flag
0099B2  2  10 02              BPL   LAB_2905          ; skip exponent increment if not set
0099B4  2               
0099B4  2  E6 5A              INC   numexp            ; else increment number exponent
0099B6  2               LAB_2905
0099B6  2  20 5E 97           JSR   LAB_269E          ; multiply FAC1 by 10
0099B9  2  68                 PLA                     ; restore character
0099BA  2  29 0F              AND   #$0F              ; convert to binary
0099BC  2  20 C1 99           JSR   LAB_2912          ; evaluate new ASCII digit
0099BF  2  80 8F              BRA   LAB_289E          ; go do next character
0099C1  2               
0099C1  2               ; evaluate new ASCII digit
0099C1  2               
0099C1  2               LAB_2912
0099C1  2  48                 PHA                     ; save digit
0099C2  2  20 4F 98           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
0099C5  2  68                 PLA                     ; restore digit
0099C6  2  20 7F 98           JSR   LAB_27DB          ; save A as integer byte
0099C9  2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
0099CB  2  45 62              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
0099CD  2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
0099CF  2  A6 5E              LDX   FAC1_e            ; get FAC1 exponent
0099D1  2  4C 4D 95           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
0099D4  2               
0099D4  2               ; evaluate next character of exponential part of number
0099D4  2               
0099D4  2               LAB_2925
0099D4  2  A5 5B              LDA   expcnt            ; get exponent count byte
0099D6  2  C9 0A              CMP   #$0A              ; compare with 10 decimal
0099D8  2  90 09              BCC   LAB_2934          ; branch if less
0099DA  2               
0099DA  2  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
0099DC  2  24 5D              BIT   expneg            ; test exponent -ve flag
0099DE  2  30 0C              BMI   LAB_2942          ; branch if -ve
0099E0  2               
0099E0  2  4C 4B 96           JMP   LAB_2564          ; else do overflow error
0099E3  2               
0099E3  2               LAB_2934
0099E3  2  0A                 ASL                     ; * 2
0099E4  2  0A                 ASL                     ; * 4
0099E5  2  65 5B              ADC   expcnt            ; * 5
0099E7  2  0A                 ASL                     ; * 10
0099E8  2  72 6E              ADC   (Bpntrl)          ; add character (will be $30 too much!)
0099EA  2  E9 2F              SBC   #'0'-1            ; convert character to binary
0099EC  2               LAB_2942
0099EC  2  85 5B              STA   expcnt            ; save exponent count byte
0099EE  2  80 86              BRA   LAB_28C4          ; go get next character
0099F0  2               
0099F0  2               ; print " in line [LINE #]"
0099F0  2               
0099F0  2               LAB_2953
0099F0  2  A9 56              LDA   #<LAB_LMSG        ; point to " in line " message low byte
0099F2  2  A0 A7              LDY   #>LAB_LMSG        ; point to " in line " message high byte
0099F4  2  20 73 88           JSR   LAB_18C3          ; print null terminated string from memory
0099F7  2               
0099F7  2                                             ; print Basic line #
0099F7  2  A5 3A              LDA   Clineh            ; get current line high byte
0099F9  2  A6 39              LDX   Clinel            ; get current line low byte
0099FB  2               
0099FB  2               ; print XA as unsigned integer
0099FB  2               
0099FB  2               LAB_295E
0099FB  2  85 5F              STA   FAC1_1            ; save low byte as FAC1 mantissa1
0099FD  2  86 60              STX   FAC1_2            ; save high byte as FAC1 mantissa2
0099FF  2  A2 90              LDX   #$90              ; set exponent to 16d bits
009A01  2  38                 SEC                     ; set integer is +ve flag
009A02  2  20 8A 98           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
009A05  2  A0 00              LDY   #$00              ; clear index
009A07  2  98                 TYA                     ; clear A
009A08  2  20 1B 9A           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
009A0B  2  4C 73 88           JMP   LAB_18C3          ; print null terminated string from memory and return
009A0E  2               
009A0E  2               ; convert FAC1 to ASCII string result in (AY)
009A0E  2               ; not any more, moved scratchpad to page 0
009A0E  2               
009A0E  2               LAB_296E
009A0E  2  A0 01              LDY   #$01              ; set index = 1
009A10  2  A9 20              LDA   #$20              ; character = " " (assume +ve)
009A12  2  24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
009A14  2  10 02              BPL   LAB_2978          ; branch if +ve
009A16  2               
009A16  2  A9 2D              LDA   #$2D              ; else character = "-"
009A18  2               LAB_2978
009A18  2  99 74 00           STA   Decss,Y           ; save leading character (" " or "-")
009A1B  2               LAB_297B
009A1B  2  85 62              STA   FAC1_s            ; clear FAC1 sign (b7)
009A1D  2  84 6C              STY   Sendl             ; save index
009A1F  2  C8                 INY                     ; increment index
009A20  2  A6 5E              LDX   FAC1_e            ; get FAC1 exponent
009A22  2  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
009A24  2               
009A24  2                                             ; exponent was $00 so FAC1 is 0
009A24  2  A9 30              LDA   #'0'              ; set character = "0"
009A26  2  4C 27 9B           JMP   LAB_2A89          ; save last character, [EOT] and exit
009A29  2               
009A29  2                                             ; FAC1 is some non zero value
009A29  2               LAB_2989
009A29  2  A9 00              LDA   #$00              ; clear (number exponent count)
009A2B  2  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
009A2D  2               
009A2D  2  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
009A2F  2               
009A2F  2                                             ; FAC1<1
009A2F  2  A9 11              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
009A31  2  A0 A1              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
009A33  2  20 C1 96           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
009A36  2  A9 FA              LDA   #$FA              ; set number exponent count (-6)
009A38  2               LAB_299A
009A38  2  85 5A              STA   numexp            ; save number exponent count
009A3A  2               LAB_299C
009A3A  2  A9 0D              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
009A3C  2  A0 A1              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
009A3E  2  20 98 98           JSR   LAB_27F8          ; compare FAC1 with (AY)
009A41  2  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
009A43  2               
009A43  2  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
009A45  2               
009A45  2                                             ; FAC1 < (AY)
009A45  2               LAB_29A7
009A45  2  A9 09              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
009A47  2  A0 A1              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
009A49  2  20 98 98           JSR   LAB_27F8          ; compare FAC1 with (AY)
009A4C  2  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
009A4E  2  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
009A50  2               
009A50  2                                             ; FAC1 <= (AY)
009A50  2               LAB_29B2
009A50  2  20 5E 97           JSR   LAB_269E          ; multiply by 10
009A53  2  C6 5A              DEC   numexp            ; decrement number exponent count
009A55  2  80 EE              BRA   LAB_29A7          ; go test again (branch always)
009A57  2               
009A57  2               LAB_29B9
009A57  2  20 77 97           JSR   LAB_26B9          ; divide by 10
009A5A  2  E6 5A              INC   numexp            ; increment number exponent count
009A5C  2  80 DC              BRA   LAB_299C          ; go test again (branch always)
009A5E  2               
009A5E  2               ; now we have just the digits to do
009A5E  2               
009A5E  2               LAB_29C0
009A5E  2  20 46 95           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
009A61  2               LAB_29C3
009A61  2  20 D0 98           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
009A64  2  A2 01              LDX   #$01              ; set default digits before dp = 1
009A66  2  A5 5A              LDA   numexp            ; get number exponent count
009A68  2  18                 CLC                     ; clear carry for add
009A69  2  69 07              ADC   #$07              ; up to 6 digits before point
009A6B  2  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
009A6D  2               
009A6D  2  C9 08              CMP   #$08              ; A>=8 if n>=1E6
009A6F  2  B0 06              BCS   LAB_29D9          ; branch if >= $08
009A71  2               
009A71  2                                             ; carry is clear
009A71  2  69 FF              ADC   #$FF              ; take 1 from digit count
009A73  2  AA                 TAX                     ; copy to A
009A74  2  A9 02              LDA   #$02              ;.set exponent adjust
009A76  2               LAB_29D8
009A76  2  38                 SEC                     ; set carry for subtract
009A77  2               LAB_29D9
009A77  2  E9 02              SBC   #$02              ; -2
009A79  2  85 5B              STA   expcnt            ; save exponent adjust
009A7B  2  86 5A              STX   numexp            ; save digits before dp count
009A7D  2  8A                 TXA                     ; copy to A
009A7E  2  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
009A80  2  10 13              BPL   LAB_29F7          ; branch if digits before dp
009A82  2               
009A82  2               LAB_29E4
009A82  2  A4 6C              LDY   Sendl             ; get output string index
009A84  2  A9 2E              LDA   #$2E              ; character "."
009A86  2  C8                 INY                     ; increment index
009A87  2  99 74 00           STA   Decss,Y           ; save to output string
009A8A  2  8A                 TXA                     ;
009A8B  2  F0 06              BEQ   LAB_29F5          ;
009A8D  2               
009A8D  2  A9 30              LDA   #'0'              ; character "0"
009A8F  2  C8                 INY                     ; increment index
009A90  2  99 74 00           STA   Decss,Y           ; save to output string
009A93  2               LAB_29F5
009A93  2  84 6C              STY   Sendl             ; save output string index
009A95  2               LAB_29F7
009A95  2  A0 00              LDY   #$00              ; clear index (point to 100,000)
009A97  2  A2 80              LDX   #$80              ;
009A99  2               LAB_29FB
009A99  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
009A9B  2  18                 CLC                     ; clear carry for add
009A9C  2  79 87 A1           ADC   LAB_2A9C,Y        ; add -ve LSB
009A9F  2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
009AA1  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
009AA3  2  79 86 A1           ADC   LAB_2A9B,Y        ; add -ve NMSB
009AA6  2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
009AA8  2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
009AAA  2  79 85 A1           ADC   LAB_2A9A,Y        ; add -ve MSB
009AAD  2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
009AAF  2  E8                 INX                     ;
009AB0  2  B0 04              BCS   LAB_2A18          ;
009AB2  2               
009AB2  2  10 E5              BPL   LAB_29FB          ; not -ve so try again
009AB4  2               
009AB4  2  30 02              BMI   LAB_2A1A          ;
009AB6  2               
009AB6  2               LAB_2A18
009AB6  2  30 E1              BMI   LAB_29FB          ;
009AB8  2               
009AB8  2               LAB_2A1A
009AB8  2  8A                 TXA                     ;
009AB9  2  90 04              BCC   LAB_2A21          ;
009ABB  2               
009ABB  2  49 FF              EOR   #$FF              ;
009ABD  2  69 0A              ADC   #$0A              ;
009ABF  2               LAB_2A21
009ABF  2  69 2F              ADC   #'0'-1            ; add "0"-1 to result
009AC1  2  C8                 INY                     ; increment index ..
009AC2  2  C8                 INY                     ; .. to next less ..
009AC3  2  C8                 INY                     ; .. power of ten
009AC4  2  84 47              STY   Cvaral            ; save as current var address low byte
009AC6  2  A4 6C              LDY   Sendl             ; get output string index
009AC8  2  C8                 INY                     ; increment output string index
009AC9  2  AA                 TAX                     ; copy character to X
009ACA  2  29 7F              AND   #$7F              ; mask out top bit
009ACC  2  99 74 00           STA   Decss,Y           ; save to output string
009ACF  2  C6 5A              DEC   numexp            ; decrement # of characters before the dp
009AD1  2  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
009AD3  2               
009AD3  2                                             ; else output the point
009AD3  2  A9 2E              LDA   #$2E              ; character "."
009AD5  2  C8                 INY                     ; increment output string index
009AD6  2  99 74 00           STA   Decss,Y           ; save to output string
009AD9  2               LAB_2A3B
009AD9  2  84 6C              STY   Sendl             ; save output string index
009ADB  2  A4 47              LDY   Cvaral            ; get current var address low byte
009ADD  2  8A                 TXA                     ; get character back
009ADE  2  49 FF              EOR   #$FF              ;
009AE0  2  29 80              AND   #$80              ;
009AE2  2  AA                 TAX                     ;
009AE3  2  C0 12              CPY   #$12              ; compare index with max
009AE5  2  D0 B2              BNE   LAB_29FB          ; loop if not max
009AE7  2               
009AE7  2                                             ; now remove trailing zeroes
009AE7  2  A4 6C              LDY   Sendl             ; get output string index
009AE9  2               LAB_2A4B
009AE9  2  B9 74 00           LDA   Decss,Y           ; get character from output string
009AEC  2  88                 DEY                     ; decrement output string index
009AED  2  C9 30              CMP   #'0'              ; compare with "0"
009AEF  2  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
009AF1  2               
009AF1  2  C9 2E              CMP   #'.'              ; compare with "."
009AF3  2  F0 01              BEQ   LAB_2A58          ; branch if was dp
009AF5  2               
009AF5  2                                             ; restore last character
009AF5  2  C8                 INY                     ; increment output string index
009AF6  2               LAB_2A58
009AF6  2  A9 2B              LDA   #$2B              ; character "+"
009AF8  2  A6 5B              LDX   expcnt            ; get exponent count
009AFA  2  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
009AFC  2               
009AFC  2                                             ; exponent isn't zero so write exponent
009AFC  2  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
009AFE  2               
009AFE  2  A9 00              LDA   #$00              ; clear A
009B00  2  38                 SEC                     ; set carry for subtract
009B01  2  E5 5B              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
009B03  2  AA                 TAX                     ; copy exponent count to X
009B04  2  A9 2D              LDA   #'-'              ; character "-"
009B06  2               LAB_2A68
009B06  2  99 76 00           STA   Decss+2,Y         ; save to output string
009B09  2  A9 45              LDA   #$45              ; character "E"
009B0B  2  99 75 00           STA   Decss+1,Y         ; save exponent sign to output string
009B0E  2  8A                 TXA                     ; get exponent count back
009B0F  2  A2 2F              LDX   #'0'-1            ; one less than "0" character
009B11  2  38                 SEC                     ; set carry for subtract
009B12  2               LAB_2A74
009B12  2  E8                 INX                     ; increment 10's character
009B13  2  E9 0A              SBC   #$0A              ; subtract 10 from exponent count
009B15  2  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
009B17  2               
009B17  2  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
009B19  2  99 78 00           STA   Decss+4,Y         ; save to output string
009B1C  2  8A                 TXA                     ; copy 10's character
009B1D  2  99 77 00           STA   Decss+3,Y         ; save to output string
009B20  2  A9 00              LDA   #$00              ; set null terminator
009B22  2  99 79 00           STA   Decss+5,Y         ; save to output string
009B25  2  80 08              BRA   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
009B27  2               
009B27  2                                             ; save last character, [EOT] and exit
009B27  2               LAB_2A89
009B27  2  99 74 00           STA   Decss,Y           ; save last character to output string
009B2A  2               
009B2A  2                                             ; set null terminator and exit
009B2A  2               LAB_2A8C
009B2A  2  A9 00              LDA   #$00              ; set null terminator
009B2C  2  99 75 00           STA   Decss+1,Y         ; save after last character
009B2F  2               
009B2F  2                                             ; set string pointer (AY) and exit
009B2F  2               LAB_2A91
009B2F  2  A9 75              LDA   #<Decssp1         ; set result string low pointer
009B31  2  A0 00              LDY   #>Decssp1         ; set result string high pointer
009B33  2  60                 RTS
009B34  2               
009B34  2               ; perform power function
009B34  2               
009B34  2               LAB_POWER
009B34  2  F0 42              BEQ   LAB_EXP           ; go do  EXP()
009B36  2               
009B36  2  A5 65              LDA   FAC2_e            ; get FAC2 exponent
009B38  2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
009B3A  2               
009B3A  2  4C DA 95           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
009B3D  2               
009B3D  2               LAB_2ABF
009B3D  2  A2 4E              LDX   #<func_l          ; set destination pointer low byte
009B3F  2  A0 00              LDY   #>func_l          ; set destination pointer high byte
009B41  2  20 2C 98           JSR   LAB_2778          ; pack FAC1 into (XY)
009B44  2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
009B46  2  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
009B48  2               
009B48  2                                             ; else FAC2 is -ve and can only be raised to an
009B48  2                                             ; integer power which gives an x +j0 result
009B48  2  20 01 99           JSR   LAB_INT           ; perform INT
009B4B  2  A9 4E              LDA   #<func_l          ; set source pointer low byte
009B4D  2  A0 00              LDY   #>func_l          ; set source pointer high byte
009B4F  2  20 98 98           JSR   LAB_27F8          ; compare FAC1 with (AY)
009B52  2  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
009B54  2                                             ; this will leave FAC1 -ve and cause a Function Call
009B54  2                                             ; error when LOG() is called
009B54  2               
009B54  2  98                 TYA                     ; clear sign b7
009B55  2  A4 0D              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
009B57  2                                             ; for possible later negation, b0
009B57  2               LAB_2AD9
009B57  2  20 51 95           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
009B5A  2  98                 TYA                     ; copy sign back ..
009B5B  2  48                 PHA                     ; .. and save it
009B5C  2  20 83 96           JSR   LAB_LOG           ; do LOG(n)
009B5F  2  A9 4E              LDA   #<garb_l          ; set pointer low byte
009B61  2  A0 00              LDY   #>garb_l          ; set pointer high byte
009B63  2  20 C1 96           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
009B66  2  20 78 9B           JSR   LAB_EXP           ; go do EXP(n)
009B69  2  68                 PLA                     ; pull sign from stack
009B6A  2  4A                 LSR                     ; b0 is to be tested, shift to Cb
009B6B  2  90 0A              BCC   LAB_2AF9          ; if no bit then exit
009B6D  2               
009B6D  2                                             ; Perform negation
009B6D  2               ; do - FAC1
009B6D  2               
009B6D  2               LAB_GTHAN
009B6D  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009B6F  2  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
009B71  2               
009B71  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009B73  2  49 FF              EOR   #$FF              ; complement it
009B75  2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
009B77  2               LAB_2AF9
009B77  2  60                 RTS
009B78  2               
009B78  2               ; perform EXP()   (x^e)
009B78  2               
009B78  2               LAB_EXP
009B78  2  A9 15              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
009B7A  2  A0 A1              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
009B7C  2  20 C1 96           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
009B7F  2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
009B81  2  69 50              ADC   #$50              ; +$50/$100
009B83  2  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
009B85  2               
009B85  2  20 66 98           JSR   LAB_27C2          ; round FAC1 (no check)
009B88  2               LAB_2B2B
009B88  2  85 55              STA   FAC2_r            ; save FAC2 rounding byte
009B8A  2  20 52 98           JSR   LAB_27AE          ; copy FAC1 to FAC2
009B8D  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009B8F  2  C9 88              CMP   #$88              ; compare with EXP limit (256d)
009B91  2  90 03              BCC   LAB_2B39          ; branch if less
009B93  2               
009B93  2               LAB_2B36
009B93  2  20 55 97           JSR   LAB_2690          ; handle overflow and underflow
009B96  2               LAB_2B39
009B96  2  20 01 99           JSR   LAB_INT           ; perform INT
009B99  2  A5 0D              LDA   Temp3             ; get mantissa 3 from INT() function
009B9B  2  18                 CLC                     ; clear carry for add
009B9C  2  69 81              ADC   #$81              ; normalise +1
009B9E  2  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
009BA0  2               
009BA0  2  38                 SEC                     ; set carry for subtract
009BA1  2  E9 01              SBC   #$01              ; now correct for exponent
009BA3  2  48                 PHA                     ; save FAC2 exponent
009BA4  2               
009BA4  2                                             ; swap FAC1 and FAC2
009BA4  2  A2 04              LDX   #$04              ; 4 bytes to do
009BA6  2               LAB_2B49
009BA6  2  B5 65              LDA   FAC2_e,X          ; get FAC2,X
009BA8  2  B4 5E              LDY   FAC1_e,X          ; get FAC1,X
009BAA  2  95 5E              STA   FAC1_e,X          ; save FAC1,X
009BAC  2  94 65              STY   FAC2_e,X          ; save FAC2,X
009BAE  2  CA                 DEX                     ; decrement count/index
009BAF  2  10 F5              BPL   LAB_2B49          ; loop if not all done
009BB1  2               
009BB1  2  A5 55              LDA   FAC2_r            ; get FAC2 rounding byte
009BB3  2  85 6B              STA   FAC1_r            ; save as FAC1 rounding byte
009BB5  2  20 33 95           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
009BB8  2  20 6D 9B           JSR   LAB_GTHAN         ; do - FAC1
009BBB  2  A9 19              LDA   #<LAB_2AFE        ; set counter pointer low byte
009BBD  2  A0 A1              LDY   #>LAB_2AFE        ; set counter pointer high byte
009BBF  2  20 DE 9B           JSR   LAB_2B84          ; go do series evaluation
009BC2  2  64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
009BC4  2  68                 PLA                     ;.get saved FAC2 exponent
009BC5  2  4C 39 97           JMP   LAB_2675          ; test and adjust accumulators and return
009BC8  2               
009BC8  2               ; ^2 then series evaluation
009BC8  2               
009BC8  2               LAB_2B6E
009BC8  2  85 6C              STA   Cptrl             ; save count pointer low byte
009BCA  2  84 6D              STY   Cptrh             ; save count pointer high byte
009BCC  2  20 22 98           JSR   LAB_276E          ; pack FAC1 into Adatal
009BCF  2  A9 56              LDA   #<Adatal          ; set pointer low byte (Y already $00)
009BD1  2  20 C1 96           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
009BD4  2  20 E2 9B           JSR   LAB_2B88          ; go do series evaluation
009BD7  2  A9 56              LDA   #<Adatal          ; pointer to original # low byte
009BD9  2  A0 00              LDY   #>Adatal          ; pointer to original # high byte
009BDB  2  4C C1 96           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
009BDE  2               
009BDE  2               ; series evaluation
009BDE  2               
009BDE  2               LAB_2B84
009BDE  2  85 6C              STA   Cptrl             ; save count pointer low byte
009BE0  2  84 6D              STY   Cptrh             ; save count pointer high byte
009BE2  2               LAB_2B88
009BE2  2  A2 5A              LDX   #<numexp          ; set pointer low byte
009BE4  2  20 24 98           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
009BE7  2  B1 6C              LDA   (Cptrl),Y         ; get constants count
009BE9  2  85 63              STA   numcon            ; save constants count
009BEB  2  A4 6C              LDY   Cptrl             ; get count pointer low byte
009BED  2  C8                 INY                     ; increment it (now constants pointer)
009BEE  2  98                 TYA                     ; copy it
009BEF  2  D0 02              BNE   LAB_2B97          ; skip next if no overflow
009BF1  2               
009BF1  2  E6 6D              INC   Cptrh             ; else increment high byte
009BF3  2               LAB_2B97
009BF3  2  85 6C              STA   Cptrl             ; save low byte
009BF5  2  A4 6D              LDY   Cptrh             ; get high byte
009BF7  2               LAB_2B9B
009BF7  2  20 C1 96           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
009BFA  2  A5 6C              LDA   Cptrl             ; get constants pointer low byte
009BFC  2  A4 6D              LDY   Cptrh             ; get constants pointer high byte
009BFE  2  18                 CLC                     ; clear carry for add
009BFF  2  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
009C01  2  90 01              BCC   LAB_2BA8          ; skip next if no overflow
009C03  2               
009C03  2  C8                 INY                     ; increment high byte
009C04  2               LAB_2BA8
009C04  2  85 6C              STA   Cptrl             ; save pointer low byte
009C06  2  84 6D              STY   Cptrh             ; save pointer high byte
009C08  2  20 4A 95           JSR   LAB_246C          ; add (AY) to FAC1
009C0B  2  A9 5A              LDA   #<numexp          ; set pointer low byte to partial @ numexp
009C0D  2  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
009C0F  2  C6 63              DEC   numcon            ; decrement constants count
009C11  2  D0 E4              BNE   LAB_2B9B          ; loop until all done
009C13  2  60                 RTS
009C14  2               
009C14  2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
009C14  2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
009C14  2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
009C14  2               
009C14  2               ; Entropy = 7.997442 bits per byte
009C14  2               ; Optimum compression would reduce these 65536 bytes by 0 percent
009C14  2               
009C14  2               ; Chi square distribution for 65536 samples is 232.01, and
009C14  2               ; randomly would exceed this value 75.00 percent of the time
009C14  2               
009C14  2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
009C14  2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
009C14  2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
009C14  2               
009C14  2               LAB_RND
009C14  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009C16  2  F0 07              BEQ   NextPRN           ; do next random # if zero
009C18  2               
009C18  2                                             ; else get seed into random number store
009C18  2  A2 70              LDX   #Rbyte4           ; set PRNG pointer low byte
009C1A  2  A0 00              LDY   #$00              ; set PRNG pointer high byte
009C1C  2  20 2C 98           JSR   LAB_2778          ; pack FAC1 into (XY)
009C1F  2               NextPRN
009C1F  2  A2 AF              LDX   #$AF              ; set EOR byte
009C21  2  A0 13              LDY   #$13              ; do this nineteen times
009C23  2               LoopPRN
009C23  2  06 71              ASL   Rbyte1            ; shift PRNG most significant byte
009C25  2  26 72              ROL   Rbyte2            ; shift PRNG middle byte
009C27  2  26 73              ROL   Rbyte3            ; shift PRNG least significant byte
009C29  2  26 70              ROL   Rbyte4            ; shift PRNG extra byte
009C2B  2  90 05              BCC   Ninc1             ; branch if bit 32 clear
009C2D  2               
009C2D  2  8A                 TXA                     ; set EOR byte
009C2E  2  45 71              EOR   Rbyte1            ; EOR PRNG extra byte
009C30  2  85 71              STA   Rbyte1            ; save new PRNG extra byte
009C32  2               Ninc1
009C32  2  88                 DEY                     ; decrement loop count
009C33  2  D0 EE              BNE   LoopPRN           ; loop if not all done
009C35  2               
009C35  2  A2 02              LDX   #$02              ; three bytes to copy
009C37  2               CopyPRNG
009C37  2  B5 71              LDA   Rbyte1,X          ; get PRNG byte
009C39  2  95 5F              STA   FAC1_1,X          ; save FAC1 byte
009C3B  2  CA                 DEX
009C3C  2  10 F9              BPL   CopyPRNG          ; loop if not complete
009C3E  2               
009C3E  2  A9 80              LDA   #$80              ; set the exponent
009C40  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
009C42  2               
009C42  2  0A                 ASL                     ; clear A
009C43  2  85 62              STA   FAC1_s            ; save FAC1 sign
009C45  2               
009C45  2  4C BC 95           JMP   LAB_24D5          ; normalise FAC1 and return
009C48  2               
009C48  2               ; perform COS()
009C48  2               
009C48  2               LAB_COS
009C48  2  A9 36              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
009C4A  2  A0 A1              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
009C4C  2  20 4A 95           JSR   LAB_246C          ; add (AY) to FAC1
009C4F  2               
009C4F  2               ; perform SIN()
009C4F  2               
009C4F  2               LAB_SIN
009C4F  2  20 4F 98           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009C52  2  A9 4B              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
009C54  2  A0 A1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
009C56  2  A6 69              LDX   FAC2_s            ; get FAC2 sign (b7)
009C58  2  20 80 97           JSR   LAB_26C2          ; divide by (AY) (X=sign)
009C5B  2  20 4F 98           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009C5E  2  20 01 99           JSR   LAB_INT           ; perform INT
009C61  2  64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
009C63  2  20 33 95           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
009C66  2  A9 7D              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
009C68  2  A0 A1              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
009C6A  2  20 30 95           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
009C6D  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009C6F  2  48                 PHA                     ; save FAC1 sign
009C70  2  10 0D              BPL   LAB_2C35          ; branch if +ve
009C72  2               
009C72  2                                             ; FAC1 sign was -ve
009C72  2  20 46 95           JSR   LAB_244E          ; add 0.5 to FAC1
009C75  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009C77  2  30 09              BMI   LAB_2C38          ; branch if -ve
009C79  2               
009C79  2  A5 15              LDA   Cflag             ; get comparison evaluation flag
009C7B  2  49 FF              EOR   #$FF              ; toggle flag
009C7D  2  85 15              STA   Cflag             ; save comparison evaluation flag
009C7F  2               LAB_2C35
009C7F  2  20 6D 9B           JSR   LAB_GTHAN         ; do - FAC1
009C82  2               LAB_2C38
009C82  2  A9 7D              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
009C84  2  A0 A1              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
009C86  2  20 4A 95           JSR   LAB_246C          ; add (AY) to FAC1
009C89  2  68                 PLA                     ; restore FAC1 sign
009C8A  2  10 03              BPL   LAB_2C45          ; branch if was +ve
009C8C  2               
009C8C  2                                             ; else correct FAC1
009C8C  2  20 6D 9B           JSR   LAB_GTHAN         ; do - FAC1
009C8F  2               LAB_2C45
009C8F  2  A9 3A              LDA   #<LAB_2C84        ; set pointer low byte to counter
009C91  2  A0 A1              LDY   #>LAB_2C84        ; set pointer high byte to counter
009C93  2  4C C8 9B           JMP   LAB_2B6E          ; ^2 then series evaluation and return
009C96  2               
009C96  2               ; perform TAN()
009C96  2               
009C96  2               LAB_TAN
009C96  2  20 22 98           JSR   LAB_276E          ; pack FAC1 into Adatal
009C99  2  64 15              STZ   Cflag             ; clear comparison evaluation flag
009C9B  2  20 4F 9C           JSR   LAB_SIN           ; go do SIN(n)
009C9E  2  A2 4E              LDX   #<func_l          ; set sin(n) pointer low byte
009CA0  2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
009CA2  2  20 2C 98           JSR   LAB_2778          ; pack FAC1 into (XY)
009CA5  2  A9 56              LDA   #<Adatal          ; set n pointer low addr
009CA7  2  A0 00              LDY   #>Adatal          ; set n pointer high addr
009CA9  2  20 02 98           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
009CAC  2  64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
009CAE  2  A5 15              LDA   Cflag             ; get comparison evaluation flag
009CB0  2  20 BA 9C           JSR   LAB_2C74          ; save flag and go do series evaluation
009CB3  2               
009CB3  2  A9 4E              LDA   #<func_l          ; set sin(n) pointer low byte
009CB5  2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
009CB7  2  4C 87 97           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
009CBA  2               
009CBA  2               LAB_2C74
009CBA  2  48                 PHA                     ; save comparison evaluation flag
009CBB  2  80 C2              BRA   LAB_2C35          ; go do series evaluation
009CBD  2               
009CBD  2               ; perform USR()
009CBD  2               
009CBD  2               LAB_USR
009CBD  2  20 03 00           JSR   Usrjmp            ; call user code
009CC0  2  4C 8B 8B           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
009CC3  2               
009CC3  2               ; perform ATN()
009CC3  2               
009CC3  2               LAB_ATN
009CC3  2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
009CC5  2  48                 PHA                     ; save sign
009CC6  2  10 03              BPL   LAB_2CA1          ; branch if +ve
009CC8  2               
009CC8  2  20 6D 9B           JSR   LAB_GTHAN         ; else do - FAC1
009CCB  2               LAB_2CA1
009CCB  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009CCD  2  48                 PHA                     ; push exponent
009CCE  2  C9 81              CMP   #$81              ; compare with 1
009CD0  2  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
009CD2  2               
009CD2  2  A9 70              LDA   #<LAB_259C        ; set 1 pointer low byte
009CD4  2  A0 A1              LDY   #>LAB_259C        ; set 1 pointer high byte
009CD6  2  20 87 97           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
009CD9  2               LAB_2CAF
009CD9  2  A9 4F              LDA   #<LAB_2CC9        ; set pointer low byte to counter
009CDB  2  A0 A1              LDY   #>LAB_2CC9        ; set pointer high byte to counter
009CDD  2  20 C8 9B           JSR   LAB_2B6E          ; ^2 then series evaluation
009CE0  2  68                 PLA                     ; restore old FAC1 exponent
009CE1  2  C9 81              CMP   #$81              ; compare with 1
009CE3  2  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
009CE5  2               
009CE5  2  A9 36              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
009CE7  2  A0 A1              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
009CE9  2  20 30 95           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
009CEC  2               LAB_2CC2
009CEC  2  68                 PLA                     ; restore FAC1 sign
009CED  2  10 16              BPL   LAB_2D04          ; exit if was +ve
009CEF  2               
009CEF  2  4C 6D 9B           JMP   LAB_GTHAN         ; else do - FAC1 and return
009CF2  2               
009CF2  2               ; perform BITSET
009CF2  2               
009CF2  2               LAB_BITSET
009CF2  2  20 65 94           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
009CF5  2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
009CF7  2  B0 20              BCS   FCError           ; branch if > 7
009CF9  2               
009CF9  2  A9 00              LDA   #$00              ; clear A
009CFB  2  38                 SEC                     ; set the carry
009CFC  2               S_Bits
009CFC  2  2A                 ROL                     ; shift bit
009CFD  2  CA                 DEX                     ; decrement bit number
009CFE  2  10 FC              BPL   S_Bits            ; loop if still +ve
009D00  2               
009D00  2  E8                 INX                     ; make X = $00
009D01  2  01 0A              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
009D03  2  81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
009D05  2               LAB_2D04
009D05  2  60                 RTS
009D06  2               
009D06  2               ; perform BITCLR
009D06  2               
009D06  2               LAB_BITCLR
009D06  2  20 65 94           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
009D09  2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
009D0B  2  B0 0C              BCS   FCError           ; branch if > 7
009D0D  2               
009D0D  2  A9 FF              LDA   #$FF              ; set A
009D0F  2               S_Bitc
009D0F  2  2A                 ROL                     ; shift bit
009D10  2  CA                 DEX                     ; decrement bit number
009D11  2  10 FC              BPL   S_Bitc            ; loop if still +ve
009D13  2               
009D13  2  E8                 INX                     ; make X = $00
009D14  2  21 0A              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
009D16  2  81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
009D18  2  60                 RTS
009D19  2               
009D19  2               FCError
009D19  2  4C C8 8E           JMP   LAB_FCER          ; do function call error then warm start
009D1C  2               
009D1C  2               ; perform BITTST()
009D1C  2               
009D1C  2               LAB_BTST
009D1C  2  20 B5 9F           JSR   LAB_IGBY          ; increment BASIC pointer
009D1F  2  20 65 94           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
009D22  2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
009D24  2  B0 F3              BCS   FCError           ; branch if > 7
009D26  2               
009D26  2  20 BB 9F           JSR   LAB_GBYT          ; get next BASIC byte
009D29  2  C9 29              CMP   #')'              ; is next character ")"
009D2B  2  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
009D2D  2               
009D2D  2  4C 9C 8B           JMP   LAB_SNER          ; do syntax error then warm start
009D30  2               
009D30  2               TST_OK
009D30  2  20 B5 9F           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
009D33  2  A9 00              LDA   #$00              ; clear A
009D35  2  38                 SEC                     ; set the carry
009D36  2               T_Bits
009D36  2  2A                 ROL                     ; shift bit
009D37  2  CA                 DEX                     ; decrement bit number
009D38  2  10 FC              BPL   T_Bits            ; loop if still +ve
009D3A  2               
009D3A  2  E8                 INX                     ; make X = $00
009D3B  2  21 0A              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
009D3D  2  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
009D3F  2               
009D3F  2  A9 FF              LDA   #$FF              ; set for -1 result
009D41  2               LAB_NOTT
009D41  2  4C 7F 98           JMP   LAB_27DB          ; go do SGN tail
009D44  2               
009D44  2               ; perform BIN$()
009D44  2               
009D44  2               LAB_BINS
009D44  2  E0 19              CPX   #$19              ; max + 1
009D46  2  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
009D48  2               
009D48  2  86 2A              STX   TempB             ; save # of characters ($00 = leading zero remove)
009D4A  2  A9 18              LDA   #$18              ; need A byte long space
009D4C  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long
009D4F  2  A0 17              LDY   #$17              ; set index
009D51  2  A2 18              LDX   #$18              ; character count
009D53  2               NextB1
009D53  2  46 0A              LSR   nums_1            ; shift highest byte
009D55  2  66 0B              ROR   nums_2            ; shift middle byte
009D57  2  66 0C              ROR   nums_3            ; shift lowest byte bit 0 to carry
009D59  2  8A                 TXA                     ; load with "0"/2
009D5A  2  2A                 ROL                     ; shift in carry
009D5B  2  91 5F              STA   (str_pl),Y        ; save to temp string + index
009D5D  2  88                 DEY                     ; decrement index
009D5E  2  10 F3              BPL   NextB1            ; loop if not done
009D60  2               
009D60  2  A5 2A              LDA   TempB             ; get # of characters
009D62  2  F0 0A              BEQ   EndBHS            ; branch if truncate
009D64  2               
009D64  2  AA                 TAX                     ; copy length to X
009D65  2  38                 SEC                     ; set carry for add !
009D66  2  49 FF              EOR   #$FF              ; 1's complement
009D68  2  69 18              ADC   #$18              ; add 24d
009D6A  2  F0 1C              BEQ   GoPr2             ; if zero print whole string
009D6C  2  80 0F              BRA   GoPr1             ; else go make output string
009D6E  2               
009D6E  2               ; this is the exit code and is also used by HEX$()
009D6E  2               ; truncate string to remove leading "0"s
009D6E  2               
009D6E  2               EndBHS
009D6E  2  A8                 TAY                     ; clear index (A=0, X=length here)
009D6F  2               NextB2
009D6F  2  B1 5F              LDA   (str_pl),Y        ; get character from string
009D71  2  C9 30              CMP   #'0'              ; compare with "0"
009D73  2  D0 07              BNE   GoPr              ; if not "0" then go print string from here
009D75  2               
009D75  2  CA                 DEX                     ; decrement character count
009D76  2  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
009D78  2               
009D78  2  C8                 INY                     ; else increment index
009D79  2  80 F4              BRA   NextB2            ; loop always
009D7B  2               
009D7B  2               ; make fixed length output string - ignore overflows!
009D7B  2               
009D7B  2               GoPr3
009D7B  2  E8                 INX                     ; need at least 1 character
009D7C  2               GoPr
009D7C  2  98                 TYA                     ; copy result
009D7D  2               GoPr1
009D7D  2  18                 CLC                     ; clear carry for add
009D7E  2  65 5F              ADC   str_pl            ; add low address
009D80  2  85 5F              STA   str_pl            ; save low address
009D82  2  A9 00              LDA   #$00              ; do high byte
009D84  2  65 60              ADC   str_ph            ; add high address
009D86  2  85 60              STA   str_ph            ; save high address
009D88  2               GoPr2
009D88  2  86 5E              STX   str_ln            ; X holds string length
009D8A  2  20 B5 9F           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
009D8D  2  4C 22 91           JMP   LAB_RTST          ; check for space on descriptor stack then put address
009D90  2                                             ; and length on descriptor stack and update stack pointers
009D90  2               
009D90  2               BinFErr
009D90  2  4C C8 8E           JMP   LAB_FCER          ; do function call error then warm start
009D93  2               
009D93  2               ; perform HEX$()
009D93  2               
009D93  2               LAB_HEXS
009D93  2  E0 07              CPX   #$07              ; max + 1
009D95  2  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
009D97  2               
009D97  2  86 2A              STX   TempB             ; save # of characters
009D99  2               
009D99  2  A9 06              LDA   #$06              ; need 6 bytes for string
009D9B  2  20 D5 90           JSR   LAB_MSSP          ; make string space A bytes long
009D9E  2  A0 05              LDY   #$05              ; set string index
009DA0  2               
009DA0  2  A5 0C              LDA   nums_3            ; get lowest byte
009DA2  2  20 BF 9D           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
009DA5  2  A5 0B              LDA   nums_2            ; get middle byte
009DA7  2  20 BF 9D           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
009DAA  2  A5 0A              LDA   nums_1            ; get highest byte
009DAC  2  20 BF 9D           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
009DAF  2               
009DAF  2  A2 06              LDX   #$06              ; character count
009DB1  2  A5 2A              LDA   TempB             ; get # of characters
009DB3  2  F0 B9              BEQ   EndBHS            ; branch if truncate
009DB5  2               
009DB5  2  AA                 TAX                     ; copy length to X
009DB6  2  38                 SEC                     ; set carry for add !
009DB7  2  49 FF              EOR   #$FF              ; 1's complement
009DB9  2  69 06              ADC   #$06              ; add 6d
009DBB  2  F0 CB              BEQ   GoPr2             ; if zero print whole string
009DBD  2  80 BE              BRA   GoPr1             ; else go make output string (branch always)
009DBF  2               
009DBF  2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
009DBF  2               
009DBF  2               LAB_A2HX
009DBF  2  AA                 TAX                     ; save byte
009DC0  2  29 0F              AND   #$0F              ; mask off top bits
009DC2  2  20 CA 9D           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
009DC5  2  8A                 TXA                     ; get byte back
009DC6  2  4A                 LSR                     ; /2  shift high nibble to low nibble
009DC7  2  4A                 LSR                     ; /4
009DC8  2  4A                 LSR                     ; /8
009DC9  2  4A                 LSR                     ; /16
009DCA  2               LAB_AL2X
009DCA  2  C9 0A              CMP   #$0A              ; set carry for +1 if >9
009DCC  2  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
009DCE  2  69 06              ADC   #$06              ; adjust for A to F
009DD0  2               LAB_AL20
009DD0  2  69 30              ADC   #'0'              ; add ASCII "0"
009DD2  2  91 5F              STA   (str_pl),Y        ; save to temp string
009DD4  2  88                 DEY                     ; decrement counter
009DD5  2  60                 RTS
009DD6  2               
009DD6  2               LAB_NLTO
009DD6  2  85 5E              STA   FAC1_e            ; save FAC1 exponent
009DD8  2  A9 00              LDA   #$00              ; clear sign compare
009DDA  2               LAB_MLTE
009DDA  2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009DDC  2  8A                 TXA                     ; restore character
009DDD  2  20 C1 99           JSR   LAB_2912          ; evaluate new ASCII digit
009DE0  2               
009DE0  2               ; gets here if the first character was "$" for hex
009DE0  2               ; get hex number
009DE0  2               
009DE0  2               LAB_CHEX
009DE0  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009DE3  2  90 0A              BCC   LAB_ISHN          ; branch if numeric character
009DE5  2               
009DE5  2  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
009DE7  2  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
009DE9  2  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
009DEB  2  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
009DED  2               
009DED  2  69 0A              ADC   #$0A              ; convert to nibble
009DEF  2               LAB_ISHN
009DEF  2  29 0F              AND   #$0F              ; convert to binary
009DF1  2  AA                 TAX                     ; save nibble
009DF2  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009DF4  2  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
009DF6  2               
009DF6  2  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
009DF8  2  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
009DFA  2               
009DFA  2               LAB_MLTO
009DFA  2  4C 4B 96           JMP   LAB_2564          ; do overflow error and warm start
009DFD  2               
009DFD  2               LAB_NXCH
009DFD  2  AA                 TAX                     ; save bit
009DFE  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009E00  2  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
009E02  2               
009E02  2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*2)
009E04  2  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
009E06  2               
009E06  2  A9 00              LDA   #$00              ; clear sign compare
009E08  2               LAB_MLBT
009E08  2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
009E0A  2  8A                 TXA                     ; restore bit
009E0B  2  20 C1 99           JSR   LAB_2912          ; evaluate new ASCII digit
009E0E  2               
009E0E  2               ; gets here if the first character was  "%" for binary
009E0E  2               ; get binary number
009E0E  2               
009E0E  2               LAB_CBIN
009E0E  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009E11  2  49 30              EOR   #'0'              ; convert "0" to 0 etc.
009E13  2  C9 02              CMP   #$02              ; compare with max+1
009E15  2  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
009E17  2               
009E17  2               LAB_EXCH
009E17  2  4C A7 99           JMP   LAB_28F6          ; evaluate -ve flag and return
009E1A  2               
009E1A  2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
009E1A  2               
009E1A  2               CTRLC
009E1A  2  AD 7F 03           LDA   ccflag            ; get [CTRL-C] check flag
009E1D  2  D0 18              BNE   LAB_FBA2          ; exit if inhibited
009E1F  2               
009E1F  2  20 3E A0           JSR   V_INPT            ; scan input device
009E22  2  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
009E24  2               
009E24  2  8D 80 03           STA   ccbyte            ; save received byte
009E27  2  A2 20              LDX   #$20              ; "life" timer for bytes
009E29  2  8E 81 03           STX   ccnull            ; set countdown
009E2C  2  4C DC 84           JMP   LAB_1636          ; return to BASIC
009E2F  2               
009E2F  2               LAB_FBA0
009E2F  2  AE 81 03           LDX   ccnull            ; get countdown byte
009E32  2  F0 03              BEQ   LAB_FBA2          ; exit if finished
009E34  2               
009E34  2  CE 81 03           DEC   ccnull            ; else decrement countdown
009E37  2               LAB_FBA2
009E37  2  60                 RTS
009E38  2               
009E38  2               INGET
009E38  2  20 3E A0           JSR   V_INPT            ; call scan input device
009E3B  2  B0 09              BCS   LAB_FB95          ; if byte go reset timer
009E3D  2               
009E3D  2  AD 81 03           LDA   ccnull            ; get countdown
009E40  2  F0 07              BEQ   LAB_FB96          ; exit if empty
009E42  2               
009E42  2  AD 80 03           LDA   ccbyte            ; get last received byte
009E45  2  38                 SEC                     ; flag we got a byte
009E46  2               LAB_FB95
009E46  2  9C 81 03           STZ   ccnull            ; clear timer because we got a byte
009E49  2               LAB_FB96
009E49  2  60                 RTS
009E4A  2               
009E4A  2               ; MAX() MIN() pre process
009E4A  2               
009E4A  2               LAB_MMPP
009E4A  2  20 84 8A           JSR   LAB_EVEZ          ; process expression
009E4D  2  4C 6A 8A           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
009E50  2               
009E50  2               ; perform MAX()
009E50  2               
009E50  2               LAB_MAX
009E50  2  20 7E 9E           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
009E53  2                                             ; pull FAC2 and compare with FAC1
009E53  2  10 FB              BPL   LAB_MAX           ; branch if no swap to do
009E55  2               
009E55  2  A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
009E57  2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
009E59  2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
009E5B  2  20 4F 95           JSR   LAB_279B          ; copy FAC2 to FAC1
009E5E  2  80 F0              BRA   LAB_MAX           ; go do next (branch always)
009E60  2               
009E60  2               ; perform MIN()
009E60  2               
009E60  2               LAB_MIN
009E60  2  20 7E 9E           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
009E63  2                                             ; pull FAC2 and compare with FAC1
009E63  2  30 FB              BMI   LAB_MIN           ; branch if no swap to do
009E65  2  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
009E67  2               
009E67  2  A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
009E69  2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
009E6B  2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
009E6D  2  20 4F 95           JSR   LAB_279B          ; copy FAC2 to FAC1
009E70  2  80 EE              BRA   LAB_MIN           ; go do next (branch always)
009E72  2               
009E72  2               ; exit routine. don't bother returning to the loop code
009E72  2               ; check for correct exit, else so syntax error
009E72  2               
009E72  2               LAB_MMEC
009E72  2  C9 29              CMP   #')'              ; is it end of function?
009E74  2  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
009E76  2               
009E76  2  68                 PLA                     ; dump return address low byte
009E77  2  68                 PLA                     ; dump return address high byte
009E78  2  4C B5 9F           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
009E7B  2               
009E7B  2               LAB_MMSE
009E7B  2  4C 9C 8B           JMP   LAB_SNER          ; do syntax error then warm start
009E7E  2               
009E7E  2               ; check for next, evaluate and return or exit
009E7E  2               ; this is the routine that does most of the work
009E7E  2               
009E7E  2               LAB_PHFA
009E7E  2  20 BB 9F           JSR   LAB_GBYT          ; get next BASIC byte
009E81  2  C9 2C              CMP   #','              ; is there more ?
009E83  2  D0 ED              BNE   LAB_MMEC          ; if not go do end check
009E85  2               
009E85  2                                             ; push FAC1
009E85  2  20 5E 98           JSR   LAB_27BA          ; round FAC1
009E88  2  A5 62              LDA   FAC1_s            ; get FAC1 sign
009E8A  2  09 7F              ORA   #$7F              ; set all non sign bits
009E8C  2  25 5F              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
009E8E  2  48                 PHA                     ; push on stack
009E8F  2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
009E91  2  48                 PHA                     ; push on stack
009E92  2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
009E94  2  48                 PHA                     ; push on stack
009E95  2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
009E97  2  48                 PHA                     ; push on stack
009E98  2               
009E98  2  20 B5 9F           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
009E9B  2  20 67 8A           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
009E9E  2                                             ; else do type mismatch
009E9E  2               
009E9E  2                                             ; pop FAC2 (MAX/MIN expression so far)
009E9E  2  68                 PLA                     ; pop exponent
009E9F  2  85 65              STA   FAC2_e            ; save FAC2 exponent
009EA1  2  68                 PLA                     ; pop mantissa3
009EA2  2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
009EA4  2  68                 PLA                     ; pop mantissa1
009EA5  2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
009EA7  2  68                 PLA                     ; pop sign/mantissa1
009EA8  2  85 66              STA   FAC2_1            ; save FAC2 sign/mantissa1
009EAA  2  85 69              STA   FAC2_s            ; save FAC2 sign
009EAC  2               
009EAC  2                                             ; compare FAC1 with (packed) FAC2
009EAC  2  A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
009EAE  2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
009EB0  2  4C 98 98           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
009EB3  2                                             ; returns A=$00 if FAC1 = (AY)
009EB3  2                                             ; returns A=$01 if FAC1 > (AY)
009EB3  2                                             ; returns A=$FF if FAC1 < (AY)
009EB3  2               
009EB3  2               ; perform WIDTH
009EB3  2               
009EB3  2               LAB_WDTH
009EB3  2  C9 2C              CMP   #','              ; is next byte ","
009EB5  2  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
009EB7  2               
009EB7  2  20 21 94           JSR   LAB_GTBY          ; get byte parameter
009EBA  2  8A                 TXA                     ; copy width to A
009EBB  2  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
009EBD  2               
009EBD  2  E0 10              CPX   #$10              ; else make min width = 16d
009EBF  2  90 45              BCC   TabErr            ; if less do function call error and exit
009EC1  2               
009EC1  2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
009EC1  2               ; tab size greater than the line length.
009EC1  2               
009EC1  2  E4 16              CPX   TabSiz            ; compare with tab size
009EC3  2  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
009EC5  2               
009EC5  2  86 16              STX   TabSiz            ; else make tab size = terminal width
009EC7  2               LAB_NSTT
009EC7  2  86 08              STX   TWidth            ; set the terminal width
009EC9  2  20 BB 9F           JSR   LAB_GBYT          ; get BASIC byte back
009ECC  2  F0 1A              BEQ   WExit             ; exit if no following
009ECE  2               
009ECE  2  C9 2C              CMP   #','              ; else is it ","
009ED0  2  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
009ED2  2               
009ED2  2               LAB_TBSZ
009ED2  2  20 1E 94           JSR   LAB_SGBY          ; scan and get byte parameter
009ED5  2  8A                 TXA                     ; copy TAB size
009ED6  2  30 2E              BMI   TabErr            ; if >127 do function call error and exit
009ED8  2               
009ED8  2  E0 01              CPX   #$01              ; compare with min-1
009EDA  2  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
009EDC  2               
009EDC  2  A5 08              LDA   TWidth            ; set flags for width
009EDE  2  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
009EE0  2               
009EE0  2  E4 08              CPX   TWidth            ; compare TAB with width
009EE2  2  F0 02              BEQ   LAB_SVTB          ; ok if =
009EE4  2  B0 20              BCS   TabErr            ; branch if too big
009EE6  2               
009EE6  2               LAB_SVTB
009EE6  2  86 16              STX   TabSiz            ; save TAB size
009EE8  2               
009EE8  2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
009EE8  2               ; position on a line that still has at least one whole tab width between it
009EE8  2               ; and the end of the line.
009EE8  2               
009EE8  2               WExit
009EE8  2  A5 08              LDA   TWidth            ; get width
009EEA  2  F0 06              BEQ   LAB_SULP          ; branch if infinite line
009EEC  2               
009EEC  2  C5 16              CMP   TabSiz            ; compare with tab size
009EEE  2  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
009EF0  2               
009EF0  2  85 16              STA   TabSiz            ; else make tab size = terminal width
009EF2  2               LAB_SULP
009EF2  2  38                 SEC                     ; set carry for subtract
009EF3  2               LAB_WDLP
009EF3  2  E5 16              SBC   TabSiz            ; subtract tab size
009EF5  2  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
009EF7  2               
009EF7  2  65 16              ADC   TabSiz            ; add tab size back
009EF9  2  18                 CLC                     ; clear carry for add
009EFA  2  65 16              ADC   TabSiz            ; add tab size back again
009EFC  2  85 09              STA   Iclim             ; save for now
009EFE  2  A5 08              LDA   TWidth            ; get width back
009F00  2  38                 SEC                     ; set carry for subtract
009F01  2  E5 09              SBC   Iclim             ; subtract remainder
009F03  2  85 09              STA   Iclim             ; save tab column limit
009F05  2               LAB_NOSQ
009F05  2  60                 RTS
009F06  2               
009F06  2               TabErr
009F06  2  4C C8 8E           JMP   LAB_FCER          ; do function call error then warm start
009F09  2               
009F09  2               ; perform SQR()
009F09  2               
009F09  2               LAB_SQR
009F09  2  A5 62              LDA   FAC1_s            ; get FAC1 sign
009F0B  2  30 F9              BMI   TabErr            ; if -ve do function call error
009F0D  2               
009F0D  2  A5 5E              LDA   FAC1_e            ; get exponent
009F0F  2  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
009F11  2               
009F11  2                                             ; else do root
009F11  2  20 4F 98           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
009F14  2               
009F14  2  64 29              STZ   FACt_3            ; clear remainder
009F16  2  64 28              STZ   FACt_2            ; ..
009F18  2  64 27              STZ   FACt_1            ; ..
009F1A  2  64 2A              STZ   TempB             ; ..
009F1C  2               
009F1C  2  64 61              STZ   FAC1_3            ; clear root
009F1E  2  64 60              STZ   FAC1_2            ; ..
009F20  2  64 5F              STZ   FAC1_1            ; ..
009F22  2               
009F22  2  A2 18              LDX   #$18              ; 24 pairs of bits to do
009F24  2  A5 65              LDA   FAC2_e            ; get exponent
009F26  2  4A                 LSR                     ; check odd/even
009F27  2  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
009F29  2               
009F29  2               LAB_SQE1
009F29  2  06 68              ASL   FAC2_3            ; shift highest bit of number ..
009F2B  2  26 67              ROL   FAC2_2            ; ..
009F2D  2  26 66              ROL   FAC2_1            ; ..
009F2F  2  26 29              ROL   FACt_3            ; .. into remainder
009F31  2  26 28              ROL   FACt_2            ; ..
009F33  2  26 27              ROL   FACt_1            ; ..
009F35  2  26 2A              ROL   TempB             ; .. never overflows
009F37  2               LAB_SQE2
009F37  2  06 68              ASL   FAC2_3            ; shift highest bit of number ..
009F39  2  26 67              ROL   FAC2_2            ; ..
009F3B  2  26 66              ROL   FAC2_1            ; ..
009F3D  2  26 29              ROL   FACt_3            ; .. into remainder
009F3F  2  26 28              ROL   FACt_2            ; ..
009F41  2  26 27              ROL   FACt_1            ; ..
009F43  2  26 2A              ROL   TempB             ; .. never overflows
009F45  2               
009F45  2  06 61              ASL   FAC1_3            ; root = root * 2
009F47  2  26 60              ROL   FAC1_2            ; ..
009F49  2  26 5F              ROL   FAC1_1            ; .. never overflows
009F4B  2               
009F4B  2  A5 61              LDA   FAC1_3            ; get root low byte
009F4D  2  2A                 ROL                     ; *2
009F4E  2  85 0D              STA   Temp3             ; save partial low byte
009F50  2  A5 60              LDA   FAC1_2            ; get root low mid byte
009F52  2  2A                 ROL                     ; *2
009F53  2  85 0E              STA   Temp3+1           ; save partial low mid byte
009F55  2  A5 5F              LDA   FAC1_1            ; get root high mid byte
009F57  2  2A                 ROL                     ; *2
009F58  2  85 0F              STA   Temp3+2           ; save partial high mid byte
009F5A  2  A9 00              LDA   #$00              ; get root high byte (always $00)
009F5C  2  2A                 ROL                     ; *2
009F5D  2  85 10              STA   Temp3+3           ; save partial high byte
009F5F  2               
009F5F  2                                             ; carry clear for subtract +1
009F5F  2  A5 29              LDA   FACt_3            ; get remainder low byte
009F61  2  E5 0D              SBC   Temp3             ; subtract partial low byte
009F63  2  85 0D              STA   Temp3             ; save partial low byte
009F65  2               
009F65  2  A5 28              LDA   FACt_2            ; get remainder low mid byte
009F67  2  E5 0E              SBC   Temp3+1           ; subtract partial low mid byte
009F69  2  85 0E              STA   Temp3+1           ; save partial low mid byte
009F6B  2               
009F6B  2  A5 27              LDA   FACt_1            ; get remainder high mid byte
009F6D  2  E5 0F              SBC   Temp3+2           ; subtract partial high mid byte
009F6F  2  A8                 TAY                     ; copy partial high mid byte
009F70  2               
009F70  2  A5 2A              LDA   TempB             ; get remainder high byte
009F72  2  E5 10              SBC   Temp3+3           ; subtract partial high byte
009F74  2  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
009F76  2               
009F76  2  85 2A              STA   TempB             ; save remainder high byte
009F78  2               
009F78  2  84 27              STY   FACt_1            ; save remainder high mid byte
009F7A  2               
009F7A  2  A5 0E              LDA   Temp3+1           ; get remainder low mid byte
009F7C  2  85 28              STA   FACt_2            ; save remainder low mid byte
009F7E  2               
009F7E  2  A5 0D              LDA   Temp3             ; get partial low byte
009F80  2  85 29              STA   FACt_3            ; save remainder low byte
009F82  2               
009F82  2  E6 61              INC   FAC1_3            ; increment root low byte (never any rollover)
009F84  2               LAB_SQNS
009F84  2  CA                 DEX                     ; decrement bit pair count
009F85  2  D0 A2              BNE   LAB_SQE1          ; loop if not all done
009F87  2               
009F87  2  38                 SEC                     ; set carry for subtract
009F88  2  A5 65              LDA   FAC2_e            ; get exponent
009F8A  2  E9 80              SBC   #$80              ; normalise
009F8C  2  6A                 ROR                     ; /2 and re-bias to $80
009F8D  2  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
009F8F  2  85 5E              STA   FAC1_e            ; save it
009F91  2  4C BC 95           JMP   LAB_24D5          ; normalise FAC1 and return
009F94  2               
009F94  2               ; perform VARPTR()
009F94  2               
009F94  2               LAB_VARPTR
009F94  2  20 B5 9F           JSR   LAB_IGBY          ; increment and scan memory
009F97  2  20 4C 8D           JSR   LAB_GVAR          ; get var address
009F9A  2  20 8B 8B           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
009F9D  2  A4 47              LDY   Cvaral            ; get var address low byte
009F9F  2  A5 48              LDA   Cvarah            ; get var address high byte
009FA1  2  4C F8 8F           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
009FA4  2               
009FA4  2               ; perform PI
009FA4  2               
009FA4  2               LAB_PI
009FA4  2  A9 4B              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
009FA6  2  A0 A1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
009FA8  2  20 02 98           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
009FAB  2  C6 5E              DEC   FAC1_e            ; make result = PI
009FAD  2  60                 RTS
009FAE  2               
009FAE  2               ; perform TWOPI
009FAE  2               
009FAE  2               LAB_TWOPI
009FAE  2  A9 4B              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
009FB0  2  A0 A1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
009FB2  2  4C 02 98           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
009FB5  2               
009FB5  2               ; character get subroutine - ROM based
009FB5  2               
009FB5  2               ; the target address for the LDA at LAB_GBYT is the BASIC execute pointer.
009FB5  2               ; block is no longer copied to page zero and uses a CMOS instruction/address mode.
009FB5  2               ; 16-bit pointer is located in page zero.
009FB5  2               
009FB5  2               ; increment and scan memory
009FB5  2               LAB_IGBY
009FB5  2  E6 6E              INC   Bpntrl            ; increment BASIC execute pointer low byte
009FB7  2  D0 02              BNE   LAB_GBYT          ; branch if no carry, else
009FB9  2  E6 6F              INC   Bpntrh            ; increment BASIC execute pointer high byte
009FBB  2               
009FBB  2               ; scan memory
009FBB  2               LAB_GBYT
009FBB  2  B2 6E              LDA   (Bpntrl)          ; get byte to scan (addr set by call routine)
009FBD  2  C9 A9              CMP   #TK_ELSE          ; compare with the token for ELSE
009FBF  2  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
009FC1  2               
009FC1  2  C9 3A              CMP   #':'              ; compare with ":"
009FC3  2  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
009FC5  2               
009FC5  2  C9 20              CMP   #' '              ; compare with " "
009FC7  2  F0 EC              BEQ   LAB_IGBY          ; if " " go do next
009FC9  2               
009FC9  2               ; changes per Mike Barry, saves a couple clock cycles
009FC9  2  49 30              EOR #'0'                ; convert to binary
009FCB  2  C9 0A              CMP #10                 ; clear carry if decimal digit
009FCD  2  49 30              EOR #'0'                ; convert back to ASCII
009FCF  2               
009FCF  2               LAB_2D05
009FCF  2  60                 RTS
009FD0  2               
009FD0  2               LAB_LOAD
009FD0  2               ; To Load a program you need to start loading at Smeml/h
009FD0  2               ; then find the end of program (two $00), using Itempl/h,
009FD0  2               ; then clear other variables and call BASIC cleanup
009FD0  2               ;
009FD0  2               ; The variables used by the C02 Monitor are:
009FD0  2               ; PTRL/H, plus set the Block count to 1 and clear the OPXMDM flag
009FD0  2               ;
009FD0  2               ; LOAD command
009FD0  2               
009FD0  2  A5 2B             LDA     Smeml            ; get start address
009FD2  2  85 DA             STA     PTRL             ; put it in XMODEM pointer
009FD4  2  A5 2C             LDA     Smemh            ;
009FD6  2  85 DB             STA     PTRH             ;
009FD8  2               
009FD8  2  A9 01             LDA    #$01              ; get count of one
009FDA  2  85 DC             STA    BLKNO             ; set Xmodem block count
009FDC  2  64 D6             STZ    OPXMDM            ; clear OPXMDM flag
009FDE  2  20 44 A0          JSR    V_LOAD            ; call XMODEM receive vector
009FE1  2               
009FE1  2               ; Program loaded into memory, likely padded with $1A from Xmodem protocol
009FE1  2               ; use get_basmem routine to find the end program memory, then reset the pointers
009FE1  2               ; and call LAB_1319 to cleanup EhBasic.
009FE1  2               ; NOTE: Modified routine using OPXMDM Bit7 to indicate a LOAD was done and
009FE1  2               ; print the Ready message after cleanup.
009FE1  2               
009FE1  2  20 19 A0          JSR     get_basmem       ; find end of program space
009FE4  2  A5 0A             LDA     Itempl           ; get start of free memory low byte address
009FE6  2  A4 0B             LDY     Itemph           ; get start of free memory high byte address
009FE8  2  85 2D             STA     Svarl            ; and set variables and strings pointers
009FEA  2  85 2F             STA     Sarryl           ; to the start of free memory
009FEC  2  85 31             STA     Earryl           ;
009FEE  2  84 2E             STY     Svarh            ;
009FF0  2  84 30             STY     Sarryh           ;
009FF2  2  84 32             STY     Earryh           ;
009FF4  2  F7 D6             SMB7    OPXMDM           ; set upper bit in flag (print Ready msg)
009FF6  2  4C D3 81          JMP     LAB_1319         ; cleanup and Return to BASIC
009FF9  2               
009FF9  2               LAB_SAVE
009FF9  2               ; To Save a program you need to save start to end of program
009FF9  2               ; marked by two consecutive $00.
009FF9  2               ;
009FF9  2               ; The Xmodem Save routine in the C02 Monitor expects it's variables
009FF9  2               ; to be set before making the call via the JMP to V_SAVE.
009FF9  2               
009FF9  2               ; The variables used by the C02 Monitor are:
009FF9  2               ; - Source address (SCRL/H), Length (LENL/H), plus
009FF9  2               ; - the Block count set to one and the OPXMDM flag cleared.
009FF9  2               ;
009FF9  2               ; SAVE command
009FF9  2               
009FF9  2  20 19 A0          JSR    get_basmem        ; find end of program space
009FFC  2  A6 2B             LDX    Smeml             ;
009FFE  2  A5 2C             LDA    Smemh             ; get start address of BASIC program
00A000  2  86 C8             STX    SRCL              ;
00A002  2  85 C9             STA    SRCH              ; save in xmodem pointer
00A004  2               
00A004  2  A5 0A             LDA    Itempl            ; get end of memory low byte
00A006  2  38                SEC                      ; set carry flag for subtract
00A007  2  E5 2B             SBC    Smeml             ; subtract start of memory low byte
00A009  2  85 CC             STA    LENL              ; store to Monitor length low byte
00A00B  2               
00A00B  2  A5 0B             LDA    Itemph            ; get end of memory high byte
00A00D  2  E5 2C             SBC    Smemh             ; subtract start of memory high byte
00A00F  2  85 CD             STA    LENH              ; save to Monitor length high byte
00A011  2               
00A011  2  A9 01             LDA    #$01              ; get count of one
00A013  2  85 DC             STA    BLKNO             ; set Xmodem block count
00A015  2  64 D6             STZ    OPXMDM            ; clear OPXMDM flag
00A017  2               
00A017  2  80 2E             BRA    V_SAVE            ; call Xmodem SAVE vector and return
00A019  2               
00A019  2               ; Basic program code links line numbers via the first two bytes of
00A019  2               ; the program code starting at (Smeml) pointing to the next line of
00A019  2               ; Basic code. The end is marked by two consecutive $00 bytes.
00A019  2               ;
00A019  2               ; This routine, starts at (smeml) which points to the next line of
00A019  2               ; Basic code, then calculates the address to the next line after that
00A019  2               ; and continues till it locates the last line.
00A019  2               ;
00A019  2               ; Once the end of Basic program space is found, (Itempl) is updated
00A019  2               ; by two, which points to the start of free memory.
00A019  2               
00A019  2               get_basmem
00A019  2  A5 2B             LDA     Smeml            ; get start address
00A01B  2  85 0A             STA     Itempl           ; and save to
00A01D  2  A5 2C             LDA     Smemh            ; temp pointer
00A01F  2  85 0B             STA     Itemph           ; high and low byte
00A021  2  A0 01             LDY     #$01             ; set Y reg for offset of 1
00A023  2               
00A023  2               scan_bas
00A023  2  B2 0A             LDA     (Itempl)         ; get BASIC low byte line address
00A025  2  AA                TAX                      ; save to X reg (could be next line low address)
00A026  2  F0 08             BEQ     chk_next         ; if zero, might be end, branch and check
00A028  2  B1 0A             LDA     (Itempl),y       ; else, get high byte line address
00A02A  2               upd_bas
00A02A  2  85 0B             STA     Itemph           ; update high byte line address
00A02C  2  86 0A             STX     Itempl           ; update low byte line address
00A02E  2  80 F3             BRA     scan_bas         ; branch back to find next line
00A030  2               
00A030  2               chk_next
00A030  2  B1 0A             LDA     (Itempl),y       ; get next byte, BASIC high byte line address
00A032  2  D0 F6             BNE     upd_bas          ; if non-zero, branch to update line address
00A034  2               
00A034  2  20 37 A0          JSR     inc_line         ; else increment line address twice
00A037  2               inc_line
00A037  2  E6 0A             INC     Itempl           ; increment low byte count
00A039  2  D0 02             BNE     skp_ith          ; if not zero, skip high byte increment
00A03B  2  E6 0B             INC     Itemph           ; else, increment high byte count
00A03D  2               skp_ith
00A03D  2  60                RTS                      ; return to caller
00A03E  2               
00A03E  2               ; system dependant I/O vectors
00A03E  2               ; these are in RAM and are set by the monitor at start-up
00A03E  2               
00A03E  2               V_INPT
00A03E  2  6C 84 03           JMP   (VEC_IN)          ; non halting scan input device
00A041  2               V_OUTP
00A041  2  6C 86 03           JMP   (VEC_OUT)         ; send byte to output device
00A044  2               V_LOAD
00A044  2  6C 88 03           JMP   (VEC_LD)          ; load BASIC program
00A047  2               V_SAVE
00A047  2  6C 8A 03           JMP   (VEC_SV)          ; save BASIC program
00A04A  2               V_EXIT
00A04A  2  6C 8C 03           JMP   (VEC_EXIT)        ; warm start C02 Monitor
00A04D  2               
00A04D  2               ; The rest are tables messages and code for RAM
00A04D  2               
00A04D  2               ; the rest of the code is tables and BASIC start-up code
00A04D  2               ; monitor routines required are added below for initialization
00A04D  2               
00A04D  2               PG4_TABS
00A04D  2  00                 .byte $00               ; ctrl-c flag - $00 = enabled
00A04E  2  00                 .byte $00               ; ctrl-c byte - GET needs this
00A04F  2  00                 .byte $00               ; ctrl-c byte timeout - GET needs this
00A050  2  1A 9E              .word CTRLC             ; ctrl-c check vector
00A052  2               ;
00A052  2  48 A9              .word B_CHRIN_NW        ; byte in from C02BIOS (no waiting)
00A054  2  44 A9              .word B_CHROUT          ; byte out from C02BIOS
00A056  2  4C A9              .word M_LOAD            ; Xmodem LOAD for C02 Monitor
00A058  2  4D A9              .word M_SAVE            ; Xmodem SAVE for C02 Monitor
00A05A  2  14 A9              .word M_EXIT            ; Warm start for C02 Monitor
00A05C  2               
00A05C  2               PG4_TABE
00A05C  2               
00A05C  2               ; page zero initialisation table $00-$0B inclusive
00A05C  2               
00A05C  2               StrTab
00A05C  2  4C                 .byte $4C               ; JMP opcode
00A05D  2  1F 81              .word LAB_1274          ; warm start vector
00A05F  2               
00A05F  2  4C                 .byte $4C               ; JMP opcode
00A060  2  C8 8E              .word LAB_FCER          ; initial user function vector ("Function call" error)
00A062  2               
00A062  2  00                 .byte $00               ; default NULL count
00A063  2  00                 .byte $00               ; clear terminal position
00A064  2  50                 .byte $50               ; default terminal width byte = 80
00A065  2  F2                 .byte $F2               ; default limit for TAB = 14
00A066  2  00 05              .word Ram_base          ; start of user RAM
00A068  2               EndTab
00A068  2               
00A068  2               BOOT_BASIC
00A068  2               ; To conserve some space in the C02Monitor allocated EEPROM space, the startup
00A068  2               ; routine has been moved here. The goal is to ensure that EnHanced Basic is
00A068  2               ; fully self contained and requires nothing but the ROM vectors to function.
00A068  2               ; This adds some additional coding, but still ensures total allocated space
00A068  2               ; is within 10KB (10240 bytes) of EEPROM space.
00A068  2               
00A068  2  A9 9F              LDA   #<LAB_CSMSG          ; point to init message (low addr)
00A06A  2  A0 A0              LDY   #>LAB_CSMSG          ; point to init message (high addr)
00A06C  2  85 C6              STA   PROMPTL              ; Store low byte
00A06E  2  84 C7              STY   PROMPTH              ; Store high byte
00A070  2               PROMPT2
00A070  2  B2 C6              LDA   (PROMPTL)            ; Get string data
00A072  2  F0 0B              BEQ   EHB_TRY2             ; If null character, branch to user entry
00A074  2  20 44 A9           JSR   B_CHROUT             ; Send character to terminal
00A077  2  E6 C6              INC   PROMPTL              ; Increment low byte index
00A079  2  D0 F5              BNE   PROMPT2              ; Loop back for next character
00A07B  2  E6 C7              INC   PROMPTH              ; Increment high byte index
00A07D  2  80 F1              BRA   PROMPT2              ; Loop back and continue printing
00A07F  2               
00A07F  2               EHB_TRY2
00A07F  2  20 48 A9           JSR   B_CHRIN_NW           ; Request keystroke input from terminal
00A082  2  90 FB              BCC   EHB_TRY2             ; If carry clear, nothing entered, loop back
00A084  2  C9 61              CMP   #$61                 ; Check for lower case value range
00A086  2  90 02              BCC   UCOK                 ; Branch if < $61, control code/upper-case/numeric
00A088  2  E9 20              SBC   #$20                 ; Subtract $20 to convert to upper case
00A08A  2               UCOK
00A08A  2  C9 43              CMP   #'C'                 ; Check for Cold start
00A08C  2  F0 0E              BEQ   EHB_COLD             ; If yes, go Cold Start
00A08E  2  C9 57              CMP   #'W'                 ; Check for Warm start
00A090  2  F0 07              BEQ   EHB_WARM             ; If yes, go Warm start
00A092  2  A9 07              LDA   #$07                 ; Get bell character
00A094  2  20 44 A9           JSR   B_CHROUT             ; Else, beep for entry error
00A097  2  80 E6              BRA   EHB_TRY2             ; Branch back and try again
00A099  2               
00A099  2               EHB_WARM
00A099  2  4C 00 00           JMP   $0000                ; Warm start soft vector
00A09C  2               
00A09C  2               EHB_COLD
00A09C  2  4C 03 80           JMP   LAB_COLD             ; Cold start routine
00A09F  2               
00A09F  2               LAB_CSMSG
00A09F  2  0D 0A              .byte $0D,$0A
00A0A1  2  36 35 43 30        .byte "65C02 Enhanced BASIC Version 2.22p5C02"
00A0A5  2  32 20 45 6E  
00A0A9  2  68 61 6E 63  
00A0C7  2  0D 0A              .byte $0D,$0A
00A0C9  2  20 5B 43 5D        .byte " [C]old/[W]arm start? ",$00
00A0CD  2  6F 6C 64 2F  
00A0D1  2  5B 57 5D 61  
00A0E0  2               
00A0E0  2               LAB_SMSG
00A0E0  2  20 42 79 74        .byte " Bytes free",$00
00A0E4  2  65 73 20 66  
00A0E8  2  72 65 65 00  
00A0EC  2               
00A0EC  2               ; numeric constants and series
00A0EC  2               ; cleaned up to removed commented lines which were replaced
00A0EC  2               
00A0EC  2                                             ; constants and series for LOG(n)
00A0EC  2               LAB_25A0
00A0EC  2  02                 .byte $02               ; counter
00A0ED  2  80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
00A0F1  2  80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
00A0F5  2  82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
00A0F9  2               
00A0F9  2               LAB_25AD
00A0F9  2  80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
00A0FD  2               LAB_25B1
00A0FD  2  81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
00A101  2               LAB_25B5
00A101  2  80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
00A105  2               LAB_25B9
00A105  2  80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
00A109  2               
00A109  2                                             ; numeric PRINT constants
00A109  2               LAB_2947
00A109  2  91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
00A10D  2               LAB_294B
00A10D  2  94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
00A111  2               LAB_294F
00A111  2  94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
00A115  2               
00A115  2                                             ; EXP(n) constants and series
00A115  2               LAB_2AFA
00A115  2  81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427 (1/LOG base 2 e)
00A119  2               LAB_2AFE
00A119  2  06                 .byte $06               ; counter
00A11A  2  74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
00A11E  2  77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
00A122  2  7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
00A126  2  7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
00A12A  2  7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
00A12E  2  80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
00A132  2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
00A136  2               
00A136  2                                             ; trigonometric constants and series
00A136  2               LAB_2C78
00A136  2  81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
00A13A  2               LAB_2C84
00A13A  2  04                 .byte $04               ; counter
00A13B  2  86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
00A13F  2  87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
00A143  2  87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
00A147  2  86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
00A14B  2               LAB_2C7C
00A14B  2  83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
00A14F  2               
00A14F  2               LAB_2CC9
00A14F  2  08                 .byte $08               ; counter
00A150  2  78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
00A154  2  7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
00A158  2  7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
00A15C  2  7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
00A160  2  7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
00A164  2  7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
00A168  2  7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
00A16C  2  7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
00A170  2               
00A170  2               LAB_1D96    = *+1          ; $00,$00 used for undefined variables
00A170  2               LAB_259C
00A170  2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
00A174  2               LAB_2AFD
00A174  2  81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC, must be on the same page as +1.00
00A178  2               
00A178  2                                             ; misc constants
00A178  2               LAB_1DF7
00A178  2  90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
00A179  2               LAB_2A96
00A179  2  80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
00A17D  2               LAB_2C80
00A17D  2  7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
00A181  2               LAB_26B5
00A181  2  84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
00A185  2               
00A185  2               ; This table is used in converting numbers to ASCII.
00A185  2               
00A185  2               LAB_2A9A
00A185  2               LAB_2A9B = LAB_2A9A+1
00A185  2               LAB_2A9C = LAB_2A9B+1
00A185  2  FE 79 60           .byte $FE,$79,$60       ; -100000
00A188  2  00 27 10           .byte $00,$27,$10       ; 10000
00A18B  2  FF FC 18           .byte $FF,$FC,$18       ; -1000
00A18E  2  00 00 64           .byte $00,$00,$64       ; 100
00A191  2  FF FF F6           .byte $FF,$FF,$F6       ; -10
00A194  2  00 00 01           .byte $00,$00,$01       ; 1
00A197  2               
00A197  2               LAB_CTBL
00A197  2  DF 84              .word LAB_END-1         ; END
00A199  2  20 84              .word LAB_FOR-1         ; FOR
00A19B  2  FE 89              .word LAB_NEXT-1        ; NEXT
00A19D  2  42 86              .word LAB_DATA-1        ; DATA
00A19F  2  E6 88              .word LAB_INPUT-1       ; INPUT
00A1A1  2  00 8D              .word LAB_DIM-1         ; DIM
00A1A3  2  05 89              .word LAB_READ-1        ; READ
00A1A5  2  5D 87              .word LAB_LET-1         ; LET
00A1A7  2  2F 87              .word LAB_DEC-1         ; DEC new command
00A1A9  2  A1 85              .word LAB_GOTO-1        ; GOTO
00A1AB  2  60 85              .word LAB_RUN-1         ; RUN
00A1AD  2  71 86              .word LAB_IF-1          ; IF
00A1AF  2  00 85              .word LAB_RESTORE-1     ; RESTORE modified command
00A1B1  2  84 85              .word LAB_GOSUB-1       ; GOSUB
00A1B3  2  2D 86              .word LAB_RETURN-1      ; RETURN
00A1B5  2  D6 86              .word LAB_REM-1         ; REM
00A1B7  2  DD 84              .word LAB_STOP-1        ; STOP
00A1B9  2  DF 86              .word LAB_ON-1          ; ON modified command
00A1BB  2  3E 85              .word LAB_NULL-1        ; NULL modified command
00A1BD  2  33 87              .word LAB_INC-1         ; INC new command
00A1BF  2  15 95              .word LAB_WAIT-1        ; WAIT
00A1C1  2  CF 9F              .word LAB_LOAD-1        ; LOAD
00A1C3  2  F8 9F              .word LAB_SAVE-1        ; SAVE
00A1C5  2  12 90              .word LAB_DEF-1         ; DEF
00A1C7  2  9A 94              .word LAB_POKE-1        ; POKE
00A1C9  2  B6 94              .word LAB_DOKE-1        ; DOKE new command
00A1CB  2  03 95              .word LAB_CALL-1        ; CALL new command
00A1CD  2  6A 85              .word LAB_DO-1          ; DO new command
00A1CF  2  D3 85              .word LAB_LOOP-1        ; LOOP new command
00A1D1  2  F8 87              .word LAB_PRINT-1       ; PRINT
00A1D3  2  44 85              .word LAB_CONT-1        ; CONT
00A1D5  2  6B 83              .word LAB_LIST-1        ; LIST
00A1D7  2  68 83              .word LAB_CLEAR-1       ; CLEAR
00A1D9  2  1B 83              .word LAB_NEW-1         ; NEW
00A1DB  2  B2 9E              .word LAB_WDTH-1        ; WIDTH new command
00A1DD  2  CA 87              .word LAB_GET-1         ; GET new command
00A1DF  2  DB 94              .word LAB_SWAP-1        ; SWAP new command
00A1E1  2  F1 9C              .word LAB_BITSET-1      ; BITSET new command
00A1E3  2  05 9D              .word LAB_BITCLR-1      ; BITCLR new command
00A1E5  2  49 A0              .word V_EXIT-1          ; EXIT new command (exits to C02 Monitor)
00A1E7  2               
00A1E7  2               ; function pre process routine table
00A1E7  2               
00A1E7  2               LAB_FTPL
00A1E7  2               LAB_FTPM    = LAB_FTPL+$01
00A1E7  2  0B 8C              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
00A1E9  2  0B 8C              .word LAB_PPFN-1        ; INT(n)          "
00A1EB  2  0B 8C              .word LAB_PPFN-1        ; ABS(n)          "
00A1ED  2  83 8A              .word LAB_EVEZ-1        ; USR(x)    process any expression
00A1EF  2  87 8B              .word LAB_1BF7-1        ; FRE(x)          "
00A1F1  2  87 8B              .word LAB_1BF7-1        ; POS(x)          "
00A1F3  2  0B 8C              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
00A1F5  2  0B 8C              .word LAB_PPFN-1        ; RND(n)          "
00A1F7  2  0B 8C              .word LAB_PPFN-1        ; LOG(n)          "
00A1F9  2  0B 8C              .word LAB_PPFN-1        ; EXP(n)          "
00A1FB  2  0B 8C              .word LAB_PPFN-1        ; COS(n)          "
00A1FD  2  0B 8C              .word LAB_PPFN-1        ; SIN(n)          "
00A1FF  2  0B 8C              .word LAB_PPFN-1        ; TAN(n)          "
00A201  2  0B 8C              .word LAB_PPFN-1        ; ATN(n)          "
00A203  2  0B 8C              .word LAB_PPFN-1        ; PEEK(n)         "
00A205  2  0B 8C              .word LAB_PPFN-1        ; DEEK(n)         "
00A207  2  00 00              .word $0000             ; SADD()    none
00A209  2  05 8C              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
00A20B  2  0B 8C              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
00A20D  2  05 8C              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
00A20F  2  05 8C              .word LAB_PPFS-1        ; ASC($)          "
00A211  2  05 8C              .word LAB_PPFS-1        ; UCASE$($)       "
00A213  2  05 8C              .word LAB_PPFS-1        ; LCASE$($)       "
00A215  2  0B 8C              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
00A217  2  2E 8C              .word LAB_BHSS-1        ; HEX$(n)         "
00A219  2  2E 8C              .word LAB_BHSS-1        ; BIN$(n)         "
00A21B  2  00 00              .word $0000             ; BITTST()  none
00A21D  2  49 9E              .word LAB_MMPP-1        ; MAX()     process numeric expression
00A21F  2  49 9E              .word LAB_MMPP-1        ; MIN()           "
00A221  2  11 8C              .word LAB_PPBI-1        ; PI        advance pointer
00A223  2  11 8C              .word LAB_PPBI-1        ; TWOPI           "
00A225  2  00 00              .word $0000             ; VARPTR()  none
00A227  2  16 8C              .word LAB_LRMS-1        ; LEFT$()   process string expression
00A229  2  16 8C              .word LAB_LRMS-1        ; RIGHT$()        "
00A22B  2  16 8C              .word LAB_LRMS-1        ; MID$()          "
00A22D  2               
00A22D  2               ; action addresses for functions
00A22D  2               
00A22D  2               LAB_FTBL
00A22D  2               LAB_FTBM    = LAB_FTBL+$01
00A22D  2  7B 98              .word LAB_SGN-1         ; SGN()
00A22F  2  00 99              .word LAB_INT-1         ; INT()
00A231  2  94 98              .word LAB_ABS-1         ; ABS()
00A233  2  BC 9C              .word LAB_USR-1         ; USR()
00A235  2  E3 8F              .word LAB_FRE-1         ; FRE()
00A237  2  02 90              .word LAB_POS-1         ; POS()
00A239  2  08 9F              .word LAB_SQR-1         ; SQR()
00A23B  2  13 9C              .word LAB_RND-1         ; RND() modified function
00A23D  2  82 96              .word LAB_LOG-1         ; LOG()
00A23F  2  77 9B              .word LAB_EXP-1         ; EXP()
00A241  2  47 9C              .word LAB_COS-1         ; COS()
00A243  2  4E 9C              .word LAB_SIN-1         ; SIN()
00A245  2  95 9C              .word LAB_TAN-1         ; TAN()
00A247  2  C2 9C              .word LAB_ATN-1         ; ATN()
00A249  2  8F 94              .word LAB_PEEK-1        ; PEEK()
00A24B  2  A3 94              .word LAB_DEEK-1        ; DEEK() new function
00A24D  2  EB 93              .word LAB_SADD-1        ; SADD() new function
00A24F  2  04 94              .word LAB_LENS-1        ; LEN()
00A251  2  C0 90              .word LAB_STRS-1        ; STR$()
00A253  2  2F 94              .word LAB_VAL-1         ; VAL()
00A255  2  0F 94              .word LAB_ASC-1         ; ASC()
00A257  2  C9 93              .word LAB_UCASE-1       ; UCASE$() new function
00A259  2  A8 93              .word LAB_LCASE-1       ; LCASE$()  new function
00A25B  2  1F 93              .word LAB_CHRS-1        ; CHR$()
00A25D  2  92 9D              .word LAB_HEXS-1        ; HEX$() new function
00A25F  2  43 9D              .word LAB_BINS-1        ; BIN$() new function
00A261  2  1B 9D              .word LAB_BTST-1        ; BITTST() new function
00A263  2  4F 9E              .word LAB_MAX-1         ; MAX() new function
00A265  2  5F 9E              .word LAB_MIN-1         ; MIN() new function
00A267  2  A3 9F              .word LAB_PI-1          ; PI new function
00A269  2  AD 9F              .word LAB_TWOPI-1       ; TWOPI new function
00A26B  2  93 9F              .word LAB_VARPTR-1      ; VARPTR() new function
00A26D  2  2E 93              .word LAB_LEFT-1        ; LEFT$()
00A26F  2  37 93              .word LAB_RIGHT-1       ; RIGHT$()
00A271  2  65 93              .word LAB_MIDS-1        ; MID$()
00A273  2               
00A273  2               ; hierarchy and action addresses for operator
00A273  2               
00A273  2               LAB_OPPT
00A273  2  79                 .byte $79               ; +
00A274  2  4C 95              .word LAB_ADD-1
00A276  2  79                 .byte $79               ; -
00A277  2  32 95              .word LAB_SUBTRACT-1
00A279  2  7B                 .byte $7B               ; *
00A27A  2  C3 96              .word LAB_MULTIPLY-1
00A27C  2  7B                 .byte $7B               ; /
00A27D  2  89 97              .word LAB_DIVIDE-1
00A27F  2  7F                 .byte $7F               ; ^
00A280  2  33 9B              .word LAB_POWER-1
00A282  2  50                 .byte $50               ; AND
00A283  2  77 8C              .word LAB_AND-1
00A285  2  46                 .byte $46               ; EOR new operator
00A286  2  5D 8C              .word LAB_EOR-1
00A288  2  46                 .byte $46               ; OR
00A289  2  6A 8C              .word LAB_OR-1
00A28B  2  56                 .byte $56               ; >> new operator
00A28C  2  22 8D              .word LAB_RSHIFT-1
00A28E  2  56                 .byte $56               ; << new operator
00A28F  2  0A 8D              .word LAB_LSHIFT-1
00A291  2  7D                 .byte $7D               ; >
00A292  2  6C 9B              .word LAB_GTHAN-1
00A294  2  5A                 .byte $5A               ; =
00A295  2  B0 8B              .word LAB_EQUAL-1
00A297  2  64                 .byte $64               ; <
00A298  2  98 8C              .word LAB_LTHAN-1
00A29A  2               
00A29A  2               ; keywords start with ..
00A29A  2               ; this is the first character table and must be in alphabetic order
00A29A  2               
00A29A  2               TAB_1STC
00A29A  2  2A                 .byte "*"
00A29B  2  2B                 .byte "+"
00A29C  2  2D                 .byte "-"
00A29D  2  2F                 .byte "/"
00A29E  2  3C                 .byte "<"
00A29F  2  3D                 .byte "="
00A2A0  2  3E                 .byte ">"
00A2A1  2  3F                 .byte "?"
00A2A2  2  41                 .byte "A"
00A2A3  2  42                 .byte "B"
00A2A4  2  43                 .byte "C"
00A2A5  2  44                 .byte "D"
00A2A6  2  45                 .byte "E"
00A2A7  2  46                 .byte "F"
00A2A8  2  47                 .byte "G"
00A2A9  2  48                 .byte "H"
00A2AA  2  49                 .byte "I"
00A2AB  2  4C                 .byte "L"
00A2AC  2  4D                 .byte "M"
00A2AD  2  4E                 .byte "N"
00A2AE  2  4F                 .byte "O"
00A2AF  2  50                 .byte "P"
00A2B0  2  52                 .byte "R"
00A2B1  2  53                 .byte "S"
00A2B2  2  54                 .byte "T"
00A2B3  2  55                 .byte "U"
00A2B4  2  56                 .byte "V"
00A2B5  2  57                 .byte "W"
00A2B6  2  5E                 .byte "^"
00A2B7  2  00                 .byte $00               ; table terminator
00A2B8  2               
00A2B8  2               ; pointers to keyword tables
00A2B8  2               
00A2B8  2               TAB_CHRT
00A2B8  2  F2 A2              .word TAB_STAR          ; table for "*"
00A2BA  2  F4 A2              .word TAB_PLUS          ; table for "+"
00A2BC  2  F6 A2              .word TAB_MNUS          ; table for "-"
00A2BE  2  F8 A2              .word TAB_SLAS          ; table for "/"
00A2C0  2  FA A2              .word TAB_LESS          ; table for "<"
00A2C2  2  FE A2              .word TAB_EQUL          ; table for "="
00A2C4  2  00 A3              .word TAB_MORE          ; table for ">"
00A2C6  2  04 A3              .word TAB_QEST          ; table for "?"
00A2C8  2  06 A3              .word TAB_ASCA          ; table for "A"
00A2CA  2  16 A3              .word TAB_ASCB          ; table for "B"
00A2CC  2  2F A3              .word TAB_ASCC          ; table for "C"
00A2CE  2  46 A3              .word TAB_ASCD          ; table for "D"
00A2D0  2  5F A3              .word TAB_ASCE          ; table for "E"
00A2D2  2  72 A3              .word TAB_ASCF          ; table for "F"
00A2D4  2  7C A3              .word TAB_ASCG          ; table for "G"
00A2D6  2  89 A3              .word TAB_ASCH          ; table for "H"
00A2D8  2  8F A3              .word TAB_ASCI          ; table for "I"
00A2DA  2  9E A3              .word TAB_ASCL          ; table for "L"
00A2DC  2  C3 A3              .word TAB_ASCM          ; table for "M"
00A2DE  2  D1 A3              .word TAB_ASCN          ; table for "N"
00A2E0  2  E0 A3              .word TAB_ASCO          ; table for "O"
00A2E2  2  E5 A3              .word TAB_ASCP          ; table for "P"
00A2E4  2  FA A3              .word TAB_ASCR          ; table for "R"
00A2E6  2  1D A4              .word TAB_ASCS          ; table for "S"
00A2E8  2  48 A4              .word TAB_ASCT          ; table for "T"
00A2EA  2  5C A4              .word TAB_ASCU          ; table for "U"
00A2EC  2  6D A4              .word TAB_ASCV          ; table for "V"
00A2EE  2  79 A4              .word TAB_ASCW          ; table for "W"
00A2F0  2  88 A4              .word TAB_POWR          ; table for "^"
00A2F2  2               
00A2F2  2               ; tables for each start character, note if a longer keyword with the same start
00A2F2  2               ; letters as a shorter one exists then it must come first, else the list is in
00A2F2  2               ; alphabetical order as follows ..
00A2F2  2               
00A2F2  2               ; [keyword,token
00A2F2  2               ; [keyword,token]]
00A2F2  2               ; end marker (#$00)
00A2F2  2               
00A2F2  2               TAB_STAR
00A2F2  2  B4 00              .byte TK_MUL,$00        ; *
00A2F4  2               TAB_PLUS
00A2F4  2  B2 00              .byte TK_PLUS,$00       ; +
00A2F6  2               TAB_MNUS
00A2F6  2  B3 00              .byte TK_MINUS,$00      ; -
00A2F8  2               TAB_SLAS
00A2F8  2  B5 00              .byte TK_DIV,$00        ; /
00A2FA  2               TAB_LESS
00A2FA  2               LBB_LSHIFT
00A2FA  2  3C BB              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
00A2FC  2  BE                 .byte TK_LT             ; <
00A2FD  2  00                 .byte $00
00A2FE  2               TAB_EQUL
00A2FE  2  BD 00              .byte TK_EQUAL,$00      ; =
00A300  2               TAB_MORE
00A300  2               LBB_RSHIFT
00A300  2  3E BA              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
00A302  2  BC                 .byte TK_GT             ; >
00A303  2  00                 .byte $00
00A304  2               TAB_QEST
00A304  2  9D 00              .byte TK_PRINT,$00      ; ?
00A306  2               TAB_ASCA
00A306  2               LBB_ABS
00A306  2  42 53 28 C1        .byte "BS(",TK_ABS      ; ABS(
00A30A  2               LBB_AND
00A30A  2  4E 44 B7           .byte "ND",TK_AND       ; AND
00A30D  2               LBB_ASC
00A30D  2  53 43 28 D3        .byte "SC(",TK_ASC      ; ASC(
00A311  2               LBB_ATN
00A311  2  54 4E 28 CC        .byte "TN(",TK_ATN      ; ATN(
00A315  2  00                 .byte $00
00A316  2               TAB_ASCB
00A316  2               LBB_BINS
00A316  2  49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
00A31A  2  D8           
00A31B  2               LBB_BITCLR
00A31B  2  49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
00A31F  2  52 A6        
00A321  2               LBB_BITSET
00A321  2  49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
00A325  2  54 A5        
00A327  2               LBB_BITTST
00A327  2  49 54 54 53        .byte "ITTST(",TK_BITTST
00A32B  2  54 28 D9     
00A32E  2                                             ; BITTST(
00A32E  2  00                 .byte $00
00A32F  2               TAB_ASCC
00A32F  2               LBB_CALL
00A32F  2  41 4C 4C 9A        .byte "ALL",TK_CALL     ; CALL
00A333  2               LBB_CHRS
00A333  2  48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
00A337  2  D6           
00A338  2               LBB_CLEAR
00A338  2  4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
00A33C  2  A0           
00A33D  2               LBB_CONT
00A33D  2  4F 4E 54 9E        .byte "ONT",TK_CONT     ; CONT
00A341  2               LBB_COS
00A341  2  4F 53 28 C9        .byte "OS(",TK_COS      ; COS(
00A345  2  00                 .byte $00
00A346  2               TAB_ASCD
00A346  2               LBB_DATA
00A346  2  41 54 41 83        .byte "ATA",TK_DATA     ; DATA
00A34A  2               LBB_DEC
00A34A  2  45 43 88           .byte "EC",TK_DEC       ; DEC
00A34D  2               LBB_DEEK
00A34D  2  45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
00A351  2  CE           
00A352  2               LBB_DEF
00A352  2  45 46 97           .byte "EF",TK_DEF       ; DEF
00A355  2               LBB_DIM
00A355  2  49 4D 85           .byte "IM",TK_DIM       ; DIM
00A358  2               LBB_DOKE
00A358  2  4F 4B 45 99        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
00A35C  2               LBB_DO
00A35C  2  4F 9B              .byte "O",TK_DO         ; DO
00A35E  2  00                 .byte $00
00A35F  2               TAB_ASCE
00A35F  2               LBB_ELSE
00A35F  2  4C 53 45 A9        .byte "LSE",TK_ELSE     ; ELSE
00A363  2               LBB_END
00A363  2  4E 44 80           .byte "ND",TK_END       ; END
00A366  2               LBB_EOR
00A366  2  4F 52 B8           .byte "OR",TK_EOR       ; EOR
00A369  2               LBB_EXP
00A369  2  58 50 28 C8        .byte "XP(",TK_EXP      ; EXP(
00A36D  2               LBB_EXIT
00A36D  2  58 49 54 A7        .byte "XIT",TK_EXIT     ; EXIT
00A371  2  00                 .byte $00
00A372  2               TAB_ASCF
00A372  2               LBB_FN
00A372  2  4E AB              .byte "N",TK_FN         ; FN
00A374  2               LBB_FOR
00A374  2  4F 52 81           .byte "OR",TK_FOR       ; FOR
00A377  2               LBB_FRE
00A377  2  52 45 28 C3        .byte "RE(",TK_FRE      ; FRE(
00A37B  2  00                 .byte $00
00A37C  2               TAB_ASCG
00A37C  2               LBB_GET
00A37C  2  45 54 A3           .byte "ET",TK_GET       ; GET
00A37F  2               LBB_GOSUB
00A37F  2  4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
00A383  2  8D           
00A384  2               LBB_GOTO
00A384  2  4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
00A388  2  00                 .byte $00
00A389  2               TAB_ASCH
00A389  2               LBB_HEXS
00A389  2  45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
00A38D  2  D7           
00A38E  2  00                 .byte $00
00A38F  2               TAB_ASCI
00A38F  2               LBB_IF
00A38F  2  46 8B              .byte "F",TK_IF         ; IF
00A391  2               LBB_INC
00A391  2  4E 43 93           .byte "NC",TK_INC       ; INC
00A394  2               LBB_INPUT
00A394  2  4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
00A398  2  84           
00A399  2               LBB_INT
00A399  2  4E 54 28 C0        .byte "NT(",TK_INT      ; INT(
00A39D  2  00                 .byte $00
00A39E  2               TAB_ASCL
00A39E  2               LBB_LCASES
00A39E  2  43 41 53 45        .byte "CASE$(",TK_LCASES
00A3A2  2  24 28 D5     
00A3A5  2                                             ; LCASE$(
00A3A5  2               LBB_LEFTS
00A3A5  2  45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
00A3A9  2  28 DF        
00A3AB  2               LBB_LEN
00A3AB  2  45 4E 28 D0        .byte "EN(",TK_LEN      ; LEN(
00A3AF  2               LBB_LET
00A3AF  2  45 54 87           .byte "ET",TK_LET       ; LET
00A3B2  2               LBB_LIST
00A3B2  2  49 53 54 9F        .byte "IST",TK_LIST     ; LIST
00A3B6  2               LBB_LOAD
00A3B6  2  4F 41 44 95        .byte "OAD",TK_LOAD     ; LOAD
00A3BA  2               LBB_LOG
00A3BA  2  4F 47 28 C7        .byte "OG(",TK_LOG      ; LOG(
00A3BE  2               LBB_LOOP
00A3BE  2  4F 4F 50 9C        .byte "OOP",TK_LOOP     ; LOOP
00A3C2  2  00                 .byte $00
00A3C3  2               TAB_ASCM
00A3C3  2               LBB_MAX
00A3C3  2  41 58 28 DA        .byte "AX(",TK_MAX      ; MAX(
00A3C7  2               LBB_MIDS
00A3C7  2  49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
00A3CB  2  E1           
00A3CC  2               LBB_MIN
00A3CC  2  49 4E 28 DB        .byte "IN(",TK_MIN      ; MIN(
00A3D0  2  00                 .byte $00
00A3D1  2               TAB_ASCN
00A3D1  2               LBB_NEW
00A3D1  2  45 57 A1           .byte "EW",TK_NEW       ; NEW
00A3D4  2               LBB_NEXT
00A3D4  2  45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
00A3D8  2               LBB_NOT
00A3D8  2  4F 54 AE           .byte "OT",TK_NOT       ; NOT
00A3DB  2               LBB_NULL
00A3DB  2  55 4C 4C 92        .byte "ULL",TK_NULL     ; NULL
00A3DF  2  00                 .byte $00
00A3E0  2               TAB_ASCO
00A3E0  2               LBB_ON
00A3E0  2  4E 91              .byte "N",TK_ON         ; ON
00A3E2  2               LBB_OR
00A3E2  2  52 B9              .byte "R",TK_OR         ; OR
00A3E4  2  00                 .byte $00
00A3E5  2               TAB_ASCP
00A3E5  2               LBB_PEEK
00A3E5  2  45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
00A3E9  2  CD           
00A3EA  2               LBB_PI
00A3EA  2  49 DC              .byte "I",TK_PI         ; PI
00A3EC  2               LBB_POKE
00A3EC  2  4F 4B 45 98        .byte "OKE",TK_POKE     ; POKE
00A3F0  2               LBB_POS
00A3F0  2  4F 53 28 C4        .byte "OS(",TK_POS      ; POS(
00A3F4  2               LBB_PRINT
00A3F4  2  52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
00A3F8  2  9D           
00A3F9  2  00                 .byte $00
00A3FA  2               TAB_ASCR
00A3FA  2               LBB_READ
00A3FA  2  45 41 44 86        .byte "EAD",TK_READ     ; READ
00A3FE  2               LBB_REM
00A3FE  2  45 4D 8F           .byte "EM",TK_REM       ; REM
00A401  2               LBB_RESTORE
00A401  2  45 53 54 4F        .byte "ESTORE",TK_RESTORE
00A405  2  52 45 8C     
00A408  2                                             ; RESTORE
00A408  2               LBB_RETURN
00A408  2  45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
00A40C  2  4E 8E        
00A40E  2               LBB_RIGHTS
00A40E  2  49 47 48 54        .byte "IGHT$(",TK_RIGHTS
00A412  2  24 28 E0     
00A415  2                                             ; RIGHT$(
00A415  2               LBB_RND
00A415  2  4E 44 28 C6        .byte "ND(",TK_RND      ; RND(
00A419  2               LBB_RUN
00A419  2  55 4E 8A           .byte "UN",TK_RUN       ; RUN
00A41C  2  00                 .byte $00
00A41D  2               TAB_ASCS
00A41D  2               LBB_SADD
00A41D  2  41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
00A421  2  CF           
00A422  2               LBB_SAVE
00A422  2  41 56 45 96        .byte "AVE",TK_SAVE     ; SAVE
00A426  2               LBB_SGN
00A426  2  47 4E 28 BF        .byte "GN(",TK_SGN      ; SGN(
00A42A  2               LBB_SIN
00A42A  2  49 4E 28 CA        .byte "IN(",TK_SIN      ; SIN(
00A42E  2               LBB_SPC
00A42E  2  50 43 28 AC        .byte "PC(",TK_SPC      ; SPC(
00A432  2               LBB_SQR
00A432  2  51 52 28 C5        .byte "QR(",TK_SQR      ; SQR(
00A436  2               LBB_STEP
00A436  2  54 45 50 AF        .byte "TEP",TK_STEP     ; STEP
00A43A  2               LBB_STOP
00A43A  2  54 4F 50 90        .byte "TOP",TK_STOP     ; STOP
00A43E  2               LBB_STRS
00A43E  2  54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
00A442  2  D1           
00A443  2               LBB_SWAP
00A443  2  57 41 50 A4        .byte "WAP",TK_SWAP     ; SWAP
00A447  2  00                 .byte $00
00A448  2               TAB_ASCT
00A448  2               LBB_TAB
00A448  2  41 42 28 A8        .byte "AB(",TK_TAB      ; TAB(
00A44C  2               LBB_TAN
00A44C  2  41 4E 28 CB        .byte "AN(",TK_TAN      ; TAN(
00A450  2               LBB_THEN
00A450  2  48 45 4E AD        .byte "HEN",TK_THEN     ; THEN
00A454  2               LBB_TO
00A454  2  4F AA              .byte "O",TK_TO         ; TO
00A456  2               LBB_TWOPI
00A456  2  57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
00A45A  2  DD           
00A45B  2  00                 .byte $00
00A45C  2               TAB_ASCU
00A45C  2               LBB_UCASES
00A45C  2  43 41 53 45        .byte "CASE$(",TK_UCASES
00A460  2  24 28 D4     
00A463  2                                             ; UCASE$(
00A463  2               LBB_UNTIL
00A463  2  4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
00A467  2  B0           
00A468  2               LBB_USR
00A468  2  53 52 28 C2        .byte "SR(",TK_USR      ; USR(
00A46C  2  00                 .byte $00
00A46D  2               TAB_ASCV
00A46D  2               LBB_VAL
00A46D  2  41 4C 28 D2        .byte "AL(",TK_VAL      ; VAL(
00A471  2               LBB_VPTR
00A471  2  41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
00A475  2  52 28 DE     
00A478  2  00                 .byte $00
00A479  2               TAB_ASCW
00A479  2               LBB_WAIT
00A479  2  41 49 54 94        .byte "AIT",TK_WAIT     ; WAIT
00A47D  2               LBB_WHILE
00A47D  2  48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
00A481  2  B1           
00A482  2               LBB_WIDTH
00A482  2  49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
00A486  2  A2           
00A487  2  00                 .byte $00
00A488  2               TAB_POWR
00A488  2  B6 00              .byte TK_POWER,$00      ; ^
00A48A  2               
00A48A  2               ; new decode table for LIST
00A48A  2               ; Table is ..
00A48A  2               ; byte - keyword length, keyword first character
00A48A  2               ; word - pointer to rest of keyword from dictionary
00A48A  2               
00A48A  2               ; note if length is 1 then the pointer is ignored
00A48A  2               
00A48A  2               LAB_KEYT
00A48A  2  03 45              .byte 3,'E'
00A48C  2  63 A3              .word LBB_END           ; END
00A48E  2  03 46              .byte 3,'F'
00A490  2  74 A3              .word LBB_FOR           ; FOR
00A492  2  04 4E              .byte 4,'N'
00A494  2  D4 A3              .word LBB_NEXT          ; NEXT
00A496  2  04 44              .byte 4,'D'
00A498  2  46 A3              .word LBB_DATA          ; DATA
00A49A  2  05 49              .byte 5,'I'
00A49C  2  94 A3              .word LBB_INPUT         ; INPUT
00A49E  2  03 44              .byte 3,'D'
00A4A0  2  55 A3              .word LBB_DIM           ; DIM
00A4A2  2  04 52              .byte 4,'R'
00A4A4  2  FA A3              .word LBB_READ          ; READ
00A4A6  2  03 4C              .byte 3,'L'
00A4A8  2  AF A3              .word LBB_LET           ; LET
00A4AA  2  03 44              .byte 3,'D'
00A4AC  2  4A A3              .word LBB_DEC           ; DEC
00A4AE  2  04 47              .byte 4,'G'
00A4B0  2  84 A3              .word LBB_GOTO          ; GOTO
00A4B2  2  03 52              .byte 3,'R'
00A4B4  2  19 A4              .word LBB_RUN           ; RUN
00A4B6  2  02 49              .byte 2,'I'
00A4B8  2  8F A3              .word LBB_IF            ; IF
00A4BA  2  07 52              .byte 7,'R'
00A4BC  2  01 A4              .word LBB_RESTORE       ; RESTORE
00A4BE  2  05 47              .byte 5,'G'
00A4C0  2  7F A3              .word LBB_GOSUB         ; GOSUB
00A4C2  2  06 52              .byte 6,'R'
00A4C4  2  08 A4              .word LBB_RETURN        ; RETURN
00A4C6  2  03 52              .byte 3,'R'
00A4C8  2  FE A3              .word LBB_REM           ; REM
00A4CA  2  04 53              .byte 4,'S'
00A4CC  2  3A A4              .word LBB_STOP          ; STOP
00A4CE  2  02 4F              .byte 2,'O'
00A4D0  2  E0 A3              .word LBB_ON            ; ON
00A4D2  2  04 4E              .byte 4,'N'
00A4D4  2  DB A3              .word LBB_NULL          ; NULL
00A4D6  2  03 49              .byte 3,'I'
00A4D8  2  91 A3              .word LBB_INC           ; INC
00A4DA  2  04 57              .byte 4,'W'
00A4DC  2  79 A4              .word LBB_WAIT          ; WAIT
00A4DE  2  04 4C              .byte 4,'L'
00A4E0  2  B6 A3              .word LBB_LOAD          ; LOAD
00A4E2  2  04 53              .byte 4,'S'
00A4E4  2  22 A4              .word LBB_SAVE          ; SAVE
00A4E6  2  03 44              .byte 3,'D'
00A4E8  2  52 A3              .word LBB_DEF           ; DEF
00A4EA  2  04 50              .byte 4,'P'
00A4EC  2  EC A3              .word LBB_POKE          ; POKE
00A4EE  2  04 44              .byte 4,'D'
00A4F0  2  58 A3              .word LBB_DOKE          ; DOKE
00A4F2  2  04 43              .byte 4,'C'
00A4F4  2  2F A3              .word LBB_CALL          ; CALL
00A4F6  2  02 44              .byte 2,'D'
00A4F8  2  5C A3              .word LBB_DO            ; DO
00A4FA  2  04 4C              .byte 4,'L'
00A4FC  2  BE A3              .word LBB_LOOP          ; LOOP
00A4FE  2  05 50              .byte 5,'P'
00A500  2  F4 A3              .word LBB_PRINT         ; PRINT
00A502  2  04 43              .byte 4,'C'
00A504  2  3D A3              .word LBB_CONT          ; CONT
00A506  2  04 4C              .byte 4,'L'
00A508  2  B2 A3              .word LBB_LIST          ; LIST
00A50A  2  05 43              .byte 5,'C'
00A50C  2  38 A3              .word LBB_CLEAR         ; CLEAR
00A50E  2  03 4E              .byte 3,'N'
00A510  2  D1 A3              .word LBB_NEW           ; NEW
00A512  2  05 57              .byte 5,'W'
00A514  2  82 A4              .word LBB_WIDTH         ; WIDTH
00A516  2  03 47              .byte 3,'G'
00A518  2  7C A3              .word LBB_GET           ; GET
00A51A  2  04 53              .byte 4,'S'
00A51C  2  43 A4              .word LBB_SWAP          ; SWAP
00A51E  2  06 42              .byte 6,'B'
00A520  2  21 A3              .word LBB_BITSET        ; BITSET
00A522  2  06 42              .byte 6,'B'
00A524  2  1B A3              .word LBB_BITCLR        ; BITCLR
00A526  2  04 45              .byte 4,"E"
00A528  2  6D A3              .word LBB_EXIT          ; EXIT
00A52A  2               
00A52A  2               ; secondary commands (can't start a statement)
00A52A  2               
00A52A  2  04 54              .byte 4,'T'
00A52C  2  48 A4              .word LBB_TAB           ; TAB
00A52E  2  04 45              .byte 4,'E'
00A530  2  5F A3              .word LBB_ELSE          ; ELSE
00A532  2  02 54              .byte 2,'T'
00A534  2  54 A4              .word LBB_TO            ; TO
00A536  2  02 46              .byte 2,'F'
00A538  2  72 A3              .word LBB_FN            ; FN
00A53A  2  04 53              .byte 4,'S'
00A53C  2  2E A4              .word LBB_SPC           ; SPC
00A53E  2  04 54              .byte 4,'T'
00A540  2  50 A4              .word LBB_THEN          ; THEN
00A542  2  03 4E              .byte 3,'N'
00A544  2  D8 A3              .word LBB_NOT           ; NOT
00A546  2  04 53              .byte 4,'S'
00A548  2  36 A4              .word LBB_STEP          ; STEP
00A54A  2  05 55              .byte 5,'U'
00A54C  2  63 A4              .word LBB_UNTIL         ; UNTIL
00A54E  2  05 57              .byte 5,'W'
00A550  2  7D A4              .word LBB_WHILE         ; WHILE
00A552  2               
00A552  2               ; opperators
00A552  2               
00A552  2  01 2B              .byte 1,'+'
00A554  2  00 00              .word $0000             ; +
00A556  2  01 2D              .byte 1,'-'
00A558  2  00 00              .word $0000             ; -
00A55A  2  01 2A              .byte 1,'*'
00A55C  2  00 00              .word $0000             ; *
00A55E  2  01 2F              .byte 1,'/'
00A560  2  00 00              .word $0000             ; /
00A562  2  01 5E              .byte 1,'^'
00A564  2  00 00              .word $0000             ; ^
00A566  2  03 41              .byte 3,'A'
00A568  2  0A A3              .word LBB_AND           ; AND
00A56A  2  03 45              .byte 3,'E'
00A56C  2  66 A3              .word LBB_EOR           ; EOR
00A56E  2  02 4F              .byte 2,'O'
00A570  2  E2 A3              .word LBB_OR            ; OR
00A572  2  02 3E              .byte 2,'>'
00A574  2  00 A3              .word LBB_RSHIFT        ; >>
00A576  2  02 3C              .byte 2,'<'
00A578  2  FA A2              .word LBB_LSHIFT        ; <<
00A57A  2  01 3E              .byte 1,'>'
00A57C  2  00 00              .word $0000             ; >
00A57E  2  01 3D              .byte 1,'='
00A580  2  00 00              .word $0000             ; =
00A582  2  01 3C              .byte 1,'<'
00A584  2  00 00              .word $0000             ; <
00A586  2               
00A586  2               ; functions
00A586  2               
00A586  2  04 53              .byte 4,'S'             ;
00A588  2  26 A4              .word LBB_SGN           ; SGN
00A58A  2  04 49              .byte 4,'I'             ;
00A58C  2  99 A3              .word LBB_INT           ; INT
00A58E  2  04 41              .byte 4,'A'             ;
00A590  2  06 A3              .word LBB_ABS           ; ABS
00A592  2  04 55              .byte 4,'U'             ;
00A594  2  68 A4              .word LBB_USR           ; USR
00A596  2  04 46              .byte 4,'F'             ;
00A598  2  77 A3              .word LBB_FRE           ; FRE
00A59A  2  04 50              .byte 4,'P'             ;
00A59C  2  F0 A3              .word LBB_POS           ; POS
00A59E  2  04 53              .byte 4,'S'             ;
00A5A0  2  32 A4              .word LBB_SQR           ; SQR
00A5A2  2  04 52              .byte 4,'R'             ;
00A5A4  2  15 A4              .word LBB_RND           ; RND
00A5A6  2  04 4C              .byte 4,'L'             ;
00A5A8  2  BA A3              .word LBB_LOG           ; LOG
00A5AA  2  04 45              .byte 4,'E'             ;
00A5AC  2  69 A3              .word LBB_EXP           ; EXP
00A5AE  2  04 43              .byte 4,'C'             ;
00A5B0  2  41 A3              .word LBB_COS           ; COS
00A5B2  2  04 53              .byte 4,'S'             ;
00A5B4  2  2A A4              .word LBB_SIN           ; SIN
00A5B6  2  04 54              .byte 4,'T'             ;
00A5B8  2  4C A4              .word LBB_TAN           ; TAN
00A5BA  2  04 41              .byte 4,'A'             ;
00A5BC  2  11 A3              .word LBB_ATN           ; ATN
00A5BE  2  05 50              .byte 5,'P'             ;
00A5C0  2  E5 A3              .word LBB_PEEK          ; PEEK
00A5C2  2  05 44              .byte 5,'D'             ;
00A5C4  2  4D A3              .word LBB_DEEK          ; DEEK
00A5C6  2  05 53              .byte 5,'S'             ;
00A5C8  2  1D A4              .word LBB_SADD          ; SADD
00A5CA  2  04 4C              .byte 4,'L'             ;
00A5CC  2  AB A3              .word LBB_LEN           ; LEN
00A5CE  2  05 53              .byte 5,'S'             ;
00A5D0  2  3E A4              .word LBB_STRS          ; STR$
00A5D2  2  04 56              .byte 4,'V'             ;
00A5D4  2  6D A4              .word LBB_VAL           ; VAL
00A5D6  2  04 41              .byte 4,'A'             ;
00A5D8  2  0D A3              .word LBB_ASC           ; ASC
00A5DA  2  07 55              .byte 7,'U'             ;
00A5DC  2  5C A4              .word LBB_UCASES        ; UCASE$
00A5DE  2  07 4C              .byte 7,'L'             ;
00A5E0  2  9E A3              .word LBB_LCASES        ; LCASE$
00A5E2  2  05 43              .byte 5,'C'             ;
00A5E4  2  33 A3              .word LBB_CHRS          ; CHR$
00A5E6  2  05 48              .byte 5,'H'             ;
00A5E8  2  89 A3              .word LBB_HEXS          ; HEX$
00A5EA  2  05 42              .byte 5,'B'             ;
00A5EC  2  16 A3              .word LBB_BINS          ; BIN$
00A5EE  2  07 42              .byte 7,'B'             ;
00A5F0  2  27 A3              .word LBB_BITTST        ; BITTST
00A5F2  2  04 4D              .byte 4,'M'             ;
00A5F4  2  C3 A3              .word LBB_MAX           ; MAX
00A5F6  2  04 4D              .byte 4,'M'             ;
00A5F8  2  CC A3              .word LBB_MIN           ; MIN
00A5FA  2  02 50              .byte 2,'P'             ;
00A5FC  2  EA A3              .word LBB_PI            ; PI
00A5FE  2  05 54              .byte 5,'T'             ;
00A600  2  56 A4              .word LBB_TWOPI         ; TWOPI
00A602  2  07 56              .byte 7,'V'             ;
00A604  2  71 A4              .word LBB_VPTR          ; VARPTR
00A606  2  06 4C              .byte 6,'L'             ;
00A608  2  A5 A3              .word LBB_LEFTS         ; LEFT$
00A60A  2  07 52              .byte 7,'R'             ;
00A60C  2  0E A4              .word LBB_RIGHTS        ; RIGHT$
00A60E  2  05 4D              .byte 5,'M'             ;
00A610  2  C7 A3              .word LBB_MIDS          ; MID$
00A612  2               
00A612  2               ; BASIC messages, mostly error messages
00A612  2               
00A612  2               LAB_BAER
00A612  2  36 A6              .word ERR_NF            ;$00 NEXT without FOR
00A614  2  47 A6              .word ERR_SN            ;$02 syntax
00A616  2  4E A6              .word ERR_RG            ;$04 RETURN without GOSUB
00A618  2  63 A6              .word ERR_OD            ;$06 out of data
00A61A  2  6F A6              .word ERR_FC            ;$08 function call
00A61C  2  7D A6              .word ERR_OV            ;$0A overflow
00A61E  2  86 A6              .word ERR_OM            ;$0C out of memory
00A620  2  94 A6              .word ERR_US            ;$0E undefined statement
00A622  2  A8 A6              .word ERR_BS            ;$10 array bounds
00A624  2  B5 A6              .word ERR_DD            ;$12 double dimension array
00A626  2  C6 A6              .word ERR_D0            ;$14 divide by 0
00A628  2  D5 A6              .word ERR_ID            ;$16 illegal direct
00A62A  2  E4 A6              .word ERR_TM            ;$18 type mismatch
00A62C  2  F2 A6              .word ERR_LS            ;$1A long string
00A62E  2  02 A7              .word ERR_ST            ;$1C string too complex
00A630  2  15 A7              .word ERR_CN            ;$1E continue error
00A632  2  24 A7              .word ERR_UF            ;$20 undefined function
00A634  2  37 A7              .word ERR_LD            ;$22 LOOP without DO
00A636  2               
00A636  2               ; I may implement these two errors to force definition of variables and
00A636  2               ; dimensioning of arrays before use.
00A636  2               
00A636  2               ;     .word ERR_UV            ;$24 undefined variable
00A636  2               
00A636  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00A636  2               
00A636  2               ;     .word ERR_UA            ;$26 undimensioned array
00A636  2               
00A636  2  4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
00A63A  2  20 77 69 74  
00A63E  2  68 6F 75 74  
00A647  2  53 79 6E 74  ERR_SN      .byte "Syntax",$00
00A64B  2  61 78 00     
00A64E  2  52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
00A652  2  52 4E 20 77  
00A656  2  69 74 68 6F  
00A663  2  4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
00A667  2  6F 66 20 44  
00A66B  2  41 54 41 00  
00A66F  2  46 75 6E 63  ERR_FC      .byte "Function call",$00
00A673  2  74 69 6F 6E  
00A677  2  20 63 61 6C  
00A67D  2  4F 76 65 72  ERR_OV      .byte "Overflow",$00
00A681  2  66 6C 6F 77  
00A685  2  00           
00A686  2  4F 75 74 20  ERR_OM      .byte "Out of memory",$00
00A68A  2  6F 66 20 6D  
00A68E  2  65 6D 6F 72  
00A694  2  55 6E 64 65  ERR_US      .byte "Undefined statement",$00
00A698  2  66 69 6E 65  
00A69C  2  64 20 73 74  
00A6A8  2  41 72 72 61  ERR_BS      .byte "Array bounds",$00
00A6AC  2  79 20 62 6F  
00A6B0  2  75 6E 64 73  
00A6B5  2  44 6F 75 62  ERR_DD      .byte "Double dimension",$00
00A6B9  2  6C 65 20 64  
00A6BD  2  69 6D 65 6E  
00A6C6  2  44 69 76 69  ERR_D0      .byte "Divide by zero",$00
00A6CA  2  64 65 20 62  
00A6CE  2  79 20 7A 65  
00A6D5  2  49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
00A6D9  2  67 61 6C 20  
00A6DD  2  64 69 72 65  
00A6E4  2  54 79 70 65  ERR_TM      .byte "Type mismatch",$00
00A6E8  2  20 6D 69 73  
00A6EC  2  6D 61 74 63  
00A6F2  2  53 74 72 69  ERR_LS      .byte "String too long",$00
00A6F6  2  6E 67 20 74  
00A6FA  2  6F 6F 20 6C  
00A702  2  53 74 72 69  ERR_ST      .byte "String too complex",$00
00A706  2  6E 67 20 74  
00A70A  2  6F 6F 20 63  
00A715  2  43 61 6E 27  ERR_CN      .byte "Can't continue",$00
00A719  2  74 20 63 6F  
00A71D  2  6E 74 69 6E  
00A724  2  55 6E 64 65  ERR_UF      .byte "Undefined function",$00
00A728  2  66 69 6E 65  
00A72C  2  64 20 66 75  
00A737  2  4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
00A73B  2  20 77 69 74  
00A73F  2  68 6F 75 74  
00A747  2               
00A747  2               ;ERR_UV     .byte "Undefined variable",$00
00A747  2               
00A747  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00A747  2               
00A747  2               ;ERR_UA     .byte "Undimensioned array",$00
00A747  2               
00A747  2  0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
00A74B  2  65 61 6B 00  
00A74F  2  20 45 72 72  LAB_EMSG    .byte " Error",$00
00A753  2  6F 72 00     
00A756  2  20 69 6E 20  LAB_LMSG    .byte " in line ",$00
00A75A  2  6C 69 6E 65  
00A75E  2  20 00        
00A760  2  0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
00A764  2  61 64 79 0D  
00A768  2  0A 00        
00A76A  2               
00A76A  2  20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
00A76E  2  72 61 20 69  
00A772  2  67 6E 6F 72  
00A77B  2  20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
00A77F  2  6F 20 66 72  
00A783  2  6F 6D 20 73  
00A78E  2               
00A78E  1               	.include "acia.s"
00A78E  2               ; ACIA Ports
00A78E  2               ACIA_BASE			= $0220
00A78E  2               ACIA_DATA			= ACIA_BASE + $0
00A78E  2               ACIA_STATUS			= ACIA_BASE + $1
00A78E  2               ACIA_RESET			= ACIA_BASE + $1
00A78E  2               ACIA_COMMAND		= ACIA_BASE + $2
00A78E  2               ACIA_CONTROL		= ACIA_BASE + $3
00A78E  2               
00A78E  2               ; ACIA Status Register
00A78E  2               ACIA_INT_ENABLE		= %10000000
00A78E  2               ACIA_DSR_NOT_READY	= %01000000
00A78E  2               ACIA_DCD_NOT_DETECD	= %00100000
00A78E  2               ACIA_TX_DR_EMPTY	= %00010000
00A78E  2               ACIA_RX_DR_FULL		= %00001000
00A78E  2               ACIA_OVERFLOW_ERROR	= %00000100
00A78E  2               ACIA_FRAMING_ERROR	= %00000010
00A78E  2               ACIA_PARITY_ERROR	= %00000001
00A78E  2               
00A78E  2               ; ACIA Control Register
00A78E  2               ; Stop Bit Number (SBN) bit 7
00A78E  2               ACIA_1_SBN			= %00000000
00A78E  2               ACIA_2_SBN			= %10000000
00A78E  2               ; Word Length (WL) bits 6-5
00A78E  2               ACIA_WL_8			= %00000000
00A78E  2               ACIA_WL_7			= %00100000
00A78E  2               ACIA_WL_6			= %01000000
00A78E  2               ACIA_WL_5			= %01100000
00A78E  2               ; Receiver Clock Source (RCS) bit 4
00A78E  2               ACIA_RX_CLK_EXT		= %00000000
00A78E  2               ACIA_RX_CLK_B_RATE	= %00010000
00A78E  2               ; Selected Baud Rate (SBR) bits 3-0
00A78E  2               ACIA_BAUD_115200	= %00000000
00A78E  2               ACIA_BAUD_50		= %00000001
00A78E  2               ACIA_BAUD_75		= %00000010
00A78E  2               ACIA_BAUD_109_92	= %00000011
00A78E  2               ACIA_BAUD_134_58	= %00000100
00A78E  2               ACIA_BAUD_150		= %00000101
00A78E  2               ACIA_BAUD_300		= %00000110
00A78E  2               ACIA_BAUD_600		= %00000111
00A78E  2               ACIA_BAUD_1200		= %00001000
00A78E  2               ACIA_BAUD_1800		= %00001001
00A78E  2               ACIA_BAUD_2400		= %00001010
00A78E  2               ACIA_BAUD_3600		= %00001011
00A78E  2               ACIA_BAUD_4800		= %00001100
00A78E  2               ACIA_BAUD_7200		= %00001101
00A78E  2               ACIA_BAUD_9600		= %00001110
00A78E  2               ACIA_BAUD_19200		= %00001111
00A78E  2               
00A78E  2               ; ACIA Command Register
00A78E  2               ACIA_NO_PARITY		= %00000000
00A78E  2               ACIA_NO_ECHO		= %00000000
00A78E  2               ACIA_ECHO_MODE		= %00010000
00A78E  2               ; Transmitter Interrupt Control (TIC)
00A78E  2               ACIA_RTSB_H			= %00000000
00A78E  2               ACIA_RTSB_L			= %00001000
00A78E  2               ACIA_RTSB_L_TX_BRK	= %00001100
00A78E  2               ; Receiver Interrupt Request Disabled (IRD)
00A78E  2               ACIA_RX_IRQ			= %00000000
00A78E  2               ACIA_RX_NO_IRQ		= %00000010
00A78E  2               ; Data Terminal Ready (DTR)
00A78E  2               ACIA_DTR			= %00000001
00A78E  2               
00A78E  2               acia_init:
00A78E  2  48           	pha
00A78F  2  9C 21 02     	stz		ACIA_RESET
00A792  2  A9 10        	lda		#(ACIA_1_SBN | ACIA_WL_8 | ACIA_RX_CLK_B_RATE | ACIA_BAUD_115200)
00A794  2  8D 23 02     	sta		ACIA_CONTROL
00A797  2               
00A797  2  A9 0B        	lda		#(ACIA_NO_PARITY | ACIA_NO_ECHO | ACIA_RTSB_L | ACIA_RX_NO_IRQ | ACIA_DTR)
00A799  2               	; lda		#(ACIA_NO_PARITY | ACIA_NO_ECHO | ACIA_RTSB_L | ACIA_RX_IRQ | ACIA_DTR)
00A799  2  8D 22 02     	sta		ACIA_COMMAND
00A79C  2  68           	pla
00A79D  2  60           	rts
00A79E  2                ;-------------
00A79E  2               
00A79E  2               acia_resume_rx:
00A79E  2  A9 09        	lda		#(ACIA_NO_PARITY | ACIA_NO_ECHO | ACIA_RTSB_L | ACIA_RX_IRQ | ACIA_DTR)
00A7A0  2  8D 22 02     	sta		ACIA_COMMAND
00A7A3  2  60           	rts
00A7A4  2                ;-------------
00A7A4  2               
00A7A4  2               acia_write:
00A7A4  2  8D 20 02     	sta 	ACIA_DATA
00A7A7  2  20 C4 A7     	jsr 	delay_6551
00A7AA  2  60           	rts
00A7AB  2                ;-------------
00A7AB  2               
00A7AB  2               acia_get_byte:
00A7AB  2  AD 21 02     	lda 	ACIA_STATUS			; Load the ACIA Status
00A7AE  2  29 08        	and 	#ACIA_RX_DR_FULL	; Checks if RX Data Register is full
00A7B0  2  F0 F9        	beq 	acia_get_byte		; Loop if no new data
00A7B2  2  AD 20 02     	lda 	ACIA_DATA			; Load received data into A register
00A7B5  2  60           	rts
00A7B6  2                ;-------------
00A7B6  2               
00A7B6  2               acia_read:
00A7B6  2  AD 21 02     	lda		ACIA_STATUS			; Load the ACIA Status
00A7B9  2  29 08        	and		#ACIA_RX_DR_FULL	; Checks if RX Data Register is full
00A7BB  2  F0 05        	beq		@no_data
00A7BD  2  AD 20 02     	lda		ACIA_DATA			; Load received data into A register
00A7C0  2  38           	sec							; Carry set if data available
00A7C1  2  60           	rts
00A7C2  2               @no_data:
00A7C2  2  18           	clc							; Carry clear if no key pressed
00A7C3  2  60           	rts
00A7C4  2                ;-------------
00A7C4  2               
00A7C4  2               ; acia_handle:
00A7C4  2               ; 	phx
00A7C4  2               ; 	lda		ACIA_STATUS		; Get the contents of the ACIA's status register.
00A7C4  2               ; 	; BPL		@end		; If ACIA didn't call, just exit.
00A7C4  2               ; 	and		#(ACIA_OVERFLOW_ERROR | ACIA_FRAMING_ERROR | ACIA_PARITY_ERROR)	; Check for error conditions by ANDing with 7.
00A7C4  2               ; 	bne		@report_err		; If there was any error condx, go report it.
00A7C4  2               
00A7C4  2               ; 	lda		ACIA_DATA		; Get the data from the ACIA
00A7C4  2               ; 	jsr		buf_write		; and store it in the buffer.
00A7C4  2               
00A7C4  2               ; 	jsr		buf_dif			; Now see how full the buffer is.
00A7C4  2               ; 	cmp		#$F0			; If it has less than 240 bytes unread,
00A7C4  2               ; 	bcc		@end			; just exit the ISR here.
00A7C4  2               
00A7C4  2               ; 	lda		#(ACIA_NO_PARITY | ACIA_NO_ECHO | ACIA_RTSB_H | ACIA_RX_IRQ | ACIA_DTR)	; Else, tell the other end to stop sending data before
00A7C4  2               ; 	sta		ACIA_COMMAND	; the buffer overflows, by storing 1 in the ACIA's
00A7C4  2               ; 							; command register.	(See text.)
00A7C4  2               ; 	jmp		@end
00A7C4  2               ; @report_err:
00A7C4  2               ; 	lda		#$07			; Ring bell
00A7C4  2               ; 	jsr		buf_write
00A7C4  2               
00A7C4  2               ;  @end:
00A7C4  2               ;  	plx						; Restore X , and return from interrupt.
00A7C4  2               ; 	rts
00A7C4  2               ;  ;-------------
00A7C4  2               
00A7C4  2               
00A7C4  2               
00A7C4  2               
00A7C4  2               ; Latest WDC 65C51 has a bug - Xmit bit in status register is stuck on
00A7C4  2               ; IRQ driven transmit is not possible as a result - interrupts are endlessly triggered
00A7C4  2               ; Polled I/O mode also doesn't work as the Xmit bit is polled - delay routine is the only option
00A7C4  2               ; The following delay routine kills time to allow W65C51 to complete a character transmit
00A7C4  2               ; 0.523 milliseconds required loop time for 19,200 baud rate
00A7C4  2               ; .mini_delay routine takes 524 clock cycles to complete - X Reg is used for the count loop
00A7C4  2               ; Y Reg is loaded with the CPU clock rate in MHz (whole increments only) and used as a multiplier
00A7C4  2               ;
00A7C4  2               delay_6551:
00A7C4  2  5A           	phy				;Save Y Reg
00A7C5  2  DA           	phx				;Save X Reg
00A7C6  2  A0 08        	ldy		#8		;Get delay value (clock rate in MHz 8 clock cycles)
00A7C8  2               	; ldy		#1		;Get delay value (clock rate in MHz 1 clock cycles)
00A7C8  2               
00A7C8  2               @clock_loop:
00A7C8  2  A2 CC        	ldx		#$CC	;Seed X reg, $11 works for 115200 baud, $66 for 19200, $CC for 9600
00A7CA  2               @baud_loop:
00A7CA  2  CA           	dex				;Decrement low index
00A7CB  2  D0 FD        	bne		@baud_loop	 ;Loop back until done
00A7CD  2  88           	dey				;Decrease by one
00A7CE  2  D0 F8        	bne		@clock_loop	 ;Loop until done
00A7D0  2  FA           	plx				;Restore X Reg
00A7D1  2  7A           	ply				;Restore Y Reg
00A7D2  2  60           	rts				;Delay done, return
00A7D3  2               
00A7D3  1               	.include "via.s"
00A7D3  2               ; VIA Ports
00A7D3  2               VIA1_BASE = $0200
00A7D3  2               VIA2_BASE = $0210
00A7D3  2               VIA1_PORTB = VIA1_BASE + $0
00A7D3  2               VIA1_PORTA = VIA1_BASE + $1
00A7D3  2               VIA1_DDRB  = VIA1_BASE + $2
00A7D3  2               VIA1_DDRA  = VIA1_BASE + $3
00A7D3  2               VIA1_PRC = VIA1_BASE + $C
00A7D3  2               VIA1_IFR = VIA1_BASE + $D
00A7D3  2               VIA1_IER = VIA1_BASE + $E
00A7D3  2               VIA2_PORTB = VIA2_BASE + $0
00A7D3  2               VIA2_PORTA = VIA2_BASE + $1
00A7D3  2               VIA2_DDRB  = VIA2_BASE + $2
00A7D3  2               VIA2_DDRA  = VIA2_BASE + $3
00A7D3  2               VIA2_PRC = VIA2_BASE + $C
00A7D3  2               VIA2_IFR = VIA2_BASE + $D
00A7D3  2               VIA2_IER = VIA2_BASE + $E
00A7D3  2               
00A7D3  2               ; VIA Interrupt Control
00A7D3  2               VIA_INT_CA2 = $00000001
00A7D3  2               VIA_INT_CA1 = %00000010
00A7D3  2               VIA_INT_SR  = %00000100
00A7D3  2               VIA_INT_CB2 = %00001000
00A7D3  2               VIA_INT_CB1 = %00010000
00A7D3  2               VIA_INT_T2  = %00100000
00A7D3  2               VIA_INT_T1  = %01000000
00A7D3  2               VIA_INT_SET = %10000000
00A7D3  2               
00A7D3  2               ; VIA Peripheral Control Register
00A7D3  2               VIA_CB2_INT_LOW = %00000000
00A7D3  2               VIA_CB2_INDEPENDENT_INT_LOW = %00100000
00A7D3  2               VIA_CB2_INT_HIGH = %01000000
00A7D3  2               VIA_CB2_INDEPENDENT_INT_HIGH = %01100000
00A7D3  2               VIA_CB2_HANDSHAKE_OUT = %10000000
00A7D3  2               VIA_CB2_PULSE_OUT = %10100000
00A7D3  2               VIA_CB2_LOW_OUT = %11000000
00A7D3  2               VIA_CB2_HIGH_OUT = %11100000
00A7D3  2               VIA_CB1_INT_LOW = %00000000
00A7D3  2               VIA_CB1_INT_HIGH = %00010000
00A7D3  2               VIA_CA2_INT_LOW = %00000000
00A7D3  2               VIA_CA2_INDEPENDENT_INT_LOW = %00000010
00A7D3  2               VIA_CA2_INT_HIGH = %00000100
00A7D3  2               VIA_CA2_INDEPENDENT_INT_HIGH = %00000110
00A7D3  2               VIA_CA2_HANDSHAKE_OUT = %00001000
00A7D3  2               VIA_CA2_PULSE_OUT = %00001010
00A7D3  2               VIA_CA2_LOW_OUT = %00001100
00A7D3  2               VIA_CA2_HIGH_OUT = %00001110
00A7D3  2               VIA_CA1_INT_LOW = %00000000
00A7D3  2               VIA_CA1_INT_HIGH = %0000001
00A7D3  2               
00A7D3  2               via_init:
00A7D3  2  48             pha
00A7D4  2  A9 82          lda #VIA_INT_SET | VIA_INT_CA1
00A7D6  2  8D 0E 02       sta VIA1_IER
00A7D9  2               
00A7D9  2  A9 01          lda #VIA_CA1_INT_HIGH
00A7DB  2  8D 0C 02       sta VIA1_PRC
00A7DE  2               
00A7DE  2  A9 FF          lda #%11111111 ; Set all pins on port B to output
00A7E0  2  8D 02 02       sta VIA1_DDRB
00A7E3  2  9C 00 02       stz VIA1_PORTB
00A7E6  2  68             pla
00A7E7  2  60             rts
00A7E8  2               
00A7E8  2               
00A7E8  2               ; CNT_ISR: BIT   VIA_T1CL ; Turn off interrupt early.  (More on that below.)
00A7E8  2               ;          INC   CNT      ; Increment the low byte of the variable.
00A7E8  2               ;          BNE   isr1$    ; Branch to end if the low byte didn't roll over to 00.
00A7E8  2               ;          INC   CNT+1    ; Otherwise increment high byte of variable.
00A7E8  2               ;  isr1$:  RTI            ; Exit the ISR, restoring the previous processor status.
00A7E8  2               
00A7E8  1               	.include "lcd.s"
00A7E8  2               SET_DDRAM_ADDR       = %10000000
00A7E8  2               
00A7E8  2               SET_CGRAM_ADDR       = %01000000
00A7E8  2               
00A7E8  2               FUNCTION_SET         = %00100000
00A7E8  2               FUNCTION_8_BIT       = %00010000
00A7E8  2               FUNCTION_2_LINE      = %00001000
00A7E8  2               FUNCTION_5x10_FONT   = %00000100
00A7E8  2               
00A7E8  2               CD_SHIFT             = %00010000
00A7E8  2               CD_SHIFT_DISPLAY     = %00001000
00A7E8  2               CD_SHIFT_RIGHT       = %00000100
00A7E8  2               
00A7E8  2               
00A7E8  2               DISPLAY_CONTROL      = %00001000
00A7E8  2               DISPLAY_ON           = %00000100
00A7E8  2               DISPLAY_CURSOR_ON    = %00000010
00A7E8  2               DISPLAY_CURSOR_BLINK = %00000001
00A7E8  2               
00A7E8  2               ENTRY_MODE_SET       = %00000100
00A7E8  2               ENTRY_MODE_INCREMENT = %00000010
00A7E8  2               ENTRY_MODE_SHIFT     = %00000001
00A7E8  2               
00A7E8  2               RETURN_HOME          = %00000010
00A7E8  2               
00A7E8  2               CLEAR_DISPLAY        = %00000001
00A7E8  2               
00A7E8  2               
00A7E8  2               E  = %10000000
00A7E8  2               RW = %01000000
00A7E8  2               RS = %00100000
00A7E8  2               
00A7E8  2               string_ptr = r0
00A7E8  2               
00A7E8  2               lcd_init:
00A7E8  2  48             pha
00A7E9  2  A9 78          lda #120
00A7EB  2  20 F2 A8       jsr wait_ms
00A7EE  2  A9 03          lda #%00000011 ; Sets to 8-bit mode; 1-line display; 5x8 font
00A7F0  2  20 2A A8       jsr lcd_instruction_send_command
00A7F3  2  A9 21          lda #33
00A7F5  2  20 F2 A8       jsr wait_ms
00A7F8  2  A9 03          lda #%00000011 ; Sets to 8-bit mode; 1-line display; 5x8 font
00A7FA  2  20 2A A8       jsr lcd_instruction_send_command
00A7FD  2  A9 01          lda #1
00A7FF  2  20 F2 A8       jsr wait_ms
00A802  2  A9 03          lda #%00000011 ; Sets to 8-bit mode; 1-line display; 5x8 font
00A804  2  20 2A A8       jsr lcd_instruction_send_command
00A807  2  A9 01          lda #1
00A809  2  20 F2 A8       jsr wait_ms
00A80C  2  A9 02          lda #%00000010 ; Sets to 4-bit mode
00A80E  2  20 2A A8       jsr lcd_instruction_send_command
00A811  2  A9 28          lda #(FUNCTION_SET | FUNCTION_2_LINE) ; Sets to 4-bit mode; 2-line display; 5x8 font
00A813  2  20 27 A8       jsr lcd_instruction
00A816  2  A9 06          lda #(ENTRY_MODE_SET | ENTRY_MODE_INCREMENT) ; Entry mode set; increment and shift cursor; no scroll
00A818  2  20 27 A8       jsr lcd_instruction
00A81B  2  A9 01          lda #CLEAR_DISPLAY ; Clear display
00A81D  2  20 27 A8       jsr lcd_instruction
00A820  2  A9 0E          lda #(DISPLAY_CONTROL | DISPLAY_ON | DISPLAY_CURSOR_ON) ; Display on; cursor on; blink off
00A822  2  20 27 A8       jsr lcd_instruction
00A825  2  68             pla
00A826  2  60             rts
00A827  2               
00A827  2               lcd_instruction:
00A827  2  20 47 A8       jsr lcd_wait
00A82A  2               lcd_instruction_send_command:
00A82A  2  48             pha
00A82B  2  4A             lsr            ; shift high nibble to low 4 bits
00A82C  2  4A             lsr
00A82D  2  4A             lsr
00A82E  2  4A             lsr
00A82F  2  09 80          ora #E         ; Sets E bit
00A831  2  8D 00 02       sta VIA1_PORTB
00A834  2               
00A834  2  49 80          eor #E         ; Clear E bit
00A836  2  8D 00 02       sta VIA1_PORTB
00A839  2               
00A839  2  68             pla
00A83A  2  29 0F          and #%00001111 ; Mask high nibble
00A83C  2  09 80          ora #E         ; Sets E bit
00A83E  2  8D 00 02       sta VIA1_PORTB
00A841  2               
00A841  2  49 80          eor #E         ; Clear E bit
00A843  2  8D 00 02       sta VIA1_PORTB
00A846  2  60             rts
00A847  2               
00A847  2               lcd_wait:
00A847  2  48             pha
00A848  2  A9 F0          lda #%11110000 ; Port B D0-D3 are input
00A84A  2  8D 02 02       sta VIA1_DDRB
00A84D  2               lcd_wait_loop:
00A84D  2  A9 40          lda #RW ; Set RW and pulse E to read LCD address
00A84F  2  8D 00 02       sta VIA1_PORTB
00A852  2  A9 C0          lda #(RW | E)
00A854  2  8D 00 02       sta VIA1_PORTB
00A857  2  AD 00 02       lda VIA1_PORTB ; Read high bits from LCD
00A85A  2  0A             asl
00A85B  2  0A             asl
00A85C  2  0A             asl
00A85D  2  0A             asl
00A85E  2  85 E2          sta lcd_addr ; Shift bits into high bits of byte
00A860  2  A9 40          lda #RW ; Set RW and pulse E to read LCD address
00A862  2  8D 00 02       sta VIA1_PORTB
00A865  2  A9 C0          lda #(RW | E)
00A867  2  8D 00 02       sta VIA1_PORTB
00A86A  2  AD 00 02       lda VIA1_PORTB ; Read low bits from LCD
00A86D  2  29 0F          and #%00001111 ; Mask off high bits which are not part of address
00A86F  2  05 E2          ora lcd_addr ; Combine bits read with high bits and store complete address with busy flag
00A871  2  85 E2          sta lcd_addr
00A873  2  29 80          and #%10000000 ; Check busy flag
00A875  2  D0 D6          bne lcd_wait_loop
00A877  2               
00A877  2  A9 40          lda #RW
00A879  2  8D 00 02       sta VIA1_PORTB
00A87C  2  A9 FF          lda #%11111111 ; Port B is output
00A87E  2  8D 02 02       sta VIA1_DDRB
00A881  2  68             pla
00A882  2  60             rts
00A883  2               
00A883  2               
00A883  2               lcd_clear:
00A883  2  A9 01          lda #CLEAR_DISPLAY ; Clear
00A885  2  20 27 A8       jsr lcd_instruction
00A888  2               
00A888  2               lcd_home:
00A888  2  A9 02          lda #RETURN_HOME
00A88A  2  20 27 A8       jsr lcd_instruction
00A88D  2  60             rts
00A88E  2               
00A88E  2               lcd_cursor_left:
00A88E  2  A9 10          lda #CD_SHIFT
00A890  2  20 27 A8       jsr lcd_instruction
00A893  2  60             rts
00A894  2               
00A894  2               lcd_cursor_right:
00A894  2  A9 14          lda #(CD_SHIFT | CD_SHIFT_RIGHT)
00A896  2  20 27 A8       jsr lcd_instruction
00A899  2  60             rts
00A89A  2               
00A89A  2               lcd_screen_left:
00A89A  2  A9 18          lda #(CD_SHIFT | CD_SHIFT_DISPLAY)
00A89C  2  20 27 A8       jsr lcd_instruction
00A89F  2  60             rts
00A8A0  2               
00A8A0  2               lcd_screen_right:
00A8A0  2  A9 1C          lda #(CD_SHIFT | CD_SHIFT_DISPLAY | CD_SHIFT_RIGHT)
00A8A2  2  20 27 A8       jsr lcd_instruction
00A8A5  2  60             rts
00A8A6  2               
00A8A6  2               lcd_set_ddram_addr: ; Sets cursor position to value in A register
00A8A6  2  09 80          ora #SET_DDRAM_ADDR
00A8A8  2  20 27 A8       jsr lcd_instruction
00A8AB  2  60             rts
00A8AC  2               
00A8AC  2               lcd_print_char:
00A8AC  2  48             pha
00A8AD  2  20 47 A8       jsr lcd_wait
00A8B0  2  4A             lsr            ; shift high nibble to low 4 bits
00A8B1  2  4A             lsr
00A8B2  2  4A             lsr
00A8B3  2  4A             lsr
00A8B4  2  09 20          ora #RS        ; Set RS, clear RW/E bits
00A8B6  2  8D 00 02       sta VIA1_PORTB
00A8B9  2               
00A8B9  2  09 80          ora #E         ; Set E
00A8BB  2  8D 00 02       sta VIA1_PORTB
00A8BE  2               
00A8BE  2  49 80          eor #E         ; Clear E
00A8C0  2  8D 00 02       sta VIA1_PORTB
00A8C3  2               
00A8C3  2  68             pla
00A8C4  2  48             pha
00A8C5  2  29 0F          and #%00001111 ; Mask high nibble
00A8C7  2  09 20          ora #RS        ; Set RS, clear RW/E bits
00A8C9  2  8D 00 02       sta VIA1_PORTB
00A8CC  2               
00A8CC  2  09 80          ora #E         ; Set E
00A8CE  2  8D 00 02       sta VIA1_PORTB
00A8D1  2               
00A8D1  2  49 80          eor #E         ; Clear E
00A8D3  2  8D 00 02       sta VIA1_PORTB
00A8D6  2               
00A8D6  2  68             pla
00A8D7  2  60             rts
00A8D8  2               
00A8D8  2               lcd_new_line:
00A8D8  2  48             pha
00A8D9  2  A5 E2          lda lcd_addr
00A8DB  2  69 40          adc #$40
00A8DD  2  29 40          and #$40
00A8DF  2  20 A6 A8       jsr lcd_set_ddram_addr
00A8E2  2  68             pla
00A8E3  2  60             rts
00A8E4  2               
00A8E4  2               
00A8E4  2               
00A8E4  2               ; lcd_print_screen_buf
00A8E4  2               ;   ldx #0
00A8E4  2               ; lcd_print_screen_buf_loop:
00A8E4  2               ;   lda screen_buf,x
00A8E4  2               ;   beq lcd_print_screen_buf_return
00A8E4  2               ;   jsr lcd_print_char
00A8E4  2               ;   inx
00A8E4  2               ;   jmp lcd_print_screen_buf_loop
00A8E4  2               ; lcd_print_screen_buf_return
00A8E4  2               ;   rts
00A8E4  2               
00A8E4  2               ; print null terminated string located at address contained in s0
00A8E4  2               ; input r0
00A8E4  2               lcd_print:
00A8E4  2  A0 00          ldy #0
00A8E6  2               lcd_print_loop:
00A8E6  2  B1 E8          lda (string_ptr),y
00A8E8  2  F0 07          beq lcd_print_return
00A8EA  2  20 AC A8       jsr lcd_print_char
00A8ED  2  C8             iny
00A8EE  2  4C E6 A8       jmp lcd_print_loop
00A8F1  2               lcd_print_return:
00A8F1  2  60             rts
00A8F2  2               
00A8F2  2               ; push_char_screen_buf:
00A8F2  2               ;   pha
00A8F2  2               ;   ldx #0
00A8F2  2               
00A8F2  2               ; push_char_screen_buf_char_loop:
00A8F2  2               ;   lda screen_buf,x
00A8F2  2               ;   beq push_char_screen_buf_add_char
00A8F2  2               ;   inx
00A8F2  2               ;   jmp push_char_screen_buf_char_loop
00A8F2  2               
00A8F2  2               ; push_char_screen_buf_add_char:
00A8F2  2               ;   pla
00A8F2  2               ;   sta screen_buf,x
00A8F2  2               ;   inx
00A8F2  2               ;   stz screen_buf,x
00A8F2  2               ;   rts
00A8F2  2               
00A8F2  2               
00A8F2  1               	.include "utils.s"
00A8F2  2               wait_ms:
00A8F2  2  85 E8          sta r0
00A8F4  2  DA             phx
00A8F5  2  5A             phy
00A8F6  2  A6 E8          ldx r0
00A8F8  2               
00A8F8  2  A0 BE          ldy #190
00A8FA  2               wait_ms_loop1:
00A8FA  2  EA             nop ; spin 2 cycles
00A8FB  2  65 00          adc $00 ; spin 3 cycles
00A8FD  2  88             dey
00A8FE  2  D0 FA          bne wait_ms_loop1
00A900  2               
00A900  2               wait_ms_loop2:
00A900  2  CA             dex
00A901  2  F0 0C          beq wait_ms_return
00A903  2               
00A903  2  EA             nop
00A904  2  A0 C6          ldy #198
00A906  2               wait_ms_loop3:
00A906  2  EA             nop ; spin 2 cycles
00A907  2  65 00          adc $00 ; spin 3 cycles
00A909  2  88             dey
00A90A  2  D0 FA          bne wait_ms_loop3
00A90C  2               
00A90C  2  4C 00 A9       jmp wait_ms_loop2
00A90F  2               
00A90F  2               wait_ms_return:
00A90F  2  7A             ply
00A910  2  FA             plx
00A911  2  A5 E8          lda r0
00A913  2  60             rts
00A914  2               
00A914  1               	; .include "keyboard.s"
00A914  1               	; .include "io.s"
00A914  1               
00A914  1               ; ; Defines
00A914  1               ; lcd_addr		= $E2	; 1 byte, lcd busy flag and address
00A914  1               ; in_wptr			= $E3	; 1 byte
00A914  1               ; in_rptr			= $E4	; 1 byte
00A914  1               ; kb_flags		= $E5	; 1 byte
00A914  1               ; kb_modifiers 	= $E6	; 1 byte
00A914  1               ; r0				= $E8	; 2 bytes
00A914  1               ; r0L				= $E8	; low byte
00A914  1               ; r0H				= $E9	; high byte
00A914  1               ; r1				= $EA	; 2 bytes
00A914  1               ; r1L				= $EA	; low byte
00A914  1               ; r1H				= $EB	; high byte
00A914  1               ; r2				= $EC	; 2 bytes
00A914  1               ; r2L				= $EC	; low byte
00A914  1               ; r2H				= $ED	; high byte
00A914  1               
00A914  1               ; Put the IRQ and NMI code in RAM so that it can be changed
00A914  1               
00A914  1               ; IRQ_vec	= VEC_SV+2	; IRQ code vector
00A914  1               ; NMI_vec	= IRQ_vec+$0A	; NMI code vector
00A914  1               
00A914  1               ; Now the code. all this does is set up the vectors and interrupt code
00A914  1               ; and wait for the user to select [C]old or [W]arm start. Nothing else.
00A914  1               ; Fits in less than 128 bytes
00A914  1               
00A914  1               ; Reset vector points here
00A914  1               EXIT:
00A914  1               RES_vec
00A914  1  D8           	cld				; clear decimal mode
00A915  1  A2 FF        	ldx		#$FF	; empty stack
00A917  1  9A           	txs				; set the stack
00A918  1               
00A918  1  20 D3 A7     	jsr		via_init
00A91B  1  20 E8 A7     	jsr		lcd_init
00A91E  1  20 8E A7     	jsr		acia_init
00A921  1               	; jsr io_init
00A921  1               	; jsr		kb_init
00A921  1  58           	cli
00A922  1               
00A922  1  A2 00        	ldx		#0
00A924  1               PrintWelcome
00A924  1  BD 50 A9     	lda		WELCOME_mess,x
00A927  1  F0 07        	beq		print_next
00A929  1  20 AC A8     	jsr		lcd_print_char
00A92C  1  E8           	inx
00A92D  1  4C 24 A9     	jmp		PrintWelcome
00A930  1               print_next
00A930  1  20 D8 A8     	jsr		lcd_new_line
00A933  1  A2 00        	ldx		#0
00A935  1               PrintBASIC
00A935  1  BD 61 A9     	lda		BASIC_mess,x
00A938  1  F0 07        	beq		PrintDone
00A93A  1  20 AC A8     	jsr		lcd_print_char
00A93D  1  E8           	inx
00A93E  1  4C 35 A9     	jmp		PrintBASIC
00A941  1               PrintDone
00A941  1               
00A941  1  4C 00 80     	jmp		ROM_START
00A944  1               
00A944  1               ; ; Set up vectors and interrupt code, copy them to page 2.
00A944  1               
00A944  1               ; 	LDY	#END_CODE-LAB_vec	; set index/count
00A944  1               ; LAB_stlp
00A944  1               ; 	LDA	LAB_vec-1,Y		; get byte from interrupt code
00A944  1               ; 	STA	VEC_IN-1,Y		; save to RAM
00A944  1               ; 	DEY				; decrement index/count
00A944  1               ; 	BNE	LAB_stlp		; loop if more to do
00A944  1               
00A944  1               ; ; Now do the signon message, Y = $00 here
00A944  1               
00A944  1               ; LAB_signon
00A944  1               ; 	LDA	LAB_mess,Y		; get byte from sign on message
00A944  1               ; 	BEQ	LAB_nokey		; exit loop if done
00A944  1               
00A944  1               ; 	JSR	V_OUTP		        ; output character
00A944  1               ; 	INY				; increment index
00A944  1               ; 	BNE	LAB_signon		; loop, branch always
00A944  1               
00A944  1               ; LAB_nokey
00A944  1               ; 	JSR	V_INPT                  ; call scan input device
00A944  1               ; 	BCC	LAB_nokey		; loop if no key
00A944  1               
00A944  1               ; 	AND	#$DF			; mask xx0x xxxx, ensure upper case
00A944  1               
00A944  1               ; 	CMP	#'W'			; compare with [W]arm start
00A944  1               ; 	BEQ	LAB_dowarm		; branch if [W]arm start
00A944  1               
00A944  1               ; 	CMP	#'C'			; compare with [C]old start
00A944  1               ; 	BNE	RES_vec		        ; loop if not [C]old start
00A944  1               
00A944  1               ; 	JMP	LAB_COLD		; do EhBASIC cold start
00A944  1               
00A944  1               ; LAB_dowarm
00A944  1               ; 	JMP	LAB_WARM		; do EhBASIC warm start
00A944  1               
00A944  1               ; Byte out to serial console
00A944  1               
00A944  1               CHROUT
00A944  1  20 A4 A7     	jsr acia_write
00A947  1  60           	rts
00A948  1               
00A948  1               ; Byte in from serial console or keyboard
00A948  1               
00A948  1               CHRIN_NW
00A948  1  20 B6 A7     	jsr acia_read
00A94B  1  60           	rts
00A94C  1               ; 	jsr buf_dif				; get bytes to read
00A94C  1               ; 	beq NoDataIn			; If 0 branch to NoDataIn
00A94C  1               ; 	ldx in_rptr				; load the read pointer into X
00A94C  1               ; 	lda in_buffer,x			; and read the byte from the buffer
00A94C  1               ; 	pha						; them save it to the stack
00A94C  1               ; 	inc in_rptr				; increment the read pointer
00A94C  1               ; 	jsr buf_dif				; get bytes to read still
00A94C  1               ; 	cmp #$E0				; if it is over 224
00A94C  1               ; 	bcs buf_full			; leave the sending end turned off
00A94C  1               ; 	jsr acia_resume_rx		; otherwise set RTSB low to request RX
00A94C  1               ; buf_full:
00A94C  1               ; 	pla						; pull the byte from the stack
00A94C  1               ; 	sec						; Set carry if byte received
00A94C  1               ; 	rts
00A94C  1               ; NoDataIn:
00A94C  1               ; 	clc		                ; Carry clear no byte received pressed
00A94C  1               ; 	rts
00A94C  1               
00A94C  1               
00A94C  1               ; LOAD - currently does nothing.
00A94C  1               LOAD				        ; load vector for EhBASIC
00A94C  1  60           	RTS
00A94D  1               
00A94D  1               ; SAVE - currently does nothing.
00A94D  1               SAVE				        ; save vector for EhBASIC
00A94D  1  60           	RTS
00A94E  1               
00A94E  1               ; vector tables
00A94E  1               
00A94E  1               ; LAB_vec
00A94E  1               ; 	.word	KBDin                   ; byte in from keyboard
00A94E  1               ; 	.word	SCRNout		        ; byte out to screen
00A94E  1               ; 	.word	SBCload		        ; load vector for EhBASIC
00A94E  1               ; 	.word	SBCsave		        ; save vector for EhBASIC
00A94E  1               
00A94E  1               ; EhBASIC IRQ support
00A94E  1               
00A94E  1               IRQ
00A94E  1               ; 	pha				; save A
00A94E  1               ;     lda		ACIA_STATUS             ; Check if ACIA wants service
00A94E  1               ;     bpl		no_acia_int                ; bit 7 not set, so no
00A94E  1               ;     jsr		acia_handle          ; service ACIA
00A94E  1               ; no_acia_int
00A94E  1               ; ; 	lda		VIA1_IFR
00A94E  1               ; ; 	bpl		no_via1_int
00A94E  1               ; ; 	jsr		kb_handle
00A94E  1               ; ; no_via1_int
00A94E  1               ; 	PLA				; restore A
00A94E  1  40           	RTI
00A94F  1               
00A94F  1               ; EhBASIC NMI support
00A94F  1               
00A94F  1               NMI
00A94F  1  40           	RTI
00A950  1               
00A950  1               ; END_CODE
00A950  1               
00A950  1               ; LAB_mess
00A950  1               ; 	.byte	$0D,$0A,"6502 EhBASIC",$0D,$0A, "[C]old/[W]arm?",$00
00A950  1               ; 					; sign on string
00A950  1               
00A950  1               WELCOME_mess
00A950  1  20 57 65 6C  	.byte	" Welcome:  6502 ",$00
00A954  1  63 6F 6D 65  
00A958  1  3A 20 20 36  
00A961  1               					; Welcome string
00A961  1               
00A961  1               BASIC_mess
00A961  1  20 45 68 42  	.byte	" EhBASIC  v2.22 ",$00
00A965  1  41 53 49 43  
00A969  1  20 20 76 32  
00A972  1               					; EhBASIC v string
00A972  1               
00A972  1               ; system vectors
00A972  1               
00A972  1                       ; .res    $FFFA-*
00A972  1               .segment "VECTORS"
00A972  1  4F A9        	.word	NMI		; NMI vector
00A974  1  14 A9        	.word	RES_vec		; RESET vector
00A976  1  4E A9        	.word	IRQ		; IRQ vector
00A976  1               
