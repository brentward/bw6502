ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000000r 1               ;
000000r 1               ;***************************************************
000000r 1               ;*  C02Monitor 1.4 (c)2013-2017 by Kevin E. Maier  *
000000r 1               ;*    Extendable BIOS and Monitor for 65C02 CPU    *
000000r 1               ;*                                                 *
000000r 1               ;* Basic functions include:                        *
000000r 1               ;*  - Byte/Text memory search                      *
000000r 1               ;*  - CPU register display/modify                  *
000000r 1               ;*  - Memory fill, move, compare, examine/edit     *
000000r 1               ;*  - Xmodem/CRC Loader with S-Record support      *
000000r 1               ;*  - Input buffer Macro utility up to 127 bytes   *
000000r 1               ;*  - EEPROM Program utility (Atmel Byte-write)    *
000000r 1               ;*  - RTC via 65C22 showing time since boot        *
000000r 1               ;*  - 1ms timer delay via 65C22                    *
000000r 1               ;*  - Table-driven Disassembler for W65C02S        *
000000r 1               ;*  - Monitor space increased for future expansion *
000000r 1               ;*  - Monitor version change to match BIOS version *
000000r 1               ;*  - Added Loop Counter for Macro operation       *
000000r 1               ;*                                                 *
000000r 1               ;*                  07/11/17 KM                    *
000000r 1               ;*   Uses <6KB EEPROM - JMP table page at $FF00    *
000000r 1               ;*     Uses one page for I/O: default at $FE00     *
000000r 1               ;*         Default assembly start at $E000:        *
000000r 1               ;*                                                 *
000000r 1               ;*  C02BIOS 1.4 (c)2013-2017 by Kevin E. Maier     *
000000r 1               ;*  - BIOS in pages $F8-$FD, $FF                   *
000000r 1               ;*  - Full duplex interrupt-driven/buffered I/O    *
000000r 1               ;*  - extendable BIOS structure with soft vectors  *
000000r 1               ;*  - soft config parameters for all I/O devices   *
000000r 1               ;*  - monitor cold/warm start soft vectored        *
000000r 1               ;*  - fully relocatable code (sans page $FF)       *
000000r 1               ;*  - precision timer services 1ms accuracy        *
000000r 1               ;*  - delays from 1ms to 49.71 days                *
000000r 1               ;*  - basic port services for 6522 VIA             *
000000r 1               ;*  - moved BEEP to main Monitor, CHRIN_NW in BIOS *
000000r 1               ;*  - BIOS space increased for future expansion    *
000000r 1               ;*                                                 *
000000r 1               ;*   Note default HW system memory map as:         *
000000r 1               ;*         RAM - $0000 - $01FF                     *
000000r 1               ;*         I/O - $0200 - $02FF                     *
000000r 1               ;*         RAM - $0300 - $7FFF                     *
000000r 1               ;*         ROM - $8000 - $FFFF                     *
000000r 1               ;*                                                 *
000000r 1               ;***************************************************
000000r 1               ;
000000r 1               	; PL	66	;Page Length
000000r 1               	; PW	132	;Page Width (# of char/line)
000000r 1               	; CHIP	W65C02S	;Enable WDC 65C02 instructions
000000r 1               	; PASS1	OFF	;Set ON when used for debug
000000r 1               ;
000000r 1               .pagelength 66
000000r 1               .setcpu "65C02"
000000r 1               
000000r 1               	.include "zeropage.s"
000000r 2               .segment "ZEROPAGE"
000000r 2               
000000r 2               ;*************************
000000r 2               ;* Page Zero definitions *
000000r 2               ;*************************
000000r 2               ;Reserved from $00 to $AF for user routines
000000r 2               ; Basic uses $00 to $84
000000r 2               ;NOTES:
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/zeropage.s

000000r 2               ;	locations $00 and $01 are used to zero RAM (calls CPU reset)
000000r 2               ;	EEPROM Byte Write routine loaded into Page Zero at $00-$14
000000r 2               
000000r 2               ; Note:	BIOS uses Page Zero locations from $E0 - $FF
000000r 2               ;				Monitor uses Page Zero locations from $B0 - $DF
000000r 2               
000000r 2               ;******************************************************************************
000000r 2               ; Monitor Page Zero definitions
000000r 2               ;******************************************************************************
000000r 2               
000000r 2               PGZERO_ST	=	$B0	;Start of Page Zero usage
000000r 2               ;
000000r 2               ;	Page Zero Buffers used by the default Monitor code
000000r 2               ; - Two buffers are required;
000000r 2               ;	DATABUFF is used by the HEX2ASC routine (6 bytes)
000000r 2               ;	INBUFF is used by RDLINE routine (4 bytes)
000000r 2               BUFF_PG0	=	PGZERO_ST	;Default Page zero location for Monitor buffers
000000r 2               ;
000000r 2               ;INBUFF is used for conversion from 4 HEX characters to a 16-bit address
000000r 2               INBUFF		=	BUFF_PG0	;4 bytes ($B0-$B3)
000000r 2               ;
000000r 2               ;DATABUFF is used for conversion of 16-bit binary to ASCII decimal output
000000r 2               ; note string is terminated by null character
000000r 2               DATABUFF	=	BUFF_PG0+4	;6 bytes ($B4-$B9)
000000r 2               ;
000000r 2               ;16-bit variables:
000000r 2               HEXDATAH	=	PGZERO_ST+10	;Hexadecimal input
000000r 2               HEXDATAL	=	PGZERO_ST+11
000000r 2               BINVALL		=	PGZERO_ST+12	;Binary Value for HEX2ASC
000000r 2               BINVALH		=	PGZERO_ST+13
000000r 2               COMLO			=	PGZERO_ST+14	;User command address
000000r 2               COMHI			=	PGZERO_ST+15
000000r 2               INDEXL		=	PGZERO_ST+16	;Index for address - multiple routines
000000r 2               INDEXH		=	PGZERO_ST+17
000000r 2               TEMP1L		=	PGZERO_ST+18	;Index for word temp value used by Memdump
000000r 2               TEMP1H		=	PGZERO_ST+19
000000r 2               TEMP2L		=	PGZERO_ST+20	;Index for Text entry
000000r 2               TEMP2H		=	PGZERO_ST+21
000000r 2               PROMPTL		=	PGZERO_ST+22	;Prompt string address
000000r 2               PROMPTH		=	PGZERO_ST+23
000000r 2               SRCL			=	PGZERO_ST+24	;Source address for memory operations
000000r 2               SRCH			=	PGZERO_ST+25
000000r 2               TGTL			=	PGZERO_ST+26	;Target address for memory operations
000000r 2               TGTH			=	PGZERO_ST+27
000000r 2               LENL			=	PGZERO_ST+28	;Length address for memory operations
000000r 2               LENH			=	PGZERO_ST+29
000000r 2               ;
000000r 2               ;8-bit variables and constants:
000000r 2               BUFIDX		=	PGZERO_ST+30	;Buffer index
000000r 2               BUFLEN		=	PGZERO_ST+31	;Buffer length
000000r 2               IDX				=	PGZERO_ST+32	;Temp Indexing
000000r 2               IDY				=	PGZERO_ST+33	;Temp Indexing
000000r 2               TEMP1			=	PGZERO_ST+34	;Temp - Code Conversion routines
000000r 2               TEMP2			=	PGZERO_ST+35	;Temp - Memory/EEPROM/SREC routines - Disassembler
000000r 2               TEMP3			=	PGZERO_ST+36	;Temp - EEPROM/SREC routines
000000r 2               CMDFLAG		=	PGZERO_ST+37	;Command Flag - used by RDLINE & others
000000r 2               OPCODE		=	PGZERO_ST+38	;Saved Opcode
000000r 2               OPXMDM		= PGZERO_ST+38      ; Saved Opcode/Xmodem Flag variable
000000r 2               ;
000000r 2               ;Xmodem transfer variables
000000r 2               CRCHI			=	PGZERO_ST+39	;CRC hi byte  (two byte variable)
000000r 2               CRCLO			=	PGZERO_ST+40	;CRC lo byte - Operand in Disassembler
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/zeropage.s

000000r 2               CRCCNT		=	PGZERO_ST+41	;CRC retry count - Operand in Disassembler
000000r 2               ;
000000r 2               PTRL			=	PGZERO_ST+42	;Data pointer lo byte - Mnemonic in Disassembler
000000r 2               PTRH			=	PGZERO_ST+43	;Data pointer hi byte - Mnemonic in Disassembler
000000r 2               BLKNO			=	PGZERO_ST+44	;Block number
000000r 2               LPCNTL		=	PGZERO_ST+45	;Loop Count low byte
000000r 2               LPCNTH		=	PGZERO_ST+46	;Loop Count high byte
000000r 2               LPCNTF		=	PGZERO_ST+47	;Loop Count flag byte
000000r 2               
000000r 2               ;******************************************************************************
000000r 2               ; BIOS variables, pointers, flags located at top of Page Zero.
000000r 2               ;******************************************************************************
000000r 2               
000000r 2               BIOS_PG0	=	$E0	;PGZERO_ST+96	;Start of BIOS page zero use ($E0-$FF)
000000r 2               ;	- BRK handler routine
000000r 2               PCL				=	BIOS_PG0+0	;Program Counter Low index
000000r 2               PCH				=	BIOS_PG0+1	;Program Counter High index
000000r 2               PREG			=	BIOS_PG0+2	;Temp Status reg
000000r 2               SREG			=	BIOS_PG0+3	;Temp Stack ptr
000000r 2               YREG			=	BIOS_PG0+4	;Temp Y reg
000000r 2               XREG			=	BIOS_PG0+5	;Temp X reg
000000r 2               AREG			=	BIOS_PG0+6	;Temp A reg
000000r 2               ;
000000r 2               ;	- 6551 IRQ handler pointers and status
000000r 2               ICNT			=	BIOS_PG0+7	;Input buffer count
000000r 2               IHEAD			=	BIOS_PG0+8	;Input buffer head pointer
000000r 2               ITAIL			=	BIOS_PG0+9	;Input buffer tail pointer
000000r 2               OCNT			=	BIOS_PG0+10	;Output buffer count
000000r 2               OHEAD			=	BIOS_PG0+11	;Output buffer head pointer
000000r 2               OTAIL			=	BIOS_PG0+12	;Output buffer tail pointer
000000r 2               STTVAL		=	BIOS_PG0+13	;6551 BIOS status byte
000000r 2               ;
000000r 2               ;	- Real-Time Clock variables
000000r 2               TICKS			=	BIOS_PG0+14	;# timer countdowns for 1 second (250)
000000r 2               SECS			=	BIOS_PG0+15	;Seconds: 0-59
000000r 2               MINS			=	BIOS_PG0+16	;Minutes: 0-59
000000r 2               HOURS			=	BIOS_PG0+17	;Hours: 0-23
000000r 2               DAYSL			=	BIOS_PG0+18	;Days: (2 bytes) 0-65535 >179 years
000000r 2               DAYSH			=	BIOS_PG0+19	;High order byte
000000r 2               ;
000000r 2               ;	- Delay Timer variables
000000r 2               MSDELAY		=	BIOS_PG0+20	;Timer delay countdown byte (255 > 0)
000000r 2               MATCH			=	BIOS_PG0+21	;Delay Match flag, $FF is set, $00 is cleared
000000r 2               SETIM			=	BIOS_PG0+22	;Set timeout for delay routines - BIOS use only
000000r 2               DELLO			=	BIOS_PG0+23	;Delay value BIOS use only
000000r 2               DELHI			=	BIOS_PG0+24	;Delay value BIOS use only
000000r 2               XDL				=	BIOS_PG0+25	;XL Delay count
000000r 2               STVVAL		=	BIOS_PG0+26	;Status for VIA IRQ flags
000000r 2               ;
000000r 2               ;	- I/O port variables
000000r 2               IO_DIR		=	BIOS_PG0+27	;I/O port direction temp
000000r 2               IO_IN			=	BIOS_PG0+28	;I/O port Input temp
000000r 2               IO_OUT		=	BIOS_PG0+29	;I/O port Output temp
000000r 2               ;
000000r 2               ; - Xmodem variables
000000r 2               XMFLAG		=	BIOS_PG0+30	;Xmodem transfer active flag
000000r 2               SPARE_B0	=	BIOS_PG0+31	;Spare BIOS page zero byte
000000r 2               
000000r 2               ;******************************************************************************
000000r 2               ; EhBASIC variables, pointers, flags located at top of Page Zero.
000000r 2               ;******************************************************************************
000000r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/zeropage.s

000000r 2               ZPSTART		= $00        ; Start of zero page workspace
000000r 2               ;
000000r 2               LAB_WARM	= ZPSTART    ; $00=BASIC warm start entry point
000000r 2               Wrmjpl		= LAB_WARM+1 ; BASIC warm start vector jump low byte
000000r 2               Wrmjph		= LAB_WARM+2 ; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp		= Wrmjph+1   ; USR function JMP address
000000r 2               Usrjpl		= Usrjmp+1   ; USR function JMP vector low byte
000000r 2               Usrjph		= Usrjmp+2   ; USR function JMP vector high byte
000000r 2               
000000r 2               Nullct		= Usrjph+1   ; nulls output after each line
000000r 2               TPos			= Nullct+1   ; BASIC terminal position byte
000000r 2               TWidth		= TPos+1     ; BASIC terminal width byte
000000r 2               Iclim			= TWidth+1   ; input column limit
000000r 2               Itempl		= Iclim+1    ; temporary integer low byte
000000r 2               Itemph		= Itempl+1   ; temporary integer high byte
000000r 2               
000000r 2               nums_1		= Itempl     ; number to bin/hex string convert MSB
000000r 2               nums_2		= nums_1+1   ; number to bin/hex string convert
000000r 2               nums_3		= nums_1+2   ; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc			= nums_3+1   ; search character
000000r 2               Temp3			= Srchc      ; temp byte used in number routines
000000r 2               Scnquo		= Srchc+1    ; scan-between-quotes flag
000000r 2               Asrch			= Scnquo     ; alt search character
000000r 2               
000000r 2               XOAw_l		= Srchc      ; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h		= Scnquo     ; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr			= Scnquo+1   ; input buffer pointer
000000r 2               Dimcnt		= Ibptr      ; # of dimensions
000000r 2               Tindx			= Ibptr      ; token index
000000r 2               
000000r 2               Defdim		= Ibptr+1    ; default DIM flag
000000r 2               Dtypef		= Defdim+1   ; data type flag, $FF=string, $00=numeric
000000r 2               Oquote		= Dtypef+1   ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd		= Oquote     ; garbage collected flag
000000r 2               Sufnxf		= Gclctd+1   ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode			= Sufnxf+1   ; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag			= Imode+1    ; comparison evaluation flag
000000r 2               
000000r 2               TabSiz		= Cflag+1    ; TAB step size (was input flag)
000000r 2               
000000r 2               next_s		= TabSiz+1   ; next descriptor stack address
000000r 2               
000000r 2               ; these two bytes form a word pointer to the item
000000r 2               ; currently on top of the descriptor stack
000000r 2               
000000r 2               last_sl		= next_s+1   ; last descriptor stack address low byte
000000r 2               last_sh		= last_sl+1  ; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk		= last_sh+1  ; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ut1_pl		= des_sk+9   ; utility pointer 1 low byte
000000r 2               ut1_ph		= ut1_pl+1   ; utility pointer 1 high byte
000000r 2               ut2_pl		= ut1_ph+1   ; utility pointer 2 low byte
000000r 2               ut2_ph		= ut2_pl+1   ; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2		= ut1_pl     ; temp byte for block move
000000r 2               
000000r 2               FACt_1		= ut2_ph+1   ; FAC temp mantissa1
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/zeropage.s

000000r 2               FACt_2		= FACt_1+1   ; FAC temp mantissa2
000000r 2               FACt_3		= FACt_2+1   ; FAC temp mantissa3
000000r 2               
000000r 2               dims_l		= FACt_2     ; array dimension size low byte
000000r 2               dims_h		= FACt_3     ; array dimension size high byte
000000r 2               
000000r 2               TempB			= FACt_1+3   ; temp page 0 byte
000000r 2               
000000r 2               Smeml			= TempB+1    ; start of mem low byte         (Start-of-Basic)
000000r 2               Smemh			= Smeml+1    ; start of mem high byte        (Start-of-Basic)
000000r 2               Svarl			= Smemh+1    ; start of vars low byte        (Start-of-Variables)
000000r 2               Svarh			= Svarl+1    ; start of vars high byte       (Start-of-Variables)
000000r 2               Sarryl		= Svarh+1    ; var mem end low byte          (Start-of-Arrays)
000000r 2               Sarryh		= Sarryl+1   ; var mem end high byte         (Start-of-Arrays)
000000r 2               Earryl		= Sarryh+1   ; array mem end low byte        (End-of-Arrays)
000000r 2               Earryh		= Earryl+1   ; array mem end high byte       (End-of-Arrays)
000000r 2               Sstorl		= Earryh+1   ; string storage low byte       (String storage (moving down))
000000r 2               Sstorh		= Sstorl+1   ; string storage high byte      (String storage (moving down))
000000r 2               Sutill		= Sstorh+1   ; string utility ptr low byte
000000r 2               Sutilh		= Sutill+1   ; string utility ptr high byte
000000r 2               Ememl			= Sutilh+1   ; end of mem low byte           (Limit-of-memory)
000000r 2               Ememh			= Ememl+1    ; end of mem high byte          (Limit-of-memory)
000000r 2               Clinel		= Ememh+1    ; current line low byte         (Basic line number)
000000r 2               Clineh		= Clinel+1   ; current line high byte        (Basic line number)
000000r 2               Blinel		= Clineh+1   ; break line low byte           (Previous Basic line number)
000000r 2               Blineh		= Blinel+1   ; break line high byte          (Previous Basic line number)
000000r 2               
000000r 2               Cpntrl		= Blineh+1   ; continue pointer low byte
000000r 2               Cpntrh		= Cpntrl+1   ; continue pointer high byte
000000r 2               
000000r 2               Dlinel		= Cpntrh+1   ; current DATA line low byte
000000r 2               Dlineh		= Dlinel+1   ; current DATA line high byte
000000r 2               
000000r 2               Dptrl			= Dlineh+1   ; DATA pointer low byte
000000r 2               Dptrh			= Dptrl+1    ; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl		= Dptrh+1    ; read pointer low byte
000000r 2               Rdptrh		= Rdptrl+1   ; read pointer high byte
000000r 2               
000000r 2               Varnm1		= Rdptrh+1   ; current var name 1st byte
000000r 2               Varnm2		= Varnm1+1   ; current var name 2nd byte
000000r 2               
000000r 2               Cvaral		= Varnm2+1   ; current var address low byte
000000r 2               Cvarah		= Cvaral+1   ; current var address high byte
000000r 2               
000000r 2               Frnxtl		= Cvarah+1   ; var pointer for FOR/NEXT low byte
000000r 2               Frnxth		= Frnxtl+1   ; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1			= Frnxtl     ; temp line index
000000r 2               
000000r 2               Lvarpl		= Frnxtl     ; let var pointer low byte
000000r 2               Lvarph		= Frnxth     ; let var pointer high byte
000000r 2               
000000r 2               prstk			= Frnxtl+2   ; precedence stacked flag
000000r 2               
000000r 2               comp_f		= prstk+2    ; compare function flag, bits 0,1 and 2 used
000000r 2                                               ; bit 2 set if >
000000r 2                                               ; bit 1 set if =
000000r 2                                               ; bit 0 set if <
000000r 2               
000000r 2               func_l		= comp_f+1   ; function pointer low byte
000000r 2               func_h		= func_l+1   ; function pointer high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/zeropage.s

000000r 2               
000000r 2               garb_l		= func_l     ; garbage collection working pointer low byte
000000r 2               garb_h		= func_h     ; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l		= func_h+1   ; string descriptor_2 pointer low byte
000000r 2               des_2h		= des_2l+1   ; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step		= des_2l+2   ; garbage collect step size
000000r 2               
000000r 2               Fnxjmp		= g_step+1   ; jump vector for functions
000000r 2               Fnxjpl		= Fnxjmp+1   ; functions jump vector low byte
000000r 2               Fnxjph		= Fnxjmp+2   ; functions jump vector high byte
000000r 2               
000000r 2               g_indx		= Fnxjpl     ; garbage collect temp index
000000r 2               
000000r 2               FAC2_r		= Fnxjmp+2   ; FAC2 rounding byte
000000r 2               
000000r 2               Adatal		= FAC2_r+1   ; array data pointer low byte
000000r 2               Adatah		= Adatal+1   ; array data pointer high byte
000000r 2               
000000r 2               Nbendl		= Adatal     ; new block end pointer low byte
000000r 2               Nbendh		= Adatah     ; new block end pointer high byte
000000r 2               
000000r 2               Obendl		= Adatah+1   ; old block end pointer low byte
000000r 2               Obendh		= Obendl+1   ; old block end pointer high byte
000000r 2               
000000r 2               numexp		= Obendh+1   ; string to float number exponent count
000000r 2               expcnt		= numexp+1   ; string to float exponent count
000000r 2               
000000r 2               numbit		= numexp     ; bit count for array element calculations
000000r 2               
000000r 2               numdpf		= expcnt+1   ; string to float decimal point flag
000000r 2               expneg		= numdpf+1   ; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl		= numdpf     ; array start pointer low byte
000000r 2               Astrth		= expneg     ; array start pointer high byte
000000r 2               
000000r 2               Histrl		= numdpf     ; highest string low byte
000000r 2               Histrh		= expneg     ; highest string high byte
000000r 2               
000000r 2               Baslnl		= numdpf     ; BASIC search line pointer low byte
000000r 2               Baslnh		= expneg     ; BASIC search line pointer high byte
000000r 2               
000000r 2               Fvar_l		= numdpf     ; find/found variable pointer low byte
000000r 2               Fvar_h		= expneg     ; find/found variable pointer high byte
000000r 2               
000000r 2               Ostrtl		= numdpf     ; old block start pointer low byte
000000r 2               Ostrth		= expneg     ; old block start pointer high byte
000000r 2               
000000r 2               Vrschl		= numdpf     ; variable search pointer low byte
000000r 2               Vrschh		= expneg     ; variable search pointer high byte
000000r 2               
000000r 2               FAC1_e		= expneg+1   ; FAC1 exponent
000000r 2               FAC1_1		= FAC1_e+1   ; FAC1 mantissa1
000000r 2               FAC1_2		= FAC1_e+2   ; FAC1 mantissa2
000000r 2               FAC1_3		= FAC1_e+3   ; FAC1 mantissa3
000000r 2               FAC1_s		= FAC1_e+4   ; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln		= FAC1_e     ; string length
000000r 2               str_pl		= FAC1_1     ; string pointer low byte
000000r 2               str_ph		= FAC1_2     ; string pointer high byte
000000r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/zeropage.s

000000r 2               des_pl		= FAC1_2     ; string descriptor pointer low byte
000000r 2               des_ph		= FAC1_3     ; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l		= FAC1_3     ; MID$ string temp length byte
000000r 2               
000000r 2               negnum		= FAC1_e+5   ; string to float eval -ve flag
000000r 2               numcon		= negnum     ; series evaluation constant count
000000r 2               
000000r 2               FAC1_o		= negnum+1   ; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e		= FAC1_o+1   ; FAC2 exponent
000000r 2               FAC2_1		= FAC2_e+1   ; FAC2 mantissa1
000000r 2               FAC2_2		= FAC2_e+2   ; FAC2 mantissa2
000000r 2               FAC2_3		= FAC2_e+3   ; FAC2 mantissa3
000000r 2               FAC2_s		= FAC2_e+4   ; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc		= FAC2_e+5   ; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r		= FAC_sc+1   ; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l		= FAC_sc     ; string start pointer low byte
000000r 2               ssptr_h		= FAC1_r     ; string start pointer high byte
000000r 2               
000000r 2               sdescr		= FAC_sc     ; string descriptor pointer
000000r 2               
000000r 2               csidx			= FAC1_r+1   ; line crunch save index
000000r 2               Asptl			= csidx      ; array size/pointer low byte
000000r 2               Aspth			= csidx+1    ; array size/pointer high byte
000000r 2               
000000r 2               Btmpl			= Asptl      ; BASIC pointer temp low byte
000000r 2               Btmph			= Aspth      ; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl			= Asptl      ; BASIC pointer temp low byte
000000r 2               Cptrh			= Aspth      ; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl			= Asptl      ; BASIC pointer temp low byte
000000r 2               Sendh			= Aspth      ; BASIC pointer temp low byte
000000r 2               ;
000000r 2               ; CHRGET/CHRGOT routine now located in ROM
000000r 2               ; The two pointers below are accessed via ROM
000000r 2               ; Reduces Page zero usage by quite a bit with a minor performance penalty
000000r 2               ; CMOS addressing mode used, saves memory and execution time
000000r 2               ;
000000r 2               Bpntrl		= Sendh+1    ; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh		= Bpntrl+1   ; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               Rbyte4		= Bpntrh+1   ; extra PRNG byte
000000r 2               
000000r 2               Rbyte1		= Rbyte4+1   ; most significant PRNG byte
000000r 2               Rbyte2		= Rbyte4+2   ; middle PRNG byte
000000r 2               Rbyte3		= Rbyte4+3   ; least significant PRNG byte
000000r 2               
000000r 2               Decss			= Rbyte3+1   ; number to decimal string start
000000r 2               Decssp1		= Decss+1    ; number to decimal string start
000000r 2               ZPLB			= Decss+17	 ; last declared byte in Page Zero
000000r 2               
000000r 2               ; ZPLastByte = $85
000000r 2               LCDadr		= ZPLB 	 ; 1 byte, lcd busy flag and address
000000r 2               KBflags		= ZPLB+1 ; 1 byte
000000r 2               KBmods		= ZPLB+2 ; 1 byte
000000r 2               
000000r 1               	.include "basic.s"
000000r 2               ;
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000000r 2               ; Enhanced BASIC for the C02 Pocket SBC, Version 2.22p5C02
000000r 2               ; Original version/source by Lee Davison w/updates to Version 2.22
000000r 2               ; Patches and updates by Klaus Dorman Version 2.22p4 - see below
000000r 2               ; "C" is appended to define CMOS instructions/addressing modes used
000000r 2               ; "C02" is appemded to define CMOS only and working with C02Monitor/C02BIOS
000000r 2               ; Modified source code to assemble with WDC Tools package
000000r 2               ; Changes by K. E. Maier - July-November 2018
000000r 2               ;   minor changes and cleanup as of 13th November 2018
000000r 2               ;
000000r 2               ; Additional functions added 25th September 2019
000000r 2               ;   LOAD/SAVE functions via Xmodem-CRC routines in C02Monitor Version 2.03
000000r 2               ;
000000r 2               ; Additional patches added. Klaus provided a 2.22p5 patched version 13th January 2020
000000r 2               ; those patches are included here, albeit not in identical code for all patches
000000r 2               ;
000000r 2               ; NOTE: a couple patches to correct p5 patches on 27th February 2020 - oops
000000r 2               ;
000000r 2               ; NOTE: startup code is now contained here. Any Monitor or OS can now call the
000000r 2               ; ROM start location of EhBasic. Five Monitor/OS routines are required for the
000000r 2               ; core functions required: CHRIN, CHROUT, LOAD, SAVE, EXIT.
000000r 2               ; These are defined below. - 31st March, 2020
000000r 2               ;
000000r 2               ; Several of the Basic messages have been abbreviated to keep ROM space below $2700 bytes.
000000r 2               ; Well, We blew past $2700 on size after including all the startup code, so Basic messages
000000r 2               ; have been restored to their original text... sniff. It's still less than 10KB, so yeah!
000000r 2               ; Latest version shows as version 2.22p5C02 - 23rd May, 2020
000000r 2               ;
000000r 2               ;       Assembler/Linker directives for WDC Tools
000000r 2               ;
000000r 2                       ; PL      66      ;Page Length
000000r 2                       ; PW      132     ;Page Width (# of char/line)
000000r 2                       ; CHIP    W65C02S ;Enable WDC 65C02 instructions/addressing modes
000000r 2                       ; INCLIST ON      ;Include listing file
000000r 2                       ; PASS1   OFF     ;Set ON when used for debug
000000r 2               ;
000000r 2               ; Code changes include:
000000r 2               ;  Use ROM based CHRGET/CHRGOT routine with Page Zero pointer
000000r 2               ;  All Page zero usage is from the bottom ($00) up ($AF is max available)
000000r 2               ;  CMOS opcodes/addressing modes are used! tested with WDC65C02 only!
000000r 2               ;  Note: new instructions used include SMBx, RMBx, BBSx, BBRx! Note that
000000r 2               ;  this version will NOT run on a W65C816 in emulation mode!!
000000r 2               ;  Version renamed to Ver 2.22p5C02 (concurrency with Klaus' patched version)
000000r 2               ;
000000r 2               ; The following functions and all associated code (interrupt related)
000000r 2               ;  have been removed as they aren't needed with the C02 Pocket SBC:
000000r 2               ; - IRQ
000000r 2               ; - RETIRQ
000000r 2               ; - NMI
000000r 2               ; - RETNMI
000000r 2               ; - OFF
000000r 2               ; It is known that the interrupt functions above were not fully implemented
000000r 2               ; and didn't really work without additional coding. As the NMI routine is a
000000r 2               ; Panic routine on the C02 Pocket SBC, there's no need to support this one.
000000r 2               ; Also, the C02 Pocket SBC has a full IRQ code stack that is extendable. It
000000r 2               ; provides full support for the SCC2691 UART for Transmit, Receive, Break,
000000r 2               ; a 10ms jiffy-clock plus delays and a benchmark timer. These routines can
000000r 2               ; be called via JMP table entries in the C02 BIOS and Monitor. They could
000000r 2               ; also be added as additional Basic Commands, but I don't have any current
000000r 2               ; plan to do so as of now.
000000r 2               ;
000000r 2               ; NOTE: BASIC Tokens are NOT the same due to removal of the above commands!!
000000r 2               ; This would only be a problem if someone did a binary save of a BASIC program
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000000r 2               ; from the original code and then loaded it to this version of Basic. This is
000000r 2               ; unlikely however, as the original Enhanced Basic had NO Load or Save functions
000000r 2               ; implemented! Also note that Lee (when asked) recommended that Load and Save be
000000r 2               ; implemented using the LIST function redirected to Save and Basic Entry for Load.
000000r 2               ;
000000r 2               ; NOTE: The LOAD and SAVE functions implemented in this version are done as Binary!
000000r 2               ; The actual Load and Save routines are contained in the C02 Monitor code and called
000000r 2               ; via vectors. The C02 Monitor uses Xmodem-CRC for transferring data to and from
000000r 2               ; the host machine running the terminal emulator. Serial (OSX) and ExtraPutty have
000000r 2               ; been tested and work properly.
000000r 2               ;
000000r 2               ; An EXIT primary command has been added
000000r 2               ;  The EXIT command performs a JMP to the C02Monitor Warm start vector
000000r 2               ;  EhBasic can be re-entered via Warm start unless pages zero/four are changed
000000r 2               ;
000000r 2               ; 2.00      new revision numbers start here
000000r 2               ; 2.01      fixed LCASE$() and UCASE$()
000000r 2               ; 2.02      new get value routine done
000000r 2               ; 2.03      changed RND() to galoise method
000000r 2               ; 2.04      fixed SPC()
000000r 2               ; 2.05      new get value routine fixed
000000r 2               ; 2.06      changed USR() code
000000r 2               ; 2.07      fixed STR$()
000000r 2               ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09      fixed RND()
000000r 2               ; 2.10      integrated missed changes from an earlier version
000000r 2               ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21      fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22      fixed RND() breaking the get byte routine
000000r 2               ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
000000r 2               ;              (bugsnquirks.txt notes 2, 4 and 5)
000000r 2               ;              tabs converted to spaces, tabwidth=6
000000r 2               ; 2.22p2    fixed can't continue error on 1st statement after direct mode
000000r 2               ;              changed INPUT to throw "break in line ##" on empty line input
000000r 2               ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
000000r 2               ;              fix provided by github user mgcaret
000000r 2               ;              fixed string compare of equal strings in direct mode returns FALSE
000000r 2               ; 2.22p4    fixed FALSE stored to a variable after a string compare
000000r 2               ;                 is > 0 and < 1E-16
000000r 2               ;              added additional stack floor protection for background interrupts
000000r 2               ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
000000r 2               ; 2.22p4C   Port to C02 Pocket SBC - SCC2691 UART Console, 32KB RAM / 32KB ROM, 6MHz CPU
000000r 2               ;
000000r 2               ; 2.22p5C   Updates from Klaus for specific bug fixes added to the CMOS version
000000r 2               ;
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END            = $80             ; END token
000000r 2               TK_FOR            = TK_END+1        ; FOR token
000000r 2               TK_NEXT           = TK_FOR+1        ; NEXT token
000000r 2               TK_DATA           = TK_NEXT+1       ; DATA token
000000r 2               TK_INPUT          = TK_DATA+1       ; INPUT token
000000r 2               TK_DIM            = TK_INPUT+1      ; DIM token
000000r 2               TK_READ           = TK_DIM+1        ; READ token
000000r 2               TK_LET            = TK_READ+1       ; LET token
000000r 2               TK_DEC            = TK_LET+1        ; DEC token
000000r 2               TK_GOTO           = TK_DEC+1        ; GOTO token
000000r 2               TK_RUN            = TK_GOTO+1       ; RUN token
000000r 2               TK_IF             = TK_RUN+1        ; IF token
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000000r 2               TK_RESTORE        = TK_IF+1         ; RESTORE token
000000r 2               TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
000000r 2               TK_RETURN         = TK_GOSUB+1      ; RETURN token
000000r 2               TK_REM            = TK_RETURN+1     ; REM token
000000r 2               TK_STOP           = TK_REM+1        ; STOP token
000000r 2               TK_ON             = TK_STOP+1       ; ON token
000000r 2               TK_NULL           = TK_ON+1         ; NULL token
000000r 2               TK_INC            = TK_NULL+1       ; INC token
000000r 2               TK_WAIT           = TK_INC+1        ; WAIT token
000000r 2               TK_LOAD           = TK_WAIT+1       ; LOAD token
000000r 2               TK_SAVE           = TK_LOAD+1       ; SAVE token
000000r 2               TK_DEF            = TK_SAVE+1       ; DEF token
000000r 2               TK_POKE           = TK_DEF+1        ; POKE token
000000r 2               TK_DOKE           = TK_POKE+1       ; DOKE token
000000r 2               TK_CALL           = TK_DOKE+1       ; CALL token
000000r 2               TK_DO             = TK_CALL+1       ; DO token
000000r 2               TK_LOOP           = TK_DO+1         ; LOOP token
000000r 2               TK_PRINT          = TK_LOOP+1       ; PRINT token
000000r 2               TK_CONT           = TK_PRINT+1      ; CONT token
000000r 2               TK_LIST           = TK_CONT+1       ; LIST token
000000r 2               TK_CLEAR          = TK_LIST+1       ; CLEAR token
000000r 2               TK_NEW            = TK_CLEAR+1      ; NEW token
000000r 2               TK_WIDTH          = TK_NEW+1        ; WIDTH token
000000r 2               TK_GET            = TK_WIDTH+1      ; GET token
000000r 2               TK_SWAP           = TK_GET+1        ; SWAP token
000000r 2               TK_BITSET         = TK_SWAP+1       ; BITSET token
000000r 2               TK_BITCLR         = TK_BITSET+1     ; BITCLR token
000000r 2               TK_EXIT           = TK_BITCLR+1     ; EXIT token
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB            = TK_EXIT+1       ; TAB token
000000r 2               TK_ELSE           = TK_TAB+1        ; ELSE token
000000r 2               TK_TO             = TK_ELSE+1       ; TO token
000000r 2               TK_FN             = TK_TO+1         ; FN token
000000r 2               TK_SPC            = TK_FN+1         ; SPC token
000000r 2               TK_THEN           = TK_SPC+1        ; THEN token
000000r 2               TK_NOT            = TK_THEN+1       ; NOT token
000000r 2               TK_STEP           = TK_NOT+1        ; STEP token
000000r 2               TK_UNTIL          = TK_STEP+1       ; UNTIL token
000000r 2               TK_WHILE          = TK_UNTIL+1      ; WHILE token
000000r 2               
000000r 2               ; operator tokens
000000r 2               
000000r 2               TK_PLUS           = TK_WHILE+1      ; + token
000000r 2               TK_MINUS          = TK_PLUS+1       ; - token
000000r 2               TK_MUL            = TK_MINUS+1      ; * token
000000r 2               TK_DIV            = TK_MUL+1        ; / token
000000r 2               TK_POWER          = TK_DIV+1        ; ^ token
000000r 2               TK_AND            = TK_POWER+1      ; AND token
000000r 2               TK_EOR            = TK_AND+1        ; EOR token
000000r 2               TK_OR             = TK_EOR+1        ; OR token
000000r 2               TK_RSHIFT         = TK_OR+1         ; RSHIFT token
000000r 2               TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
000000r 2               TK_GT             = TK_LSHIFT+1     ; > token
000000r 2               TK_EQUAL          = TK_GT+1         ; = token
000000r 2               TK_LT             = TK_EQUAL+1      ; < token
000000r 2               
000000r 2               ; function tokens
000000r 2               
000000r 2               TK_SGN            = TK_LT+1         ; SGN token
000000r 2               TK_INT            = TK_SGN+1        ; INT token
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000000r 2               TK_ABS            = TK_INT+1        ; ABS token
000000r 2               TK_USR            = TK_ABS+1        ; USR token
000000r 2               TK_FRE            = TK_USR+1        ; FRE token
000000r 2               TK_POS            = TK_FRE+1        ; POS token
000000r 2               TK_SQR            = TK_POS+1        ; SQR token
000000r 2               TK_RND            = TK_SQR+1        ; RND token
000000r 2               TK_LOG            = TK_RND+1        ; LOG token
000000r 2               TK_EXP            = TK_LOG+1        ; EXP token
000000r 2               TK_COS            = TK_EXP+1        ; COS token
000000r 2               TK_SIN            = TK_COS+1        ; SIN token
000000r 2               TK_TAN            = TK_SIN+1        ; TAN token
000000r 2               TK_ATN            = TK_TAN+1        ; ATN token
000000r 2               TK_PEEK           = TK_ATN+1        ; PEEK token
000000r 2               TK_DEEK           = TK_PEEK+1       ; DEEK token
000000r 2               TK_SADD           = TK_DEEK+1       ; SADD token
000000r 2               TK_LEN            = TK_SADD+1       ; LEN token
000000r 2               TK_STRS           = TK_LEN+1        ; STR$ token
000000r 2               TK_VAL            = TK_STRS+1       ; VAL token
000000r 2               TK_ASC            = TK_VAL+1        ; ASC token
000000r 2               TK_UCASES         = TK_ASC+1        ; UCASE$ token
000000r 2               TK_LCASES         = TK_UCASES+1     ; LCASE$ token
000000r 2               TK_CHRS           = TK_LCASES+1     ; CHR$ token
000000r 2               TK_HEXS           = TK_CHRS+1       ; HEX$ token
000000r 2               TK_BINS           = TK_HEXS+1       ; BIN$ token
000000r 2               TK_BITTST         = TK_BINS+1       ; BITTST token
000000r 2               TK_MAX            = TK_BITTST+1     ; MAX token
000000r 2               TK_MIN            = TK_MAX+1        ; MIN token
000000r 2               TK_PI             = TK_MIN+1        ; PI token
000000r 2               TK_TWOPI          = TK_PI+1         ; TWOPI token
000000r 2               TK_VPTR           = TK_TWOPI+1      ; VARPTR token
000000r 2               TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
000000r 2               TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
000000r 2               TK_MIDS           = TK_RIGHTS+1     ; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0            = $00       ; X or Y plus 0
000000r 2               PLUS_1            = $01       ; X or Y plus 1
000000r 2               PLUS_2            = $02       ; X or Y plus 2
000000r 2               PLUS_3            = $03       ; X or Y plus 3
000000r 2               
000000r 2               STACK_RES         = 20       ; reserved stack space
000000r 2               
000000r 2               LAB_STAK          = $0100     ; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE          = LAB_STAK+$FE
000000r 2                                                ; flushed stack address
000000r 2               LAB_SKFF          = LAB_STAK+$FF
000000r 2                                                ; flushed stack address
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
000000r 2               ; the input buffer must not cross a page boundary and must not overlap with
000000r 2               ; program RAM pages!
000000r 2               
000000r 2               Ibuffs          = $0500     ; Start of input buffer
000000r 2               Ibuffe          = Ibuffs+$7E ; end of input buffer (127 bytes)
000000r 2               
000000r 2               ccflag          = Ibuffe+1  ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte          = ccflag+1  ; BASIC CTRL-C byte
000000r 2               ccnull          = ccbyte+1  ; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC          = ccnull+1  ; CTRL-C check vector
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000000r 2               
000000r 2               VEC_IN          = VEC_CC+2  ; input vector
000000r 2               VEC_OUT         = VEC_IN+2  ; output vector
000000r 2               VEC_LD          = VEC_OUT+2 ; load vector
000000r 2               VEC_SV          = VEC_LD+2  ; save vector
000000r 2               VEC_EXIT        = VEC_SV+2  ; exit vector
000000r 2               
000000r 2               Ram_base        = $0800     ; start of user RAM (1st 2KB used/reserved)
000000r 2               Ram_top         = $8000     ; end of user RAM+1 ($8000 is start of ROM)
000000r 2               
000000r 2               ; The start address can be changed, noting the BIOS/Monitor locations
000000r 2               
000000r 2                           	            		; Start of Basic in ROM
000000r 2                                             ; BASIC starts at $B000
000000r 2                                             ; Monitor starts at $E000
000000r 2                                             ; BIOS starts at $F800
000000r 2               .segment "BASIC"
000000r 2               ; BASIC cold start entry point
000000r 2               
000000r 2               ; new page $04 initialisation, copy ROM data to RAM
000000r 2               ; consists of the vectors Input/Output/Load/Save/Exit
000000r 2               ; and Control-C flags, pointers
000000r 2               
000000r 2               LAB_COLD
000000r 2  A2 0E              LDX   #PG4_TABE-PG4_TABS-1 ; byte count-1
000002r 2               LAB_2D13
000002r 2  BD rr rr           LDA   PG4_TABS,X        ; get byte
000005r 2  9D 7F 05           STA   ccflag,X          ; store in page 4
000008r 2  CA                 DEX                     ; decrement count
000009r 2  10 F7              BPL   LAB_2D13          ; loop if not done
00000Br 2               
00000Br 2  9A                 TXS                     ; reset stack pointer (X Reg = $FF from above)
00000Cr 2  86 3A              STX   Clineh            ; set current line high byte (set immediate mode)
00000Er 2               
00000Er 2  A9 4C              LDA   #$4C              ; code for JMP
000010r 2  85 53              STA   Fnxjmp            ; save for jump vector for functions
000012r 2               
000012r 2               ; copy block from StrTab to $0000 - $0012
000012r 2               
000012r 2               LAB_GMEM
000012r 2  A2 0B              LDX   #EndTab-StrTab-1  ; set byte count-1
000014r 2               TabLoop
000014r 2  BD rr rr           LDA   StrTab,X          ; get byte from table
000017r 2  95 00              STA   PLUS_0,X          ; save byte in page zero
000019r 2  CA                 DEX                     ; decrement count
00001Ar 2  10 F8              BPL   TabLoop           ; loop until done
00001Cr 2               
00001Cr 2               ; set-up start values
00001Cr 2               
00001Cr 2  64 64              STZ   FAC1_o            ; clear FAC1 overflow byte
00001Er 2  64 19              STZ   last_sh           ; clear descriptor stack top item pointer high byte
000020r 2               
000020r 2  A9 0E              LDA   #$0E              ; set default tab size
000022r 2  85 16              STA   TabSiz            ; save it
000024r 2  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
000026r 2  85 52              STA   g_step            ; save it
000028r 2  A2 1A              LDX   #des_sk           ; descriptor stack start
00002Ar 2  86 17              STX   next_s            ; set descriptor stack pointer
00002Cr 2               
00002Cr 2               ; bypass user memory prompt, just test, show and go
00002Cr 2               ; we get here with Itempl/h = Ram_base
00002Cr 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00002Cr 2               LAB_2D93
00002Cr 2  A9 55              LDA   #$55              ; set test byte
00002Er 2  92 0A              STA   (Itempl)          ; save via temporary integer
000030r 2  D2 0A              CMP   (Itempl)          ; compare via temporary integer
000032r 2  D0 1B              BNE   LAB_2DB6          ; branch if fail
000034r 2               
000034r 2  0A                 ASL                     ; shift test byte left (now $AA)
000035r 2  92 0A              STA   (Itempl)          ; save via temporary integer
000037r 2  D2 0A              CMP   (Itempl)          ; compare via temporary integer
000039r 2  D0 14              BNE   LAB_2DB6          ; branch if fail
00003Br 2               
00003Br 2  A9 00              LDA   #$00              ; get zero
00003Dr 2  92 0A              STA   (Itempl)          ; clear tested byte
00003Fr 2  D2 0A              CMP   (Itempl)          ; compare via temporary integer
000041r 2  D0 0C              BNE   LAB_2DB6          ; branch if fail
000043r 2               
000043r 2  E6 0A              INC   Itempl            ; increment temporary integer low byte
000045r 2  D0 E5              BNE   LAB_2D93          ; branch if no overflow
000047r 2               
000047r 2  E6 0B              INC   Itemph            ; increment temporary integer high byte
000049r 2  A5 0B              LDA   Itemph            ; get high byte
00004Br 2  C9 80              CMP   #>Ram_top         ; compare with top of RAM+1
00004Dr 2  D0 DD              BNE   LAB_2D93          ; branch and continue testing RAM
00004Fr 2               
00004Fr 2               LAB_2DB6
00004Fr 2  A5 0A              LDA   Itempl            ; get temporary integer low byte
000051r 2  A4 0B              LDY   Itemph            ; get temporary integer high byte ($00)
000053r 2               
000053r 2  85 37              STA   Ememl             ; set end of mem low byte
000055r 2  84 38              STY   Ememh             ; set end of mem high byte
000057r 2  85 33              STA   Sstorl            ; set bottom of string space low byte
000059r 2  84 34              STY   Sstorh            ; set bottom of string space high byte
00005Br 2               
00005Br 2  A0 00              LDY   #<Ram_base        ; set start addr low byte
00005Dr 2  A2 08              LDX   #>Ram_base        ; set start addr high byte
00005Fr 2  C8                 INY                     ; increment Ram_base low byte
000060r 2  84 2B              STY   Smeml             ; save start of mem low byte
000062r 2  86 2C              STX   Smemh             ; save start of mem high byte
000064r 2               
000064r 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
000067r 2  20 rr rr           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00006Ar 2  A5 37              LDA   Ememl             ; get end of mem low byte
00006Cr 2  38                 SEC                     ; set carry for subtract
00006Dr 2  E5 2B              SBC   Smeml             ; subtract start of mem low byte
00006Fr 2  AA                 TAX                     ; copy to X
000070r 2  A5 38              LDA   Ememh             ; get end of mem high byte
000072r 2  E5 2C              SBC   Smemh             ; subtract start of mem high byte
000074r 2  20 rr rr           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
000077r 2  A9 rr              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
000079r 2  A0 rr              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00007Br 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
00007Er 2  6C 01 00           JMP   (Wrmjpl)          ; jump to warm start
000081r 2               
000081r 2               ; open up space in memory
000081r 2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
000081r 2               
000081r 2               ; Nbendl,Nbendh - new block end address (A/Y)
000081r 2               ; Obendl,Obendh - old block end address
000081r 2               ; Ostrtl,Ostrth - old block start address
000081r 2               
000081r 2               ; returns with ..
000081r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000081r 2               ; Nbendl,Nbendh - new block start address (high byte - $100)
000081r 2               ; Obendl,Obendh - old block start address (high byte - $100)
000081r 2               ; Ostrtl,Ostrth - old block start address (unchanged)
000081r 2               
000081r 2               LAB_11CF
000081r 2  20 rr rr           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
000084r 2                                             ; addr to check is in AY (low/high)
000084r 2  85 31              STA   Earryl            ; save new array mem end low byte
000086r 2  84 32              STY   Earryh            ; save new array mem end high byte
000088r 2               
000088r 2               ; open up space in memory
000088r 2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
000088r 2               ; don't set array end
000088r 2               
000088r 2               LAB_11D6
000088r 2  38                 SEC                     ; set carry for subtract
000089r 2  A5 58              LDA   Obendl            ; get block end low byte
00008Br 2  E5 5C              SBC   Ostrtl            ; subtract block start low byte
00008Dr 2  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00008Er 2  A5 59              LDA   Obendh            ; get block end high byte
000090r 2  E5 5D              SBC   Ostrth            ; subtract block start high byte
000092r 2  AA                 TAX                     ; copy block length high byte to X
000093r 2  E8                 INX                     ; +1 to allow for count=0 exit
000094r 2  98                 TYA                     ; copy block length low byte to A
000095r 2  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
000097r 2               
000097r 2                                             ; block is (X-1)*256+Y bytes, do the Y bytes first
000097r 2  38                 SEC                     ; set carry for add + 1, two's complement
000098r 2  49 FF              EOR   #$FF              ; invert low byte for subtract
00009Ar 2  65 58              ADC   Obendl            ; add block end low byte
00009Cr 2  85 58              STA   Obendl            ; save corrected old block end low byte
00009Er 2  B0 03              BCS   LAB_11F3          ; branch if no underflow
0000A0r 2  C6 59              DEC   Obendh            ; else decrement block end high byte
0000A2r 2  38                 SEC                     ; set carry for add + 1, two's complement
0000A3r 2               LAB_11F3
0000A3r 2  98                 TYA                     ; get MOD(block length/$100) byte
0000A4r 2  49 FF              EOR   #$FF              ; invert low byte for subtract
0000A6r 2  65 56              ADC   Nbendl            ; add destination end low byte
0000A8r 2  85 56              STA   Nbendl            ; save modified new block end low byte
0000AAr 2  B0 08              BCS   LAB_1203          ; branch if no underflow
0000ACr 2  C6 57              DEC   Nbendh            ; else decrement block end high byte
0000AEr 2  80 04              BRA   LAB_1203          ; branch always
0000B0r 2               
0000B0r 2               LAB_11FF
0000B0r 2  B1 58              LDA   (Obendl),Y        ; get byte from source
0000B2r 2  91 56              STA   (Nbendl),Y        ; copy byte to destination
0000B4r 2               LAB_1203
0000B4r 2  88                 DEY                     ; decrement index
0000B5r 2  D0 F9              BNE   LAB_11FF          ; loop until Y=0
0000B7r 2                                             ; now do Y=0 indexed byte
0000B7r 2  B1 58              LDA   (Obendl),Y        ; get byte from source
0000B9r 2  91 56              STA   (Nbendl),Y        ; save byte to destination
0000BBr 2               LAB_120A
0000BBr 2  C6 59              DEC   Obendh            ; decrement source pointer high byte
0000BDr 2  C6 57              DEC   Nbendh            ; decrement destination pointer high byte
0000BFr 2  CA                 DEX                     ; decrement block count
0000C0r 2  D0 F2              BNE   LAB_1203          ; loop until count = $0
0000C2r 2  60                 RTS
0000C3r 2               
0000C3r 2               ; check room on stack for A bytes
0000C3r 2               ; stack too deep? do OM error
0000C3r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0000C3r 2               LAB_1212                      ; patched for stack floor
0000C3r 2  18                 CLC                     ; prep ADC
0000C4r 2  69 14              ADC   #STACK_RES        ; stack pointer lower limit before interrupts
0000C6r 2  85 2A              STA   TempB             ; save result in temp byte
0000C8r 2  BA                 TSX                     ; copy stack
0000C9r 2  E4 2A              CPX   TempB             ; compare new "limit" with stack
0000CBr 2  90 2F              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
0000CDr 2  60                 RTS
0000CEr 2               
0000CEr 2               ; check available memory, "Out of memory" error if no room
0000CEr 2               ; addr to check is in AY (low/high)
0000CEr 2               
0000CEr 2               LAB_121F
0000CEr 2  C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
0000D0r 2  90 29              BCC   LAB_124B          ; if less then exit (is ok)
0000D2r 2               
0000D2r 2  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
0000D4r 2               
0000D4r 2                                             ; high byte was =, now do low byte
0000D4r 2  C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
0000D6r 2  90 23              BCC   LAB_124B          ; if less then exit (is ok)
0000D8r 2               
0000D8r 2                                             ; addr is > string storage ptr (oops!)
0000D8r 2               LAB_1229
0000D8r 2  48                 PHA                     ; push addr low byte
0000D9r 2  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
0000DBr 2  98                 TYA                     ; copy addr high byte (to push on stack)
0000DCr 2               
0000DCr 2                                             ; save misc numeric work area
0000DCr 2               LAB_122D
0000DCr 2  48                 PHA                     ; push byte
0000DDr 2  B5 55              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
0000DFr 2  CA                 DEX                     ; decrement index
0000E0r 2  10 FA              BPL   LAB_122D          ; loop until all done
0000E2r 2               
0000E2r 2  20 rr rr           JSR   LAB_GARB          ; garbage collection routine
0000E5r 2               
0000E5r 2                                             ; restore misc numeric work area
0000E5r 2  A2 00              LDX   #$00              ; clear the index to restore bytes
0000E7r 2               LAB_1238
0000E7r 2  68                 PLA                     ; pop byte
0000E8r 2  95 56              STA   Adatal,X          ; save byte to Adatal to expneg
0000EAr 2  E8                 INX                     ; increment index
0000EBr 2  E0 08              CPX   #$08              ; compare with end + 1
0000EDr 2  30 F8              BMI   LAB_1238          ; loop if more to do
0000EFr 2               
0000EFr 2  7A                 PLY                     ; pop addr high byte
0000F0r 2  68                 PLA                     ; pop addr low byte
0000F1r 2  C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
0000F3r 2  90 06              BCC   LAB_124B          ; if less then exit (is ok)
0000F5r 2               
0000F5r 2  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
0000F7r 2               
0000F7r 2                                             ; high byte was =, now do low byte
0000F7r 2  C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
0000F9r 2  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
0000FBr 2                                             ; ok exit, carry clear
0000FBr 2               LAB_124B
0000FBr 2  60                 RTS
0000FCr 2               
0000FCr 2               ; do "Out of memory" error then warm start
0000FCr 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0000FCr 2               LAB_OMER
0000FCr 2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
0000FEr 2               
0000FEr 2               ; do error #X, then warm start
0000FEr 2               
0000FEr 2               LAB_XERR
0000FEr 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
000101r 2               
000101r 2  BD rr rr           LDA   LAB_BAER,X        ; get error message pointer low byte
000104r 2  BC rr rr           LDY   LAB_BAER+1,X      ; get error message pointer high byte
000107r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
00010Ar 2               
00010Ar 2  20 rr rr           JSR   LAB_1491          ; flush stack and clear continue flag
00010Dr 2  A9 rr              LDA   #<LAB_EMSG        ; point to " Error" low addr
00010Fr 2  A0 rr              LDY   #>LAB_EMSG        ; point to " Error" high addr
000111r 2               LAB_1269
000111r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
000114r 2  A4 3A              LDY   Clineh            ; get current line high byte
000116r 2  C8                 INY                     ; increment it
000117r 2  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
000119r 2               
000119r 2                                             ; else print line number
000119r 2  20 rr rr           JSR   LAB_2953          ; print " in line [LINE #]"
00011Cr 2               
00011Cr 2               ; BASIC warm start entry point
00011Cr 2               ; wait for Basic command
00011Cr 2               
00011Cr 2               LAB_1274
00011Cr 2  A9 rr              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00011Er 2  A0 rr              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
000120r 2               
000120r 2  20 rr rr           JSR   LAB_18C3          ; go do print string
000123r 2               
000123r 2               ; wait for Basic command (no "Ready")
000123r 2               
000123r 2               LAB_127D
000123r 2  20 rr rr           JSR   LAB_1357          ; call for BASIC input
000126r 2               LAB_1280
000126r 2  86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
000128r 2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
00012Ar 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
00012Dr 2  F0 F4              BEQ   LAB_127D          ; loop while null
00012Fr 2               
00012Fr 2               ; got to interpret input line now ..
00012Fr 2               
00012Fr 2  A2 FF              LDX   #$FF              ; current line to null value
000131r 2  86 3A              STX   Clineh            ; set current line high byte
000133r 2  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
000135r 2               
000135r 2                                             ; no line number .. immediate mode
000135r 2  20 rr rr           JSR   LAB_13A6          ; crunch keywords into Basic tokens
000138r 2  4C rr rr           JMP   LAB_15F6          ; go scan and interpret code
00013Br 2               
00013Br 2               ; handle new BASIC line
00013Br 2               
00013Br 2               LAB_1295
00013Br 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00013Er 2  20 rr rr           JSR   LAB_13A6          ; crunch keywords into Basic tokens
000141r 2  84 0F              STY   Ibptr             ; save index pointer to end of crunched line
000143r 2  20 rr rr           JSR   LAB_SSLN          ; search BASIC for temp integer line number
000146r 2  90 44              BCC   LAB_12E6          ; branch if not found
000148r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000148r 2                                             ; aroooogah! line # already exists! delete it
000148r 2  A0 01              LDY   #$01              ; set index to next line pointer high byte
00014Ar 2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
00014Cr 2  85 24              STA   ut1_ph            ; save it
00014Er 2  A5 2D              LDA   Svarl             ; get start of vars low byte
000150r 2  85 23              STA   ut1_pl            ; save it
000152r 2  A5 5D              LDA   Baslnh            ; get found line pointer high byte
000154r 2  85 26              STA   ut2_ph            ; save it
000156r 2  A5 5C              LDA   Baslnl            ; get found line pointer low byte
000158r 2  88                 DEY                     ; decrement index
000159r 2  F1 5C              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00015Br 2  18                 CLC                     ; clear carry for add
00015Cr 2  65 2D              ADC   Svarl             ; add start of vars low byte
00015Er 2  85 2D              STA   Svarl             ; save new start of vars low byte
000160r 2  85 25              STA   ut2_pl            ; save destination pointer low byte
000162r 2  A5 2E              LDA   Svarh             ; get start of vars high byte
000164r 2  69 FF              ADC   #$FF              ; -1 + carry
000166r 2  85 2E              STA   Svarh             ; save start of vars high byte
000168r 2  E5 5D              SBC   Baslnh            ; subtract found line pointer high byte
00016Ar 2  AA                 TAX                     ; copy to block count
00016Br 2  38                 SEC                     ; set carry for subtract
00016Cr 2  A5 5C              LDA   Baslnl            ; get found line pointer low byte
00016Er 2  E5 2D              SBC   Svarl             ; subtract start of vars low byte
000170r 2  A8                 TAY                     ; copy to bytes in first block count
000171r 2  B0 03              BCS   LAB_12D0          ; branch if overflow
000173r 2               
000173r 2  E8                 INX                     ; increment block count (correct for =0 loop exit)
000174r 2  C6 26              DEC   ut2_ph            ; decrement destination high byte
000176r 2               LAB_12D0
000176r 2  18                 CLC                     ; clear carry for add
000177r 2  65 23              ADC   ut1_pl            ; add source pointer low byte
000179r 2  90 03              BCC   LAB_12D8          ; branch if no overflow
00017Br 2               
00017Br 2  C6 24              DEC   ut1_ph            ; else decrement source pointer high byte
00017Dr 2  18                 CLC                     ; clear carry
00017Er 2               
00017Er 2                                             ; close up memory to delete old line
00017Er 2               LAB_12D8
00017Er 2  B1 23              LDA   (ut1_pl),Y        ; get byte from source
000180r 2  91 25              STA   (ut2_pl),Y        ; copy to destination
000182r 2  C8                 INY                     ; increment index
000183r 2  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
000185r 2               
000185r 2  E6 24              INC   ut1_ph            ; increment source pointer high byte
000187r 2  E6 26              INC   ut2_ph            ; increment destination pointer high byte
000189r 2  CA                 DEX                     ; decrement block count
00018Ar 2  D0 F2              BNE   LAB_12D8          ; loop until all done
00018Cr 2               
00018Cr 2                                             ; got new line in buffer and no existing same #
00018Cr 2               LAB_12E6
00018Cr 2  AD 00 05           LDA   Ibuffs            ; get byte from start of input buffer
00018Fr 2  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
000191r 2               
000191r 2                                             ; got new line and it isn't empty line
000191r 2  A5 37              LDA   Ememl             ; get end of mem low byte
000193r 2  A4 38              LDY   Ememh             ; get end of mem high byte
000195r 2  85 33              STA   Sstorl            ; set bottom of string space low byte
000197r 2  84 34              STY   Sstorh            ; set bottom of string space high byte
000199r 2  A5 2D              LDA   Svarl             ; get start of vars low byte (end of BASIC)
00019Br 2  85 58              STA   Obendl            ; save old block end low byte
00019Dr 2  A4 2E              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00019Fr 2  84 59              STY   Obendh            ; save old block end high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0001A1r 2  65 0F              ADC   Ibptr             ; add input buffer pointer (also buffer length)
0001A3r 2  90 01              BCC   LAB_1301          ; branch if no overflow from add
0001A5r 2  C8                 INY                     ; else increment high byte
0001A6r 2               LAB_1301
0001A6r 2  85 56              STA   Nbendl            ; save new block end low byte (move to, low byte)
0001A8r 2  84 57              STY   Nbendh            ; save new block end high byte
0001AAr 2  20 rr rr           JSR   LAB_11CF          ; open up space in memory
0001ADr 2                                             ; old start pointer Ostrtl,Ostrth set by the find line call
0001ADr 2  A5 31              LDA   Earryl            ; get array mem end low byte
0001AFr 2  A4 32              LDY   Earryh            ; get array mem end high byte
0001B1r 2  85 2D              STA   Svarl             ; save start of vars low byte
0001B3r 2  84 2E              STY   Svarh             ; save start of vars high byte
0001B5r 2  A4 0F              LDY   Ibptr             ; get input buffer pointer (also buffer length)
0001B7r 2  88                 DEY                     ; adjust for loop type
0001B8r 2               LAB_1311
0001B8r 2  B9 FC 04           LDA   Ibuffs-4,Y        ; get byte from crunched line
0001BBr 2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0001BDr 2  88                 DEY                     ; decrement count
0001BEr 2  C0 03              CPY   #$03              ; compare with first byte-1
0001C0r 2  D0 F6              BNE   LAB_1311          ; continue while count <> 3
0001C2r 2               
0001C2r 2  A5 0B              LDA   Itemph            ; get line # high byte
0001C4r 2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0001C6r 2  88                 DEY                     ; decrement count
0001C7r 2  A5 0A              LDA   Itempl            ; get line # low byte
0001C9r 2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0001CBr 2  88                 DEY                     ; decrement count
0001CCr 2  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
0001CEr 2                                             ; byte then a zero already here would stop the chain rebuild
0001CEr 2                                             ; as it would think it was the [EOT] marker.
0001CEr 2  91 5C              STA   (Baslnl),Y        ; save it to program memory
0001D0r 2               
0001D0r 2               LAB_1319
0001D0r 2  20 rr rr           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
0001D3r 2  A6 2B              LDX   Smeml             ; get start of mem low byte
0001D5r 2  A5 2C              LDA   Smemh             ; get start of mem high byte
0001D7r 2  A0 01              LDY   #$01              ; index to high byte of next line pointer
0001D9r 2               LAB_1325
0001D9r 2  86 23              STX   ut1_pl            ; set line start pointer low byte
0001DBr 2  85 24              STA   ut1_ph            ; set line start pointer high byte
0001DDr 2  B1 23              LDA   (ut1_pl),Y        ; get it
0001DFr 2  F0 18              BEQ   LAB_133E          ; exit if end of program
0001E1r 2               
0001E1r 2               ; rebuild chaining of Basic lines
0001E1r 2               
0001E1r 2  A0 04              LDY   #$04              ; point to first code byte of line
0001E3r 2                                             ; there is always 1 byte + [EOL] as null entries are deleted
0001E3r 2               LAB_1330
0001E3r 2  C8                 INY                     ; next code byte
0001E4r 2  B1 23              LDA   (ut1_pl),Y        ; get byte
0001E6r 2  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
0001E8r 2               
0001E8r 2  38                 SEC                     ; set carry for add + 1
0001E9r 2  98                 TYA                     ; copy end index
0001EAr 2  65 23              ADC   ut1_pl            ; add to line start pointer low byte
0001ECr 2  AA                 TAX                     ; copy to X
0001EDr 2  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
0001EFr 2  91 23              STA   (ut1_pl),Y        ; set next line pointer low byte
0001F1r 2  98                 TYA                     ; clear A
0001F2r 2  65 24              ADC   ut1_ph            ; add line start pointer high byte + carry
0001F4r 2  C8                 INY                     ; increment index to high byte
0001F5r 2  91 23              STA   (ut1_pl),Y        ; save next line pointer low byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0001F7r 2  80 E0              BRA   LAB_1325          ; go do next line, branch always, carry clear
0001F9r 2               
0001F9r 2               LAB_133E
0001F9r 2  FF D6 03           BBS7  OPXMDM, DO_RDY    ; test to see if LOAD was executed
0001FCr 2  4C rr rr           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
0001FFr 2               DO_RDY
0001FFr 2  77 D6              RMB7  OPXMDM            ; reset flag bit to zero
000201r 2  4C rr rr           JMP   LAB_1274          ; print Ready msg and wait for Basic command
000204r 2               
000204r 2               ; print "? " and get BASIC input
000204r 2               
000204r 2               LAB_INLN
000204r 2  20 rr rr           JSR   LAB_18E3          ; print "?" character
000207r 2  20 rr rr           JSR   LAB_18E0          ; print " "
00020Ar 2  80 06              BRA   LAB_1357          ; call for BASIC input and return
00020Cr 2               
00020Cr 2               ; receive line from keyboard
00020Cr 2               
00020Cr 2                                             ; $08 as delete key (BACKSPACE on standard keyboard)
00020Cr 2               LAB_134B
00020Cr 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
00020Fr 2  CA                 DEX                     ; decrement the buffer counter (delete)
000210r 2  80 02              BRA   LAB_1359          ; branch over next instruction, save 1 clock cycle
000212r 2               
000212r 2               ; call for BASIC input (main entry point)
000212r 2               
000212r 2               LAB_1357
000212r 2  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
000214r 2               LAB_1359
000214r 2  20 rr rr           JSR   V_INPT            ; call scan input device
000217r 2  90 FB              BCC   LAB_1359          ; loop if no byte
000219r 2               
000219r 2  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
00021Br 2               
00021Br 2  C9 07              CMP   #$07              ; compare with [BELL]
00021Dr 2  F0 10              BEQ   LAB_1378          ; branch if [BELL]
00021Fr 2               
00021Fr 2  C9 0D              CMP   #$0D              ; compare with [CR]
000221r 2  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
000223r 2               
000223r 2  E0 00              CPX   #$00              ; compare pointer with $00
000225r 2  D0 04              BNE   LAB_1374          ; branch if not empty
000227r 2               
000227r 2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
000227r 2               
000227r 2  C9 21              CMP   #$21              ; compare with [SP]+1
000229r 2  90 E9              BCC   LAB_1359          ; if < ignore character
00022Br 2               
00022Br 2               LAB_1374
00022Br 2  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
00022Dr 2  F0 DD              BEQ   LAB_134B          ; go delete last character
00022Fr 2               
00022Fr 2               LAB_1378
00022Fr 2  E0 7E              CPX   #Ibuffe-Ibuffs    ; compare character count with max
000231r 2  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
000233r 2               
000233r 2  9D 00 05           STA   Ibuffs,X          ; else store in buffer
000236r 2  E8                 INX                     ; increment pointer
000237r 2               LAB_137F
000237r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
00023Ar 2  80 D8              BRA   LAB_1359          ; always loop for next character
00023Cr 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00023Cr 2               LAB_1384
00023Cr 2  4C rr rr           JMP   LAB_1866          ; do CR/LF exit to BASIC
00023Fr 2               
00023Fr 2               ; announce buffer full
00023Fr 2               
00023Fr 2               LAB_138E
00023Fr 2  A9 07              LDA   #$07              ; [BELL] character into A
000241r 2  80 F4              BRA   LAB_137F          ; go print the [BELL] but ignore input character
000243r 2                                             ; branch always
000243r 2               
000243r 2               ; crunch keywords into Basic tokens
000243r 2               ; position independent buffer version ..
000243r 2               ; faster, dictionary search version ....
000243r 2               
000243r 2               LAB_13A6
000243r 2  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
000245r 2  38                 SEC                     ; set carry for subtract
000246r 2  A5 6E              LDA   Bpntrl            ; get basic execute pointer low byte
000248r 2  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
00024Ar 2  AA                 TAX                     ; copy result to X (index past line # if any)
00024Br 2  86 12              STX   Oquote            ; clear open quote/DATA flag
00024Dr 2               LAB_13AC
00024Dr 2  BD 00 05           LDA   Ibuffs,X          ; get byte from input buffer
000250r 2  F0 5D              BEQ   LAB_13EC          ; if null save byte then exit
000252r 2  C9 7B              CMP   #'{'              ; convert lower to upper case
000254r 2  B0 59              BCS   LAB_13EC          ; is above lower case
000256r 2  C9 61              CMP   #'a'
000258r 2  90 02              BCC   PATCH_LC          ; is below lower case
00025Ar 2  29 DF              AND   #$DF              ; mask lower case bit
00025Cr 2               
00025Cr 2               PATCH_LC
00025Cr 2  C9 5F              CMP   #'_'              ; compare with "_"
00025Er 2  B0 4F              BCS   LAB_13EC          ; if >= go save byte then continue crunching
000260r 2               
000260r 2  C9 3C              CMP   #'<'              ; compare with "<"
000262r 2  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
000264r 2               
000264r 2  C9 30              CMP   #'0'              ; compare with "0"
000266r 2  B0 47              BCS   LAB_13EC          ; if >= go save byte then continue crunching
000268r 2               
000268r 2  85 0E              STA   Scnquo            ; save buffer byte as search character
00026Ar 2  C9 22              CMP   #$22              ; is it quote character?
00026Cr 2  F0 63              BEQ   LAB_1410          ; branch if so (copy quoted string)
00026Er 2               
00026Er 2  C9 2A              CMP   #'*'              ; compare with "*"
000270r 2  90 3D              BCC   LAB_13EC          ; if < go save byte then continue crunching
000272r 2                                             ; else crunch now
000272r 2               LAB_13CC
000272r 2  24 12              BIT   Oquote            ; get open quote/DATA token flag
000274r 2  70 39              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
000276r 2                                             ; go save byte then continue crunching
000276r 2  86 2A              STX   TempB             ; save buffer read index
000278r 2  84 6C              STY   csidx             ; copy buffer save index
00027Ar 2  A0 rr              LDY   #<TAB_1STC        ; get keyword first character table low address
00027Cr 2  84 25              STY   ut2_pl            ; save pointer low byte
00027Er 2  A0 rr              LDY   #>TAB_1STC        ; get keyword first character table high address
000280r 2  84 26              STY   ut2_ph            ; save pointer high byte
000282r 2  A0 00              LDY   #$00              ; clear table pointer
000284r 2               
000284r 2               LAB_13D0
000284r 2  D1 25              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
000286r 2  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000288r 2               
000288r 2  90 5B              BCC   PATCH_LC2         ; if < keyword first character table byte go restore
00028Ar 2                                             ; Y and save to crunched
00028Ar 2               
00028Ar 2  C8                 INY                     ; else increment pointer
00028Br 2  80 F7              BRA   LAB_13D0          ; and loop (branch always)
00028Dr 2               
00028Dr 2               ; have matched first character of some keyword
00028Dr 2               
00028Dr 2               LAB_13D1
00028Dr 2  98                 TYA                     ; copy matching index
00028Er 2  0A                 ASL                     ; *2 (bytes per pointer)
00028Fr 2  AA                 TAX                     ; copy to new index
000290r 2  BD rr rr           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
000293r 2  85 25              STA   ut2_pl            ; save pointer low byte
000295r 2  BD rr rr           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
000298r 2  85 26              STA   ut2_ph            ; save pointer high byte
00029Ar 2  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
00029Cr 2  A6 2A              LDX   TempB             ; restore buffer read index
00029Er 2               
00029Er 2               LAB_13D6
00029Er 2  C8                 INY                     ; next table byte
00029Fr 2  B1 25              LDA   (ut2_pl),Y        ; get byte from table
0002A1r 2               LAB_13D8
0002A1r 2  30 0A              BMI   LAB_13EA          ; all bytes matched so go save token
0002A3r 2  E8                 INX                     ; next buffer byte
0002A4r 2  5D 00 05           EOR		Ibuffs,x        ; check bits against table
0002A7r 2  29 DF              AND		#$DF            ; DF masks the upper/lower case bit
0002A9r 2  F0 F3              BEQ   LAB_13D6          ; go compare next if match
0002ABr 2  80 2B              BRA   LAB_1417          ; branch if >< (not found keyword)
0002ADr 2               
0002ADr 2               LAB_13EA
0002ADr 2  A4 6C              LDY   csidx             ; restore save index
0002AFr 2                                             ; save crunched to output
0002AFr 2               LAB_13EC
0002AFr 2  E8                 INX                     ; increment buffer index (to next input byte)
0002B0r 2  C8                 INY                     ; increment save index (to next output byte)
0002B1r 2  99 00 05           STA   Ibuffs,Y          ; save byte to output
0002B4r 2  C9 00              CMP   #$00              ; set the flags, set carry
0002B6r 2  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
0002B8r 2               
0002B8r 2                                             ; A holds token or byte here
0002B8r 2  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
0002BAr 2  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
0002BCr 2               
0002BCr 2                                             ; A now holds token-$3A
0002BCr 2  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
0002BEr 2  D0 02              BNE   LAB_1401          ; branch if not DATA
0002C0r 2               
0002C0r 2                                             ; token was : or DATA
0002C0r 2               LAB_13FF
0002C0r 2  85 12              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0002C2r 2               LAB_1401
0002C2r 2  49 55              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
0002C4r 2  D0 87              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
0002C6r 2  85 0E              STA   Asrch             ; else was REM so set search for [EOL]
0002C8r 2                                             ; loop for REM, "..." etc.
0002C8r 2               LAB_1408
0002C8r 2  BD 00 05           LDA   Ibuffs,X          ; get byte from input buffer
0002CBr 2  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
0002CDr 2  C5 0E              CMP   Asrch             ; compare with stored character
0002CFr 2  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0002D1r 2                                             ; entry for copy string in quotes, don't crunch
0002D1r 2               LAB_1410
0002D1r 2  C8                 INY                     ; increment buffer save index
0002D2r 2  99 00 05           STA   Ibuffs,Y          ; save byte to output
0002D5r 2  E8                 INX                     ; increment buffer read index
0002D6r 2  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
0002D8r 2                                             ; not found keyword this go
0002D8r 2               LAB_1417
0002D8r 2  A6 2A              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
0002DAr 2               
0002DAr 2                                             ; now find the end of this word in the table
0002DAr 2               LAB_141B
0002DAr 2  B1 25              LDA   (ut2_pl),Y        ; get table byte
0002DCr 2  08                 PHP                     ; save status
0002DDr 2  C8                 INY                     ; increment table index
0002DEr 2  28                 PLP                     ; restore byte status
0002DFr 2  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
0002E1r 2               
0002E1r 2  B1 25              LDA   (ut2_pl),Y        ; get byte from keyword table
0002E3r 2  D0 BC              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
0002E5r 2               
0002E5r 2                                             ; reached end of table with no match
0002E5r 2               PATCH_LC2
0002E5r 2  BD 00 05           LDA   Ibuffs,X          ; restore byte from input buffer
0002E8r 2  80 C3              BRA   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
0002EAr 2                                             ; go save byte in output and continue crunching
0002EAr 2                                             ; reached [EOL]
0002EAr 2               LAB_142A
0002EAr 2  C8                 INY                     ; increment pointer
0002EBr 2  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
0002ECr 2  99 00 05           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
0002EFr 2  C8                 INY                     ; adjust for line copy
0002F0r 2  C8                 INY                     ; adjust for line copy
0002F1r 2  C8                 INY                     ; adjust for line copy
0002F2r 2  A5 6E              LDA   Bpntrl            ; test for $00
0002F4r 2  D0 02              BNE   LAB_142P          ; not $00
0002F6r 2  C6 6F              DEC   Bpntrh            ; allow for increment when $xx00
0002F8r 2               LAB_142P
0002F8r 2  C6 6E              DEC   Bpntrl            ; allow for increment
0002FAr 2  60                 RTS
0002FBr 2               
0002FBr 2               ; search Basic for temp integer line number from start of mem
0002FBr 2               
0002FBr 2               LAB_SSLN
0002FBr 2  A5 2B              LDA   Smeml             ; get start of mem low byte
0002FDr 2  A6 2C              LDX   Smemh             ; get start of mem high byte
0002FFr 2               
0002FFr 2               ; search Basic for temp integer line number from AX
0002FFr 2               ; returns carry set if found
0002FFr 2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
0002FFr 2               
0002FFr 2               LAB_SHLN
0002FFr 2  A0 01              LDY   #$01              ; set index
000301r 2  85 5C              STA   Baslnl            ; save low byte as current
000303r 2  86 5D              STX   Baslnh            ; save high byte as current
000305r 2  B1 5C              LDA   (Baslnl),Y        ; get pointer high byte from addr
000307r 2  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
000309r 2               
000309r 2  A0 03              LDY   #$03              ; set index to line # high byte
00030Br 2  B1 5C              LDA   (Baslnl),Y        ; get line # high byte
00030Dr 2  88                 DEY                     ; decrement index (point to low byte)
00030Er 2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000310r 2  D0 04              BNE   LAB_1455          ; if <> skip low byte check
000312r 2               
000312r 2  B1 5C              LDA   (Baslnl),Y        ; get line # low byte
000314r 2  C5 0A              CMP   Itempl            ; compare with temporary integer low byte
000316r 2               LAB_1455
000316r 2  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
000318r 2               
000318r 2               LAB_1456
000318r 2  88                 DEY                     ; decrement index to next line ptr high byte
000319r 2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
00031Br 2  AA                 TAX                     ; copy to X
00031Cr 2  88                 DEY                     ; decrement index to next line ptr low byte
00031Dr 2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
00031Fr 2  80 DE              BRA   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
000321r 2                                             ; (carry always clear)
000321r 2               
000321r 2               LAB_145E
000321r 2  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
000323r 2               
000323r 2               LAB_145F
000323r 2  18                 CLC                     ; clear found flag
000324r 2               LAB_1460
000324r 2  60                 RTS
000325r 2               
000325r 2               ; perform NEW
000325r 2               
000325r 2               LAB_NEW
000325r 2  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
000327r 2               
000327r 2               LAB_1463
000327r 2  A9 00              LDA   #$00              ; clear A
000329r 2  A8                 TAY                     ; clear Y
00032Ar 2  91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
00032Cr 2  C8                 INY                     ; increment index
00032Dr 2  91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
00032Fr 2  18                 CLC                     ; clear carry
000330r 2  A5 2B              LDA   Smeml             ; get start of mem low byte
000332r 2  69 02              ADC   #$02              ; calculate end of BASIC low byte
000334r 2  85 2D              STA   Svarl             ; save start of vars low byte
000336r 2  A5 2C              LDA   Smemh             ; get start of mem high byte
000338r 2  69 00              ADC   #$00              ; add any carry
00033Ar 2  85 2E              STA   Svarh             ; save start of vars high byte
00033Cr 2               
00033Cr 2               ; reset execution to start, clear vars and flush stack
00033Cr 2               
00033Cr 2               LAB_1477
00033Cr 2  18                 CLC                     ; clear carry
00033Dr 2  A5 2B              LDA   Smeml             ; get start of mem low byte
00033Fr 2  69 FF              ADC   #$FF              ; -1
000341r 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
000343r 2  A5 2C              LDA   Smemh             ; get start of mem high byte
000345r 2  69 FF              ADC   #$FF              ; -1+carry
000347r 2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
000349r 2               
000349r 2               ; "CLEAR" command gets here
000349r 2               
000349r 2               LAB_147A
000349r 2  A5 37              LDA   Ememl             ; get end of mem low byte
00034Br 2  A4 38              LDY   Ememh             ; get end of mem high byte
00034Dr 2  85 33              STA   Sstorl            ; set bottom of string space low byte
00034Fr 2  84 34              STY   Sstorh            ; set bottom of string space high byte
000351r 2  A5 2D              LDA   Svarl             ; get start of vars low byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000353r 2  A4 2E              LDY   Svarh             ; get start of vars high byte
000355r 2  85 2F              STA   Sarryl            ; save var mem end low byte
000357r 2  84 30              STY   Sarryh            ; save var mem end high byte
000359r 2  85 31              STA   Earryl            ; save array mem end low byte
00035Br 2  84 32              STY   Earryh            ; save array mem end high byte
00035Dr 2  20 rr rr           JSR   LAB_161A          ; perform RESTORE command
000360r 2               
000360r 2               ; flush stack and clear continue flag
000360r 2               
000360r 2               LAB_1491
000360r 2  A2 1A              LDX   #des_sk           ; set descriptor stack pointer
000362r 2  86 17              STX   next_s            ; save descriptor stack pointer
000364r 2  FA                 PLX                     ; pull return address low byte
000365r 2  68                 PLA                     ; pull return address high byte
000366r 2  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
000369r 2  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
00036Cr 2  A2 FD              LDX   #$FD              ; new stack pointer
00036Er 2  9A                 TXS                     ; reset stack
00036Fr 2  64 13              STZ   Sufnxf            ; clear subscript/FNX flag
000371r 2               LAB_14A6
000371r 2  60                 RTS
000372r 2               
000372r 2               ; perform CLEAR
000372r 2               
000372r 2               LAB_CLEAR
000372r 2  F0 D5              BEQ   LAB_147A          ; if no following token go do "CLEAR"
000374r 2                                             ; else there was a following token (go do syntax error)
000374r 2  60                 RTS
000375r 2               
000375r 2               ; perform LIST [n][-m]
000375r 2               ; bigger, faster version (a _lot_ faster)
000375r 2               
000375r 2               LAB_LIST
000375r 2  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
000377r 2  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
000379r 2               
000379r 2  C9 B3              CMP   #TK_MINUS         ; compare with token for -
00037Br 2  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
00037Dr 2               
00037Dr 2                                             ; LIST [[n][-m]]
00037Dr 2                                             ; this bit sets the n , if present, as the start and end
00037Dr 2               LAB_14BD
00037Dr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
000380r 2  20 rr rr           JSR   LAB_SSLN          ; search BASIC for temp integer line number
000383r 2                                             ; (pointer in Baslnl/Baslnh)
000383r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000386r 2  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
000388r 2               
000388r 2                                             ; this bit checks the - is present
000388r 2  C9 B3              CMP   #TK_MINUS         ; compare with token for -
00038Ar 2  D0 98              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
00038Cr 2               
00038Cr 2                                             ; LIST [n]-m
00038Cr 2                                             ; the - was there so set m as the end value
00038Cr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
00038Fr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
000392r 2  D0 90              BNE   LAB_1460          ; exit if not ok
000394r 2               
000394r 2               LAB_14D4
000394r 2  A5 0A              LDA   Itempl            ; get temporary integer low byte
000396r 2  05 0B              ORA   Itemph            ; OR temporary integer high byte
000398r 2  D0 06              BNE   LAB_14E2          ; branch if start set
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00039Ar 2               
00039Ar 2  A9 FF              LDA   #$FF              ; set for -1
00039Cr 2  85 0A              STA   Itempl            ; set temporary integer low byte
00039Er 2  85 0B              STA   Itemph            ; set temporary integer high byte
0003A0r 2               LAB_14E2
0003A0r 2  A0 01              LDY   #$01              ; set index for line
0003A2r 2  84 12              STY   Oquote            ; clear open quote flag
0003A4r 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
0003A7r 2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
0003A9r 2                                             ; pointer initially set by search at LAB_14BD
0003A9r 2  F0 3E              BEQ   LAB_152B          ; if null all done so exit
0003ABr 2  20 rr rr           JSR   LAB_1629          ; do CRTL-C check vector
0003AEr 2               
0003AEr 2  C8                 INY                     ; increment index for line
0003AFr 2  B1 5C              LDA   (Baslnl),Y        ; get line # low byte
0003B1r 2  AA                 TAX                     ; copy to X
0003B2r 2  C8                 INY                     ; increment index
0003B3r 2  B1 5C              LDA   (Baslnl),Y        ; get line # high byte
0003B5r 2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
0003B7r 2  D0 04              BNE   LAB_14FF          ; branch if no high byte match
0003B9r 2               
0003B9r 2  E4 0A              CPX   Itempl            ; compare with temporary integer low byte
0003BBr 2  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
0003BDr 2               
0003BDr 2               LAB_14FF                      ; else ..
0003BDr 2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
0003BFr 2               
0003BFr 2               LAB_1501
0003BFr 2  84 49              STY   Tidx1             ; save index for line
0003C1r 2  20 rr rr           JSR   LAB_295E          ; print XA as unsigned integer
0003C4r 2  A9 20              LDA   #$20              ; space is the next character
0003C6r 2               LAB_1508
0003C6r 2  A4 49              LDY   Tidx1             ; get index for line
0003C8r 2  29 7F              AND   #$7F              ; mask top out bit of character
0003CAr 2               LAB_150C
0003CAr 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
0003CDr 2  C9 22              CMP   #$22              ; was it " character
0003CFr 2  D0 06              BNE   LAB_1519          ; branch if not
0003D1r 2                                             ; we are either entering or leaving a pair of quotes
0003D1r 2  A5 12              LDA   Oquote            ; get open quote flag
0003D3r 2  49 FF              EOR   #$FF              ; toggle it
0003D5r 2  85 12              STA   Oquote            ; save it back
0003D7r 2               LAB_1519
0003D7r 2  C8                 INY                     ; increment index
0003D8r 2  B1 5C              LDA   (Baslnl),Y        ; get next byte
0003DAr 2  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
0003DCr 2  A8                 TAY                     ; else clear index
0003DDr 2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
0003DFr 2  AA                 TAX                     ; copy to X
0003E0r 2  C8                 INY                     ; increment index
0003E1r 2  B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
0003E3r 2  86 5C              STX   Baslnl            ; set pointer to line low byte
0003E5r 2  85 5D              STA   Baslnh            ; set pointer to line high byte
0003E7r 2  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
0003E9r 2                                             ; else ..
0003E9r 2               LAB_152B
0003E9r 2  60                 RTS
0003EAr 2               
0003EAr 2               LAB_152E
0003EAr 2  10 DE              BPL   LAB_150C          ; just go print it if not token byte
0003ECr 2                                             ; else was token byte so uncrunch it (maybe)
0003ECr 2  24 12              BIT   Oquote            ; test the open quote flag
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0003EEr 2  30 DA              BMI   LAB_150C          ; just go print character if open quote set
0003F0r 2               
0003F0r 2  A2 rr              LDX   #>LAB_KEYT        ; get table address high byte
0003F2r 2  0A                 ASL                     ; *2
0003F3r 2  0A                 ASL                     ; *4
0003F4r 2  90 02              BCC   LAB_152F          ; branch if no carry
0003F6r 2               
0003F6r 2  E8                 INX                     ; else increment high byte
0003F7r 2  18                 CLC                     ; clear carry for add
0003F8r 2               LAB_152F
0003F8r 2  69 rr              ADC   #<LAB_KEYT        ; add low byte
0003FAr 2  90 01              BCC   LAB_1530          ; branch if no carry
0003FCr 2  E8                 INX                     ; else increment high byte
0003FDr 2               
0003FDr 2               LAB_1530
0003FDr 2  85 25              STA   ut2_pl            ; save table pointer low byte
0003FFr 2  86 26              STX   ut2_ph            ; save table pointer high byte
000401r 2  84 49              STY   Tidx1             ; save index for line
000403r 2  A0 00              LDY   #$00              ; clear index
000405r 2  B1 25              LDA   (ut2_pl),Y        ; get length
000407r 2  AA                 TAX                     ; copy length
000408r 2  C8                 INY                     ; increment index
000409r 2  B1 25              LDA   (ut2_pl),Y        ; get 1st character
00040Br 2  CA                 DEX                     ; decrement length
00040Cr 2  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
00040Er 2               
00040Er 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000411r 2  C8                 INY                     ; increment index
000412r 2  B1 25              LDA   (ut2_pl),Y        ; get keyword address low byte
000414r 2  48                 PHA                     ; save it for now
000415r 2  C8                 INY                     ; increment index
000416r 2  B1 25              LDA   (ut2_pl),Y        ; get keyword address high byte
000418r 2  A0 00              LDY   #$00
00041Ar 2  85 26              STA   ut2_ph            ; save keyword pointer high byte
00041Cr 2  68                 PLA                     ; pull low byte
00041Dr 2  85 25              STA   ut2_pl            ; save keyword pointer low byte
00041Fr 2               LAB_1540
00041Fr 2  B1 25              LDA   (ut2_pl),Y        ; get character
000421r 2  CA                 DEX                     ; decrement character count
000422r 2  F0 A2              BEQ   LAB_1508          ; if last character exit and print
000424r 2               
000424r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000427r 2  C8                 INY                     ; increment index
000428r 2  D0 F5              BNE   LAB_1540          ; loop for next character
00042Ar 2               
00042Ar 2               ; perform FOR
00042Ar 2               
00042Ar 2               LAB_FOR
00042Ar 2  F7 13              SMB7  Sufnxf            ; set Subscript/FNx flag
00042Cr 2               ;      LDA   #$80              ; set FNX
00042Cr 2               ;      STA   Sufnxf            ; set subscript/FNX flag
00042Cr 2  20 rr rr           JSR   LAB_LET           ; go do LET
00042Fr 2  68                 PLA                     ; pull return address
000430r 2  68                 PLA                     ; pull return address
000431r 2  A9 10              LDA   #$10              ; we need 16d bytes !
000433r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
000436r 2  20 rr rr           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
000439r 2  18                 CLC                     ; clear carry for add
00043Ar 2  98                 TYA                     ; copy index to A
00043Br 2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
00043Dr 2  48                 PHA                     ; push onto stack
00043Er 2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000440r 2  69 00              ADC   #$00              ; add carry
000442r 2  48                 PHA                     ; push onto stack
000443r 2  A5 3A              LDA   Clineh            ; get current line high byte
000445r 2  48                 PHA                     ; push onto stack
000446r 2  A5 39              LDA   Clinel            ; get current line low byte
000448r 2  48                 PHA                     ; push onto stack
000449r 2  A9 AA              LDA   #TK_TO            ; get "TO" token
00044Br 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00044Er 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000451r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
000454r 2                                             ; else do type mismatch
000454r 2               
000454r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1 First (patch 2.22p5)
000457r 2               
000457r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
000459r 2  09 7F              ORA   #$7F              ; set all non sign bits
00045Br 2  25 5F              AND   FAC1_1            ; and FAC1 mantissa1
00045Dr 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
00045Fr 2  A9 rr              LDA   #<LAB_159F        ; set return address low byte
000461r 2  A0 rr              LDY   #>LAB_159F        ; set return address high byte
000463r 2  85 23              STA   ut1_pl            ; save return address low byte
000465r 2  84 24              STY   ut1_ph            ; save return address high byte
000467r 2  4C rr rr           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
00046Ar 2               
00046Ar 2               LAB_159F
00046Ar 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
00046Cr 2  A0 rr              LDY   #>LAB_259C        ; set 1 pointer high addr
00046Er 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
000471r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000474r 2  C9 AF              CMP   #TK_STEP          ; compare with STEP token
000476r 2  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
000478r 2               
000478r 2                                             ; was step so ..
000478r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
00047Br 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00047Er 2                                             ; else do type mismatch
00047Er 2               LAB_15B3
00047Er 2  20 rr rr           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
000481r 2  85 62              STA   FAC1_s            ; set FAC1 sign (b7)
000483r 2                                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
000483r 2                                             ; compare the FOR value and the TO value and return +1 if
000483r 2                                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
000483r 2                                             ; here (+/-1) is then compared to that result and if they
000483r 2                                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
000483r 2                                             ; the loop is done
000483r 2  20 rr rr           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
000486r 2  A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
000488r 2  48                 PHA                     ; push on stack
000489r 2  A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
00048Br 2  48                 PHA                     ; push on stack
00048Cr 2  A9 81              LDA   #TK_FOR           ; get FOR token
00048Er 2  48                 PHA                     ; push on stack
00048Fr 2               
00048Fr 2               ; interpreter inner loop
00048Fr 2               
00048Fr 2               LAB_15C2
00048Fr 2  20 rr rr           JSR   LAB_1629          ; do CRTL-C check vector
000492r 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
000494r 2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
000496r 2  A6 3A              LDX   Clineh            ; continue line is $FFxx for immediate mode
000498r 2                                             ; ($00xx for RUN from immediate mode)
000498r 2  E8                 INX                     ; increment it (now $00 if immediate mode)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000499r 2  85 3D              STA   Cpntrl            ; save continue pointer low byte
00049Br 2  84 3E              STY   Cpntrh            ; save continue pointer high byte
00049Dr 2               LAB_15D1
00049Dr 2  B2 6E              LDA   (Bpntrl)          ; get next byte
00049Fr 2  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
0004A1r 2               
0004A1r 2  C9 3A              CMP   #':'              ; compare with ":"
0004A3r 2  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
0004A5r 2               
0004A5r 2               LAB_15D9
0004A5r 2  4C rr rr           JMP   LAB_SNER          ; else syntax error then warm start
0004A8r 2                                             ; have reached [EOL]
0004A8r 2               LAB_15DC
0004A8r 2  A0 02              LDY   #$02              ; set index
0004AAr 2  B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
0004ACr 2  18                 CLC                     ; clear carry for no "BREAK" message
0004ADr 2  F0 4F              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
0004AFr 2                                             ; marker)
0004AFr 2  C8                 INY                     ; increment index
0004B0r 2  B1 6E              LDA   (Bpntrl),Y        ; get line # low byte
0004B2r 2  85 39              STA   Clinel            ; save current line low byte
0004B4r 2  C8                 INY                     ; increment index
0004B5r 2  B1 6E              LDA   (Bpntrl),Y        ; get line # high byte
0004B7r 2  85 3A              STA   Clineh            ; save current line high byte
0004B9r 2  98                 TYA                     ; A now = 4
0004BAr 2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
0004BCr 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
0004BEr 2  90 02              BCC   LAB_15F6          ; branch if no overflow
0004C0r 2               
0004C0r 2  E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
0004C2r 2               LAB_15F6
0004C2r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
0004C5r 2               
0004C5r 2               LAB_15F9
0004C5r 2  20 rr rr           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
0004C8r 2               
0004C8r 2               LAB_15FC
0004C8r 2  80 C5              BRA   LAB_15C2          ; loop
0004CAr 2               
0004CAr 2               ; interpret BASIC code from (Bpntrl)
0004CAr 2               
0004CAr 2               LAB_15FF
0004CAr 2  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
0004CCr 2               
0004CCr 2               LAB_1602
0004CCr 2  0A                 ASL                     ; *2 bytes per vector and normalise token
0004CDr 2  B0 03              BCS   LAB_1609          ; branch if was token
0004CFr 2  4C rr rr           JMP   LAB_LET           ; else go do implied LET
0004D2r 2               
0004D2r 2               LAB_1609
0004D2r 2  C9 50              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
0004D4r 2  B0 CF              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
0004D6r 2                                             ; only tokens before TAB can start a line
0004D6r 2  A8                 TAY                     ; copy to index
0004D7r 2  B9 rr rr           LDA   LAB_CTBL+1,Y      ; get vector high byte
0004DAr 2  48                 PHA                     ; onto stack
0004DBr 2  B9 rr rr           LDA   LAB_CTBL,Y        ; get vector low byte
0004DEr 2  48                 PHA                     ; onto stack
0004DFr 2  4C rr rr           JMP   LAB_IGBY          ; jump to increment and scan memory
0004E2r 2                                             ; then "return" to vector
0004E2r 2               
0004E2r 2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0004E2r 2               ; key press is detected.
0004E2r 2               
0004E2r 2               LAB_1629
0004E2r 2  6C 82 05           JMP   (VEC_CC)          ; ctrl-c check vector
0004E5r 2               
0004E5r 2               ; if there was a key press it gets back here ..
0004E5r 2               
0004E5r 2               LAB_1636
0004E5r 2  C9 03              CMP   #$03              ; compare with CTRL-C
0004E7r 2               
0004E7r 2               ; perform STOP
0004E7r 2               
0004E7r 2               LAB_STOP
0004E7r 2  B0 01              BCS   LAB_163B          ; branch if token follows STOP
0004E9r 2                                             ; else just END
0004E9r 2               ; END
0004E9r 2               
0004E9r 2               LAB_END
0004E9r 2  18                 CLC                     ; clear the carry, indicate a normal program end
0004EAr 2               LAB_163B
0004EAr 2  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
0004ECr 2               
0004ECr 2  A5 6F              LDA   Bpntrh            ; get the BASIC execute pointer high byte
0004EEr 2  A4 6E              LDY   Bpntrl            ; get BASIC execute pointer low byte
0004F0r 2  84 3D              STY   Cpntrl            ; save continue pointer low byte
0004F2r 2  85 3E              STA   Cpntrh            ; save continue pointer high byte
0004F4r 2               LAB_1647
0004F4r 2  A5 39              LDA   Clinel            ; get current line low byte
0004F6r 2  A4 3A              LDY   Clineh            ; get current line high byte
0004F8r 2  85 3B              STA   Blinel            ; save break line low byte
0004FAr 2  84 3C              STY   Blineh            ; save break line high byte
0004FCr 2               LAB_164F
0004FCr 2  68                 PLA                     ; pull return address low
0004FDr 2  68                 PLA                     ; pull return address high
0004FEr 2               LAB_1651
0004FEr 2  90 07              BCC   LAB_165E          ; if was program end just do warm start
000500r 2                                             ; else ..
000500r 2  A9 rr              LDA   #<LAB_BMSG        ; point to "Break" low byte
000502r 2  A0 rr              LDY   #>LAB_BMSG        ; point to "Break" high byte
000504r 2  4C rr rr           JMP   LAB_1269          ; print "Break" and do warm start
000507r 2               
000507r 2               LAB_165E
000507r 2  4C rr rr           JMP   LAB_1274          ; go do warm start
00050Ar 2               
00050Ar 2               ; perform RESTORE
00050Ar 2               
00050Ar 2               LAB_RESTORE
00050Ar 2  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
00050Cr 2               
00050Cr 2               LAB_161A
00050Cr 2  38                 SEC                     ; set carry for subtract
00050Dr 2  A5 2B              LDA   Smeml             ; get start of mem low byte
00050Fr 2  E9 01              SBC   #$01              ; -1
000511r 2  A4 2C              LDY   Smemh             ; get start of mem high byte
000513r 2  B0 01              BCS   LAB_1624          ; branch if no underflow
000515r 2               
000515r 2               LAB_uflow
000515r 2  88                 DEY                     ; else decrement high byte
000516r 2               LAB_1624
000516r 2  85 41              STA   Dptrl             ; save DATA pointer low byte
000518r 2  84 42              STY   Dptrh             ; save DATA pointer high byte
00051Ar 2               LAB_1628
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00051Ar 2  60                 RTS
00051Br 2                                             ; is RESTORE n
00051Br 2               LAB_RESTOREn
00051Br 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00051Er 2  20 rr rr           JSR   LAB_SNBL          ; scan for next BASIC line
000521r 2  A5 3A              LDA   Clineh            ; get current line high byte
000523r 2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
000525r 2  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
000527r 2               
000527r 2  98                 TYA                     ; else copy line index to A
000528r 2  38                 SEC                     ; set carry (+1)
000529r 2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
00052Br 2  A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
00052Dr 2  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
00052Fr 2               
00052Fr 2  E8                 INX                     ; increment high byte
000530r 2  80 04              BRA   LAB_go_search     ; branch always (can never be carry clear)
000532r 2               
000532r 2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
000532r 2               
000532r 2               LAB_reset_search
000532r 2  A5 2B              LDA   Smeml             ; get start of mem low byte
000534r 2  A6 2C              LDX   Smemh             ; get start of mem high byte
000536r 2               
000536r 2               ; search for line # in temp (Itempl/Itemph) from (AX)
000536r 2               
000536r 2               LAB_go_search
000536r 2               
000536r 2  20 rr rr           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
000539r 2  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
00053Br 2               
00053Br 2  4C rr rr           JMP   LAB_16F7          ; else go do "Undefined statement" error
00053Er 2               
00053Er 2               LAB_line_found
00053Er 2                                             ; carry already set for subtract
00053Er 2  A5 5C              LDA   Baslnl            ; get pointer low byte
000540r 2  E9 01              SBC   #$01              ; -1
000542r 2  A4 5D              LDY   Baslnh            ; get pointer high byte
000544r 2  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
000546r 2  80 CD              BRA   LAB_uflow         ; else decrement high byte then save DATA pointer and
000548r 2                                             ; return (branch always)
000548r 2               ; perform NULL
000548r 2               
000548r 2               LAB_NULL
000548r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
00054Br 2  86 06              STX   Nullct            ; save new NULL count
00054Dr 2               LAB_167A
00054Dr 2  60                 RTS
00054Er 2               
00054Er 2               ; perform CONT
00054Er 2               
00054Er 2               LAB_CONT
00054Er 2  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
000550r 2               
000550r 2  A4 3E              LDY   Cpntrh            ; get continue pointer high byte
000552r 2  C0 05              CPY   #>Ibuffs          ; *** fix p2: test direct mode
000554r 2  D0 05              BNE   LAB_166C          ; go do continue if we can
000556r 2               
000556r 2  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
000558r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
00055Br 2                                             ; we can continue so ..
00055Br 2               LAB_166C
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00055Br 2  84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
00055Dr 2  A5 3D              LDA   Cpntrl            ; get continue pointer low byte
00055Fr 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
000561r 2  A5 3B              LDA   Blinel            ; get break line low byte
000563r 2  A4 3C              LDY   Blineh            ; get break line high byte
000565r 2  85 39              STA   Clinel            ; set current line low byte
000567r 2  84 3A              STY   Clineh            ; set current line high byte
000569r 2  60                 RTS
00056Ar 2               
00056Ar 2               ; perform RUN
00056Ar 2               
00056Ar 2               LAB_RUN
00056Ar 2  D0 03              BNE   LAB_1696          ; branch if RUN n
00056Cr 2  4C rr rr           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack, return
00056Fr 2               
00056Fr 2               ; does RUN n
00056Fr 2               
00056Fr 2               LAB_1696
00056Fr 2  20 rr rr           JSR   LAB_147A          ; go do "CLEAR"
000572r 2  80 2E              BRA   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
000574r 2               
000574r 2               ; perform DO
000574r 2               
000574r 2               LAB_DO
000574r 2  A9 05              LDA   #$05              ; need 5 bytes for DO
000576r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
000579r 2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
00057Br 2  48                 PHA                     ; push on stack
00057Cr 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
00057Er 2  48                 PHA                     ; push on stack
00057Fr 2  A5 3A              LDA   Clineh            ; get current line high byte
000581r 2  48                 PHA                     ; push on stack
000582r 2  A5 39              LDA   Clinel            ; get current line low byte
000584r 2  48                 PHA                     ; push on stack
000585r 2  A9 9B              LDA   #TK_DO            ; token for DO
000587r 2  48                 PHA                     ; push on stack
000588r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
00058Br 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
00058Er 2               
00058Er 2               ; perform GOSUB
00058Er 2               
00058Er 2               LAB_GOSUB
00058Er 2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
000590r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
000593r 2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
000595r 2  48                 PHA                     ; push on stack
000596r 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
000598r 2  48                 PHA                     ; push on stack
000599r 2  A5 3A              LDA   Clineh            ; get current line high byte
00059Br 2  48                 PHA                     ; push on stack
00059Cr 2  A5 39              LDA   Clinel            ; get current line low byte
00059Er 2  48                 PHA                     ; push on stack
00059Fr 2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
0005A1r 2  48                 PHA                     ; push on stack
0005A2r 2               LAB_16B0
0005A2r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
0005A5r 2  20 rr rr           JSR   LAB_GOTO          ; perform GOTO n
0005A8r 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop, return
0005ABr 2               
0005ABr 2               ; perform GOTO
0005ABr 2               
0005ABr 2               LAB_GOTO
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0005ABr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0005AEr 2  20 rr rr           JSR   LAB_SNBL          ; scan for next BASIC line
0005B1r 2  A5 3A              LDA   Clineh            ; get current line high byte
0005B3r 2  C5 0B              CMP   Itemph            ; compare with temporary integer high byte
0005B5r 2  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
0005B7r 2               
0005B7r 2  98                 TYA                     ; else copy line index to A
0005B8r 2  38                 SEC                     ; set carry (+1)
0005B9r 2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
0005BBr 2  A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
0005BDr 2  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
0005BFr 2               
0005BFr 2  E8                 INX                     ; increment high byte
0005C0r 2  80 04              BRA   LAB_16D4          ; branch always (can never be carry)
0005C2r 2               
0005C2r 2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
0005C2r 2               
0005C2r 2               LAB_16D0
0005C2r 2  A5 2B              LDA   Smeml             ; get start of mem low byte
0005C4r 2  A6 2C              LDX   Smemh             ; get start of mem high byte
0005C6r 2               
0005C6r 2               ; search for line # in temp (Itempl/Itemph) from (AX)
0005C6r 2               
0005C6r 2               LAB_16D4
0005C6r 2  20 rr rr           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
0005C9r 2  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
0005CBr 2                                             ; (unspecified statement)
0005CBr 2                                             ; carry already set for subtract
0005CBr 2  A5 5C              LDA   Baslnl            ; get pointer low byte
0005CDr 2  E9 01              SBC   #$01              ; -1
0005CFr 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
0005D1r 2  A5 5D              LDA   Baslnh            ; get pointer high byte
0005D3r 2  E9 00              SBC   #$00              ; subtract carry
0005D5r 2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
0005D7r 2               LAB_16E5
0005D7r 2  60                 RTS
0005D8r 2               
0005D8r 2               LAB_DONOK
0005D8r 2  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
0005DAr 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
0005DDr 2               
0005DDr 2               ; perform LOOP
0005DDr 2               
0005DDr 2               LAB_LOOP
0005DDr 2  A8                 TAY                     ; save following token
0005DEr 2  BA                 TSX                     ; copy stack pointer
0005DFr 2  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
0005E2r 2  C9 9B              CMP   #TK_DO            ; compare with DO token
0005E4r 2  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
0005E6r 2               
0005E6r 2  E8                 INX                     ; dump calling routine return address
0005E7r 2  E8                 INX                     ; dump calling routine return address
0005E8r 2  9A                 TXS                     ; correct stack
0005E9r 2  98                 TYA                     ; get saved following token back
0005EAr 2  F0 20              BEQ   LoopAlways        ; if no following token loop forever
0005ECr 2                                             ; (stack pointer in X)
0005ECr 2               
0005ECr 2  C9 3A              CMP   #':'              ; could be ':'
0005EEr 2  F0 1C              BEQ   LoopAlways        ; if :... loop forever
0005F0r 2               
0005F0r 2  E9 B0              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
0005F2r 2  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0005F3r 2  F0 04              BEQ   DoRest            ; branch if was UNTIL
0005F5r 2               
0005F5r 2  CA                 DEX                     ; decrement result
0005F6r 2  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
0005F8r 2                                             ; only if the token was WHILE will this fail
0005F8r 2               
0005F8r 2  CA                 DEX                     ; set invert result byte
0005F9r 2               DoRest
0005F9r 2  86 4A              STX   Frnxth            ; save invert result byte
0005FBr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
0005FEr 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
000601r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
000603r 2  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
000605r 2               
000605r 2  A9 FF              LDA   #$FF              ; else set all bits
000607r 2               DoCmp
000607r 2  BA                 TSX                     ; copy stack pointer
000608r 2  45 4A              EOR   Frnxth            ; EOR with invert byte
00060Ar 2  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
00060Cr 2                                             ; loop condition wasn't met so do it again
00060Cr 2               LoopAlways
00060Cr 2  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
00060Fr 2  85 39              STA   Clinel            ; save current line low byte
000611r 2  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
000614r 2  85 3A              STA   Clineh            ; save current line high byte
000616r 2  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
000619r 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
00061Br 2  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
00061Er 2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
000620r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000623r 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
000626r 2               
000626r 2                                             ; clear stack and back to interpreter loop
000626r 2               LoopDone
000626r 2  E8                 INX                     ; dump DO token
000627r 2  E8                 INX                     ; dump current line low byte
000628r 2  E8                 INX                     ; dump current line high byte
000629r 2  E8                 INX                     ; dump BASIC execute pointer low byte
00062Ar 2  E8                 INX                     ; dump BASIC execute pointer high byte
00062Br 2  9A                 TXS                     ; correct stack
00062Cr 2  80 1E              BRA   LAB_DATA          ; go perform DATA (find : or [EOL])
00062Er 2               
00062Er 2               ; do the return without gosub error
00062Er 2               
00062Er 2               LAB_16F4
00062Er 2  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
000630r 2  80 02              BRA   LAB_16F7b         ; branch around next instruction, save one clock cycle
000632r 2               
000632r 2               LAB_16F7                      ; do undefined statement error
000632r 2  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
000634r 2               LAB_16F7b
000634r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000637r 2               
000637r 2               ; perform RETURN
000637r 2               
000637r 2               LAB_RETURN
000637r 2  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
000639r 2               
000639r 2               LAB_16E8
000639r 2  68                 PLA                     ; dump calling routine return address
00063Ar 2  68                 PLA                     ; dump calling routine return address
00063Br 2  68                 PLA                     ; pull token
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00063Cr 2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00063Er 2  D0 EE              BNE   LAB_16F4          ; branch if no matching GOSUB
000640r 2               
000640r 2               LAB_16FF
000640r 2  68                 PLA                     ; pull current line low byte
000641r 2  85 39              STA   Clinel            ; save current line low byte
000643r 2  68                 PLA                     ; pull current line high byte
000644r 2  85 3A              STA   Clineh            ; save current line high byte
000646r 2  68                 PLA                     ; pull BASIC execute pointer low byte
000647r 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
000649r 2  68                 PLA                     ; pull BASIC execute pointer high byte
00064Ar 2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
00064Cr 2               
00064Cr 2                                             ; now do the DATA statement as we could be returning into
00064Cr 2                                             ; the middle of an ON <var> GOSUB n,m,p,q line
00064Cr 2                                             ; (the return address used by the DATA statement is the one
00064Cr 2                                             ; pushed before the GOSUB was executed!)
00064Cr 2               
00064Cr 2               ; perform DATA
00064Cr 2               
00064Cr 2               LAB_DATA
00064Cr 2  20 rr rr           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00064Fr 2               
00064Fr 2                                             ; set BASIC execute pointer
00064Fr 2               LAB_170F
00064Fr 2  98                 TYA                     ; copy index to A
000650r 2  18                 CLC                     ; clear carry for add
000651r 2  65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
000653r 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
000655r 2  90 02              BCC   LAB_1719          ; skip next if no carry
000657r 2               
000657r 2  E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
000659r 2               LAB_1719
000659r 2  60                 RTS
00065Ar 2               
00065Ar 2               LAB_16FC
00065Ar 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
00065Dr 2               
00065Dr 2               ; scan for next BASIC statement ([:] or [EOL])
00065Dr 2               ; returns Y as index to [:] or [EOL]
00065Dr 2               
00065Dr 2               LAB_SNBS
00065Dr 2  A2 3A              LDX   #':'              ; set look for character = ":"
00065Fr 2  80 02              BRA   LAB_SNBLb         ; branch around next instruction, save one clock cycle
000661r 2               
000661r 2               ; scan for next BASIC line
000661r 2               ; returns Y as index to [EOL]
000661r 2               
000661r 2               LAB_SNBL
000661r 2  A2 00              LDX   #$00              ; set alt search character = [EOL]
000663r 2               LAB_SNBLb
000663r 2  A0 00              LDY   #$00              ; set search character = [EOL]
000665r 2  84 0E              STY   Asrch             ; store search character
000667r 2               LAB_1725
000667r 2  8A                 TXA                     ; get alt search character
000668r 2  45 0E              EOR   Asrch             ; toggle search character, effectively swap with $00
00066Ar 2  85 0E              STA   Asrch             ; save swapped search character
00066Cr 2               LAB_172D
00066Cr 2  B1 6E              LDA   (Bpntrl),Y        ; get next byte
00066Er 2  F0 E9              BEQ   LAB_1719          ; exit if null [EOL]
000670r 2               
000670r 2  C5 0E              CMP   Asrch             ; compare with search character
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000672r 2  F0 E5              BEQ   LAB_1719          ; exit if found
000674r 2               
000674r 2  C8                 INY                     ; increment index
000675r 2  C9 22              CMP   #$22              ; compare current character with open quote
000677r 2  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
000679r 2  80 EC              BRA   LAB_1725          ; if found go swap search character for alt search character
00067Br 2               
00067Br 2               ; perform IF
00067Br 2               
00067Br 2               LAB_IF
00067Br 2  20 rr rr           JSR   LAB_EVEX          ; evaluate the expression
00067Er 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000681r 2  C9 AD              CMP   #TK_THEN          ; compare with THEN token
000683r 2  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
000685r 2               
000685r 2                                             ; wasn't IF .. THEN so must be IF .. GOTO
000685r 2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
000687r 2  D0 D1              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
000689r 2               
000689r 2  A6 6E              LDX   Bpntrl            ; save the basic pointer low byte
00068Br 2  A4 6F              LDY   Bpntrh            ; save the basic pointer high byte
00068Dr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000690r 2  B0 C8              BCS   LAB_16FC          ; if not numeric go do syntax error
000692r 2               
000692r 2  86 6E              STX   Bpntrl            ; restore the basic pointer low byte
000694r 2  84 6F              STY   Bpntrh            ; restore the basic pointer high byte
000696r 2               LAB_174B
000696r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
000698r 2  F0 1C              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
00069Ar 2               
00069Ar 2  20 rr rr           JSR   LAB_IGBY          ; else increment and scan memory
00069Dr 2  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
00069Fr 2               
00069Fr 2               LAB_174C
00069Fr 2  4C rr rr           JMP   LAB_GOTO          ; else was numeric so do GOTO n
0006A2r 2               
0006A2r 2                                             ; is var or keyword
0006A2r 2               LAB_174D
0006A2r 2  68                 PLA                     ; discard interpreter loop return address
0006A3r 2  68                 PLA                     ; so data structures are at the correct stack offset
0006A4r 2  20 rr rr           JSR   LAB_GBYT          ; restore token or variable
0006A7r 2  20 rr rr           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
0006AAr 2               
0006AAr 2               ; the IF was executed and there may be a following ELSE so the code needs to return
0006AAr 2               ; here to check and ignore the ELSE if present
0006AAr 2               
0006AAr 2  B2 6E              LDA   (Bpntrl)          ; get the next BASIC byte
0006ACr 2  C9 A9              CMP   #TK_ELSE          ; compare it with the token for ELSE
0006AEr 2  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
0006B0r 2  20 rr rr           JSR   LAB_DATA          ; yes - skip the rest of the line
0006B3r 2               
0006B3r 2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0006B3r 2               ; following ELSE will, correctly, cause a syntax error
0006B3r 2               
0006B3r 2               LAB_no_ELSE
0006B3r 2  4C rr rr           JMP LAB_15C2            ; return to the interpreter inner loop
0006B6r 2               
0006B6r 2               ; perform ELSE after IF
0006B6r 2               
0006B6r 2               LAB_174E
0006B6r 2  A0 00              LDY   #$00              ; clear the BASIC byte index
0006B8r 2  A2 01              LDX   #$01              ; clear the nesting depth
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0006BAr 2               LAB_1750
0006BAr 2  C8                 INY                     ; increment the BASIC byte index
0006BBr 2  B1 6E              LDA   (Bpntrl),Y        ; get the next BASIC byte
0006BDr 2  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
0006BFr 2               
0006BFr 2  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
0006C1r 2  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
0006C3r 2               
0006C3r 2  E8                 INX                     ; else increment the nesting depth,
0006C4r 2  D0 F4              BNE   LAB_1750          ; and continue looking
0006C6r 2               
0006C6r 2               LAB_1752
0006C6r 2  C9 A9              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
0006C8r 2  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
0006CAr 2               
0006CAr 2  CA                 DEX                     ; was ELSE so decrement the nesting depth
0006CBr 2  D0 ED              BNE   LAB_1750          ; loop if still nested
0006CDr 2               
0006CDr 2  C8                 INY                     ; increment the BASIC byte index past the ELSE
0006CEr 2               
0006CEr 2               ; found the matching ELSE, now do <{n|statement}>
0006CEr 2               
0006CEr 2               LAB_1753
0006CEr 2  98                 TYA                     ; else copy line index to A
0006CFr 2  18                 CLC                     ; clear carry for add
0006D0r 2  65 6E              ADC   Bpntrl            ; add the BASIC execute pointer low byte
0006D2r 2  85 6E              STA   Bpntrl            ; save the BASIC execute pointer low byte
0006D4r 2  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
0006D6r 2               
0006D6r 2  E6 6F              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
0006D8r 2               LAB_1754
0006D8r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
0006DBr 2  90 C2              BCC   LAB_174C          ; if numeric do GOTO n
0006DDr 2                                             ; the code will return to the interpreter loop at the
0006DDr 2                                             ; tail end of the GOTO <n>
0006DDr 2               
0006DDr 2  4C rr rr           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
0006E0r 2                                             ; the code will return to the interpreter loop at the
0006E0r 2                                             ; tail end of the <statement>
0006E0r 2               
0006E0r 2               ; perform REM, skip (rest of) line
0006E0r 2               
0006E0r 2               LAB_REM
0006E0r 2  20 rr rr           JSR   LAB_SNBL          ; scan for next BASIC line
0006E3r 2  4C rr rr           JMP   LAB_170F          ; go set BASIC execute pointer and return
0006E6r 2               
0006E6r 2               LAB_16FD
0006E6r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
0006E9r 2               
0006E9r 2               ; perform ON
0006E9r 2               
0006E9r 2               LAB_ON
0006E9r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
0006ECr 2  48                 PHA                     ; push GOTO/GOSUB token
0006EDr 2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
0006EFr 2  F0 04              BEQ   LAB_176B          ; branch if GOSUB
0006F1r 2               
0006F1r 2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
0006F3r 2               LAB_1767
0006F3r 2  D0 F1              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
0006F5r 2               
0006F5r 2               ; next character was GOTO or GOSUB
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0006F5r 2               
0006F5r 2               LAB_176B
0006F5r 2  C6 61              DEC   FAC1_3            ; decrement index (byte value)
0006F7r 2  D0 04              BNE   LAB_1773          ; branch if not zero
0006F9r 2               
0006F9r 2  68                 PLA                     ; pull GOTO/GOSUB token
0006FAr 2  4C rr rr           JMP   LAB_1602          ; go execute it
0006FDr 2               
0006FDr 2               LAB_1773
0006FDr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000700r 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
000703r 2                                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
000703r 2                                             ; just BNE LAB_176B for the loop. should be quicker ..
000703r 2                                             ; no we can't, what if we meet a colon or [EOL]?)
000703r 2  C9 2C              CMP   #$2C              ; compare next character with ","
000705r 2  F0 EE              BEQ   LAB_176B          ; loop if ","
000707r 2               
000707r 2               LAB_177E
000707r 2  68                 PLA                     ; else pull keyword token (run out of options)
000708r 2                                             ; also dump +/-1 pointer low byte and exit
000708r 2               LAB_177F
000708r 2  60                 RTS
000709r 2               
000709r 2               ; takes n * 106 + 11 cycles where n is the number of digits
000709r 2               
000709r 2               ; get fixed-point number into temp integer
000709r 2               
000709r 2               LAB_GFPN
000709r 2  A2 00              LDX   #$00              ; clear reg
00070Br 2  86 0A              STX   Itempl            ; clear temporary integer low byte
00070Dr 2               LAB_1785
00070Dr 2  86 0B              STX   Itemph            ; save temporary integer high byte
00070Fr 2  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
000711r 2                                             ; not 0-9
000711r 2               
000711r 2  E0 19              CPX   #$19              ; compare high byte with $19
000713r 2  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
000714r 2  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
000716r 2                                             ; bit does *$0A, = 64000, compare at target will fail
000716r 2                                             ; and do syntax error
000716r 2               
000716r 2  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
000718r 2  A8                 TAY                     ; copy binary digit
000719r 2  A5 0A              LDA   Itempl            ; get temporary integer low byte
00071Br 2  0A                 ASL                     ; *2 low byte
00071Cr 2  26 0B              ROL   Itemph            ; *2 high byte
00071Er 2  0A                 ASL                     ; *2 low byte
00071Fr 2  26 0B              ROL   Itemph            ; *2 high byte, *4
000721r 2  65 0A              ADC   Itempl            ; + low byte, *5
000723r 2  85 0A              STA   Itempl            ; save it
000725r 2  8A                 TXA                     ; get high byte copy to A
000726r 2  65 0B              ADC   Itemph            ; + high byte, *5
000728r 2  06 0A              ASL   Itempl            ; *2 low byte, *10d
00072Ar 2  2A                 ROL                     ; *2 high byte, *10d
00072Br 2  AA                 TAX                     ; copy high byte back to X
00072Cr 2  98                 TYA                     ; get binary digit back
00072Dr 2  65 0A              ADC   Itempl            ; add number low byte
00072Fr 2  85 0A              STA   Itempl            ; save number low byte
000731r 2  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
000733r 2               
000733r 2  E8                 INX                     ; else increment high byte
000734r 2               LAB_17B3
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000734r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000737r 2  80 D4              BRA   LAB_1785          ; loop for next character
000739r 2               
000739r 2               ; perform DEC
000739r 2               
000739r 2               LAB_DEC
000739r 2  A9 rr              LDA   #<LAB_2AFD        ; set -1 pointer low byte
00073Br 2  80 02              BRA   LAB_17B5          ; branch around next instruction, saves one clock cycle
00073Dr 2               
00073Dr 2               ; perform INC
00073Dr 2               
00073Dr 2               LAB_INC
00073Dr 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low byte
00073Fr 2               LAB_17B5
00073Fr 2  48                 PHA                     ; save +/-1 pointer low byte
000740r 2               LAB_17B7
000740r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
000743r 2  A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
000745r 2  30 1D              BMI   IncrErr           ; exit if string
000747r 2               
000747r 2  85 49              STA   Lvarpl            ; save var address low byte
000749r 2  84 4A              STY   Lvarph            ; save var address high byte
00074Br 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00074Er 2  68                 PLA                     ; get +/-1 pointer low byte
00074Fr 2  48                 PHA                     ; save +/-1 pointer low byte
000750r 2  A0 rr              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
000752r 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
000755r 2  20 rr rr           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
000758r 2               
000758r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
00075Br 2  C9 2C              CMP   #','              ; compare with ","
00075Dr 2  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
00075Fr 2               
00075Fr 2                                             ; was "," so another INCR variable to do
00075Fr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000762r 2  80 DC              BRA   LAB_17B7          ; go do next var
000764r 2               
000764r 2               IncrErr
000764r 2  4C rr rr           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
000767r 2               
000767r 2               ; perform LET
000767r 2               
000767r 2               LAB_LET
000767r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
00076Ar 2  85 49              STA   Lvarpl            ; save var address low byte
00076Cr 2  84 4A              STY   Lvarph            ; save var address high byte
00076Er 2  A9 BD              LDA   #TK_EQUAL         ; get = token
000770r 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
000773r 2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
000775r 2  48                 PHA                     ; push data type flag
000776r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
000779r 2  68                 PLA                     ; pop data type flag
00077Ar 2  2A                 ROL                     ; set carry if type = string
00077Br 2  20 rr rr           JSR   LAB_CKTM          ; type match check, set C for string
00077Er 2  B0 03              BCS   LAB_17D5          ; branch if string
000780r 2  4C rr rr           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
000783r 2               
000783r 2               ; string LET
000783r 2               
000783r 2               LAB_17D5
000783r 2  A0 02              LDY   #$02              ; set index to pointer high byte
000785r 2  B1 60              LDA   (des_pl),Y        ; get string pointer high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000787r 2  C5 34              CMP   Sstorh            ; compare bottom of string space high byte
000789r 2  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
00078Br 2               
00078Br 2  D0 07              BNE   LAB_17E6          ; branch if >
00078Dr 2                                             ; else was equal so compare low bytes
00078Dr 2  88                 DEY                     ; decrement index
00078Er 2  B1 60              LDA   (des_pl),Y        ; get pointer low byte
000790r 2  C5 33              CMP   Sstorl            ; compare bottom of string space low byte
000792r 2  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
000794r 2               
000794r 2                                             ; pointer was >= to bottom of string space pointer
000794r 2               LAB_17E6
000794r 2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
000796r 2  C4 2E              CPY   Svarh             ; compare start of vars high byte
000798r 2  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
00079Ar 2  D0 0C              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
00079Cr 2                                             ; else high bytes were equal so ..
00079Cr 2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
00079Er 2  C5 2D              CMP   Svarl             ; compare start of vars low byte
0007A0r 2  B0 06              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
0007A2r 2               
0007A2r 2               LAB_17F4
0007A2r 2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
0007A4r 2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
0007A6r 2  80 14              BRA   LAB_1811          ; clean stack, copy descriptor to variable and return
0007A8r 2               
0007A8r 2                                             ; make space and copy string
0007A8r 2               LAB_17FB
0007A8r 2  B2 60              LDA   (des_pl)          ; get string length
0007AAr 2  20 rr rr           JSR   LAB_209C          ; copy string
0007ADr 2  A5 50              LDA   des_2l            ; get descriptor pointer low byte
0007AFr 2  A4 51              LDY   des_2h            ; get descriptor pointer high byte
0007B1r 2  85 6A              STA   ssptr_l           ; save descriptor pointer low byte
0007B3r 2  84 6B              STY   ssptr_h           ; save descriptor pointer high byte
0007B5r 2  20 rr rr           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
0007B8r 2  A9 5E              LDA   #<FAC1_e          ; set descriptor pointer low byte
0007BAr 2  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
0007BCr 2               
0007BCr 2                                             ; clean stack and assign value to string variable
0007BCr 2               LAB_1811
0007BCr 2  85 50              STA   des_2l            ; save descriptor_2 pointer low byte
0007BEr 2  84 51              STY   des_2h            ; save descriptor_2 pointer high byte
0007C0r 2  20 rr rr           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
0007C3r 2  A0 00              LDY   #$00              ; index to length
0007C5r 2  B1 50              LDA   (des_2l),Y        ; get string length
0007C7r 2  91 49              STA   (Lvarpl),Y        ; copy to let string variable
0007C9r 2  C8                 INY                     ; index to string pointer low byte
0007CAr 2  B1 50              LDA   (des_2l),Y        ; get string pointer low byte
0007CCr 2  91 49              STA   (Lvarpl),Y        ; copy to let string variable
0007CEr 2  C8                 INY                     ; index to string pointer high byte
0007CFr 2  B1 50              LDA   (des_2l),Y        ; get string pointer high byte
0007D1r 2  91 49              STA   (Lvarpl),Y        ; copy to let string variable
0007D3r 2  60                 RTS
0007D4r 2               
0007D4r 2               ; perform GET
0007D4r 2               
0007D4r 2               LAB_GET
0007D4r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
0007D7r 2  85 49              STA   Lvarpl            ; save var address low byte
0007D9r 2  84 4A              STY   Lvarph            ; save var address high byte
0007DBr 2  20 rr rr           JSR   INGET             ; get input byte
0007DEr 2  A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0007E0r 2  30 07              BMI   LAB_GETS          ; go get string character
0007E2r 2                                             ; was numeric get
0007E2r 2  A8                 TAY                     ; copy character to Y
0007E3r 2  20 rr rr           JSR   LAB_1FD0          ; convert Y to byte in FAC1
0007E6r 2  4C rr rr           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
0007E9r 2               
0007E9r 2               LAB_GETS
0007E9r 2  48                 PHA                     ; save character
0007EAr 2  A9 01              LDA   #$01              ; string is single byte
0007ECr 2  B0 01              BCS   LAB_IsByte        ; branch if byte received
0007EEr 2               
0007EEr 2  68                 PLA                     ; string is null
0007EFr 2               LAB_IsByte
0007EFr 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
0007F2r 2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0007F2r 2  F0 03              BEQ   LAB_NoSt          ; skip store if null string
0007F4r 2               
0007F4r 2  68                 PLA                     ; get character back
0007F5r 2  92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
0007F7r 2               LAB_NoSt
0007F7r 2  20 rr rr           JSR   LAB_RTST          ; check for space on descriptor stack then put address
0007FAr 2                                             ; and length on descriptor stack and update stack pointers
0007FAr 2  80 87              BRA   LAB_17D5          ; do string LET and return
0007FCr 2               
0007FCr 2               ; perform PRINT
0007FCr 2               
0007FCr 2               LAB_1829
0007FCr 2  20 rr rr           JSR   LAB_18C6          ; print string from Sutill/Sutilh
0007FFr 2               LAB_182C
0007FFr 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000802r 2               
000802r 2               ; PRINT
000802r 2               
000802r 2               LAB_PRINT
000802r 2  F0 37              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
000804r 2               
000804r 2               LAB_1831
000804r 2  C9 A8              CMP   #TK_TAB           ; compare with TAB( token
000806r 2  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
000808r 2               
000808r 2  C9 AC              CMP   #TK_SPC           ; compare with SPC( token
00080Ar 2  F0 4E              BEQ   LAB_18A2          ; go do TAB/SPC
00080Cr 2               
00080Cr 2  C9 2C              CMP   #','              ; compare with ","
00080Er 2  F0 34              BEQ   LAB_188B          ; go do move to next TAB mark
000810r 2               
000810r 2  C9 3B              CMP   #';'              ; compare with ";"
000812r 2  F0 62              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
000814r 2               
000814r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
000817r 2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
000819r 2  30 E1              BMI   LAB_1829          ; branch if string
00081Br 2               
00081Br 2  20 rr rr           JSR   LAB_296E          ; convert FAC1 to string
00081Er 2  20 rr rr           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
000821r 2               
000821r 2               ; don't check fit if terminal width byte is zero
000821r 2               
000821r 2  A5 08              LDA   TWidth            ; get terminal width byte
000823r 2  F0 0A              BEQ   LAB_185E          ; skip check if zero
000825r 2               
000825r 2  38                 SEC                     ; set carry for subtract
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000826r 2  E5 07              SBC   TPos              ; subtract terminal position
000828r 2  F2 60              SBC   (des_pl)          ; subtract string length
00082Ar 2  B0 03              BCS   LAB_185E          ; branch if less than terminal width
00082Cr 2               
00082Cr 2  20 rr rr           JSR   LAB_CRLF          ; else print CR/LF
00082Fr 2               LAB_185E
00082Fr 2  20 rr rr           JSR   LAB_18C6          ; print string from Sutill/Sutilh
000832r 2  80 CB              BRA   LAB_182C          ; always go continue processing line
000834r 2               
000834r 2               ; CR/LF return to BASIC from BASIC input handler
000834r 2               
000834r 2               LAB_1866
000834r 2  9E 00 05           STZ   Ibuffs,X          ; null terminate input
000837r 2  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
000839r 2  A0 05              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
00083Br 2               
00083Br 2               ; print CR/LF
00083Br 2               
00083Br 2               LAB_CRLF
00083Br 2  A9 0D              LDA   #$0D              ; load [CR]
00083Dr 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000840r 2  A9 0A              LDA   #$0A              ; load [LF]
000842r 2  80 53              BRA   LAB_PRNA          ; go print the character and return, branch always
000844r 2               
000844r 2               LAB_188B
000844r 2  A5 07              LDA   TPos              ; get terminal position
000846r 2  C5 09              CMP   Iclim             ; compare with input column limit
000848r 2  90 05              BCC   LAB_1897          ; branch if less
00084Ar 2               
00084Ar 2  20 rr rr           JSR   LAB_CRLF          ; else print CR/LF (next line)
00084Dr 2  80 27              BRA   LAB_18BD          ; continue with PRINT processing (branch always)
00084Fr 2               
00084Fr 2               LAB_1897
00084Fr 2  38                 SEC                     ; set carry for subtract
000850r 2               LAB_1898
000850r 2  E5 16              SBC   TabSiz            ; subtract TAB size
000852r 2  B0 FC              BCS   LAB_1898          ; loop if result was +ve
000854r 2               
000854r 2  49 FF              EOR   #$FF              ; complement it
000856r 2  69 01              ADC   #$01              ; +1 (twos complement)
000858r 2  80 12              BRA   LAB_18B6          ; always print A spaces (result is never $00)
00085Ar 2               
00085Ar 2                                             ; do TAB/SPC
00085Ar 2               LAB_18A2
00085Ar 2  48                 PHA                     ; save token
00085Br 2  20 rr rr           JSR   LAB_SGBY          ; scan and get byte parameter
00085Er 2  C9 29              CMP   #$29              ; is next character )
000860r 2  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
000862r 2               
000862r 2  68                 PLA                     ; get token back
000863r 2  C9 A8              CMP   #TK_TAB           ; was it TAB ?
000865r 2  D0 06              BNE   LAB_18B7          ; if not go do SPC
000867r 2               
000867r 2                                             ; calculate TAB offset
000867r 2  8A                 TXA                     ; copy integer value to A
000868r 2  E5 07              SBC   TPos              ; subtract terminal position
00086Ar 2  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
00086Cr 2               
00086Cr 2                                             ; print A spaces
00086Cr 2               LAB_18B6
00086Cr 2  AA                 TAX                     ; copy result to X
00086Dr 2               LAB_18B7
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00086Dr 2  8A                 TXA                     ; set flags on size for SPC
00086Er 2  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
000870r 2               
000870r 2                                             ; print X spaces
000870r 2               LAB_18BA
000870r 2  20 rr rr           JSR   LAB_18E0          ; print " "
000873r 2  CA                 DEX                     ; decrement count
000874r 2  D0 FA              BNE   LAB_18BA          ; loop if not all done
000876r 2               
000876r 2                                             ; continue with PRINT processing
000876r 2               LAB_18BD
000876r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000879r 2  D0 89              BNE   LAB_1831          ; if more to print go do it
00087Br 2               
00087Br 2  60                 RTS
00087Cr 2               
00087Cr 2               ; print null terminated string from memory
00087Cr 2               
00087Cr 2               LAB_18C3
00087Cr 2  20 rr rr           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00087Fr 2               
00087Fr 2               ; print string from Sutill/Sutilh
00087Fr 2               
00087Fr 2               LAB_18C6
00087Fr 2  20 rr rr           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
000882r 2                                             ; space returns with A = length, X=$71=pointer low byte,
000882r 2                                             ; Y=$72=pointer high byte
000882r 2  A0 00              LDY   #$00              ; reset index
000884r 2  AA                 TAX                     ; copy length to X
000885r 2  F0 4A              BEQ   LAB_188C          ; exit (RTS) if null string
000887r 2               
000887r 2               LAB_18CD
000887r 2               
000887r 2  B1 23              LDA   (ut1_pl),Y        ; get next byte
000889r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
00088Cr 2  C8                 INY                     ; increment index
00088Dr 2  CA                 DEX                     ; decrement count
00088Er 2  D0 F7              BNE   LAB_18CD          ; loop if not done yet
000890r 2  60                 RTS
000891r 2               
000891r 2                                             ; Print single format character
000891r 2               ; print " "
000891r 2               
000891r 2               LAB_18E0
000891r 2  A9 20              LDA   #$20              ; load " "
000893r 2  80 02              BRA   LAB_PRNA          ; branch around next instruction, saves one clock cycle
000895r 2               
000895r 2               ; print "?" character
000895r 2               
000895r 2               LAB_18E3
000895r 2  A9 3F              LDA   #$3F              ; load "?" character
000897r 2               
000897r 2               ; print character in A
000897r 2               ; now includes the null handler
000897r 2               ; also includes infinite line length code
000897r 2               ; note! some routines expect this one to exit with Zb=0
000897r 2               
000897r 2               LAB_PRNA
000897r 2  C9 20              CMP   #' '              ; compare with " "
000899r 2  90 19              BCC   LAB_18F9          ; branch if less (non printing)
00089Br 2               
00089Br 2                                             ; else printable character
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00089Br 2  48                 PHA                     ; save the character
00089Cr 2               
00089Cr 2               ; don't check fit if terminal width byte is zero
00089Cr 2               
00089Cr 2  A5 08              LDA   TWidth            ; get terminal width
00089Er 2  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
0008A0r 2               
0008A0r 2               ; is "infinite line" so check TAB position
0008A0r 2               
0008A0r 2  A5 07              LDA   TPos              ; get position
0008A2r 2  E5 16              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
0008A4r 2  D0 0B              BNE   LAB_18F7          ; skip reset if different
0008A6r 2               
0008A6r 2  85 07              STA   TPos              ; else reset position
0008A8r 2  F0 07              BEQ   LAB_18F7          ; go print character
0008AAr 2               
0008AAr 2               LAB_18F0
0008AAr 2  C5 07              CMP   TPos              ; compare with terminal character position
0008ACr 2  D0 03              BNE   LAB_18F7          ; branch if not at end of line
0008AEr 2               
0008AEr 2  20 rr rr           JSR   LAB_CRLF          ; else print CR/LF
0008B1r 2               LAB_18F7
0008B1r 2  E6 07              INC   TPos              ; increment terminal position
0008B3r 2  68                 PLA                     ; get character back
0008B4r 2               LAB_18F9
0008B4r 2  20 rr rr           JSR   V_OUTP            ; output byte via output vector
0008B7r 2  C9 0D              CMP   #$0D              ; compare with [CR]
0008B9r 2  D0 14              BNE   LAB_188A          ; branch if not [CR]
0008BBr 2               
0008BBr 2                                             ; else print nullct nulls after the [CR]
0008BBr 2  86 2A              STX   TempB             ; save buffer index
0008BDr 2  A6 06              LDX   Nullct            ; get null count
0008BFr 2  F0 0A              BEQ   LAB_1886          ; branch if no nulls
0008C1r 2               
0008C1r 2  A9 00              LDA   #$00              ; load [NULL]
0008C3r 2               LAB_1880
0008C3r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
0008C6r 2  CA                 DEX                     ; decrement count
0008C7r 2  D0 FA              BNE   LAB_1880          ; loop if not all done
0008C9r 2               
0008C9r 2  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
0008CBr 2               LAB_1886
0008CBr 2  86 07              STX   TPos              ; clear terminal position (X always = zero when we get here)
0008CDr 2  A6 2A              LDX   TempB             ; restore buffer index
0008CFr 2               LAB_188A
0008CFr 2  29 FF              AND   #$FF              ; set the flags
0008D1r 2               LAB_188C
0008D1r 2  60                 RTS
0008D2r 2               
0008D2r 2               ; handle bad input data
0008D2r 2               
0008D2r 2               LAB_1904
0008D2r 2  7F 14 0B           BBR7  Imode,LAB_1913    ; Check input mode, branch if INPUT ($00)
0008D5r 2               ;      LDA   Imode             ; get input mode flag, $00=INPUT, $80=READ
0008D5r 2               ;      BPL   LAB_1913          ; branch if INPUT (go do redo)
0008D5r 2               
0008D5r 2  A5 3F              LDA   Dlinel            ; get current DATA line low byte
0008D7r 2  A4 40              LDY   Dlineh            ; get current DATA line high byte
0008D9r 2  85 39              STA   Clinel            ; save current line low byte
0008DBr 2  84 3A              STY   Clineh            ; save current line high byte
0008DDr 2               LAB_1910
0008DDr 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0008E0r 2               
0008E0r 2                                             ; mode was INPUT
0008E0r 2               LAB_1913
0008E0r 2  A9 rr              LDA   #<LAB_REDO        ; point to redo message (low addr)
0008E2r 2  A0 rr              LDY   #>LAB_REDO        ; point to redo message (high addr)
0008E4r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
0008E7r 2  A5 3D              LDA   Cpntrl            ; get continue pointer low byte
0008E9r 2  A4 3E              LDY   Cpntrh            ; get continue pointer high byte
0008EBr 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
0008EDr 2  84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
0008EFr 2  60                 RTS
0008F0r 2               
0008F0r 2               ; perform INPUT
0008F0r 2               
0008F0r 2               LAB_INPUT
0008F0r 2  C9 22              CMP   #$22              ; compare next byte with open quote
0008F2r 2  D0 0B              BNE   LAB_1934          ; branch if no prompt string
0008F4r 2               
0008F4r 2  20 rr rr           JSR   LAB_1BC1          ; print "..." string
0008F7r 2  A9 3B              LDA   #$3B              ; load A with ";"
0008F9r 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
0008FCr 2  20 rr rr           JSR   LAB_18C6          ; print string from Sutill/Sutilh
0008FFr 2               
0008FFr 2                                             ; done with prompt, now get data
0008FFr 2               LAB_1934
0008FFr 2  20 rr rr           JSR   LAB_CKRN          ; check not Direct, back here if ok
000902r 2  20 rr rr           JSR   LAB_INLN          ; print "? " and get BASIC input
000905r 2  A9 00              LDA   #$00              ; set mode = INPUT
000907r 2  CD 00 05           CMP   Ibuffs            ; test first byte in buffer
00090Ar 2  D0 09              BNE   LAB_1953          ; branch if not null input
00090Cr 2  4C rr rr           JMP   LAB_1647          ; go do BREAK exit
00090Fr 2               
00090Fr 2               ; perform READ
00090Fr 2               
00090Fr 2               LAB_READ
00090Fr 2  A6 41              LDX   Dptrl             ; get DATA pointer low byte
000911r 2  A4 42              LDY   Dptrh             ; get DATA pointer high byte
000913r 2  A9 80              LDA   #$80              ; set mode = READ
000915r 2               
000915r 2               LAB_1953
000915r 2  85 14              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
000917r 2  86 43              STX   Rdptrl            ; save READ pointer low byte
000919r 2  84 44              STY   Rdptrh            ; save READ pointer high byte
00091Br 2               
00091Br 2                                             ; READ or INPUT next variable from list
00091Br 2               LAB_195B
00091Br 2  20 rr rr           JSR   LAB_GVAR          ; get (var) address
00091Er 2  85 49              STA   Lvarpl            ; save address low byte
000920r 2  84 4A              STY   Lvarph            ; save address high byte
000922r 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
000924r 2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
000926r 2  85 0A              STA   Itempl            ; save as temporary integer low byte
000928r 2  84 0B              STY   Itemph            ; save as temporary integer high byte
00092Ar 2  A6 43              LDX   Rdptrl            ; get READ pointer low byte
00092Cr 2  A4 44              LDY   Rdptrh            ; get READ pointer high byte
00092Er 2  86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
000930r 2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
000932r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000935r 2  D0 10              BNE   LAB_1988          ; branch if not null
000937r 2               
000937r 2                                             ; pointer was to null entry
000937r 2  FF 14 64           BBS7  Imode,LAB_19DD    ; test Input mode, branch if $80=READ
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00093Ar 2               ;      BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
00093Ar 2               ;      BMI   LAB_19DD          ; branch if READ
00093Ar 2               
00093Ar 2                                             ; mode was INPUT
00093Ar 2  20 rr rr           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
00093Dr 2  20 rr rr           JSR   LAB_INLN          ; print "? " and get BASIC input
000940r 2  86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
000942r 2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
000944r 2               LAB_1985
000944r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000947r 2               LAB_1988
000947r 2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
000949r 2  10 23              BPL   LAB_19B0          ; branch if numeric
00094Br 2               
00094Br 2                                             ; else get string
00094Br 2  85 0D              STA   Srchc             ; save search character
00094Dr 2  C9 22              CMP   #$22              ; was it " ?
00094Fr 2  F0 07              BEQ   LAB_1999          ; branch if so
000951r 2               
000951r 2  A9 3A              LDA   #':'              ; else search character is ":"
000953r 2  85 0D              STA   Srchc             ; set new search character
000955r 2  A9 2C              LDA   #','              ; other search character is ","
000957r 2  18                 CLC                     ; clear carry for add
000958r 2               LAB_1999
000958r 2  85 0E              STA   Asrch             ; set second search character
00095Ar 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
00095Cr 2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
00095Er 2               
00095Er 2  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
000960r 2  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
000962r 2               
000962r 2  C8                 INY                     ; else increment high byte
000963r 2               LAB_19A4
000963r 2  20 rr rr           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
000966r 2  20 rr rr           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
000969r 2  20 rr rr           JSR   LAB_17D5          ; go do string LET
00096Cr 2  80 06              BRA   LAB_19B6          ; go check string terminator
00096Er 2               
00096Er 2                                             ; get numeric INPUT
00096Er 2               LAB_19B0
00096Er 2  20 rr rr           JSR   LAB_2887          ; get FAC1 from string
000971r 2  20 rr rr           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
000974r 2               LAB_19B6
000974r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000977r 2  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
000979r 2               
000979r 2  C9 2C              CMP   #','              ; else compare with ","
00097Br 2  F0 03              BEQ   LAB_19C2          ; branch if ","
00097Dr 2               
00097Dr 2  4C rr rr           JMP   LAB_1904          ; else go handle bad input data
000980r 2               
000980r 2                                             ; got good input data
000980r 2               LAB_19C2
000980r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000983r 2               LAB_19C5
000983r 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
000985r 2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
000987r 2  85 43              STA   Rdptrl            ; save for now
000989r 2  84 44              STY   Rdptrh            ; save for now
00098Br 2  A5 0A              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
00098Dr 2  A4 0B              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
00098Fr 2  85 6E              STA   Bpntrl            ; set BASIC execute pointer low byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000991r 2  84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
000993r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000996r 2  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
000998r 2               
000998r 2  20 rr rr           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
00099Br 2  4C rr rr           JMP   LAB_195B          ; go INPUT next variable from list
00099Er 2               
00099Er 2                                             ; find next DATA statement or do "Out of DATA" error
00099Er 2               LAB_19DD
00099Er 2  20 rr rr           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
0009A1r 2  C8                 INY                     ; increment index
0009A2r 2  AA                 TAX                     ; copy character ([:] or [EOL])
0009A3r 2  D0 12              BNE   LAB_19F6          ; branch if [:]
0009A5r 2               
0009A5r 2  A2 06              LDX   #$06              ; set for "Out of DATA" error
0009A7r 2  C8                 INY                     ; increment index, now points to next line pointer high byte
0009A8r 2  B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
0009AAr 2  F0 70              BEQ   LAB_1A54          ; branch if end (eventually does error X)
0009ACr 2               
0009ACr 2  C8                 INY                     ; increment index
0009ADr 2  B1 6E              LDA   (Bpntrl),Y        ; get next line # low byte
0009AFr 2  85 3F              STA   Dlinel            ; save current DATA line low byte
0009B1r 2  C8                 INY                     ; increment index
0009B2r 2  B1 6E              LDA   (Bpntrl),Y        ; get next line # high byte
0009B4r 2  C8                 INY                     ; increment index
0009B5r 2  85 40              STA   Dlineh            ; save current DATA line high byte
0009B7r 2               LAB_19F6
0009B7r 2  B1 6E              LDA   (Bpntrl),Y        ; get byte
0009B9r 2  C8                 INY                     ; increment index
0009BAr 2  AA                 TAX                     ; copy to X
0009BBr 2  20 rr rr           JSR   LAB_170F          ; set BASIC execute pointer
0009BEr 2  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
0009C0r 2  F0 82              BEQ   LAB_1985          ; was "DATA" so go do next READ
0009C2r 2  80 DA              BRA   LAB_19DD          ; go find next statement if not "DATA"
0009C4r 2               
0009C4r 2               ; end of INPUT/READ routine
0009C4r 2               
0009C4r 2               LAB_1A03
0009C4r 2  A5 43              LDA   Rdptrl            ; get temp READ pointer low byte
0009C6r 2  A4 44              LDY   Rdptrh            ; get temp READ pointer high byte
0009C8r 2  7F 14 03           BBR7  Imode,LAB_1A0E    ; test input mode, branch if $00=INPUT
0009CBr 2               ;      LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
0009CBr 2               ;      BPL   LAB_1A0E          ; branch if INPUT
0009CBr 2  4C rr rr           JMP   LAB_1624          ; save AY as DATA pointer and return
0009CEr 2               
0009CEr 2                                             ; we were getting INPUT
0009CEr 2               LAB_1A0E
0009CEr 2  B2 43              LDA   (Rdptrl)          ; get next byte
0009D0r 2  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
0009D2r 2  60                 RTS
0009D3r 2               
0009D3r 2                                             ; user typed too much
0009D3r 2               LAB_1A1B
0009D3r 2  A9 rr              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
0009D5r 2  A0 rr              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
0009D7r 2  4C rr rr           JMP   LAB_18C3          ; print null terminated string from memory and return
0009DAr 2               
0009DAr 2               ; search the stack for FOR activity
0009DAr 2               ; exit with z=1 if FOR else exit with z=0
0009DAr 2               
0009DAr 2               LAB_11A1
0009DAr 2  BA                 TSX                     ; copy stack pointer
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0009DBr 2  E8                 INX                     ; +1 pass return address
0009DCr 2  E8                 INX                     ; +2 pass return address
0009DDr 2  E8                 INX                     ; +3 pass calling routine return address
0009DEr 2  E8                 INX                     ; +4 pass calling routine return address
0009DFr 2               LAB_11A6
0009DFr 2  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
0009E2r 2  C9 81              CMP   #TK_FOR           ; is it FOR token
0009E4r 2  D0 21              BNE   LAB_11CE          ; exit if not FOR token
0009E6r 2               
0009E6r 2                                             ; was FOR token
0009E6r 2  A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
0009E8r 2  D0 0A              BNE   LAB_11BB          ; branch if not null
0009EAr 2               
0009EAr 2  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
0009EDr 2  85 49              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
0009EFr 2  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
0009F2r 2  85 4A              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
0009F4r 2               LAB_11BB
0009F4r 2  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
0009F7r 2  D0 07              BNE   LAB_11C7          ; branch if no match
0009F9r 2               
0009F9r 2  A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
0009FBr 2  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
0009FEr 2  F0 07              BEQ   LAB_11CE          ; exit if match found
000A00r 2               
000A00r 2               LAB_11C7
000A00r 2  8A                 TXA                     ; copy index
000A01r 2  18                 CLC                     ; clear carry for add
000A02r 2  69 10              ADC   #$10              ; add FOR stack use size
000A04r 2  AA                 TAX                     ; copy back to index
000A05r 2  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
000A07r 2               
000A07r 2               LAB_11CE
000A07r 2  60                 RTS
000A08r 2               
000A08r 2               ; perform NEXT
000A08r 2               
000A08r 2               LAB_NEXT
000A08r 2  D0 04              BNE   LAB_1A46          ; branch if NEXT var
000A0Ar 2               
000A0Ar 2  A0 00              LDY   #$00              ; else clear Y
000A0Cr 2  80 03              BRA   LAB_1A49          ; branch always (no variable to search for)
000A0Er 2               
000A0Er 2               ; NEXT var
000A0Er 2               
000A0Er 2               LAB_1A46
000A0Er 2  20 rr rr           JSR   LAB_GVAR          ; get variable address
000A11r 2               LAB_1A49
000A11r 2  85 49              STA   Frnxtl            ; store variable pointer low byte
000A13r 2  84 4A              STY   Frnxth            ; store variable pointer high byte
000A15r 2                                             ; (both cleared if no variable defined)
000A15r 2  20 rr rr           JSR   LAB_11A1          ; search the stack for FOR activity
000A18r 2  F0 04              BEQ   LAB_1A56          ; branch if found
000A1Ar 2               
000A1Ar 2  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
000A1Cr 2               LAB_1A54
000A1Cr 2  F0 64              BEQ   LAB_1ABE          ; do error #X, then warm start
000A1Er 2               
000A1Er 2               LAB_1A56
000A1Er 2  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
000A1Fr 2               
000A1Fr 2  8A                 TXA                     ; copy stack pointer
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000A20r 2  38                 SEC                     ; set carry for subtract
000A21r 2  E9 F7              SBC   #$F7              ; point to TO var
000A23r 2  85 25              STA   ut2_pl            ; save pointer to TO var for compare
000A25r 2  69 FB              ADC   #$FB              ; point to STEP var
000A27r 2               
000A27r 2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
000A29r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
000A2Cr 2  BA                 TSX                     ; get stack pointer back
000A2Dr 2  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
000A30r 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
000A32r 2  A5 49              LDA   Frnxtl            ; get FOR variable pointer low byte
000A34r 2  A4 4A              LDY   Frnxth            ; get FOR variable pointer high byte
000A36r 2  20 rr rr           JSR   LAB_246C          ; add (FOR variable) to FAC1
000A39r 2  20 rr rr           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
000A3Cr 2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
000A3Er 2  20 rr rr           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
000A41r 2  BA                 TSX                     ; get stack pointer back
000A42r 2  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
000A45r 2  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
000A47r 2               
000A47r 2                                             ; loop back and do it all again
000A47r 2  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
000A4Ar 2  85 39              STA   Clinel            ; save current line low byte
000A4Cr 2  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
000A4Fr 2  85 3A              STA   Clineh            ; save current line high byte
000A51r 2  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
000A54r 2  85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
000A56r 2  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
000A59r 2  85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
000A5Br 2               LAB_1A98
000A5Br 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
000A5Er 2               
000A5Er 2                                             ; loop complete so carry on
000A5Er 2               LAB_1A9B
000A5Er 2  8A                 TXA                     ; stack copy to A
000A5Fr 2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
000A61r 2  AA                 TAX                     ; copy back to index
000A62r 2  9A                 TXS                     ; copy to stack pointer
000A63r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000A66r 2  C9 2C              CMP   #','              ; compare with ","
000A68r 2  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
000A6Ar 2               
000A6Ar 2                                             ; was "," so another NEXT variable to do
000A6Ar 2  20 rr rr           JSR   LAB_IGBY          ; else increment and scan memory
000A6Dr 2  20 rr rr           JSR   LAB_1A46          ; do NEXT (var)
000A70r 2               
000A70r 2               ; evaluate expression and check is numeric, else do type mismatch
000A70r 2               
000A70r 2               LAB_EVNM
000A70r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
000A73r 2               
000A73r 2               ; check if source is numeric, else do type mismatch
000A73r 2               
000A73r 2               LAB_CTNM
000A73r 2  18                 CLC                     ; destination is numeric
000A74r 2  80 01              BRA   LAB_CKTM          ; branch around SEC
000A76r 2               
000A76r 2               ; check if source is string, else do type mismatch
000A76r 2               
000A76r 2               LAB_CTST
000A76r 2  38                 SEC                     ; required type is string
000A77r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000A77r 2               ; type match check, set C for string, clear C for numeric
000A77r 2               
000A77r 2               LAB_CKTM
000A77r 2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
000A79r 2  30 03              BMI   LAB_1ABA          ; branch if data type is string
000A7Br 2                                             ; else data type was numeric
000A7Br 2  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
000A7Dr 2               LAB_1AB9
000A7Dr 2  60                 RTS
000A7Er 2               
000A7Er 2                                             ; data type was string, now check required type
000A7Er 2               LAB_1ABA
000A7Er 2  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
000A80r 2               
000A80r 2                                             ; else do type mismatch error
000A80r 2               LAB_1ABC
000A80r 2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
000A82r 2               LAB_1ABE
000A82r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000A85r 2               
000A85r 2               ; evaluate expression
000A85r 2               
000A85r 2               LAB_EVEX
000A85r 2  A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
000A87r 2  D0 02              BNE   LAB_1AC7          ; skip next if not zero
000A89r 2               
000A89r 2  C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
000A8Br 2               LAB_1AC7
000A8Br 2  C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
000A8Dr 2               
000A8Dr 2               LAB_EVEZ
000A8Dr 2  A9 00              LDA   #$00              ; set null precedence (flag done)
000A8Fr 2               LAB_1ACC
000A8Fr 2  48                 PHA                     ; push precedence byte
000A90r 2  A9 02              LDA   #$02              ; 2 bytes
000A92r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
000A95r 2  20 rr rr           JSR   LAB_GVAL          ; get value from line
000A98r 2  64 4D              STZ   comp_f            ; clear compare function flag
000A9Ar 2               LAB_1ADB
000A9Ar 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000A9Dr 2               LAB_1ADE
000A9Dr 2  38                 SEC                     ; set carry for subtract
000A9Er 2  E9 BC              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
000AA0r 2  90 16              BCC   LAB_1AFA          ; branch if < TK_GT
000AA2r 2               
000AA2r 2  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
000AA4r 2  B0 12              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
000AA6r 2               
000AA6r 2                                             ; was token for > = or < (A = 0, 1 or 2)
000AA6r 2  C9 01              CMP   #$01              ; compare with token for =
000AA8r 2  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
000AA9r 2                                             ; (A = 0, 3 or 5)
000AA9r 2  49 01              EOR   #$01              ; toggle b0
000AABr 2                                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
000AABr 2  45 4D              EOR   comp_f            ; EOR with compare function flag bits
000AADr 2  C5 4D              CMP   comp_f            ; compare with compare function flag
000AAFr 2  90 66              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
000AB1r 2                                             ; was more than one <, = or >)
000AB1r 2               
000AB1r 2  85 4D              STA   comp_f            ; save new compare function flag
000AB3r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000AB6r 2  80 E5              BRA   LAB_1ADE          ; go do next character
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000AB8r 2               
000AB8r 2                                             ; token is < ">" or > "<" tokens
000AB8r 2               LAB_1AFA
000AB8r 2  A6 4D              LDX   comp_f            ; get compare function flag
000ABAr 2  D0 2C              BNE   LAB_1B2A          ; branch if compare function
000ABCr 2  B0 7D              BCS   LAB_1B78          ; go do functions
000ABEr 2               
000ABEr 2                                             ; else was <  TK_GT so is operator or lower
000ABEr 2  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
000AC0r 2  90 79              BCC   LAB_1B78          ; branch if < + operator
000AC2r 2                                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
000AC2r 2  D0 07              BNE   LAB_1B0B          ; branch if not + token
000AC4r 2               
000AC4r 2  24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
000AC6r 2  10 03              BPL   LAB_1B0B          ; branch if not string
000AC8r 2               
000AC8r 2                                             ; will only be $00 if type is string and token was +
000AC8r 2  4C rr rr           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
000ACBr 2                                             ; is in line, and return
000ACBr 2               
000ACBr 2               LAB_1B0B
000ACBr 2  85 23              STA   ut1_pl            ; save it
000ACDr 2  0A                 ASL                     ; *2
000ACEr 2  65 23              ADC   ut1_pl            ; *3
000AD0r 2  A8                 TAY                     ; copy to index
000AD1r 2               LAB_1B13
000AD1r 2  68                 PLA                     ; pull previous precedence
000AD2r 2  D9 rr rr           CMP   LAB_OPPT,Y        ; compare with precedence byte
000AD5r 2  B0 69              BCS   LAB_1B7D          ; branch if A >=
000AD7r 2               
000AD7r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000ADAr 2               LAB_1B1C
000ADAr 2  48                 PHA                     ; save precedence
000ADBr 2               LAB_1B1D
000ADBr 2  20 rr rr           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
000ADEr 2  68                 PLA                     ; restore precedence
000ADFr 2  A4 4B              LDY   prstk             ; get precedence stacked flag
000AE1r 2  10 19              BPL   LAB_1B3C          ; branch if stacked values
000AE3r 2               
000AE3r 2  AA                 TAX                     ; copy precedence (set flags)
000AE4r 2  F0 7A              BEQ   LAB_1B9D          ; exit if done
000AE6r 2  80 61              BRA   LAB_1B86          ; else pop FAC2 and return, branch always
000AE8r 2               
000AE8r 2               LAB_1B2A
000AE8r 2  26 11              ROL   Dtypef            ; shift data type flag into Cb
000AEAr 2  8A                 TXA                     ; copy compare function flag
000AEBr 2  85 11              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
000AEDr 2  2A                 ROL                     ; shift data type into compare function byte b0
000AEEr 2  A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
000AF0r 2  D0 02              BNE   LAB_1B34          ; branch if no underflow
000AF2r 2               
000AF2r 2  C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
000AF4r 2               LAB_1B34
000AF4r 2  C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
000AF6r 2               TK_LT_PLUS  = TK_LT-TK_PLUS
000AF6r 2  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
000AF8r 2  85 4D              STA   comp_f            ; save new compare function flag
000AFAr 2  80 D5              BRA   LAB_1B13          ; branch always
000AFCr 2               
000AFCr 2               LAB_1B3C
000AFCr 2  D9 rr rr           CMP   LAB_OPPT,Y        ; compare with stacked function precedence
000AFFr 2  B0 48              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000B01r 2  80 D7              BRA   LAB_1B1C          ; branch always
000B03r 2               
000B03r 2               ;.get vector, execute function then continue evaluation
000B03r 2               
000B03r 2               LAB_1B43
000B03r 2  B9 rr rr           LDA   LAB_OPPT+2,Y      ; get function vector high byte
000B06r 2  48                 PHA                     ; onto stack
000B07r 2  B9 rr rr           LDA   LAB_OPPT+1,Y      ; get function vector low byte
000B0Ar 2  48                 PHA                     ; onto stack
000B0Br 2                                             ; now push sign, round FAC1 and put on stack
000B0Br 2  20 rr rr           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
000B0Er 2                                             ; the function
000B0Er 2  A5 4D              LDA   comp_f            ; get compare function flag
000B10r 2  48                 PHA                     ; push compare evaluation byte
000B11r 2  B9 rr rr           LDA   LAB_OPPT,Y        ; get precedence byte
000B14r 2  4C rr rr           JMP   LAB_1ACC          ; continue evaluating expression
000B17r 2               
000B17r 2               LAB_1B53
000B17r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
000B1Ar 2               
000B1Ar 2               ; push sign, round FAC1 and put on stack
000B1Ar 2               
000B1Ar 2               ; patched routine - Klaus fixed in 2.22p5 by adding NOP if needed
000B1Ar 2               ; this fix corrects the RTS increment by one and handles high byte if needed
000B1Ar 2               
000B1Ar 2               LAB_1B5B
000B1Ar 2  68                 PLA                     ; get return addr low byte
000B1Br 2  85 23              STA   ut1_pl            ; save it
000B1Dr 2  68                 PLA                     ; get return addr high byte
000B1Er 2  85 24              STA   ut1_ph            ; save it
000B20r 2               
000B20r 2  E6 23              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
000B22r 2  D0 02              BNE   LAB_1B5B2         ; skip high byte increment if no low byte rollover to $00
000B24r 2  E6 24              INC   ut1_ph            ; else increment high byte
000B26r 2               LAB_1B5B2
000B26r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
000B28r 2  48                 PHA                     ; push sign
000B29r 2               
000B29r 2               ; round FAC1 and put on stack
000B29r 2               
000B29r 2               ; LAB_1B66 moved to after JSR LAB_27BA (patch 2.22p5)
000B29r 2               
000B29r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
000B2Cr 2               LAB_1B66
000B2Cr 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
000B2Er 2  48                 PHA                     ; push on stack
000B2Fr 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
000B31r 2  48                 PHA                     ; push on stack
000B32r 2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
000B34r 2  48                 PHA                     ; push on stack
000B35r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
000B37r 2  48                 PHA                     ; push on stack
000B38r 2  6C 23 00           JMP   (ut1_pl)          ; return, sort of
000B3Br 2               
000B3Br 2               ; do functions
000B3Br 2               
000B3Br 2               LAB_1B78
000B3Br 2  A0 FF              LDY   #$FF              ; flag function
000B3Dr 2  68                 PLA                     ; pull precedence byte
000B3Er 2               LAB_1B7B
000B3Er 2  F0 20              BEQ   LAB_1B9D          ; exit if done
000B40r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000B40r 2               LAB_1B7D
000B40r 2  C9 64              CMP   #$64              ; compare previous precedence with $64
000B42r 2  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
000B44r 2               
000B44r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000B47r 2               LAB_1B84
000B47r 2  84 4B              STY   prstk             ; save precedence stacked flag
000B49r 2               
000B49r 2                                             ; pop FAC2 and return
000B49r 2               LAB_1B86
000B49r 2  68                 PLA                     ; pop byte
000B4Ar 2  4A                 LSR                     ; shift out comparison evaluation lowest bit
000B4Br 2  85 15              STA   Cflag             ; save comparison evaluation flag
000B4Dr 2  68                 PLA                     ; pop exponent
000B4Er 2  85 65              STA   FAC2_e            ; save FAC2 exponent
000B50r 2  68                 PLA                     ; pop mantissa1
000B51r 2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
000B53r 2  68                 PLA                     ; pop mantissa2
000B54r 2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
000B56r 2  68                 PLA                     ; pop mantissa3
000B57r 2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
000B59r 2  68                 PLA                     ; pop sign
000B5Ar 2  85 69              STA   FAC2_s            ; save FAC2 sign (b7)
000B5Cr 2  45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
000B5Er 2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
000B60r 2               LAB_1B9D
000B60r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
000B62r 2  60                 RTS
000B63r 2               
000B63r 2               ; print "..." string to string util area
000B63r 2               
000B63r 2               LAB_1BC1
000B63r 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
000B65r 2  A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
000B67r 2  69 00              ADC   #$00              ; add carry to low byte
000B69r 2  90 01              BCC   LAB_1BCA          ; branch if no overflow
000B6Br 2               
000B6Br 2  C8                 INY                     ; increment high byte
000B6Cr 2               LAB_1BCA
000B6Cr 2  20 rr rr           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
000B6Fr 2  4C rr rr           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
000B72r 2               
000B72r 2               ; get value from line
000B72r 2               
000B72r 2               LAB_GVAL
000B72r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000B75r 2  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
000B77r 2               
000B77r 2                                             ; else numeric string found (e.g. 123)
000B77r 2               LAB_1BA9
000B77r 2  4C rr rr           JMP   LAB_2887          ; get FAC1 from string and return
000B7Ar 2               
000B7Ar 2               ; get value from line .. continued
000B7Ar 2               
000B7Ar 2                                             ; wasn't a number so ..
000B7Ar 2               LAB_1BAC
000B7Ar 2  AA                 TAX                     ; set the flags
000B7Br 2  30 2D              BMI   LAB_1BD0          ; if -ve go test token values
000B7Dr 2               
000B7Dr 2                                             ; else it is either a string, number, variable or (<expr>)
000B7Dr 2  C9 24              CMP   #'$'              ; compare with "$"
000B7Fr 2  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000B81r 2               
000B81r 2  C9 25              CMP   #'%'              ; else compare with "%"
000B83r 2  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
000B85r 2               
000B85r 2  C9 2E              CMP   #'.'              ; compare with "."
000B87r 2  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
000B89r 2               
000B89r 2                                             ; it wasn't any sort of number so ..
000B89r 2  C9 22              CMP   #$22              ; compare with "
000B8Br 2  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
000B8Dr 2               
000B8Dr 2                                             ; wasn't any sort of number so ..
000B8Dr 2               
000B8Dr 2               ; evaluate expression within parentheses
000B8Dr 2               
000B8Dr 2  C9 28              CMP   #'('              ; compare with "("
000B8Fr 2  D0 58              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
000B91r 2               
000B91r 2               LAB_1BF7
000B91r 2  20 rr rr           JSR   LAB_EVEZ          ; evaluate expression, no decrement
000B94r 2               
000B94r 2               ; all the 'scan for' routines return the character after the sought character
000B94r 2               
000B94r 2               ; scan for ")" , else do syntax error then warm start
000B94r 2               
000B94r 2               LAB_1BFB
000B94r 2  A9 29              LDA   #$29              ; load A with ")"
000B96r 2               
000B96r 2               ; scan for CHR$(A) , else do syntax error then warm start
000B96r 2               
000B96r 2               LAB_SCCA
000B96r 2  D2 6E              CMP   (Bpntrl)          ; check next byte is = A
000B98r 2  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
000B9Ar 2               
000B9Ar 2  4C rr rr           JMP   LAB_IGBY          ; increment and scan memory then return
000B9Dr 2               
000B9Dr 2               ; scan for "(" , else do syntax error then warm start
000B9Dr 2               
000B9Dr 2               LAB_1BFE
000B9Dr 2  A9 28              LDA   #$28              ; load A with "("
000B9Fr 2  80 F5              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
000BA1r 2               
000BA1r 2               ; scan for "," , else do syntax error then warm start
000BA1r 2               
000BA1r 2               LAB_1C01
000BA1r 2  A9 2C              LDA   #$2C              ; load A with ","
000BA3r 2  80 F1              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
000BA5r 2               
000BA5r 2               ; syntax error then warm start
000BA5r 2               
000BA5r 2               LAB_SNER
000BA5r 2  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
000BA7r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000BAAr 2               
000BAAr 2               ; get value from line .. continued
000BAAr 2               ; do tokens
000BAAr 2               
000BAAr 2               LAB_1BD0
000BAAr 2  C9 B3              CMP   #TK_MINUS         ; compare with token for -
000BACr 2  F0 28              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
000BAEr 2               
000BAEr 2                                             ; wasn't -n so ..
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000BAEr 2  C9 B2              CMP   #TK_PLUS          ; compare with token for +
000BB0r 2  F0 C0              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
000BB2r 2               
000BB2r 2  C9 AE              CMP   #TK_NOT           ; compare with token for NOT
000BB4r 2  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
000BB6r 2               
000BB6r 2                                             ; was NOT token
000BB6r 2               TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
000BB6r 2  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
000BB8r 2  80 1E              BRA   LAB_1C13          ; do set-up for function then execute (branch always)
000BBAr 2               
000BBAr 2               ; do = compare
000BBAr 2               
000BBAr 2               LAB_EQUAL
000BBAr 2  20 rr rr           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
000BBDr 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
000BBFr 2  49 FF              EOR   #$FF              ; invert it
000BC1r 2  A8                 TAY                     ; copy it
000BC2r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
000BC4r 2  49 FF              EOR   #$FF              ; invert it
000BC6r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000BC9r 2               
000BC9r 2               ; get value from line .. continued
000BC9r 2               
000BC9r 2                                             ; wasn't +, -, or NOT so ..
000BC9r 2               LAB_1BE7
000BC9r 2  C9 AB              CMP   #TK_FN            ; compare with token for FN
000BCBr 2  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
000BCDr 2               
000BCDr 2  4C rr rr           JMP   LAB_201E          ; go evaluate FNx
000BD0r 2               
000BD0r 2               ; get value from line .. continued
000BD0r 2               
000BD0r 2                                             ; wasn't +, -, NOT or FN so ..
000BD0r 2               LAB_1BEE
000BD0r 2  E9 BF              SBC   #TK_SGN           ; subtract with token for SGN
000BD2r 2  B0 26              BCS   LAB_1C27          ; if a function token go do it
000BD4r 2  80 CF              BRA   LAB_SNER          ; else do syntax error
000BD6r 2               
000BD6r 2               ; set-up for functions
000BD6r 2               
000BD6r 2               LAB_1C11
000BD6r 2               TK_GT_PLUS  = TK_GT-TK_PLUS
000BD6r 2  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
000BD8r 2               LAB_1C13
000BD8r 2  68                 PLA                     ; dump return address low byte
000BD9r 2               
000BD9r 2                                             ; patch 2.22p5
000BD9r 2               
000BD9r 2  AA                 TAX                     ; save to trap concatenate
000BDAr 2  68                 PLA                     ; dump return address high byte
000BDBr 2  E0 rr              CPX   #<LAB_224Da+2   ; from concatenate low return address?
000BDDr 2  D0 04              BNE   LAB_1C13b         ; No - continue!
000BDFr 2  C9 rr              CMP   #>LAB_224Da+2   ; from concatenate high return address?
000BE1r 2  F0 03              BEQ   LAB_1C13a         ; Yes - error!
000BE3r 2               LAB_1C13b
000BE3r 2  4C rr rr           JMP   LAB_1B1D          ; execute function then continue evaluation
000BE6r 2               LAB_1C13a
000BE6r 2  4C rr rr           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
000BE9r 2               
000BE9r 2               ;      PLA                     ; dump return address high byte
000BE9r 2               ;      JMP   LAB_1B1D          ; execute function then continue evaluation
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000BE9r 2               
000BE9r 2                                              ; patch 2.22p5
000BE9r 2               
000BE9r 2               ; variable name set-up
000BE9r 2               ; get (var), return value in FAC_1 and $ flag
000BE9r 2               
000BE9r 2               LAB_1C18
000BE9r 2  20 rr rr           JSR   LAB_GVAR          ; get (var) address
000BECr 2  85 60              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
000BEEr 2  84 61              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
000BF0r 2  A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
000BF2r 2  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
000BF4r 2               
000BF4r 2               LAB_1C24
000BF4r 2  4C rr rr           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
000BF7r 2               
000BF7r 2               LAB_1C25
000BF7r 2               
000BF7r 2  46 6B              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
000BF9r 2  60                 RTS
000BFAr 2               
000BFAr 2               ; get value from line .. continued
000BFAr 2               ; only functions left so ..
000BFAr 2               
000BFAr 2               ; set up function references
000BFAr 2               
000BFAr 2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
000BFAr 2               ; to process function calls. now the function vector is computed and pushed on the stack
000BFAr 2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
000BFAr 2               ; is calculated and the routine called, if not this routine just does RTS. whichever
000BFAr 2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
000BFAr 2               ; the function code
000BFAr 2               
000BFAr 2               ; this also removes some less than elegant code that was used to bypass type checking
000BFAr 2               ; for functions that returned strings
000BFAr 2               
000BFAr 2               LAB_1C27
000BFAr 2  0A                 ASL                     ; *2 (2 bytes per function address)
000BFBr 2  A8                 TAY                     ; copy to index
000BFCr 2               
000BFCr 2  B9 rr rr           LDA   LAB_FTBM,Y        ; get function jump vector high byte
000BFFr 2  48                 PHA                     ; push functions jump vector high byte
000C00r 2  B9 rr rr           LDA   LAB_FTBL,Y        ; get function jump vector low byte
000C03r 2  48                 PHA                     ; push functions jump vector low byte
000C04r 2               
000C04r 2  B9 rr rr           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
000C07r 2  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
000C09r 2               
000C09r 2  48                 PHA                     ; push functions pre process vector high byte
000C0Ar 2  B9 rr rr           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
000C0Dr 2  48                 PHA                     ; push functions pre process vector low byte
000C0Er 2               
000C0Er 2               LAB_1C56
000C0Er 2  60                 RTS                     ; do function, or pre process, call
000C0Fr 2               
000C0Fr 2               ; process string expression in parenthesis
000C0Fr 2               
000C0Fr 2               LAB_PPFS
000C0Fr 2  20 rr rr           JSR   LAB_1BF7          ; process expression in parenthesis
000C12r 2  4C rr rr           JMP   LAB_CTST          ; check if source is string then do function,
000C15r 2                                             ; else do type mismatch
000C15r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000C15r 2               ; process numeric expression in parenthesis
000C15r 2               
000C15r 2               LAB_PPFN
000C15r 2  20 rr rr           JSR   LAB_1BF7          ; process expression in parenthesis
000C18r 2  4C rr rr           JMP   LAB_CTNM          ; check if source is numeric then do function,
000C1Br 2                                             ; else do type mismatch
000C1Br 2               
000C1Br 2               ; set numeric data type and increment BASIC execute pointer
000C1Br 2               
000C1Br 2               LAB_PPBI
000C1Br 2  46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
000C1Dr 2  4C rr rr           JMP   LAB_IGBY          ; increment and scan memory then do function
000C20r 2               
000C20r 2               ; process string for LEFT$, RIGHT$ or MID$
000C20r 2               
000C20r 2               LAB_LRMS
000C20r 2  20 rr rr           JSR   LAB_EVEZ          ; evaluate (should be string) expression
000C23r 2  20 rr rr           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
000C26r 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
000C29r 2  FA                 PLX                     ; get function jump vector low byte
000C2Ar 2  7A                 PLY                     ; get function jump vector high byte
000C2Br 2  A5 61              LDA   des_ph            ; get descriptor pointer high byte
000C2Dr 2  48                 PHA                     ; push string pointer high byte
000C2Er 2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
000C30r 2  48                 PHA                     ; push string pointer low byte
000C31r 2  5A                 PHY                     ; save function jump vector high byte
000C32r 2  DA                 PHX                     ; save function jump vector low byte
000C33r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
000C36r 2  8A                 TXA                     ; copy byte parameter to A
000C37r 2  60                 RTS                     ; go do function
000C38r 2               
000C38r 2               ; process numeric expression(s) for BIN$ or HEX$
000C38r 2               
000C38r 2               LAB_BHSS
000C38r 2  20 rr rr           JSR   LAB_EVEZ          ; process expression
000C3Br 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000C3Er 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
000C40r 2  C9 98              CMP   #$98              ; compare with exponent = 2^24
000C42r 2  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
000C44r 2               
000C44r 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
000C47r 2  A2 02              LDX   #$02              ; 3 bytes to do
000C49r 2               LAB_CFAC
000C49r 2  B5 5F              LDA   FAC1_1,X          ; get byte from FAC1
000C4Br 2  95 0A              STA   nums_1,X          ; save byte to temp
000C4Dr 2  CA                 DEX                     ; decrement index
000C4Er 2  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
000C50r 2               
000C50r 2  20 rr rr           JSR   LAB_GBYT          ; get next BASIC byte
000C53r 2  A2 00              LDX   #$00              ; set default to no leading "0"s
000C55r 2  C9 29              CMP   #')'              ; compare with close bracket
000C57r 2  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
000C59r 2               
000C59r 2  20 rr rr           JSR   LAB_SCGB          ; scan for "," and get byte
000C5Cr 2  20 rr rr           JSR   LAB_GBYT          ; get last byte back
000C5Fr 2  C9 29              CMP   #')'              ; is next character )
000C61r 2  D0 01              BNE   LAB_BHER          ; if not ")" go do error
000C63r 2               
000C63r 2               LAB_1C54
000C63r 2  60                 RTS                     ; else do function
000C64r 2               
000C64r 2               LAB_BHER
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000C64r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
000C67r 2               
000C67r 2               ; perform EOR
000C67r 2               
000C67r 2               ; added operator format is the same as AND or OR, precedence is the same as OR
000C67r 2               
000C67r 2               ; this bit worked first time but it took a while to sort out the operator table
000C67r 2               ; pointers and offsets afterwards!
000C67r 2               
000C67r 2               LAB_EOR
000C67r 2  20 rr rr           JSR   GetFirst          ; get first integer expression (no sign check)
000C6Ar 2  45 0D              EOR   XOAw_l            ; EOR with expression 1 low byte
000C6Cr 2  A8                 TAY                     ; save in Y
000C6Dr 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
000C6Fr 2  45 0E              EOR   XOAw_h            ; EOR with expression 1 high byte
000C71r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000C74r 2               
000C74r 2               ; perform OR
000C74r 2               
000C74r 2               LAB_OR
000C74r 2  20 rr rr           JSR   GetFirst          ; get first integer expression (no sign check)
000C77r 2  05 0D              ORA   XOAw_l            ; OR with expression 1 low byte
000C79r 2  A8                 TAY                     ; save in Y
000C7Ar 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
000C7Cr 2  05 0E              ORA   XOAw_h            ; OR with expression 1 high byte
000C7Er 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000C81r 2               
000C81r 2               ; perform AND
000C81r 2               
000C81r 2               LAB_AND
000C81r 2  20 rr rr           JSR   GetFirst          ; get first integer expression (no sign check)
000C84r 2  25 0D              AND   XOAw_l            ; AND with expression 1 low byte
000C86r 2  A8                 TAY                     ; save in Y
000C87r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
000C89r 2  25 0E              AND   XOAw_h            ; AND with expression 1 high byte
000C8Br 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000C8Er 2               
000C8Er 2               ; get first value for OR, AND or EOR
000C8Er 2               
000C8Er 2               GetFirst
000C8Er 2  20 rr rr           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
000C91r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
000C93r 2  85 0E              STA   XOAw_h            ; save it
000C95r 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
000C97r 2  85 0D              STA   XOAw_l            ; save it
000C99r 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
000C9Cr 2  20 rr rr           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
000C9Fr 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
000CA1r 2               LAB_1C95
000CA1r 2  60                 RTS
000CA2r 2               
000CA2r 2               ; perform comparisons
000CA2r 2               
000CA2r 2               ; do < compare
000CA2r 2               
000CA2r 2               LAB_LTHAN
000CA2r 2  20 rr rr           JSR   LAB_CKTM          ; type match check, set C for string
000CA5r 2  B0 12              BCS   LAB_1CAE          ; branch if string
000CA7r 2               
000CA7r 2                                             ; do numeric < compare
000CA7r 2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
000CA9r 2  09 7F              ORA   #$7F              ; set all non sign bits
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000CABr 2  25 66              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
000CADr 2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
000CAFr 2  A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
000CB1r 2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
000CB3r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
000CB6r 2  AA                 TAX                     ; copy result
000CB7r 2  80 31              BRA   LAB_1CE1          ; go evaluate result
000CB9r 2               
000CB9r 2                                             ; do string < compare
000CB9r 2               LAB_1CAE
000CB9r 2  46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
000CBBr 2  C6 4D              DEC   comp_f            ; clear < bit in compare function flag
000CBDr 2  20 rr rr           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
000CC0r 2                                             ; space returns with A = length, X=pointer low byte,
000CC0r 2                                             ; Y=pointer high byte
000CC0r 2  85 5E              STA   str_ln            ; save length
000CC2r 2  86 5F              STX   str_pl            ; save string pointer low byte
000CC4r 2  84 60              STY   str_ph            ; save string pointer high byte
000CC6r 2  A5 67              LDA   FAC2_2            ; get descriptor pointer low byte
000CC8r 2  A4 68              LDY   FAC2_3            ; get descriptor pointer high byte
000CCAr 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
000CCDr 2                                             ; returns with A = length, X=pointer low byte,
000CCDr 2                                             ; Y=pointer high byte
000CCDr 2  86 67              STX   FAC2_2            ; save string pointer low byte
000CCFr 2  84 68              STY   FAC2_3            ; save string pointer high byte
000CD1r 2  AA                 TAX                     ; copy length
000CD2r 2  38                 SEC                     ; set carry for subtract
000CD3r 2  E5 5E              SBC   str_ln            ; subtract string 1 length
000CD5r 2  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
000CD7r 2               
000CD7r 2  A9 01              LDA   #$01              ; set str 1 length > string 2 length
000CD9r 2  90 04              BCC   LAB_1CD6          ; branch if so
000CDBr 2               
000CDBr 2  A6 5E              LDX   str_ln            ; get string 1 length
000CDDr 2  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
000CDFr 2               LAB_1CD6
000CDFr 2  85 62              STA   FAC1_s            ; save length compare
000CE1r 2  A0 FF              LDY   #$FF              ; set index
000CE3r 2  E8                 INX                     ; adjust for loop
000CE4r 2               LAB_1CDB
000CE4r 2  C8                 INY                     ; increment index
000CE5r 2  CA                 DEX                     ; decrement count
000CE6r 2  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
000CE8r 2               
000CE8r 2  A6 62              LDX   FAC1_s            ; get length compare back
000CEAr 2               LAB_1CE1
000CEAr 2  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
000CECr 2               
000CECr 2  18                 CLC                     ; flag str 1 <= str 2
000CEDr 2  90 0C              BCC   LAB_1CF2          ; go evaluate result
000CEFr 2               
000CEFr 2               LAB_1CE6
000CEFr 2  B1 67              LDA   (FAC2_2),Y        ; get string 2 byte
000CF1r 2  D1 5F              CMP   (FAC1_1),Y        ; compare with string 1 byte
000CF3r 2  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
000CF5r 2               
000CF5r 2  A2 FF              LDX   #$FF              ; set str 1 < string 2
000CF7r 2  B0 02              BCS   LAB_1CF2          ; branch if so
000CF9r 2               
000CF9r 2  A2 01              LDX   #$01              ; set str 1 > string 2
000CFBr 2               LAB_1CF2
000CFBr 2  E8                 INX                     ; x = 0, 1 or 2
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000CFCr 2  8A                 TXA                     ; copy to A
000CFDr 2  2A                 ROL                     ; *2 (1, 2 or 4)
000CFEr 2  25 15              AND   Cflag             ; AND with comparison evaluation flag
000D00r 2  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
000D02r 2               
000D02r 2  A9 FF              LDA   #$FF              ; else set result true
000D04r 2               LAB_1CFB
000D04r 2  4C rr rr           JMP   LAB_27DB          ; save A as integer byte and return
000D07r 2               
000D07r 2               LAB_1CFE
000D07r 2  20 rr rr           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
000D0Ar 2               
000D0Ar 2               ; perform DIM
000D0Ar 2               
000D0Ar 2               LAB_DIM
000D0Ar 2  AA                 TAX                     ; copy "DIM" flag to X
000D0Br 2  20 rr rr           JSR   LAB_1D10          ; search for variable
000D0Er 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000D11r 2  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
000D13r 2  60                 RTS
000D14r 2               
000D14r 2               ; perform << (left shift)
000D14r 2               
000D14r 2               LAB_LSHIFT
000D14r 2  20 rr rr           JSR   GetPair           ; get integer expression and byte (no sign check)
000D17r 2  A5 60              LDA   FAC1_2            ; get expression high byte
000D19r 2  A6 2A              LDX   TempB             ; get shift count
000D1Br 2  F0 22              BEQ   NoShift           ; branch if zero
000D1Dr 2               
000D1Dr 2  E0 10              CPX   #$10              ; compare bit count with 16d
000D1Fr 2  B0 23              BCS   TooBig            ; branch if >=
000D21r 2               
000D21r 2               Ls_loop
000D21r 2  06 61              ASL   FAC1_3            ; shift low byte
000D23r 2  2A                 ROL                     ; shift high byte
000D24r 2  CA                 DEX                     ; decrement bit count
000D25r 2  D0 FA              BNE   Ls_loop           ; loop if shift not complete
000D27r 2               
000D27r 2  A4 61              LDY   FAC1_3            ; get expression low byte
000D29r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000D2Cr 2               
000D2Cr 2               ; perform >> (right shift)
000D2Cr 2               
000D2Cr 2               LAB_RSHIFT
000D2Cr 2  20 rr rr           JSR   GetPair           ; get integer expression and byte (no sign check)
000D2Fr 2  A5 60              LDA   FAC1_2            ; get expression high byte
000D31r 2  A6 2A              LDX   TempB             ; get shift count
000D33r 2  F0 0A              BEQ   NoShift           ; branch if zero
000D35r 2               
000D35r 2  E0 10              CPX   #$10              ; compare bit count with 16d
000D37r 2  B0 0B              BCS   TooBig            ; branch if >=
000D39r 2               
000D39r 2               Rs_loop
000D39r 2  4A                 LSR                     ; shift high byte
000D3Ar 2  66 61              ROR   FAC1_3            ; shift low byte
000D3Cr 2  CA                 DEX                     ; decrement bit count
000D3Dr 2  D0 FA              BNE   Rs_loop           ; loop if shift not complete
000D3Fr 2               
000D3Fr 2               NoShift
000D3Fr 2  A4 61              LDY   FAC1_3            ; get expression low byte
000D41r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000D44r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000D44r 2               TooBig
000D44r 2  A9 00              LDA   #$00              ; clear high byte
000D46r 2  A8                 TAY                     ; copy to low byte
000D47r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000D4Ar 2               
000D4Ar 2               GetPair
000D4Ar 2  20 rr rr           JSR   LAB_EVBY          ; evaluate byte expression, result in X
000D4Dr 2  86 2A              STX   TempB             ; save it
000D4Fr 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
000D52r 2  4C rr rr           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
000D55r 2               
000D55r 2               ; search for variable
000D55r 2               
000D55r 2               ; return pointer to variable in Cvaral/Cvarah
000D55r 2               
000D55r 2               LAB_GVAR
000D55r 2  A2 00              LDX   #$00              ; set DIM flag = $00
000D57r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory (1st character)
000D5Ar 2               LAB_1D10
000D5Ar 2  86 10              STX   Defdim            ; save DIM flag
000D5Cr 2               LAB_1D12
000D5Cr 2  85 45              STA   Varnm1            ; save 1st character
000D5Er 2  29 7F              AND   #$7F              ; clear FN flag bit
000D60r 2  20 rr rr           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
000D63r 2  B0 03              BCS   LAB_1D1F          ; branch if ok
000D65r 2               
000D65r 2  4C rr rr           JMP   LAB_SNER          ; else syntax error then warm start
000D68r 2               
000D68r 2                                             ; was variable name so ..
000D68r 2               LAB_1D1F
000D68r 2  A2 00              LDX   #$00              ; set DIM flag = $00
000D6Ar 2  86 11              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
000D6Cr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
000D6Fr 2  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
000D71r 2               
000D71r 2                                             ; 2nd character wasn't "0" to "9" so ..
000D71r 2  20 rr rr           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
000D74r 2  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
000D76r 2               
000D76r 2               LAB_1D2D
000D76r 2  AA                 TAX                     ; copy 2nd character
000D77r 2               
000D77r 2                                             ; ignore further (valid) characters in the variable name
000D77r 2               LAB_1D2E
000D77r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
000D7Ar 2  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
000D7Cr 2               
000D7Cr 2  20 rr rr           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
000D7Fr 2  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
000D81r 2               
000D81r 2                                             ; check if string variable
000D81r 2               LAB_1D38
000D81r 2  C9 24              CMP   #'$'              ; compare with "$"
000D83r 2  D0 0B              BNE   LAB_1D47          ; branch if not string
000D85r 2               
000D85r 2               ; to introduce a new variable type (% suffix for integers say) then this branch
000D85r 2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
000D85r 2               
000D85r 2                                             ; type is string
000D85r 2  A9 FF              LDA   #$FF              ; set data type = string
000D87r 2  85 11              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
000D89r 2  8A                 TXA                     ; get 2nd character back
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000D8Ar 2  09 80              ORA   #$80              ; set top bit (indicate string var)
000D8Cr 2  AA                 TAX                     ; copy back to 2nd character temp
000D8Dr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000D90r 2               
000D90r 2               ; after we have determined the variable type we need to come back here to determine
000D90r 2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
000D90r 2               
000D90r 2               LAB_1D47                      ; gets here with character after var name in A
000D90r 2  86 46              STX   Varnm2            ; save 2nd character
000D92r 2  05 13              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
000D94r 2  C9 28              CMP   #'('              ; compare with "("
000D96r 2  D0 03              BNE   LAB_1D53          ; branch if not "("
000D98r 2  4C rr rr           JMP   LAB_1E17          ; go find, or make, array
000D9Br 2               
000D9Br 2               ; either find or create var
000D9Br 2               ; var name (1st two characters only!) is in Varnm1,Varnm2
000D9Br 2               
000D9Br 2                                             ; variable name wasn't var(... so look for plain var
000D9Br 2               LAB_1D53
000D9Br 2  64 13              STZ   Sufnxf            ; clear subscript/FNX flag
000D9Dr 2  A5 2D              LDA   Svarl             ; get start of vars low byte
000D9Fr 2  A6 2E              LDX   Svarh             ; get start of vars high byte
000DA1r 2  A0 00              LDY   #$00              ; clear index
000DA3r 2               LAB_1D5D
000DA3r 2  86 5D              STX   Vrschh            ; save search address high byte
000DA5r 2               LAB_1D5F
000DA5r 2  85 5C              STA   Vrschl            ; save search address low byte
000DA7r 2  E4 30              CPX   Sarryh            ; compare high address with var space end
000DA9r 2  D0 04              BNE   LAB_1D69          ; skip next compare if <>
000DABr 2               
000DABr 2                                             ; high addresses were = so compare low addresses
000DABr 2  C5 2F              CMP   Sarryl            ; compare low address with var space end
000DADr 2  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
000DAFr 2               
000DAFr 2               LAB_1D69
000DAFr 2  A5 45              LDA   Varnm1            ; get 1st character of var to find
000DB1r 2  D1 5C              CMP   (Vrschl),Y        ; compare with variable name 1st character
000DB3r 2  D0 08              BNE   LAB_1D77          ; branch if no match
000DB5r 2               
000DB5r 2                                             ; 1st characters match so compare 2nd characters
000DB5r 2  A5 46              LDA   Varnm2            ; get 2nd character of var to find
000DB7r 2  C8                 INY                     ; index to point to variable name 2nd character
000DB8r 2  D1 5C              CMP   (Vrschl),Y        ; compare with variable name 2nd character
000DBAr 2  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
000DBCr 2               
000DBCr 2  88                 DEY                     ; else decrement index (now = $00)
000DBDr 2               LAB_1D77
000DBDr 2  18                 CLC                     ; clear carry for add
000DBEr 2  A5 5C              LDA   Vrschl            ; get search address low byte
000DC0r 2  69 06              ADC   #$06              ; +6 (offset to next var name)
000DC2r 2  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
000DC4r 2               
000DC4r 2  E8                 INX                     ; else increment high byte
000DC5r 2  80 DC              BRA   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
000DC7r 2               
000DC7r 2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
000DC7r 2               
000DC7r 2               LAB_CASC
000DC7r 2  C9 61              CMP   #'a'              ; compare with "a"
000DC9r 2  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
000DCBr 2               
000DCBr 2               ; check byte, return C=0 if<"A" or >"Z"
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000DCBr 2               
000DCBr 2               LAB_1D82
000DCBr 2  C9 41              CMP   #'A'              ; compare with "A"
000DCDr 2  90 05              BCC   LAB_1D8A          ; exit if less
000DCFr 2               
000DCFr 2                                             ; carry is set
000DCFr 2  E9 5B              SBC   #$5B              ; subtract "Z"+1
000DD1r 2  38                 SEC                     ; set carry
000DD2r 2  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
000DD4r 2                                             ; carry clear if byte>$5A
000DD4r 2               LAB_1D8A
000DD4r 2  60                 RTS
000DD5r 2               
000DD5r 2               LAB_1D83
000DD5r 2  E9 7B              SBC   #$7B              ; subtract "z"+1
000DD7r 2  38                 SEC                     ; set carry
000DD8r 2  E9 85              SBC   #$85              ; subtract $85 (restore byte)
000DDAr 2                                             ; carry clear if byte>$7A
000DDAr 2  60                 RTS
000DDBr 2               
000DDBr 2                                             ; reached end of variable mem without match
000DDBr 2                                             ; .. so create new variable
000DDBr 2               LAB_1D8B
000DDBr 2  68                 PLA                     ; pop return address low byte
000DDCr 2  48                 PHA                     ; push return address low byte
000DDDr 2               LAB_1C18p2  = LAB_1C18+2
000DDDr 2  C9 rr              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
000DDFr 2  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
000DE1r 2               
000DE1r 2               ; This will only drop through if the call was from LAB_1C18 and is only called
000DE1r 2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
000DE1r 2               ; it prevents the creation of variables not assigned a value.
000DE1r 2               
000DE1r 2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
000DE1r 2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
000DE1r 2               
000DE1r 2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
000DE1r 2               
000DE1r 2               ; this is where you would put the undefined variable error call e.g.
000DE1r 2               
000DE1r 2               ;                             ; variable doesn't exist so flag error
000DE1r 2               ;     LDX   #$24              ; error code $24 ("undefined variable" error)
000DE1r 2               ;     JMP   LAB_XERR          ; do error #X then warm start
000DE1r 2               
000DE1r 2               ; the above code has been tested and works a treat! (it replaces the three code lines
000DE1r 2               ; below)
000DE1r 2               
000DE1r 2                                             ; else return dummy null value
000DE1r 2  A9 rr              LDA   #<LAB_1D96        ; low byte point to $00,$00
000DE3r 2                                             ; (uses part of misc constants table)
000DE3r 2  A0 rr              LDY   #>LAB_1D96        ; high byte point to $00,$00
000DE5r 2  60                 RTS
000DE6r 2               
000DE6r 2                                             ; create new numeric variable
000DE6r 2               LAB_1D98
000DE6r 2  A5 2F              LDA   Sarryl            ; get var mem end low byte
000DE8r 2  A4 30              LDY   Sarryh            ; get var mem end high byte
000DEAr 2  85 5C              STA   Ostrtl            ; save old block start low byte
000DECr 2  84 5D              STY   Ostrth            ; save old block start high byte
000DEEr 2  A5 31              LDA   Earryl            ; get array mem end low byte
000DF0r 2  A4 32              LDY   Earryh            ; get array mem end high byte
000DF2r 2  85 58              STA   Obendl            ; save old block end low byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000DF4r 2  84 59              STY   Obendh            ; save old block end high byte
000DF6r 2  18                 CLC                     ; clear carry for add
000DF7r 2  69 06              ADC   #$06              ; +6 (space for one var)
000DF9r 2  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
000DFBr 2               
000DFBr 2  C8                 INY                     ; else increment high byte
000DFCr 2               LAB_1DAE
000DFCr 2  85 56              STA   Nbendl            ; set new block end low byte
000DFEr 2  84 57              STY   Nbendh            ; set new block end high byte
000E00r 2  20 rr rr           JSR   LAB_11CF          ; open up space in memory
000E03r 2  A5 56              LDA   Nbendl            ; get new start low byte
000E05r 2  A4 57              LDY   Nbendh            ; get new start high byte (-$100)
000E07r 2  C8                 INY                     ; correct high byte
000E08r 2  85 2F              STA   Sarryl            ; save new var mem end low byte
000E0Ar 2  84 30              STY   Sarryh            ; save new var mem end high byte
000E0Cr 2  A0 00              LDY   #$00              ; clear index
000E0Er 2  A5 45              LDA   Varnm1            ; get var name 1st character
000E10r 2  91 5C              STA   (Vrschl),Y        ; save var name 1st character
000E12r 2  C8                 INY                     ; increment index
000E13r 2  A5 46              LDA   Varnm2            ; get var name 2nd character
000E15r 2  91 5C              STA   (Vrschl),Y        ; save var name 2nd character
000E17r 2  A9 00              LDA   #$00              ; clear A
000E19r 2  C8                 INY                     ; increment index
000E1Ar 2  91 5C              STA   (Vrschl),Y        ; initialise var byte
000E1Cr 2  C8                 INY                     ; increment index
000E1Dr 2  91 5C              STA   (Vrschl),Y        ; initialise var byte
000E1Fr 2  C8                 INY                     ; increment index
000E20r 2  91 5C              STA   (Vrschl),Y        ; initialise var byte
000E22r 2  C8                 INY                     ; increment index
000E23r 2  91 5C              STA   (Vrschl),Y        ; initialise var byte
000E25r 2               
000E25r 2                                             ; found a match for var ((Vrschl) = ptr)
000E25r 2               LAB_1DD7
000E25r 2  A5 5C              LDA   Vrschl            ; get var address low byte
000E27r 2  18                 CLC                     ; clear carry for add
000E28r 2  69 02              ADC   #$02              ; +2 (offset past var name bytes)
000E2Ar 2  A4 5D              LDY   Vrschh            ; get var address high byte
000E2Cr 2  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
000E2Er 2               
000E2Er 2  C8                 INY                     ; else increment high byte
000E2Fr 2               LAB_1DE1
000E2Fr 2  85 47              STA   Cvaral            ; save current var address low byte
000E31r 2  84 48              STY   Cvarah            ; save current var address high byte
000E33r 2  60                 RTS
000E34r 2               
000E34r 2               ; set-up array pointer (Adatal/h) to first element in array
000E34r 2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
000E34r 2               
000E34r 2               LAB_1DE6
000E34r 2  A5 0F              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
000E36r 2  0A                 ASL                     ; *2 (also clears the carry !)
000E37r 2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
000E39r 2  65 5C              ADC   Astrtl            ; add array start pointer low byte
000E3Br 2  A4 5D              LDY   Astrth            ; get array pointer high byte
000E3Dr 2  90 01              BCC   LAB_1DF2          ; branch if no overflow
000E3Fr 2               
000E3Fr 2  C8                 INY                     ; else increment high byte
000E40r 2               LAB_1DF2
000E40r 2  85 56              STA   Adatal            ; save array data pointer low byte
000E42r 2  84 57              STY   Adatah            ; save array data pointer high byte
000E44r 2  60                 RTS
000E45r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000E45r 2               ; evaluate integer expression
000E45r 2               
000E45r 2               LAB_EVIN
000E45r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
000E48r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
000E4Br 2                                             ; else do type mismatch
000E4Br 2               
000E4Br 2               ; evaluate integer expression (no check)
000E4Br 2               
000E4Br 2               LAB_EVPI
000E4Br 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
000E4Dr 2  30 0D              BMI   LAB_1E12          ; do function call error if -ve
000E4Fr 2               
000E4Fr 2               ; evaluate integer expression (no sign check)
000E4Fr 2               
000E4Fr 2               LAB_EVIR
000E4Fr 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
000E51r 2  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
000E53r 2  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
000E55r 2               
000E55r 2  A9 rr              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
000E57r 2  A0 rr              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
000E59r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
000E5Cr 2               LAB_1E12
000E5Cr 2  D0 73              BNE   LAB_FCER          ; if <> do function call error then warm start
000E5Er 2               
000E5Er 2               LAB_1E14
000E5Er 2  4C rr rr           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
000E61r 2               
000E61r 2               ; find or make array
000E61r 2               
000E61r 2               LAB_1E17
000E61r 2  A5 10              LDA   Defdim            ; get DIM flag
000E63r 2  48                 PHA                     ; push it
000E64r 2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
000E66r 2  48                 PHA                     ; push it
000E67r 2  A0 00              LDY   #$00              ; clear dimensions count
000E69r 2               
000E69r 2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
000E69r 2               
000E69r 2               LAB_1E1F
000E69r 2  5A                 PHY                     ; save dimensions count
000E6Ar 2  A5 46              LDA   Varnm2            ; get array name 2nd byte
000E6Cr 2  48                 PHA                     ; save it
000E6Dr 2  A5 45              LDA   Varnm1            ; get array name 1st byte
000E6Fr 2  48                 PHA                     ; save it
000E70r 2  20 rr rr           JSR   LAB_EVIN          ; evaluate integer expression
000E73r 2  68                 PLA                     ; pull array name 1st byte
000E74r 2  85 45              STA   Varnm1            ; restore array name 1st byte
000E76r 2  68                 PLA                     ; pull array name 2nd byte
000E77r 2  85 46              STA   Varnm2            ; restore array name 2nd byte
000E79r 2  7A                 PLY                     ; restore dimensions count
000E7Ar 2  BA                 TSX                     ; copy stack pointer
000E7Br 2  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
000E7Er 2  48                 PHA                     ; push it
000E7Fr 2  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
000E82r 2  48                 PHA                     ; push it
000E83r 2  A5 60              LDA   FAC1_2            ; get this dimension size high byte
000E85r 2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
000E88r 2  A5 61              LDA   FAC1_3            ; get this dimension size low byte
000E8Ar 2  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
000E8Dr 2  C8                 INY                     ; increment dimensions count
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000E8Er 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
000E91r 2  C9 2C              CMP   #','              ; compare with ","
000E93r 2  F0 D4              BEQ   LAB_1E1F          ; if found go do next dimension
000E95r 2               
000E95r 2  84 0F              STY   Dimcnt            ; store dimensions count
000E97r 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
000E9Ar 2  68                 PLA                     ; pull data type flag
000E9Br 2  85 11              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
000E9Dr 2  68                 PLA                     ; pull DIM flag
000E9Er 2  85 10              STA   Defdim            ; restore DIM flag
000EA0r 2  A6 2F              LDX   Sarryl            ; get array mem start low byte
000EA2r 2  A5 30              LDA   Sarryh            ; get array mem start high byte
000EA4r 2               
000EA4r 2               ; now check to see if we are at the end of array memory (we would be if there were
000EA4r 2               ; no arrays).
000EA4r 2               
000EA4r 2               LAB_1E5C
000EA4r 2  86 5C              STX   Astrtl            ; save as array start pointer low byte
000EA6r 2  85 5D              STA   Astrth            ; save as array start pointer high byte
000EA8r 2  C5 32              CMP   Earryh            ; compare with array mem end high byte
000EAAr 2  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
000EACr 2               
000EACr 2  E4 31              CPX   Earryl            ; else compare with array mem end low byte
000EAEr 2  F0 3A              BEQ   LAB_1EA1          ; go build array if not found
000EB0r 2               
000EB0r 2                                             ; search for array
000EB0r 2               LAB_1E68
000EB0r 2  A0 00              LDY   #$00              ; clear index
000EB2r 2  B1 5C              LDA   (Astrtl),Y        ; get array name first byte
000EB4r 2  C8                 INY                     ; increment index to second name byte
000EB5r 2  C5 45              CMP   Varnm1            ; compare with this array name first byte
000EB7r 2  D0 06              BNE   LAB_1E77          ; branch if no match
000EB9r 2               
000EB9r 2  A5 46              LDA   Varnm2            ; else get this array name second byte
000EBBr 2  D1 5C              CMP   (Astrtl),Y        ; compare with array name second byte
000EBDr 2  F0 17              BEQ   LAB_1E8D          ; array found so branch
000EBFr 2               
000EBFr 2                                             ; no match
000EBFr 2               LAB_1E77
000EBFr 2  C8                 INY                     ; increment index
000EC0r 2  B1 5C              LDA   (Astrtl),Y        ; get array size low byte
000EC2r 2  18                 CLC                     ; clear carry for add
000EC3r 2  65 5C              ADC   Astrtl            ; add array start pointer low byte
000EC5r 2  AA                 TAX                     ; copy low byte to X
000EC6r 2  C8                 INY                     ; increment index
000EC7r 2  B1 5C              LDA   (Astrtl),Y        ; get array size high byte
000EC9r 2  65 5D              ADC   Astrth            ; add array mem pointer high byte
000ECBr 2  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
000ECDr 2               
000ECDr 2               ; do array bounds error
000ECDr 2               
000ECDr 2               LAB_1E85
000ECDr 2  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
000ECFr 2  80 02              BRA   LAB_1E8A          ; branch around next instruction, saves on clock cycle
000ED1r 2               
000ED1r 2               ; do function call error
000ED1r 2               
000ED1r 2               LAB_FCER
000ED1r 2  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
000ED3r 2               LAB_1E8A
000ED3r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000ED6r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000ED6r 2                                             ; found array, are we trying to dimension it?
000ED6r 2               LAB_1E8D
000ED6r 2  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
000ED8r 2  A5 10              LDA   Defdim            ; get DIM flag
000EDAr 2  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
000EDCr 2                                             ; start
000EDCr 2               
000EDCr 2               ; found the array and we're not dimensioning it so we must find an element in it
000EDCr 2               
000EDCr 2  20 rr rr           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
000EDFr 2                                             ; (Astrtl,Astrth points to start of array)
000EDFr 2  A5 0F              LDA   Dimcnt            ; get dimensions count
000EE1r 2  A0 04              LDY   #$04              ; set index to array's # of dimensions
000EE3r 2  D1 5C              CMP   (Astrtl),Y        ; compare with no of dimensions
000EE5r 2  D0 E6              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
000EE7r 2                                             ; dimensions" error here .. if we want a different
000EE7r 2                                             ; error message
000EE7r 2               
000EE7r 2  4C rr rr           JMP   LAB_1F28          ; found array so go get element
000EEAr 2                                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
000EEAr 2                                             ; Dimcnt and save it at (Astrtl),Y which is already the
000EEAr 2                                             ; same or we would have taken the BNE)
000EEAr 2               
000EEAr 2                                             ; array not found, so build it
000EEAr 2               LAB_1EA1
000EEAr 2  20 rr rr           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
000EEDr 2                                             ; (Astrtl,Astrth points to start of array)
000EEDr 2  20 rr rr           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
000EF0r 2                                             ; addr to check is in AY (low/high)
000EF0r 2  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
000EF2r 2  84 6D              STY   Aspth             ; clear array data size high byte
000EF4r 2  A5 45              LDA   Varnm1            ; get variable name 1st byte
000EF6r 2  91 5C              STA   (Astrtl),Y        ; save array name 1st byte
000EF8r 2  C8                 INY                     ; increment index
000EF9r 2  A5 46              LDA   Varnm2            ; get variable name 2nd byte
000EFBr 2  91 5C              STA   (Astrtl),Y        ; save array name 2nd byte
000EFDr 2  A5 0F              LDA   Dimcnt            ; get dimensions count
000EFFr 2  A0 04              LDY   #$04              ; index to dimension count
000F01r 2  84 6C              STY   Asptl             ; set array data size low byte (four bytes per element)
000F03r 2  91 5C              STA   (Astrtl),Y        ; set array's dimensions count
000F05r 2               
000F05r 2                                             ; now calculate the size of the data space for the array
000F05r 2  18                 CLC                     ; clear carry for add (clear on subsequent loops)
000F06r 2               LAB_1EC0
000F06r 2  A2 0B              LDX   #$0B              ; set default dimension value low byte
000F08r 2  A9 00              LDA   #$00              ; set default dimension value high byte
000F0Ar 2  24 10              BIT   Defdim            ; test default DIM flag
000F0Cr 2  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
000F0Er 2               
000F0Er 2  68                 PLA                     ; else pull dimension value low byte
000F0Fr 2  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
000F11r 2  AA                 TAX                     ; copy low byte to X
000F12r 2  68                 PLA                     ; pull dimension value high byte
000F13r 2  69 00              ADC   #$00              ; add carry from low byte
000F15r 2               
000F15r 2               LAB_1ED0
000F15r 2  C8                 INY                     ; index to dimension value high byte
000F16r 2  91 5C              STA   (Astrtl),Y        ; save dimension value high byte
000F18r 2  C8                 INY                     ; index to dimension value high byte
000F19r 2  8A                 TXA                     ; get dimension value low byte
000F1Ar 2  91 5C              STA   (Astrtl),Y        ; save dimension value low byte
000F1Cr 2  20 rr rr           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000F1Fr 2  86 6C              STX   Asptl             ; save array data size low byte
000F21r 2  85 6D              STA   Aspth             ; save array data size high byte
000F23r 2  A4 23              LDY   ut1_pl            ; restore index (saved by subroutine)
000F25r 2  C6 0F              DEC   Dimcnt            ; decrement dimensions count
000F27r 2  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
000F29r 2               
000F29r 2  65 57              ADC   Adatah            ; add size high byte to first element high byte
000F2Br 2                                             ; (carry is always clear here)
000F2Br 2  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
000F2Dr 2               
000F2Dr 2  85 57              STA   Adatah            ; save end of array high byte
000F2Fr 2  A8                 TAY                     ; copy end high byte to Y
000F30r 2  8A                 TXA                     ; get array size low byte
000F31r 2  65 56              ADC   Adatal            ; add array start low byte
000F33r 2  90 03              BCC   LAB_1EF3          ; branch if no carry
000F35r 2               
000F35r 2  C8                 INY                     ; else increment end of array high byte
000F36r 2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
000F38r 2               
000F38r 2                                             ; set-up mostly complete, now zero the array
000F38r 2               LAB_1EF3
000F38r 2  20 rr rr           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
000F3Br 2                                             ; addr to check is in AY (low/high)
000F3Br 2  85 31              STA   Earryl            ; save array mem end low byte
000F3Dr 2  84 32              STY   Earryh            ; save array mem end high byte
000F3Fr 2  A9 00              LDA   #$00              ; clear byte for array clear
000F41r 2  E6 6D              INC   Aspth             ; increment array size high byte (now block count)
000F43r 2  A4 6C              LDY   Asptl             ; get array size low byte (now index to block)
000F45r 2  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
000F47r 2               
000F47r 2               LAB_1F02
000F47r 2  88                 DEY                     ; decrement index (do 0 to n-1)
000F48r 2  91 56              STA   (Adatal),Y        ; zero byte
000F4Ar 2  D0 FB              BNE   LAB_1F02          ; loop until this block done
000F4Cr 2               
000F4Cr 2               LAB_1F07
000F4Cr 2  C6 57              DEC   Adatah            ; decrement array pointer high byte
000F4Er 2  C6 6D              DEC   Aspth             ; decrement block count high byte
000F50r 2  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
000F52r 2               
000F52r 2  E6 57              INC   Adatah            ; correct for last loop
000F54r 2  38                 SEC                     ; set carry for subtract
000F55r 2  A0 02              LDY   #$02              ; index to array size low byte
000F57r 2  A5 31              LDA   Earryl            ; get array mem end low byte
000F59r 2  E5 5C              SBC   Astrtl            ; subtract array start low byte
000F5Br 2  91 5C              STA   (Astrtl),Y        ; save array size low byte
000F5Dr 2  C8                 INY                     ; index to array size high byte
000F5Er 2  A5 32              LDA   Earryh            ; get array mem end high byte
000F60r 2  E5 5D              SBC   Astrth            ; subtract array start high byte
000F62r 2  91 5C              STA   (Astrtl),Y        ; save array size high byte
000F64r 2  A5 10              LDA   Defdim            ; get default DIM flag
000F66r 2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
000F68r 2               
000F68r 2                                             ; else, find element
000F68r 2  C8                 INY                     ; index to # of dimensions
000F69r 2               
000F69r 2               LAB_1F24
000F69r 2  B1 5C              LDA   (Astrtl),Y        ; get array's dimension count
000F6Br 2  85 0F              STA   Dimcnt            ; save it
000F6Dr 2               
000F6Dr 2               ; we have found, or built, the array. now we need to find the element
000F6Dr 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000F6Dr 2               LAB_1F28
000F6Dr 2  A9 00              LDA   #$00              ; clear byte
000F6Fr 2  85 6C              STA   Asptl             ; clear array data pointer low byte
000F71r 2               LAB_1F2C
000F71r 2  85 6D              STA   Aspth             ; save array data pointer high byte
000F73r 2  C8                 INY                     ; increment index (point to array bound high byte)
000F74r 2  68                 PLA                     ; pull array index low byte
000F75r 2  AA                 TAX                     ; copy to X
000F76r 2  85 60              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
000F78r 2  68                 PLA                     ; pull array index high byte
000F79r 2  85 61              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
000F7Br 2  D1 5C              CMP   (Astrtl),Y        ; compare with array bound high byte
000F7Dr 2  90 0E              BCC   LAB_1F48          ; branch if within bounds
000F7Fr 2  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
000F81r 2               
000F81r 2                                             ; else high byte was = so test low bytes
000F81r 2  C8                 INY                     ; index to array bound low byte
000F82r 2  8A                 TXA                     ; get array index low byte
000F83r 2  D1 5C              CMP   (Astrtl),Y        ; compare with array bound low byte
000F85r 2  90 07              BCC   LAB_1F49          ; branch if within bounds
000F87r 2               
000F87r 2               LAB_1F42
000F87r 2  4C rr rr           JMP   LAB_1E85          ; else do array bounds error
000F8Ar 2               
000F8Ar 2               LAB_1F45
000F8Ar 2  4C rr rr           JMP   LAB_OMER          ; do "Out of memory" error then warm start
000F8Dr 2               
000F8Dr 2               LAB_1F48
000F8Dr 2  C8                 INY                     ; index to array bound low byte
000F8Er 2               LAB_1F49
000F8Er 2  A5 6D              LDA   Aspth             ; get array data pointer high byte
000F90r 2  05 6C              ORA   Asptl             ; OR with array data pointer low byte
000F92r 2  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
000F94r 2               
000F94r 2  20 rr rr           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
000F97r 2  8A                 TXA                     ; get result low byte
000F98r 2  65 60              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
000F9Ar 2  AA                 TAX                     ; save result low byte
000F9Br 2  98                 TYA                     ; get result high byte
000F9Cr 2  A4 23              LDY   ut1_pl            ; restore index
000F9Er 2               LAB_1F5A
000F9Er 2  65 61              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
000FA0r 2  86 6C              STX   Asptl             ; save array data pointer low byte
000FA2r 2  C6 0F              DEC   Dimcnt            ; decrement dimensions count
000FA4r 2  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
000FA6r 2               
000FA6r 2  06 6C              ASL   Asptl             ; array data pointer low byte * 2
000FA8r 2  2A                 ROL                     ; array data pointer high byte * 2
000FA9r 2  06 6C              ASL   Asptl             ; array data pointer low byte * 4
000FABr 2  2A                 ROL                     ; array data pointer high byte * 4
000FACr 2  A8                 TAY                     ; copy high byte
000FADr 2  A5 6C              LDA   Asptl             ; get low byte
000FAFr 2  65 56              ADC   Adatal            ; add array data start pointer low byte
000FB1r 2  85 47              STA   Cvaral            ; save as current var address low byte
000FB3r 2  98                 TYA                     ; get high byte back
000FB4r 2  65 57              ADC   Adatah            ; add array data start pointer high byte
000FB6r 2  85 48              STA   Cvarah            ; save as current var address high byte
000FB8r 2  A8                 TAY                     ; copy high byte to Y
000FB9r 2  A5 47              LDA   Cvaral            ; get current var address low byte
000FBBr 2               LAB_1F7B
000FBBr 2  60                 RTS
000FBCr 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

000FBCr 2               ; does XY = (Astrtl),Y * (Asptl)
000FBCr 2               
000FBCr 2               LAB_1F7C
000FBCr 2  84 23              STY   ut1_pl            ; save index
000FBEr 2  B1 5C              LDA   (Astrtl),Y        ; get dimension size low byte
000FC0r 2  85 28              STA   dims_l            ; save dimension size low byte
000FC2r 2  88                 DEY                     ; decrement index
000FC3r 2  B1 5C              LDA   (Astrtl),Y        ; get dimension size high byte
000FC5r 2  85 29              STA   dims_h            ; save dimension size high byte
000FC7r 2               
000FC7r 2  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
000FC9r 2  85 5A              STA   numbit            ; save bit count
000FCBr 2  A2 00              LDX   #$00              ; clear result low byte
000FCDr 2  A0 00              LDY   #$00              ; clear result high byte
000FCFr 2               LAB_1F8F
000FCFr 2  8A                 TXA                     ; get result low byte
000FD0r 2  0A                 ASL                     ; *2
000FD1r 2  AA                 TAX                     ; save result low byte
000FD2r 2  98                 TYA                     ; get result high byte
000FD3r 2  2A                 ROL                     ; *2
000FD4r 2  A8                 TAY                     ; save result high byte
000FD5r 2  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
000FD7r 2               
000FD7r 2  06 6C              ASL   Asptl             ; shift multiplier low byte
000FD9r 2  26 6D              ROL   Aspth             ; shift multiplier high byte
000FDBr 2  90 0B              BCC   LAB_1FA8          ; skip add if no carry
000FDDr 2               
000FDDr 2  18                 CLC                     ; else clear carry for add
000FDEr 2  8A                 TXA                     ; get result low byte
000FDFr 2  65 28              ADC   dims_l            ; add dimension size low byte
000FE1r 2  AA                 TAX                     ; save result low byte
000FE2r 2  98                 TYA                     ; get result high byte
000FE3r 2  65 29              ADC   dims_h            ; add dimension size high byte
000FE5r 2  A8                 TAY                     ; save result high byte
000FE6r 2  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
000FE8r 2               
000FE8r 2               LAB_1FA8
000FE8r 2  C6 5A              DEC   numbit            ; decrement bit count
000FEAr 2  D0 E3              BNE   LAB_1F8F          ; loop until all done
000FECr 2  60                 RTS
000FEDr 2               
000FEDr 2               ; perform FRE()
000FEDr 2               
000FEDr 2               LAB_FRE
000FEDr 2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
000FEFr 2  10 03              BPL   LAB_1FB4          ; branch if numeric
000FF1r 2               
000FF1r 2  20 rr rr           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
000FF4r 2                                             ; space returns with A = length, X=$71=pointer low byte,
000FF4r 2                                             ; Y=$72=pointer high byte
000FF4r 2               
000FF4r 2                                             ; FRE(n) was numeric so do this
000FF4r 2               LAB_1FB4
000FF4r 2  20 rr rr           JSR   LAB_GARB          ; go do garbage collection
000FF7r 2  38                 SEC                     ; set carry for subtract
000FF8r 2  A5 33              LDA   Sstorl            ; get bottom of string space low byte
000FFAr 2  E5 31              SBC   Earryl            ; subtract array mem end low byte
000FFCr 2  A8                 TAY                     ; copy result to Y
000FFDr 2  A5 34              LDA   Sstorh            ; get bottom of string space high byte
000FFFr 2  E5 32              SBC   Earryh            ; subtract array mem end high byte
001001r 2               
001001r 2               ; save and convert integer AY to FAC1
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001001r 2               
001001r 2               LAB_AYFC
001001r 2  46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
001003r 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
001005r 2  84 60              STY   FAC1_2            ; save FAC1 mantissa2
001007r 2  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
001009r 2  4C rr rr           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
00100Cr 2               
00100Cr 2               ; perform POS()
00100Cr 2               
00100Cr 2               LAB_POS
00100Cr 2  A4 07              LDY   TPos              ; get terminal position
00100Er 2               
00100Er 2               ; convert Y to byte in FAC1
00100Er 2               
00100Er 2               LAB_1FD0
00100Er 2  A9 00              LDA   #$00              ; clear high byte
001010r 2  80 EF              BRA   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
001012r 2               
001012r 2               ; check not Direct (used by DEF and INPUT)
001012r 2               
001012r 2               LAB_CKRN
001012r 2  A6 3A              LDX   Clineh            ; get current line high byte
001014r 2  E8                 INX                     ; increment it
001015r 2  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
001017r 2               
001017r 2                                             ; else do illegal direct error
001017r 2               LAB_1FD9
001017r 2  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
001019r 2               LAB_1FDB
001019r 2  4C rr rr           JMP   LAB_XERR          ; go do error #X, then warm start
00101Cr 2               
00101Cr 2               ; perform DEF
00101Cr 2               
00101Cr 2               LAB_DEF
00101Cr 2  20 rr rr           JSR   LAB_200B          ; check FNx syntax
00101Fr 2  85 4E              STA   func_l            ; save function pointer low byte
001021r 2  84 4F              STY   func_h            ; save function pointer high byte
001023r 2  20 rr rr           JSR   LAB_CKRN          ; check not Direct (back here if ok)
001026r 2  20 rr rr           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
001029r 2  F7 13              SMB7  Sufnxf            ; set subscript/FNx flag
00102Br 2               ;      LDA   #$80              ; set flag for FNx
00102Br 2               ;      STA   Sufnxf            ; save subscript/FNx flag
00102Br 2  20 rr rr           JSR   LAB_GVAR          ; get (var) address
00102Er 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
001031r 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
001034r 2  A9 BD              LDA   #TK_EQUAL         ; get = token
001036r 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
001039r 2  A5 48              LDA   Cvarah            ; get current var address high byte
00103Br 2  48                 PHA                     ; push it
00103Cr 2  A5 47              LDA   Cvaral            ; get current var address low byte
00103Er 2  48                 PHA                     ; push it
00103Fr 2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
001041r 2  48                 PHA                     ; push it
001042r 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
001044r 2  48                 PHA                     ; push it
001045r 2  20 rr rr           JSR   LAB_DATA          ; go perform DATA
001048r 2  80 6E              BRA   LAB_207A          ; put execute pointer and variable pointer into function
00104Ar 2                                             ; and return
00104Ar 2               
00104Ar 2               ; check FNx syntax
00104Ar 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00104Ar 2               LAB_200B
00104Ar 2  A9 AB              LDA   #TK_FN            ; get FN" token
00104Cr 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00104Fr 2                                             ; return character after A
00104Fr 2  09 80              ORA   #$80              ; set FN flag bit
001051r 2  85 13              STA   Sufnxf            ; save FN flag so array variable test fails
001053r 2  20 rr rr           JSR   LAB_1D12          ; search for FN variable
001056r 2  4C rr rr           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
001059r 2                                             ; mismatch
001059r 2               
001059r 2                                             ; Evaluate FNx
001059r 2               LAB_201E
001059r 2  20 rr rr           JSR   LAB_200B          ; check FNx syntax
00105Cr 2  48                 PHA                     ; push function pointer low byte
00105Dr 2  5A                 PHY                     ; push function pointer high byte
00105Er 2  20 rr rr           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
001061r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
001064r 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
001067r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00106Ar 2  68                 PLA                     ; pop function pointer high byte
00106Br 2  85 4F              STA   func_h            ; restore it
00106Dr 2  68                 PLA                     ; pop function pointer low byte
00106Er 2  85 4E              STA   func_l            ; restore it
001070r 2  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
001072r 2  A0 03              LDY   #$03              ; index to variable pointer high byte
001074r 2  B1 4E              LDA   (func_l),Y        ; get variable pointer high byte
001076r 2  F0 A1              BEQ   LAB_1FDB          ; if zero go do undefined function error
001078r 2               
001078r 2  85 48              STA   Cvarah            ; save variable address high byte
00107Ar 2  88                 DEY                     ; index to variable address low byte
00107Br 2  B1 4E              LDA   (func_l),Y        ; get variable address low byte
00107Dr 2  85 47              STA   Cvaral            ; save variable address low byte
00107Fr 2  AA                 TAX                     ; copy address low byte
001080r 2               
001080r 2                                             ; now stack the function variable value before use
001080r 2  C8                 INY                     ; index to mantissa_3
001081r 2               LAB_2043
001081r 2  B1 47              LDA   (Cvaral),Y        ; get byte from variable
001083r 2  48                 PHA                     ; stack it
001084r 2  88                 DEY                     ; decrement index
001085r 2  10 FA              BPL   LAB_2043          ; loop until variable stacked
001087r 2               
001087r 2  A4 48              LDY   Cvarah            ; get variable address high byte
001089r 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
00108Cr 2                                             ; (function variable), return Y=0, always
00108Cr 2  A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
00108Er 2  48                 PHA                     ; push it
00108Fr 2  A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
001091r 2  48                 PHA                     ; push it
001092r 2  B1 4E              LDA   (func_l),Y        ; get function execute pointer low byte
001094r 2  85 6E              STA   Bpntrl            ; save as BASIC execute pointer low byte
001096r 2  C8                 INY                     ; index to high byte
001097r 2  B1 4E              LDA   (func_l),Y        ; get function execute pointer high byte
001099r 2  85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
00109Br 2  A5 48              LDA   Cvarah            ; get variable address high byte
00109Dr 2  48                 PHA                     ; push it
00109Er 2  A5 47              LDA   Cvaral            ; get variable address low byte
0010A0r 2  48                 PHA                     ; push it
0010A1r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0010A4r 2                                             ; else do type mismatch
0010A4r 2  68                 PLA                     ; pull variable address low byte
0010A5r 2  85 4E              STA   func_l            ; save variable address low byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0010A7r 2  68                 PLA                     ; pull variable address high byte
0010A8r 2  85 4F              STA   func_h            ; save variable address high byte
0010AAr 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
0010ADr 2  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
0010AFr 2  4C rr rr           JMP   LAB_SNER          ; else syntax error then warm start
0010B2r 2               
0010B2r 2               ; restore Bpntrl,Bpntrh and function variable from stack
0010B2r 2               
0010B2r 2               LAB_2074
0010B2r 2  68                 PLA                     ; pull BASIC execute pointer low byte
0010B3r 2  85 6E              STA   Bpntrl            ; restore BASIC execute pointer low byte
0010B5r 2  68                 PLA                     ; pull BASIC execute pointer high byte
0010B6r 2  85 6F              STA   Bpntrh            ; restore BASIC execute pointer high byte
0010B8r 2               
0010B8r 2               ; put execute pointer and variable pointer into function
0010B8r 2               
0010B8r 2               LAB_207A
0010B8r 2  A0 00              LDY   #$00              ; clear index
0010BAr 2  68                 PLA                     ; pull BASIC execute pointer low byte
0010BBr 2  91 4E              STA   (func_l),Y        ; save to function
0010BDr 2  C8                 INY                     ; increment index
0010BEr 2  68                 PLA                     ; pull BASIC execute pointer high byte
0010BFr 2  91 4E              STA   (func_l),Y        ; save to function
0010C1r 2  C8                 INY                     ; increment index
0010C2r 2  68                 PLA                     ; pull current var address low byte
0010C3r 2  91 4E              STA   (func_l),Y        ; save to function
0010C5r 2  C8                 INY                     ; increment index
0010C6r 2  68                 PLA                     ; pull current var address high byte
0010C7r 2  91 4E              STA   (func_l),Y        ; save to function
0010C9r 2  60                 RTS
0010CAr 2               
0010CAr 2               ; perform STR$()
0010CAr 2               
0010CAr 2               LAB_STRS
0010CAr 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
0010CDr 2  20 rr rr           JSR   LAB_296E          ; convert FAC1 to string
0010D0r 2  A9 75              LDA   #<Decssp1         ; set result string low pointer
0010D2r 2  A0 00              LDY   #>Decssp1         ; set result string high pointer
0010D4r 2  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
0010D6r 2               
0010D6r 2               ; Do string vector
0010D6r 2               ; copy des_pl/h to des_2l/h and make string space A bytes long
0010D6r 2               
0010D6r 2               LAB_209C
0010D6r 2  A6 60              LDX   des_pl            ; get descriptor pointer low byte
0010D8r 2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
0010DAr 2  86 50              STX   des_2l            ; save descriptor pointer low byte
0010DCr 2  84 51              STY   des_2h            ; save descriptor pointer high byte
0010DEr 2               
0010DEr 2               ; make string space A bytes long
0010DEr 2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0010DEr 2               
0010DEr 2               LAB_MSSP
0010DEr 2  20 rr rr           JSR   LAB_2115          ; make space in string memory for string A long
0010E1r 2                                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0010E1r 2  86 5F              STX   str_pl            ; save string pointer low byte
0010E3r 2  84 60              STY   str_ph            ; save string pointer high byte
0010E5r 2  85 5E              STA   str_ln            ; save length
0010E7r 2  60                 RTS
0010E8r 2               
0010E8r 2               ; Scan, set up string
0010E8r 2               ; print " terminated string to Sutill/Sutilh
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0010E8r 2               
0010E8r 2               LAB_20AE
0010E8r 2  A2 22              LDX   #$22              ; set terminator to "
0010EAr 2  86 0D              STX   Srchc             ; set search character (terminator 1)
0010ECr 2  86 0E              STX   Asrch             ; set terminator 2
0010EEr 2               
0010EEr 2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
0010EEr 2               ; source is AY
0010EEr 2               
0010EEr 2               LAB_20B4
0010EEr 2  85 6A              STA   ssptr_l           ; store string start low byte
0010F0r 2  84 6B              STY   ssptr_h           ; store string start high byte
0010F2r 2  85 5F              STA   str_pl            ; save string pointer low byte
0010F4r 2  84 60              STY   str_ph            ; save string pointer high byte
0010F6r 2  A0 FF              LDY   #$FF              ; set length to -1
0010F8r 2               LAB_20BE
0010F8r 2  C8                 INY                     ; increment length
0010F9r 2  B1 6A              LDA   (ssptr_l),Y       ; get byte from string
0010FBr 2  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
0010FDr 2               
0010FDr 2  C5 0D              CMP   Srchc             ; compare with search character (terminator 1)
0010FFr 2  F0 04              BEQ   LAB_20CB          ; branch if terminator
001101r 2               
001101r 2  C5 0E              CMP   Asrch             ; compare with terminator 2
001103r 2  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
001105r 2               
001105r 2               LAB_20CB
001105r 2  C9 22              CMP   #$22              ; compare with "
001107r 2  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
001109r 2               
001109r 2               LAB_20CF
001109r 2  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
00110Ar 2               LAB_20D0
00110Ar 2  84 5E              STY   str_ln            ; save length in FAC1 exponent
00110Cr 2  98                 TYA                     ; copy length to A
00110Dr 2  65 6A              ADC   ssptr_l           ; add string start low byte
00110Fr 2  85 6C              STA   Sendl             ; save string end low byte
001111r 2  A6 6B              LDX   ssptr_h           ; get string start high byte
001113r 2  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
001115r 2               
001115r 2  E8                 INX                     ; else increment high byte
001116r 2               LAB_20DC
001116r 2  86 6D              STX   Sendh             ; save string end high byte
001118r 2  A5 6B              LDA   ssptr_h           ; get string start high byte
00111Ar 2  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
00111Cr 2  C9 05              CMP   #>Ibuffs          ; compare with location of input buffer page
00111Er 2  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
001120r 2               
001120r 2               LAB_MVST
001120r 2                                             ; string in utility area, move to string memory
001120r 2  98                 TYA                     ; copy length to A
001121r 2  20 rr rr           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
001124r 2                                             ; long
001124r 2  A6 6A              LDX   ssptr_l           ; get string start low byte
001126r 2  A4 6B              LDY   ssptr_h           ; get string start high byte
001128r 2  20 rr rr           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
00112Br 2               
00112Br 2               ; check for space on descriptor stack then ..
00112Br 2               ; put string address and length on descriptor stack and update stack pointers
00112Br 2               
00112Br 2               LAB_RTST
00112Br 2  A6 17              LDX   next_s            ; get string stack pointer
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00112Dr 2  E0 23              CPX   #des_sk+$09       ; compare with max+1
00112Fr 2  D0 05              BNE   LAB_20F8          ; branch if space on string stack
001131r 2               
001131r 2                                             ; else do string too complex error
001131r 2  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
001133r 2               LAB_20F5
001133r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
001136r 2               
001136r 2               ; put string address and length on descriptor stack and update stack pointers
001136r 2               
001136r 2               LAB_20F8
001136r 2  A5 5E              LDA   str_ln            ; get string length
001138r 2  95 00              STA   PLUS_0,X          ; put on string stack
00113Ar 2  A5 5F              LDA   str_pl            ; get string pointer low byte
00113Cr 2  95 01              STA   PLUS_1,X          ; put on string stack
00113Er 2  A5 60              LDA   str_ph            ; get string pointer high byte
001140r 2  95 02              STA   PLUS_2,X          ; put on string stack
001142r 2  86 60              STX   des_pl            ; save string descriptor pointer low byte
001144r 2  64 61              STZ   des_ph            ; save string descriptor pointer high byte (always $00)
001146r 2  A0 FF              LDY   #$FF              ; Y = $FF
001148r 2  84 11              STY   Dtypef            ; save data type flag, $FF=string
00114Ar 2  86 18              STX   last_sl           ; save old stack pointer (current top item)
00114Cr 2  E8                 INX                     ; update stack pointer
00114Dr 2  E8                 INX                     ; update stack pointer
00114Er 2  E8                 INX                     ; update stack pointer
00114Fr 2  86 17              STX   next_s            ; save new top item value
001151r 2  60                 RTS
001152r 2               
001152r 2               ; Build descriptor
001152r 2               ; make space in string memory for string A long
001152r 2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
001152r 2               
001152r 2               LAB_2115
001152r 2  46 12              LSR   Gclctd            ; clear garbage collected flag (b7)
001154r 2               
001154r 2                                             ; make space for string A long
001154r 2               LAB_2117
001154r 2  48                 PHA                     ; save string length
001155r 2  49 FF              EOR   #$FF              ; complement it
001157r 2  38                 SEC                     ; set carry for subtract (twos comp add)
001158r 2  65 33              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
00115Ar 2  A4 34              LDY   Sstorh            ; get bottom of string space high byte
00115Cr 2  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
00115Er 2               
00115Er 2  88                 DEY                     ; decrement bottom of string space high byte
00115Fr 2               LAB_2122
00115Fr 2  C4 32              CPY   Earryh            ; compare with array mem end high byte
001161r 2  90 11              BCC   LAB_2137          ; do out of memory error if less
001163r 2               
001163r 2  D0 04              BNE   LAB_212C          ; if not = skip next test
001165r 2               
001165r 2  C5 31              CMP   Earryl            ; compare with array mem end low byte
001167r 2  90 0B              BCC   LAB_2137          ; do out of memory error if less
001169r 2               
001169r 2               LAB_212C
001169r 2  85 33              STA   Sstorl            ; save bottom of string space low byte
00116Br 2  84 34              STY   Sstorh            ; save bottom of string space high byte
00116Dr 2  85 35              STA   Sutill            ; save string utility ptr low byte
00116Fr 2  84 36              STY   Sutilh            ; save string utility ptr high byte
001171r 2  AA                 TAX                     ; copy low byte to X
001172r 2  68                 PLA                     ; get string length back
001173r 2  60                 RTS
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001174r 2               
001174r 2               LAB_2137
001174r 2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
001176r 2  A5 12              LDA   Gclctd            ; get garbage collected flag
001178r 2  30 B9              BMI   LAB_20F5          ; if set then do error code X
00117Ar 2               
00117Ar 2  20 rr rr           JSR   LAB_GARB          ; else go do garbage collection
00117Dr 2  A9 80              LDA   #$80              ; flag for garbage collected
00117Fr 2  85 12              STA   Gclctd            ; set garbage collected flag
001181r 2  68                 PLA                     ; pull length
001182r 2  80 D0              BRA   LAB_2117          ; go try again (loop always, length should never be = $00)
001184r 2               
001184r 2               ; garbage collection routine
001184r 2               
001184r 2               LAB_GARB
001184r 2  A6 37              LDX   Ememl             ; get end of mem low byte
001186r 2  A5 38              LDA   Ememh             ; get end of mem high byte
001188r 2               
001188r 2               ; re-run routine from last ending
001188r 2               
001188r 2               LAB_214B
001188r 2  86 33              STX   Sstorl            ; set string storage low byte
00118Ar 2  85 34              STA   Sstorh            ; set string storage high byte
00118Cr 2  64 4F              STZ   garb_h            ; clear working pointer high byte (flag no strings to move)
00118Er 2                                             ; patch 2.22p5
00118Er 2  64 4E              STZ   garb_l            ; clear working pointer low byte (flag no strings to move)
001190r 2               
001190r 2  A5 31              LDA   Earryl            ; get array mem end low byte
001192r 2  A6 32              LDX   Earryh            ; get array mem end high byte
001194r 2  85 5C              STA   Histrl            ; save as highest string low byte
001196r 2  86 5D              STX   Histrh            ; save as highest string high byte
001198r 2  A9 1A              LDA   #des_sk           ; set descriptor stack pointer
00119Ar 2  85 23              STA   ut1_pl            ; save descriptor stack pointer low byte
00119Cr 2  64 24              STZ   ut1_ph            ; save descriptor stack pointer high byte ($00)
00119Er 2               LAB_2161
00119Er 2  C5 17              CMP   next_s            ; compare with descriptor stack pointer
0011A0r 2  F0 05              BEQ   LAB_216A          ; branch if =
0011A2r 2               
0011A2r 2  20 rr rr           JSR   LAB_21D7          ; go garbage collect descriptor stack
0011A5r 2  80 F7              BRA   LAB_2161          ; loop always
0011A7r 2               
0011A7r 2                                             ; done stacked strings, now do string vars
0011A7r 2               LAB_216A
0011A7r 2  06 52              ASL   g_step            ; set step size = $06
0011A9r 2  A5 2D              LDA   Svarl             ; get start of vars low byte
0011ABr 2  A6 2E              LDX   Svarh             ; get start of vars high byte
0011ADr 2  85 23              STA   ut1_pl            ; save as pointer low byte
0011AFr 2  86 24              STX   ut1_ph            ; save as pointer high byte
0011B1r 2               LAB_2176
0011B1r 2  E4 30              CPX   Sarryh            ; compare start of arrays high byte
0011B3r 2  D0 04              BNE   LAB_217E          ; branch if no high byte match
0011B5r 2               
0011B5r 2  C5 2F              CMP   Sarryl            ; else compare start of arrays low byte
0011B7r 2  F0 05              BEQ   LAB_2183          ; branch if = var mem end
0011B9r 2               
0011B9r 2               LAB_217E
0011B9r 2  20 rr rr           JSR   LAB_21D1          ; go garbage collect strings
0011BCr 2  80 F3              BRA   LAB_2176          ; loop always
0011BEr 2               
0011BEr 2                                             ; done string vars, now do string arrays
0011BEr 2               LAB_2183
0011BEr 2  85 56              STA   Nbendl            ; save start of arrays low byte as working pointer
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0011C0r 2  86 57              STX   Nbendh            ; save start of arrays high byte as working pointer
0011C2r 2  A9 04              LDA   #$04              ; set step size
0011C4r 2  85 52              STA   g_step            ; save step size
0011C6r 2               LAB_218B
0011C6r 2  A5 56              LDA   Nbendl            ; get pointer low byte
0011C8r 2  A6 57              LDX   Nbendh            ; get pointer high byte
0011CAr 2               LAB_218F
0011CAr 2  E4 32              CPX   Earryh            ; compare with array mem end high byte
0011CCr 2  D0 04              BNE   LAB_219A          ; branch if not at end
0011CEr 2               
0011CEr 2  C5 31              CMP   Earryl            ; else compare with array mem end low byte
0011D0r 2  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
0011D2r 2               
0011D2r 2               LAB_219A
0011D2r 2  85 23              STA   ut1_pl            ; save pointer low byte
0011D4r 2  86 24              STX   ut1_ph            ; save pointer high byte
0011D6r 2  A0 02              LDY   #$02              ; set index
0011D8r 2  B1 23              LDA   (ut1_pl),Y        ; get array size low byte
0011DAr 2  65 56              ADC   Nbendl            ; add start of this array low byte
0011DCr 2  85 56              STA   Nbendl            ; save start of next array low byte
0011DEr 2  C8                 INY                     ; increment index
0011DFr 2  B1 23              LDA   (ut1_pl),Y        ; get array size high byte
0011E1r 2  65 57              ADC   Nbendh            ; add start of this array high byte
0011E3r 2  85 57              STA   Nbendh            ; save start of next array high byte
0011E5r 2  A0 01              LDY   #$01              ; set index
0011E7r 2  B1 23              LDA   (ut1_pl),Y        ; get name second byte
0011E9r 2  10 DB              BPL   LAB_218B          ; skip if not string array
0011EBr 2               
0011EBr 2               ; was string array so ..
0011EBr 2               
0011EBr 2  A0 04              LDY   #$04              ; set index
0011EDr 2  B1 23              LDA   (ut1_pl),Y        ; get # of dimensions
0011EFr 2  0A                 ASL                     ; *2
0011F0r 2  69 05              ADC   #$05              ; +5 (array header size)
0011F2r 2  20 rr rr           JSR   LAB_2208          ; go set up for first element
0011F5r 2               LAB_21C4
0011F5r 2  E4 57              CPX   Nbendh            ; compare with start of next array high byte
0011F7r 2  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
0011F9r 2               
0011F9r 2  C5 56              CMP   Nbendl            ; else compare element pointer low byte with next array
0011FBr 2                                             ; low byte
0011FBr 2  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
0011FDr 2               
0011FDr 2               LAB_21CC
0011FDr 2  20 rr rr           JSR   LAB_21D7          ; go defrag array strings
001200r 2  80 F3              BRA   LAB_21C4          ; go do next array string (loop always)
001202r 2               
001202r 2               ; defrag string variables
001202r 2               ; enter with XA = variable pointer
001202r 2               ; return with XA = next variable pointer
001202r 2               
001202r 2               LAB_21D1
001202r 2  C8                 INY                     ; increment index (Y was $00)
001203r 2  B1 23              LDA   (ut1_pl),Y        ; get var name byte 2
001205r 2  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
001207r 2               
001207r 2  C8                 INY                     ; else increment index
001208r 2               LAB_21D7
001208r 2  B1 23              LDA   (ut1_pl),Y        ; get string length
00120Ar 2  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
00120Cr 2               
00120Cr 2  C8                 INY                     ; else increment index
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00120Dr 2  B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte
00120Fr 2  AA                 TAX                     ; copy to X
001210r 2  C8                 INY                     ; increment index
001211r 2  B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte
001213r 2  C5 34              CMP   Sstorh            ; compare bottom of string space high byte
001215r 2  90 06              BCC   LAB_21EC          ; branch if less
001217r 2  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
001219r 2               
001219r 2                                             ; high bytes were = so compare low bytes
001219r 2  E4 33              CPX   Sstorl            ; compare bottom of string space low byte
00121Br 2  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
00121Dr 2               
00121Dr 2                                             ; string pointer is < string storage pointer (pos in mem)
00121Dr 2               LAB_21EC
00121Dr 2  C5 5D              CMP   Histrh            ; compare to highest string high byte
00121Fr 2  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
001221r 2               
001221r 2  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
001223r 2               
001223r 2                                             ; high bytes were = so compare low bytes
001223r 2  E4 5C              CPX   Histrl            ; compare to highest string low byte
001225r 2  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
001227r 2               
001227r 2                                             ; string is in string memory space
001227r 2               LAB_21F6
001227r 2  86 5C              STX   Histrl            ; save as new highest string low byte
001229r 2  85 5D              STA   Histrh            ; save as new highest string high byte
00122Br 2  A5 23              LDA   ut1_pl            ; get start of vars(descriptors) low byte
00122Dr 2  A6 24              LDX   ut1_ph            ; get start of vars(descriptors) high byte
00122Fr 2  85 4E              STA   garb_l            ; save as working pointer low byte
001231r 2  86 4F              STX   garb_h            ; save as working pointer high byte
001233r 2  88                 DEY                     ; decrement index DIFFERS
001234r 2  88                 DEY                     ; decrement index (should point to descriptor start)
001235r 2  84 54              STY   g_indx            ; save index pointer
001237r 2               
001237r 2                                             ; step pointer to next string
001237r 2               LAB_2206
001237r 2  18                 CLC                     ; clear carry for add
001238r 2               LAB_2207
001238r 2  A5 52              LDA   g_step            ; get step size
00123Ar 2               LAB_2208
00123Ar 2  65 23              ADC   ut1_pl            ; add pointer low byte
00123Cr 2  85 23              STA   ut1_pl            ; save pointer low byte
00123Er 2  90 02              BCC   LAB_2211          ; branch if no overflow
001240r 2               
001240r 2  E6 24              INC   ut1_ph            ; else increment high byte
001242r 2               LAB_2211
001242r 2  A6 24              LDX   ut1_ph            ; get pointer high byte
001244r 2  A0 00              LDY   #$00              ; clear Y
001246r 2  60                 RTS
001247r 2               
001247r 2               ; search complete, now either exit or set-up and move string
001247r 2               
001247r 2               LAB_2216
001247r 2  C6 52              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
001249r 2                                             ; patch 2.22p5
001249r 2  A5 4F              LDA   garb_h            ; any string to move?
00124Br 2  05 4E              ORA   garb_l
00124Dr 2  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
00124Fr 2               
00124Fr 2  A4 54              LDY   g_indx            ; get index byte back (points to descriptor)
001251r 2  18                 CLC                     ; clear carry for add
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001252r 2  B1 4E              LDA   (garb_l),Y        ; get string length
001254r 2  65 5C              ADC   Histrl            ; add highest string low byte
001256r 2  85 58              STA   Obendl            ; save old block end low pointer
001258r 2  A5 5D              LDA   Histrh            ; get highest string high byte
00125Ar 2  69 00              ADC   #$00              ; add any carry
00125Cr 2  85 59              STA   Obendh            ; save old block end high byte
00125Er 2  A5 33              LDA   Sstorl            ; get bottom of string space low byte
001260r 2  A6 34              LDX   Sstorh            ; get bottom of string space high byte
001262r 2  85 56              STA   Nbendl            ; save new block end low byte
001264r 2  86 57              STX   Nbendh            ; save new block end high byte
001266r 2  20 rr rr           JSR   LAB_11D6          ; open up space in memory, don't set array end
001269r 2  A4 54              LDY   g_indx            ; get index byte
00126Br 2  C8                 INY                     ; point to descriptor low byte
00126Cr 2  A5 56              LDA   Nbendl            ; get string pointer low byte
00126Er 2  91 4E              STA   (garb_l),Y        ; save new string pointer low byte
001270r 2  AA                 TAX                     ; copy string pointer low byte
001271r 2  E6 57              INC   Nbendh            ; correct high byte (move sets high byte -1)
001273r 2  A5 57              LDA   Nbendh            ; get new string pointer high byte
001275r 2  C8                 INY                     ; point to descriptor high byte
001276r 2  91 4E              STA   (garb_l),Y        ; save new string pointer high byte
001278r 2  4C rr rr           JMP   LAB_214B          ; re-run routine from last ending
00127Br 2                                             ; (but don't collect this string)
00127Br 2               
00127Br 2               ; concatenate
00127Br 2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
00127Br 2               
00127Br 2               LAB_224D
00127Br 2  A5 61              LDA   des_ph            ; get descriptor pointer high byte
00127Dr 2  48                 PHA                     ; put on stack
00127Er 2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
001280r 2  48                 PHA                     ; put on stack
001281r 2               
001281r 2               LAB_224Da                     ; patch 2.22p5 - added extra label
001281r 2               
001281r 2  20 rr rr           JSR   LAB_GVAL          ; get value from line
001284r 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
001287r 2  68                 PLA                     ; get descriptor pointer low byte back
001288r 2  85 6A              STA   ssptr_l           ; set pointer low byte
00128Ar 2  68                 PLA                     ; get descriptor pointer high byte back
00128Br 2  85 6B              STA   ssptr_h           ; set pointer high byte
00128Dr 2  B2 6A              LDA   (ssptr_l)         ; get length_1 from descriptor
00128Fr 2  18                 CLC                     ; clear carry for add
001290r 2  72 60              ADC   (des_pl)          ; add length_2
001292r 2  90 05              BCC   LAB_226D          ; branch if no overflow
001294r 2               
001294r 2  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
001296r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
001299r 2               
001299r 2               LAB_226D
001299r 2  20 rr rr           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00129Cr 2                                             ; long
00129Cr 2  20 rr rr           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
00129Fr 2  A5 50              LDA   des_2l            ; get descriptor pointer low byte
0012A1r 2  A4 51              LDY   des_2h            ; get descriptor pointer high byte
0012A3r 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
0012A6r 2                                             ; returns with A = length, ut1_pl = pointer low byte,
0012A6r 2                                             ; ut1_ph = pointer high byte
0012A6r 2  20 rr rr           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
0012A9r 2  A5 6A              LDA   ssptr_l           ; set descriptor pointer low byte
0012ABr 2  A4 6B              LDY   ssptr_h           ; set descriptor pointer high byte
0012ADr 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
0012B0r 2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0012B0r 2                                             ; Y=ut1_ph=pointer high byte
0012B0r 2  20 rr rr           JSR   LAB_RTST          ; check for space on descriptor stack then put string
0012B3r 2                                             ; address and length on descriptor stack and update stack
0012B3r 2                                             ; pointers
0012B3r 2  4C rr rr           JMP   LAB_1ADB          ; continue evaluation
0012B6r 2               
0012B6r 2               ; copy string from descriptor (sdescr) to (Sutill)
0012B6r 2               
0012B6r 2               LAB_228A
0012B6r 2  A0 00              LDY   #$00              ; clear index
0012B8r 2  B1 6A              LDA   (sdescr),Y        ; get string length
0012BAr 2  48                 PHA                     ; save on stack
0012BBr 2  C8                 INY                     ; increment index
0012BCr 2  B1 6A              LDA   (sdescr),Y        ; get source string pointer low byte
0012BEr 2  AA                 TAX                     ; copy to X
0012BFr 2  C8                 INY                     ; increment index
0012C0r 2  B1 6A              LDA   (sdescr),Y        ; get source string pointer high byte
0012C2r 2  A8                 TAY                     ; copy to Y
0012C3r 2  68                 PLA                     ; get length back
0012C4r 2               
0012C4r 2               ; store string A bytes long from YX to (Sutill)
0012C4r 2               
0012C4r 2               LAB_2298
0012C4r 2  86 23              STX   ut1_pl            ; save source string pointer low byte
0012C6r 2  84 24              STY   ut1_ph            ; save source string pointer high byte
0012C8r 2               
0012C8r 2               ; store string A bytes long from (ut1_pl) to (Sutill)
0012C8r 2               
0012C8r 2               LAB_229C
0012C8r 2  AA                 TAX                     ; copy length to index (don't count with Y)
0012C9r 2  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
0012CBr 2               
0012CBr 2  A0 00              LDY   #$00              ; zero pointer (copy forward)
0012CDr 2               LAB_22A0
0012CDr 2  B1 23              LDA   (ut1_pl),Y        ; get source byte
0012CFr 2  91 35              STA   (Sutill),Y        ; save destination byte
0012D1r 2               
0012D1r 2  C8                 INY                     ; increment index
0012D2r 2  CA                 DEX                     ; decrement counter
0012D3r 2  D0 F8              BNE   LAB_22A0          ; loop while <> 0
0012D5r 2               
0012D5r 2  98                 TYA                     ; restore length from Y
0012D6r 2               LAB_22A9
0012D6r 2  18                 CLC                     ; clear carry for add
0012D7r 2  65 35              ADC   Sutill            ; add string utility ptr low byte
0012D9r 2  85 35              STA   Sutill            ; save string utility ptr low byte
0012DBr 2  90 02              BCC   LAB_22B2          ; branch if no carry
0012DDr 2               
0012DDr 2  E6 36              INC   Sutilh            ; else increment string utility ptr high byte
0012DFr 2               LAB_22B2
0012DFr 2  60                 RTS
0012E0r 2               
0012E0r 2               ; evaluate string
0012E0r 2               
0012E0r 2               LAB_EVST
0012E0r 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
0012E3r 2               
0012E3r 2               ; pop string off descriptor stack, or from top of string space
0012E3r 2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
0012E3r 2               
0012E3r 2               LAB_22B6
0012E3r 2  A5 60              LDA   des_pl            ; get descriptor pointer low byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0012E5r 2  A4 61              LDY   des_ph            ; get descriptor pointer high byte
0012E7r 2               
0012E7r 2               ; pop (YA) descriptor off stack or from top of string space
0012E7r 2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
0012E7r 2               
0012E7r 2               LAB_22BA
0012E7r 2  85 23              STA   ut1_pl            ; save descriptor pointer low byte
0012E9r 2  84 24              STY   ut1_ph            ; save descriptor pointer high byte
0012EBr 2  20 rr rr           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
0012EEr 2  08                 PHP                     ; save status flags
0012EFr 2  A0 00              LDY   #$00              ; clear index
0012F1r 2  B1 23              LDA   (ut1_pl),Y        ; get length from string descriptor
0012F3r 2  48                 PHA                     ; put on stack
0012F4r 2  C8                 INY                     ; increment index
0012F5r 2  B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
0012F7r 2  AA                 TAX                     ; copy to X
0012F8r 2  C8                 INY                     ; increment index
0012F9r 2  B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
0012FBr 2  A8                 TAY                     ; copy to Y
0012FCr 2  68                 PLA                     ; get string length back
0012FDr 2  28                 PLP                     ; restore status
0012FEr 2  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
001300r 2               
001300r 2  C4 34              CPY   Sstorh            ; compare bottom of string space high byte
001302r 2  D0 0F              BNE   LAB_22E6          ; branch if <>
001304r 2               
001304r 2  E4 33              CPX   Sstorl            ; else compare bottom of string space low byte
001306r 2  D0 0B              BNE   LAB_22E6          ; branch if <>
001308r 2               
001308r 2  48                 PHA                     ; save string length
001309r 2  18                 CLC                     ; clear carry for add
00130Ar 2  65 33              ADC   Sstorl            ; add bottom of string space low byte
00130Cr 2  85 33              STA   Sstorl            ; save bottom of string space low byte
00130Er 2  90 02              BCC   LAB_22E5          ; skip increment if no overflow
001310r 2               
001310r 2  E6 34              INC   Sstorh            ; increment bottom of string space high byte
001312r 2               LAB_22E5
001312r 2  68                 PLA                     ; restore string length
001313r 2               LAB_22E6
001313r 2  86 23              STX   ut1_pl            ; save string pointer low byte
001315r 2  84 24              STY   ut1_ph            ; save string pointer high byte
001317r 2  60                 RTS
001318r 2               
001318r 2               ; clean descriptor stack, YA = pointer
001318r 2               ; checks if AY is on the descriptor stack, if so does a stack discard
001318r 2               
001318r 2               LAB_22EB
001318r 2  C4 19              CPY   last_sh           ; compare pointer high byte
00131Ar 2  D0 0C              BNE   LAB_22FB          ; exit if <>
00131Cr 2               
00131Cr 2  C5 18              CMP   last_sl           ; compare pointer low byte
00131Er 2  D0 08              BNE   LAB_22FB          ; exit if <>
001320r 2               
001320r 2  85 17              STA   next_s            ; save descriptor stack pointer
001322r 2  E9 03              SBC   #$03              ; -3
001324r 2  85 18              STA   last_sl           ; save low byte -3
001326r 2  A0 00              LDY   #$00              ; clear high byte
001328r 2               LAB_22FB
001328r 2  60                 RTS
001329r 2               
001329r 2               ; perform CHR$()
001329r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001329r 2               LAB_CHRS
001329r 2  20 rr rr           JSR   LAB_EVBY          ; evaluate byte expression, result in X
00132Cr 2  DA                 PHX                     ; save character to stack
00132Dr 2  A9 01              LDA   #$01              ; string is single byte
00132Fr 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
001332r 2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
001332r 2  68                 PLA                     ; get character back
001333r 2  92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
001335r 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put string
001338r 2                                             ; address and length on descriptor stack and update stack
001338r 2                                             ; pointers
001338r 2               
001338r 2               ; perform LEFT$()
001338r 2               
001338r 2               LAB_LEFT
001338r 2  48                 PHA                     ; push byte parameter
001339r 2  20 rr rr           JSR   LAB_236F          ; pull string data and byte parameter from stack
00133Cr 2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00133Cr 2  D1 50              CMP   (des_2l),Y        ; compare byte parameter with string length
00133Er 2  98                 TYA                     ; clear A
00133Fr 2  80 09              BRA   LAB_2316          ; go do string copy (branch always)
001341r 2               
001341r 2               ; perform RIGHT$()
001341r 2               
001341r 2               LAB_RIGHT
001341r 2  48                 PHA                     ; push byte parameter
001342r 2  20 rr rr           JSR   LAB_236F          ; pull string data and byte parameter from stack
001345r 2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
001345r 2  18                 CLC                     ; clear carry for add-1
001346r 2  F1 50              SBC   (des_2l),Y        ; subtract string length
001348r 2  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
00134Ar 2               
00134Ar 2               LAB_2316
00134Ar 2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
00134Cr 2               
00134Cr 2  B1 50              LDA   (des_2l),Y        ; else make parameter = length
00134Er 2  AA                 TAX                     ; copy to byte parameter copy
00134Fr 2  98                 TYA                     ; clear string start offset
001350r 2               LAB_231C
001350r 2  48                 PHA                     ; save string start offset
001351r 2               LAB_231D
001351r 2  8A                 TXA                     ; copy byte parameter (or string length if <)
001352r 2               LAB_231E
001352r 2  48                 PHA                     ; save string length
001353r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
001356r 2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
001356r 2  A5 50              LDA   des_2l            ; get descriptor pointer low byte
001358r 2  A4 51              LDY   des_2h            ; get descriptor pointer high byte
00135Ar 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00135Dr 2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
00135Dr 2                                             ; Y=ut1_ph=pointer high byte
00135Dr 2  7A                 PLY                     ; get string length back
00135Er 2  68                 PLA                     ; get string start offset back
00135Fr 2  18                 CLC                     ; clear carry for add
001360r 2  65 23              ADC   ut1_pl            ; add start offset to string start pointer low byte
001362r 2  85 23              STA   ut1_pl            ; save string start pointer low byte
001364r 2  90 02              BCC   LAB_2335          ; branch if no overflow
001366r 2               
001366r 2  E6 24              INC   ut1_ph            ; else increment string start pointer high byte
001368r 2               LAB_2335
001368r 2  98                 TYA                     ; copy length to A
001369r 2  20 rr rr           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00136Cr 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00136Fr 2                                             ; address and length on descriptor stack and update stack
00136Fr 2                                             ; pointers
00136Fr 2               
00136Fr 2               ; perform MID$()
00136Fr 2               
00136Fr 2               LAB_MIDS
00136Fr 2  48                 PHA                     ; push byte parameter
001370r 2  A9 FF              LDA   #$FF              ; set default length = 255
001372r 2  85 61              STA   mids_l            ; save default length
001374r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
001377r 2  C9 29              CMP   #')'              ; compare with ")"
001379r 2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
00137Br 2               
00137Br 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00137Er 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
001381r 2               LAB_2358
001381r 2  20 rr rr           JSR   LAB_236F          ; pull string data and byte parameter from stack
001384r 2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
001384r 2  CA                 DEX                     ; decrement start index
001385r 2  8A                 TXA                     ; copy to A
001386r 2  48                 PHA                     ; save string start offset
001387r 2  18                 CLC                     ; clear carry for sub-1
001388r 2  A2 00              LDX   #$00              ; clear output string length
00138Ar 2  F1 50              SBC   (des_2l),Y        ; subtract string length
00138Cr 2  B0 C3              BCS   LAB_231D          ; if start>string length go do null string
00138Er 2               
00138Er 2  49 FF              EOR   #$FF              ; complement -length
001390r 2  C5 61              CMP   mids_l            ; compare byte parameter
001392r 2  90 BE              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
001394r 2               
001394r 2  A5 61              LDA   mids_l            ; get length byte
001396r 2  80 BA              BRA   LAB_231E          ; go do string copy (branch always)
001398r 2               
001398r 2               ; pull string data and byte parameter from stack
001398r 2               ; return pointer in des_2l/h, byte in A (and X), Y=0
001398r 2               
001398r 2               LAB_236F
001398r 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00139Br 2  68                 PLA                     ; pull return address low byte (return address)
00139Cr 2  85 54              STA   Fnxjpl            ; save functions jump vector low byte
00139Er 2  68                 PLA                     ; pull return address high byte (return address)
00139Fr 2  85 55              STA   Fnxjph            ; save functions jump vector high byte
0013A1r 2  FA                 PLX                     ; get byte parameter
0013A2r 2  68                 PLA                     ; pull string pointer low byte
0013A3r 2  85 50              STA   des_2l            ; save it
0013A5r 2  68                 PLA                     ; pull string pointer high byte
0013A6r 2  85 51              STA   des_2h            ; save it
0013A8r 2  A0 00              LDY   #$00              ; clear index
0013AAr 2  8A                 TXA                     ; copy byte parameter
0013ABr 2  F0 77              BEQ   LAB_23A8          ; if null do function call error then warm start
0013ADr 2               
0013ADr 2  E6 54              INC   Fnxjpl            ; increment function jump vector low byte
0013AFr 2                                             ; (JSR pushes return addr-1. this is all very nice
0013AFr 2                                             ; but will go tits up if either call is on a page
0013AFr 2                                             ; boundary!)
0013AFr 2  6C 54 00           JMP   (Fnxjpl)          ; in effect, RTS
0013B2r 2               
0013B2r 2               ; perform LCASE$()
0013B2r 2               
0013B2r 2               LAB_LCASE
0013B2r 2  20 rr rr           JSR   LAB_EVST          ; evaluate string
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0013B5r 2  85 5E              STA   str_ln            ; set string length
0013B7r 2  A8                 TAY                     ; copy length to Y
0013B8r 2  F0 38              BEQ   NoString          ; branch if null string
0013BAr 2               
0013BAr 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=length,
0013BDr 2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0013BDr 2  86 5F              STX   str_pl            ; save string pointer low byte
0013BFr 2  84 60              STY   str_ph            ; save string pointer high byte
0013C1r 2  A8                 TAY                     ; get string length back
0013C2r 2               
0013C2r 2               LC_loop
0013C2r 2  88                 DEY                     ; decrement index
0013C3r 2  B1 23              LDA   (ut1_pl),Y        ; get byte from string
0013C5r 2  20 rr rr           JSR   LAB_1D82          ; is character "A" to "Z"
0013C8r 2  90 02              BCC   NoUcase           ; branch if not upper case alpha
0013CAr 2               
0013CAr 2  09 20              ORA   #$20              ; convert upper to lower case
0013CCr 2               NoUcase
0013CCr 2  91 35              STA   (Sutill),Y        ; save byte back to string
0013CEr 2  98                 TYA                     ; test index
0013CFr 2  D0 F1              BNE   LC_loop           ; loop if not all done
0013D1r 2  80 1F              BRA   NoString          ; tidy up and exit, branch always
0013D3r 2               
0013D3r 2               ; perform UCASE$()
0013D3r 2               
0013D3r 2               LAB_UCASE
0013D3r 2  20 rr rr           JSR   LAB_EVST          ; evaluate string
0013D6r 2  85 5E              STA   str_ln            ; set string length
0013D8r 2  A8                 TAY                     ; copy length to Y
0013D9r 2  F0 17              BEQ   NoString          ; branch if null string
0013DBr 2               
0013DBr 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=length,
0013DEr 2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
0013DEr 2  86 5F              STX   str_pl            ; save string pointer low byte
0013E0r 2  84 60              STY   str_ph            ; save string pointer high byte
0013E2r 2  A8                 TAY                     ; get string length back
0013E3r 2               
0013E3r 2               UC_loop
0013E3r 2  88                 DEY                     ; decrement index
0013E4r 2  B1 23              LDA   (ut1_pl),Y        ; get byte from string
0013E6r 2  20 rr rr           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
0013E9r 2  90 02              BCC   NoLcase           ; branch if not alpha
0013EBr 2               
0013EBr 2  29 DF              AND   #$DF              ; convert lower to upper case
0013EDr 2               NoLcase
0013EDr 2  91 35              STA   (Sutill),Y        ; save byte back to string
0013EFr 2  98                 TYA                     ; test index
0013F0r 2  D0 F1              BNE   UC_loop           ; loop if not all done
0013F2r 2               
0013F2r 2               NoString
0013F2r 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put string
0013F5r 2                                             ; address and length on descriptor stack and update stack
0013F5r 2                                             ; pointers
0013F5r 2               
0013F5r 2               ; perform SADD()
0013F5r 2               
0013F5r 2               LAB_SADD
0013F5r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
0013F8r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
0013FBr 2               
0013FBr 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
0013FEr 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001401r 2               
001401r 2  A0 02              LDY   #$02              ; index to string pointer high byte
001403r 2  B1 47              LDA   (Cvaral),Y        ; get string pointer high byte
001405r 2  AA                 TAX                     ; copy string pointer high byte to X
001406r 2  88                 DEY                     ; index to string pointer low byte
001407r 2  B1 47              LDA   (Cvaral),Y        ; get string pointer low byte
001409r 2  A8                 TAY                     ; copy string pointer low byte to Y
00140Ar 2  8A                 TXA                     ; copy string pointer high byte to A
00140Br 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00140Er 2               
00140Er 2               ; perform LEN()
00140Er 2               
00140Er 2               LAB_LENS
00140Er 2  20 rr rr           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
001411r 2  4C rr rr           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
001414r 2               
001414r 2               ; evaluate string, get length in Y
001414r 2               
001414r 2               LAB_ESGL
001414r 2  20 rr rr           JSR   LAB_EVST          ; evaluate string
001417r 2  A8                 TAY                     ; copy length to Y
001418r 2  60                 RTS
001419r 2               
001419r 2               ; perform ASC()
001419r 2               
001419r 2               LAB_ASC
001419r 2  20 rr rr           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00141Cr 2  F0 06              BEQ   LAB_23A8          ; if null do function call error then warm start
00141Er 2               
00141Er 2  B2 23              LDA   (ut1_pl)          ; get byte
001420r 2  A8                 TAY                     ; copy to Y
001421r 2  4C rr rr           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
001424r 2               
001424r 2               ; do function call error then warm start
001424r 2               
001424r 2               LAB_23A8
001424r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
001427r 2               
001427r 2               ; scan and get byte parameter
001427r 2               
001427r 2               LAB_SGBY
001427r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
00142Ar 2               
00142Ar 2               ; get byte parameter
00142Ar 2               
00142Ar 2               LAB_GTBY
00142Ar 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00142Dr 2                                             ; else do type mismatch
00142Dr 2               
00142Dr 2               ; evaluate byte expression, result in X
00142Dr 2               
00142Dr 2               LAB_EVBY
00142Dr 2  20 rr rr           JSR   LAB_EVPI          ; evaluate integer expression (no check)
001430r 2               
001430r 2  A4 60              LDY   FAC1_2            ; get FAC1 mantissa2
001432r 2  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
001434r 2               
001434r 2  A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
001436r 2  4C rr rr           JMP   LAB_GBYT          ; scan memory and return
001439r 2               
001439r 2               ; perform VAL()
001439r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001439r 2               LAB_VAL
001439r 2  20 rr rr           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00143Cr 2  D0 03              BNE   LAB_23C5          ; branch if not null string
00143Er 2               
00143Er 2                                             ; string was null so set result = $00
00143Er 2  4C rr rr           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
001441r 2               
001441r 2               LAB_23C5
001441r 2                                             ; patch 2.22p5 - new routine
001441r 2  48                 PHA                     ; save length
001442r 2  C8                 INY                     ; string length +1
001443r 2  98                 TYA
001444r 2  20 rr rr           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
001447r 2  68                 PLA                     ; get length back
001448r 2  20 rr rr           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
00144Br 2  A9 00              LDA   #0                ; add delimiter to end of string
00144Dr 2  92 35              STA   (Sutill)
00144Fr 2  A6 6E              LDX   Bpntrl            ; save BASIC execute pointer low byte
001451r 2  A4 6F              LDY   Bpntrh
001453r 2  86 6C              STX   Btmpl
001455r 2  84 6D              STY   Btmph
001457r 2  A6 5F              LDX   str_pl            ; point to temporary string
001459r 2  A4 60              LDY   str_ph
00145Br 2  86 6E              STX   Bpntrl
00145Dr 2  84 6F              STY   Bpntrh
00145Fr 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
001462r 2  20 rr rr           JSR   LAB_2887          ; get FAC1 from string
001465r 2               
001465r 2               LAB_23F3
001465r 2  A6 6C              LDX   Btmpl             ; get BASIC execute pointer low byte back
001467r 2  A4 6D              LDY   Btmph             ; get BASIC execute pointer high byte back
001469r 2  86 6E              STX   Bpntrl            ; save BASIC execute pointer low byte
00146Br 2  84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
00146Dr 2  60                 RTS
00146Er 2               
00146Er 2               ; get two parameters for POKE or WAIT
00146Er 2               
00146Er 2               LAB_GADB
00146Er 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
001471r 2                                             ; else do type mismatch
001471r 2  20 rr rr           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
001474r 2               
001474r 2               ; scan for "," and get byte, else do Syntax error then warm start
001474r 2               
001474r 2               LAB_SCGB
001474r 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
001477r 2  A5 0B              LDA   Itemph            ; save temporary integer high byte
001479r 2  48                 PHA                     ; on stack
00147Ar 2  A5 0A              LDA   Itempl            ; save temporary integer low byte
00147Cr 2  48                 PHA                     ; on stack
00147Dr 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
001480r 2  68                 PLA                     ; pull low byte
001481r 2  85 0A              STA   Itempl            ; restore temporary integer low byte
001483r 2  68                 PLA                     ; pull high byte
001484r 2  85 0B              STA   Itemph            ; restore temporary integer high byte
001486r 2  60                 RTS
001487r 2               
001487r 2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
001487r 2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
001487r 2               
001487r 2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
001487r 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001487r 2               LAB_F2FX
001487r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001489r 2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00148Br 2  B0 97              BCS   LAB_23A8          ; if >= do function call error then warm start
00148Dr 2               
00148Dr 2               LAB_F2FU
00148Dr 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
001490r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
001492r 2  A4 61              LDY   FAC1_3            ; get FAC1 mantissa3
001494r 2  84 0A              STY   Itempl            ; save temporary integer low byte
001496r 2  85 0B              STA   Itemph            ; save temporary integer high byte
001498r 2  60                 RTS
001499r 2               
001499r 2               ; perform PEEK()
001499r 2               
001499r 2               LAB_PEEK
001499r 2  20 rr rr           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00149Cr 2  A2 00              LDX   #$00              ; clear index
00149Er 2  A1 0A              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
0014A0r 2  A8                 TAY                     ; copy byte to Y
0014A1r 2  4C rr rr           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
0014A4r 2               
0014A4r 2               ; perform POKE
0014A4r 2               
0014A4r 2               LAB_POKE
0014A4r 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
0014A7r 2  8A                 TXA                     ; copy byte argument to A
0014A8r 2  A2 00              LDX   #$00              ; clear index
0014AAr 2  81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
0014ACr 2  60                 RTS
0014ADr 2               
0014ADr 2               ; perform DEEK()
0014ADr 2               
0014ADr 2               LAB_DEEK
0014ADr 2  20 rr rr           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
0014B0r 2  A2 00              LDX   #$00              ; clear index
0014B2r 2  A1 0A              LDA   (Itempl,X)        ; PEEK low byte
0014B4r 2  A8                 TAY                     ; copy to Y
0014B5r 2  E6 0A              INC   Itempl            ; increment pointer low byte
0014B7r 2  D0 02              BNE   Deekh             ; skip high increment if no rollover
0014B9r 2               
0014B9r 2  E6 0B              INC   Itemph            ; increment pointer high byte
0014BBr 2               Deekh
0014BBr 2  A1 0A              LDA   (Itempl,X)        ; PEEK high byte
0014BDr 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0014C0r 2               
0014C0r 2               ; perform DOKE
0014C0r 2               
0014C0r 2               LAB_DOKE
0014C0r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0014C3r 2                                             ; else do type mismatch
0014C3r 2  20 rr rr           JSR   LAB_F2FX          ; convert floating-to-fixed
0014C6r 2               
0014C6r 2  84 49              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
0014C8r 2  85 4A              STA   Frnxth            ; save pointer high byte
0014CAr 2               
0014CAr 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
0014CDr 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0014D0r 2                                             ; else do type mismatch
0014D0r 2  20 rr rr           JSR   LAB_F2FX          ; convert floating-to-fixed
0014D3r 2               
0014D3r 2  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0014D4r 2  A2 00              LDX   #$00              ; clear index
0014D6r 2  81 49              STA   (Frnxtl,X)        ; POKE low byte
0014D8r 2  E6 49              INC   Frnxtl            ; increment pointer low byte
0014DAr 2  D0 02              BNE   Dokeh             ; skip high increment if no rollover
0014DCr 2               
0014DCr 2  E6 4A              INC   Frnxth            ; increment pointer high byte
0014DEr 2               Dokeh
0014DEr 2  A5 0B              LDA   Itemph            ; get value high byte
0014E0r 2  81 49              STA   (Frnxtl,X)        ; POKE high byte
0014E2r 2  4C rr rr           JMP   LAB_GBYT          ; scan memory and return
0014E5r 2               
0014E5r 2               ; perform SWAP
0014E5r 2               
0014E5r 2               LAB_SWAP
0014E5r 2  20 rr rr           JSR   LAB_GVAR          ; get var1 address
0014E8r 2  85 49              STA   Lvarpl            ; save var1 address low byte
0014EAr 2  84 4A              STY   Lvarph            ; save var1 address high byte
0014ECr 2  A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
0014EEr 2  48                 PHA                     ; save data type flag
0014EFr 2               
0014EFr 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
0014F2r 2  20 rr rr           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
0014F5r 2  68                 PLA                     ; pull var1 data type flag
0014F6r 2  45 11              EOR   Dtypef            ; compare with var2 data type
0014F8r 2  10 10              BPL   SwapErr           ; exit if not both the same type
0014FAr 2               
0014FAr 2  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
0014FCr 2               SwapLp
0014FCr 2  B1 49              LDA   (Lvarpl),Y        ; get byte from var1
0014FEr 2  AA                 TAX                     ; save var1 byte
0014FFr 2  B1 47              LDA   (Cvaral),Y        ; get byte from var2
001501r 2  91 49              STA   (Lvarpl),Y        ; save byte to var1
001503r 2  8A                 TXA                     ; restore var1 byte
001504r 2  91 47              STA   (Cvaral),Y        ; save byte to var2
001506r 2  88                 DEY                     ; decrement index
001507r 2  10 F3              BPL   SwapLp            ; loop until done
001509r 2  60                 RTS
00150Ar 2               
00150Ar 2               SwapErr
00150Ar 2  4C rr rr           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
00150Dr 2               
00150Dr 2               ; perform CALL
00150Dr 2               
00150Dr 2               LAB_CALL
00150Dr 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
001510r 2                                             ; else do type mismatch
001510r 2  20 rr rr           JSR   LAB_F2FX          ; convert floating-to-fixed
001513r 2  A9 rr              LDA   #>CallExit        ; set return address high byte
001515r 2  48                 PHA                     ; put on stack
001516r 2  A9 rr              LDA   #<CallExit-1      ; set return address low byte
001518r 2  48                 PHA                     ; put on stack
001519r 2  6C 0A 00           JMP   (Itempl)          ; do indirect jump to user routine
00151Cr 2               
00151Cr 2               ; if the called routine exits correctly then it will return to here. this will then get
00151Cr 2               ; the next byte for the interpreter and return
00151Cr 2               
00151Cr 2               CallExit
00151Cr 2  4C rr rr           JMP   LAB_GBYT          ; scan memory and return
00151Fr 2               
00151Fr 2               ; perform WAIT
00151Fr 2               
00151Fr 2               LAB_WAIT
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00151Fr 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001522r 2  86 49              STX   Frnxtl            ; save byte
001524r 2  A2 00              LDX   #$00              ; clear mask
001526r 2  20 rr rr           JSR   LAB_GBYT          ; scan memory
001529r 2  F0 03              BEQ   LAB_2441          ; skip if no third argument
00152Br 2               
00152Br 2  20 rr rr           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
00152Er 2               LAB_2441
00152Er 2  86 4A              STX   Frnxth            ; save EOR argument
001530r 2               LAB_2445
001530r 2  B1 0A              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
001532r 2  45 4A              EOR   Frnxth            ; EOR with second argument (mask)
001534r 2  25 49              AND   Frnxtl            ; AND with first argument (byte)
001536r 2  F0 F8              BEQ   LAB_2445          ; loop if result is zero
001538r 2               
001538r 2               LAB_244D
001538r 2  60                 RTS
001539r 2               
001539r 2               ; perform subtraction, FAC1 from (AY)
001539r 2               
001539r 2               LAB_2455
001539r 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00153Cr 2               
00153Cr 2               ; perform subtraction, FAC1 from FAC2
00153Cr 2               
00153Cr 2               LAB_SUBTRACT
00153Cr 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
00153Er 2  49 FF              EOR   #$FF              ; complement it
001540r 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
001542r 2  45 69              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
001544r 2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001546r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001548r 2  80 0C              BRA   LAB_ADD           ; go add FAC2 to FAC1
00154Ar 2               
00154Ar 2               ; perform addition
00154Ar 2               
00154Ar 2               LAB_2467
00154Ar 2  20 rr rr           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
00154Dr 2  90 49              BCC   LAB_24A8          ; go subtract mantissas
00154Fr 2               
00154Fr 2               ; add 0.5 to FAC1
00154Fr 2               
00154Fr 2               LAB_244E
00154Fr 2  A9 rr              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
001551r 2  A0 rr              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
001553r 2               
001553r 2               ; add (AY) to FAC1
001553r 2               
001553r 2               LAB_246C
001553r 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
001556r 2               
001556r 2               ; add FAC2 to FAC1
001556r 2               
001556r 2               LAB_ADD
001556r 2  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
001558r 2               
001558r 2               ; copy FAC2 to FAC1
001558r 2               
001558r 2               LAB_279B
001558r 2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
00155Ar 2               
00155Ar 2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00155Ar 2               
00155Ar 2               LAB_279D
00155Ar 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
00155Cr 2  A2 04              LDX   #$04              ; 4 bytes to copy
00155Er 2               LAB_27A1
00155Er 2  B5 64              LDA   FAC1_o,X          ; get byte from FAC2,X
001560r 2  95 5D              STA   FAC1_e-1,X        ; save byte at FAC1,X
001562r 2  CA                 DEX                     ; decrement count
001563r 2  D0 F9              BNE   LAB_27A1          ; loop if not all done
001565r 2               
001565r 2  86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
001567r 2  60                 RTS
001568r 2               
001568r 2                                             ; FAC1 is non zero
001568r 2               LAB_2474
001568r 2  A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
00156Ar 2  86 55              STX   FAC2_r            ; save as FAC2 rounding byte
00156Cr 2  A2 65              LDX   #FAC2_e           ; set index to FAC2 exponent addr
00156Er 2  A5 65              LDA   FAC2_e            ; get FAC2 exponent
001570r 2               LAB_247C
001570r 2  A8                 TAY                     ; copy exponent
001571r 2  F0 C5              BEQ   LAB_244D          ; exit if zero
001573r 2               
001573r 2  38                 SEC                     ; set carry for subtract
001574r 2  E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
001576r 2  F0 20              BEQ   LAB_24A8          ; branch if = (go add mantissa)
001578r 2  90 10              BCC   LAB_2498          ; branch if <
00157Ar 2               
00157Ar 2                                             ; FAC2>FAC1
00157Ar 2  84 5E              STY   FAC1_e            ; save FAC1 exponent
00157Cr 2  A4 69              LDY   FAC2_s            ; get FAC2 sign (b7)
00157Er 2  84 62              STY   FAC1_s            ; save FAC1 sign (b7)
001580r 2  49 FF              EOR   #$FF              ; complement A
001582r 2  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
001584r 2  64 55              STZ   FAC2_r            ; clear FAC2 rounding byte
001586r 2  A2 5E              LDX   #FAC1_e           ; set index to FAC1 exponent addr
001588r 2  80 02              BRA   LAB_249C          ; branch always
00158Ar 2               
00158Ar 2               LAB_2498
00158Ar 2  64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
00158Cr 2               LAB_249C
00158Cr 2  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
00158Er 2  30 BA              BMI   LAB_2467          ; branch if range $79-$F8
001590r 2               
001590r 2  A8                 TAY                     ; copy exponent difference to Y
001591r 2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
001593r 2  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
001595r 2  20 rr rr           JSR   LAB_2592          ; shift FACX Y times right
001598r 2               
001598r 2                                             ; exponents are equal now do mantissa subtract
001598r 2               LAB_24A8
001598r 2  24 6A              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
00159Ar 2  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
00159Cr 2               
00159Cr 2  A0 5E              LDY   #FAC1_e           ; set index to FAC1 exponent addr
00159Er 2  E0 65              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
0015A0r 2  F0 02              BEQ   LAB_24B4          ; branch if =
0015A2r 2               
0015A2r 2  A0 65              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
0015A4r 2               
0015A4r 2                                             ; subtract smaller from bigger (take sign of bigger)
0015A4r 2               LAB_24B4
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0015A4r 2  38                 SEC                     ; set carry for subtract
0015A5r 2  49 FF              EOR   #$FF              ; ones complement A
0015A7r 2  65 55              ADC   FAC2_r            ; add FAC2 rounding byte
0015A9r 2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
0015ABr 2  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
0015AEr 2  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
0015B0r 2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
0015B2r 2  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
0015B5r 2  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
0015B7r 2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
0015B9r 2  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
0015BCr 2  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
0015BEr 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
0015C0r 2               
0015C0r 2               ; do ABS and normalise FAC1
0015C0r 2               
0015C0r 2               LAB_24D0
0015C0r 2  B0 03              BCS   LAB_24D5          ; branch if number is +ve
0015C2r 2               
0015C2r 2  20 rr rr           JSR   LAB_2537          ; negate FAC1
0015C5r 2               
0015C5r 2               ; normalise FAC1
0015C5r 2               
0015C5r 2               LAB_24D5
0015C5r 2  A9 00              LDA   #$00              ; clear A
0015C7r 2  A8                 TAY                     ; clear Y
0015C8r 2  18                 CLC                     ; clear carry for add
0015C9r 2               LAB_24D9
0015C9r 2  A6 5F              LDX   FAC1_1            ; get FAC1 mantissa1
0015CBr 2  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
0015CDr 2               
0015CDr 2  A6 60              LDX   FAC1_2            ; get FAC1 mantissa2
0015CFr 2  86 5F              STX   FAC1_1            ; save FAC1 mantissa1
0015D1r 2  A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
0015D3r 2  86 60              STX   FAC1_2            ; save FAC1 mantissa2
0015D5r 2  A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
0015D7r 2  86 61              STX   FAC1_3            ; save FAC1 mantissa3
0015D9r 2  84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
0015DBr 2  69 08              ADC   #$08              ; add x to exponent offset
0015DDr 2  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
0015DFr 2  D0 E8              BNE   LAB_24D9          ; loop if not max
0015E1r 2               
0015E1r 2               ; clear FAC1 exponent and sign
0015E1r 2               
0015E1r 2               LAB_24F1
0015E1r 2  A9 00              LDA   #$00              ; clear A
0015E3r 2               LAB_24F3
0015E3r 2  85 5E              STA   FAC1_e            ; set FAC1 exponent
0015E5r 2               
0015E5r 2               ; save FAC1 sign
0015E5r 2               
0015E5r 2               LAB_24F5
0015E5r 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
0015E7r 2  60                 RTS
0015E8r 2               
0015E8r 2               ; add FAC2 mantissa to FAC1 mantissa
0015E8r 2               
0015E8r 2               LAB_24F8
0015E8r 2  65 55              ADC   FAC2_r            ; add FAC2 rounding byte
0015EAr 2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
0015ECr 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
0015EEr 2  65 68              ADC   FAC2_3            ; add FAC2 mantissa3
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0015F0r 2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
0015F2r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
0015F4r 2  65 67              ADC   FAC2_2            ; add FAC2 mantissa2
0015F6r 2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
0015F8r 2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
0015FAr 2  65 66              ADC   FAC2_1            ; add FAC2 mantissa1
0015FCr 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
0015FEr 2  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
001600r 2  60                 RTS                     ; else just exit
001601r 2               
001601r 2               LAB_2511
001601r 2  69 01              ADC   #$01              ; add 1 to exponent offset
001603r 2  06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
001605r 2  26 61              ROL   FAC1_3            ; shift FAC1 mantissa3
001607r 2  26 60              ROL   FAC1_2            ; shift FAC1 mantissa2
001609r 2  26 5F              ROL   FAC1_1            ; shift FAC1 mantissa1
00160Br 2               
00160Br 2               ; normalise FAC1
00160Br 2               
00160Br 2               LAB_251B
00160Br 2  10 F4              BPL   LAB_2511          ; loop if not normalised
00160Dr 2               
00160Dr 2  38                 SEC                     ; set carry for subtract
00160Er 2  E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
001610r 2  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
001612r 2               
001612r 2  49 FF              EOR   #$FF              ; complement exponent
001614r 2  69 01              ADC   #$01              ; +1 (twos complement)
001616r 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
001618r 2               
001618r 2               ; test and normalise FAC1 for C=0/1
001618r 2               
001618r 2               LAB_2528
001618r 2  90 0C              BCC   LAB_2536          ; exit if no overflow
00161Ar 2               
00161Ar 2               ; normalise FAC1 for C=1
00161Ar 2               
00161Ar 2               LAB_252A
00161Ar 2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent
00161Cr 2  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
00161Er 2               
00161Er 2  66 5F              ROR   FAC1_1            ; shift FAC1 mantissa1
001620r 2  66 60              ROR   FAC1_2            ; shift FAC1 mantissa2
001622r 2  66 61              ROR   FAC1_3            ; shift FAC1 mantissa3
001624r 2  66 6B              ROR   FAC1_r            ; shift FAC1 rounding byte
001626r 2               LAB_2536
001626r 2  60                 RTS
001627r 2               
001627r 2               ; negate FAC1
001627r 2               
001627r 2               LAB_2537
001627r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001629r 2  49 FF              EOR   #$FF              ; complement it
00162Br 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
00162Dr 2               
00162Dr 2               ; twos complement FAC1 mantissa
00162Dr 2               
00162Dr 2               LAB_253D
00162Dr 2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
00162Fr 2  49 FF              EOR   #$FF              ; complement it
001631r 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
001633r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001635r 2  49 FF              EOR   #$FF              ; complement it
001637r 2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
001639r 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
00163Br 2  49 FF              EOR   #$FF              ; complement it
00163Dr 2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
00163Fr 2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
001641r 2  49 FF              EOR   #$FF              ; complement it
001643r 2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
001645r 2  E6 6B              INC   FAC1_r            ; increment FAC1 rounding byte
001647r 2  D0 0A              BNE   LAB_2563          ; exit if no overflow
001649r 2               
001649r 2               ; increment FAC1 mantissa
001649r 2               
001649r 2               LAB_2559
001649r 2  E6 61              INC   FAC1_3            ; increment FAC1 mantissa3
00164Br 2  D0 06              BNE   LAB_2563          ; finished if no rollover
00164Dr 2               
00164Dr 2  E6 60              INC   FAC1_2            ; increment FAC1 mantissa2
00164Fr 2  D0 02              BNE   LAB_2563          ; finished if no rollover
001651r 2               
001651r 2  E6 5F              INC   FAC1_1            ; increment FAC1 mantissa1
001653r 2               LAB_2563
001653r 2  60                 RTS
001654r 2               
001654r 2               ; do overflow error (overflow exit)
001654r 2               
001654r 2               LAB_2564
001654r 2  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
001656r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
001659r 2               
001659r 2               ; shift FCAtemp << A+8 times
001659r 2               
001659r 2               LAB_2569
001659r 2  A2 26              LDX   #FACt_1-1         ; set offset to FACtemp
00165Br 2               LAB_256B
00165Br 2  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
00165Dr 2  84 6B              STY   FAC1_r            ; save as FAC1 rounding byte
00165Fr 2  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
001661r 2  94 03              STY   PLUS_3,X          ; save FACX mantissa3
001663r 2  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
001665r 2  94 02              STY   PLUS_2,X          ; save FACX mantissa2
001667r 2  A4 64              LDY   FAC1_o            ; get FAC1 overflow byte
001669r 2  94 01              STY   PLUS_1,X          ; save FACX mantissa1
00166Br 2               
00166Br 2               ; shift FACX -A times right (> 8 shifts)
00166Br 2               
00166Br 2               LAB_257B
00166Br 2  69 08              ADC   #$08              ; add 8 to shift count
00166Dr 2  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
00166Fr 2               
00166Fr 2  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
001671r 2               
001671r 2  E9 08              SBC   #$08              ; else subtract 8 again
001673r 2  A8                 TAY                     ; save count to Y
001674r 2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
001676r 2  B0 12              BCS   LAB_259A          ;
001678r 2               
001678r 2               LAB_2588
001678r 2  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
00167Ar 2  90 02              BCC   LAB_258E          ; branch if +ve
00167Cr 2               
00167Cr 2  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00167Er 2               LAB_258E
00167Er 2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
001680r 2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
001682r 2               
001682r 2               ; shift FACX Y times right
001682r 2               
001682r 2               LAB_2592
001682r 2  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
001684r 2  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
001686r 2  6A                 ROR                     ; shift FACX rounding byte
001687r 2  C8                 INY                     ; increment exponent diff
001688r 2  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
00168Ar 2               
00168Ar 2               LAB_259A
00168Ar 2  18                 CLC                     ; just clear it
00168Br 2  60                 RTS
00168Cr 2               
00168Cr 2               ; perform LOG()
00168Cr 2               
00168Cr 2               LAB_LOG
00168Cr 2  20 rr rr           JSR   LAB_27CA          ; test sign and zero
00168Fr 2  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
001691r 2               
001691r 2  10 03              BPL   LAB_25C7          ; skip error if +ve
001693r 2               
001693r 2               LAB_25C4
001693r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start (-ve)
001696r 2               
001696r 2               LAB_25C7
001696r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001698r 2  E9 7F              SBC   #$7F              ; normalise it
00169Ar 2  48                 PHA                     ; save it
00169Br 2  A9 80              LDA   #$80              ; set exponent to zero
00169Dr 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
00169Fr 2  A9 rr              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
0016A1r 2  A0 rr              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
0016A3r 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
0016A6r 2  A9 rr              LDA   #<LAB_25B1        ; set root2 pointer low byte
0016A8r 2  A0 rr              LDY   #>LAB_25B1        ; set root2 pointer high byte
0016AAr 2  20 rr rr           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
0016ADr 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low byte
0016AFr 2  A0 rr              LDY   #>LAB_259C        ; set 1 pointer high byte
0016B1r 2  20 rr rr           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
0016B4r 2  A9 rr              LDA   #<LAB_25A0        ; set pointer low byte to counter
0016B6r 2  A0 rr              LDY   #>LAB_25A0        ; set pointer high byte to counter
0016B8r 2  20 rr rr           JSR   LAB_2B6E          ; ^2 then series evaluation
0016BBr 2  A9 rr              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
0016BDr 2  A0 rr              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
0016BFr 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
0016C2r 2  68                 PLA                     ; restore FAC1 exponent
0016C3r 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
0016C6r 2  A9 rr              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
0016C8r 2  A0 rr              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
0016CAr 2               
0016CAr 2               ; do convert AY, FCA1*(AY)
0016CAr 2               
0016CAr 2               LAB_25FB
0016CAr 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
0016CDr 2               LAB_MULTIPLY
0016CDr 2  F0 4A              BEQ   LAB_264C          ; exit if zero
0016CFr 2               
0016CFr 2  20 rr rr           JSR   LAB_2673          ; test and adjust accumulators
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0016D2r 2  64 27              STZ   FACt_1            ; clear temp mantissa1
0016D4r 2  64 28              STZ   FACt_2            ; clear temp mantissa2
0016D6r 2  64 29              STZ   FACt_3            ; clear temp mantissa3
0016D8r 2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
0016DAr 2  20 rr rr           JSR   LAB_2622          ; go do shift/add FAC2
0016DDr 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
0016DFr 2  20 rr rr           JSR   LAB_2622          ; go do shift/add FAC2
0016E2r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
0016E4r 2  20 rr rr           JSR   LAB_2622          ; go do shift/add FAC2
0016E7r 2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
0016E9r 2  20 rr rr           JSR   LAB_2627          ; go do shift/add FAC2
0016ECr 2  4C rr rr           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
0016EFr 2               
0016EFr 2               LAB_2622
0016EFr 2  D0 04              BNE   LAB_2627          ; branch if byte <> zero
0016F1r 2                                             ; patch 2.22p5
0016F1r 2  38                 SEC
0016F2r 2  4C rr rr           JMP   LAB_2569          ; shift FACtemp << A+8 times
0016F5r 2                                             ; else do shift and add
0016F5r 2               LAB_2627
0016F5r 2  38                 SEC                     ; set top bit (mark for 8 times)
0016F6r 2  6A                 ROR
0016F7r 2               
0016F7r 2               LAB_262A
0016F7r 2  A8                 TAY                     ; copy result
0016F8r 2  90 13              BCC   LAB_2640          ; skip next if bit was zero
0016FAr 2               
0016FAr 2  18                 CLC                     ; clear carry for add
0016FBr 2  A5 29              LDA   FACt_3            ; get temp mantissa3
0016FDr 2  65 68              ADC   FAC2_3            ; add FAC2 mantissa3
0016FFr 2  85 29              STA   FACt_3            ; save temp mantissa3
001701r 2  A5 28              LDA   FACt_2            ; get temp mantissa2
001703r 2  65 67              ADC   FAC2_2            ; add FAC2 mantissa2
001705r 2  85 28              STA   FACt_2            ; save temp mantissa2
001707r 2  A5 27              LDA   FACt_1            ; get temp mantissa1
001709r 2  65 66              ADC   FAC2_1            ; add FAC2 mantissa1
00170Br 2  85 27              STA   FACt_1            ; save temp mantissa1
00170Dr 2               LAB_2640
00170Dr 2  66 27              ROR   FACt_1            ; shift temp mantissa1
00170Fr 2  66 28              ROR   FACt_2            ; shift temp mantissa2
001711r 2  66 29              ROR   FACt_3            ; shift temp mantissa3
001713r 2  66 6B              ROR   FAC1_r            ; shift temp rounding byte
001715r 2  98                 TYA                     ; get byte back
001716r 2  4A                 LSR                     ; shift byte
001717r 2  D0 DE              BNE   LAB_262A          ; loop if all bits not done
001719r 2               
001719r 2               LAB_264C
001719r 2  60                 RTS
00171Ar 2               
00171Ar 2               ; unpack memory (AY) into FAC2
00171Ar 2               
00171Ar 2               LAB_264D
00171Ar 2  85 23              STA   ut1_pl            ; save pointer low byte
00171Cr 2  84 24              STY   ut1_ph            ; save pointer high byte
00171Er 2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
001720r 2  B1 23              LDA   (ut1_pl),Y        ; get mantissa3
001722r 2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
001724r 2  88                 DEY                     ; decrement index
001725r 2  B1 23              LDA   (ut1_pl),Y        ; get mantissa2
001727r 2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
001729r 2  88                 DEY                     ; decrement index
00172Ar 2  B1 23              LDA   (ut1_pl),Y        ; get mantissa1+sign
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00172Cr 2  85 69              STA   FAC2_s            ; save FAC2 sign (b7)
00172Er 2  45 62              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
001730r 2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001732r 2  A5 69              LDA   FAC2_s            ; recover FAC2 sign (b7)
001734r 2  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
001736r 2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
001738r 2  88                 DEY                     ; decrement index
001739r 2  B1 23              LDA   (ut1_pl),Y        ; get exponent byte
00173Br 2  85 65              STA   FAC2_e            ; save FAC2 exponent
00173Dr 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
00173Fr 2  60                 RTS
001740r 2               
001740r 2               ; test and adjust accumulators
001740r 2               
001740r 2               LAB_2673
001740r 2  A5 65              LDA   FAC2_e            ; get FAC2 exponent
001742r 2               LAB_2675
001742r 2  F0 1E              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
001744r 2               
001744r 2  18                 CLC                     ; clear carry for add
001745r 2  65 5E              ADC   FAC1_e            ; add FAC1 exponent
001747r 2  90 05              BCC   LAB_2680          ; branch if sum of exponents <$0100
001749r 2               
001749r 2  30 32              BMI   LAB_269B          ; do overflow error
00174Br 2               
00174Br 2  18                 CLC                     ; clear carry for the add
00174Cr 2  80 02              BRA   LAB_2680b         ; branch around next instruction, saves one clock cycle
00174Er 2               LAB_2680
00174Er 2  10 12              BPL   LAB_2696          ; if +ve go handle underflow
001750r 2               LAB_2680b
001750r 2  69 80              ADC   #$80              ; adjust exponent
001752r 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
001754r 2  D0 03              BNE   LAB_268B          ; branch if not zero
001756r 2               
001756r 2  4C rr rr           JMP   LAB_24F5          ; save FAC1 sign and return
001759r 2               
001759r 2               LAB_268B
001759r 2  A5 6A              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
00175Br 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
00175Dr 2               LAB_268F
00175Dr 2  60                 RTS
00175Er 2               
00175Er 2               ; handle overflow and underflow
00175Er 2               
00175Er 2               LAB_2690
00175Er 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001760r 2  10 1B              BPL   LAB_269B          ; do overflow error
001762r 2               
001762r 2                                             ; handle underflow
001762r 2               LAB_2696
001762r 2  68                 PLA                     ; pop return address low byte
001763r 2  68                 PLA                     ; pop return address high byte
001764r 2  4C rr rr           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
001767r 2               
001767r 2               ; multiply by 10
001767r 2               
001767r 2               LAB_269E
001767r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00176Ar 2  AA                 TAX                     ; copy exponent (set the flags)
00176Br 2  F0 F0              BEQ   LAB_268F          ; exit if zero
00176Dr 2               
00176Dr 2  18                 CLC                     ; clear carry for add
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00176Er 2  69 02              ADC   #$02              ; add two to exponent (*4)
001770r 2  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
001772r 2               
001772r 2  A2 00              LDX   #$00              ; clear byte
001774r 2  86 6A              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
001776r 2  20 rr rr           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
001779r 2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*10)
00177Br 2  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
00177Dr 2               
00177Dr 2               LAB_269B
00177Dr 2  4C rr rr           JMP   LAB_2564          ; do overflow error and warm start
001780r 2               
001780r 2               ; divide by 10
001780r 2               
001780r 2               LAB_26B9
001780r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001783r 2  A9 rr              LDA   #<LAB_26B5        ; set pointer to 10d low addr
001785r 2  A0 rr              LDY   #>LAB_26B5        ; set pointer to 10d high addr
001787r 2  A2 00              LDX   #$00              ; clear sign
001789r 2               
001789r 2               ; divide by (AY) (X=sign)
001789r 2               
001789r 2               LAB_26C2
001789r 2  86 6A              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00178Br 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00178Er 2  80 03              BRA   LAB_DIVIDE        ; do FAC2/FAC1
001790r 2               
001790r 2                                             ; Perform divide-by
001790r 2               ; convert AY and do (AY)/FAC1
001790r 2               
001790r 2               LAB_26CA
001790r 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
001793r 2               
001793r 2                                             ; Perform divide-into
001793r 2               LAB_DIVIDE
001793r 2  F0 62              BEQ   LAB_2737          ; if zero go do /0 error
001795r 2               
001795r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
001798r 2  A9 00              LDA   #$00              ; clear A
00179Ar 2  38                 SEC                     ; set carry for subtract
00179Br 2  E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
00179Dr 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
00179Fr 2  20 rr rr           JSR   LAB_2673          ; test and adjust accumulators
0017A2r 2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent
0017A4r 2  F0 D7              BEQ   LAB_269B          ; if zero do overflow error
0017A6r 2               
0017A6r 2  A2 FF              LDX   #$FF              ; set index for pre increment
0017A8r 2  A9 01              LDA   #$01              ; set bit to flag byte save
0017AAr 2               LAB_26E4
0017AAr 2  A4 66              LDY   FAC2_1            ; get FAC2 mantissa1
0017ACr 2  C4 5F              CPY   FAC1_1            ; compare FAC1 mantissa1
0017AEr 2  D0 0A              BNE   LAB_26F4          ; branch if <>
0017B0r 2               
0017B0r 2  A4 67              LDY   FAC2_2            ; get FAC2 mantissa2
0017B2r 2  C4 60              CPY   FAC1_2            ; compare FAC1 mantissa2
0017B4r 2  D0 04              BNE   LAB_26F4          ; branch if <>
0017B6r 2               
0017B6r 2  A4 68              LDY   FAC2_3            ; get FAC2 mantissa3
0017B8r 2  C4 61              CPY   FAC1_3            ; compare FAC1 mantissa3
0017BAr 2               LAB_26F4
0017BAr 2  08                 PHP                     ; save FAC2-FAC1 compare status
0017BBr 2  2A                 ROL                     ; shift the result byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0017BCr 2  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
0017BEr 2               
0017BEr 2  A0 01              LDY   #$01              ; set bit to flag byte save
0017C0r 2  E8                 INX                     ; else increment the index to FACt
0017C1r 2  E0 02              CPX   #$02              ; compare with the index to FACt_3
0017C3r 2  30 04              BMI   LAB_2701          ; if not last byte just go save it
0017C5r 2               
0017C5r 2  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
0017C7r 2                                             ; return
0017C7r 2               
0017C7r 2  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
0017C9r 2               LAB_2701
0017C9r 2  95 27              STA   FACt_1,X          ; write result byte to FACt_1 + index
0017CBr 2  98                 TYA                     ; copy the next save byte flag
0017CCr 2               LAB_2702
0017CCr 2  28                 PLP                     ; restore FAC2-FAC1 compare status
0017CDr 2  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
0017CFr 2               
0017CFr 2  A8                 TAY                     ; save FAC2-FAC1 compare status
0017D0r 2  A5 68              LDA   FAC2_3            ; get FAC2 mantissa3
0017D2r 2  E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
0017D4r 2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
0017D6r 2  A5 67              LDA   FAC2_2            ; get FAC2 mantissa2
0017D8r 2  E5 60              SBC   FAC1_2            ; subtract FAC1 mantissa2
0017DAr 2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
0017DCr 2  A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
0017DEr 2  E5 5F              SBC   FAC1_1            ; subtract FAC1 mantissa1
0017E0r 2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
0017E2r 2  98                 TYA                     ; restore FAC2-FAC1 compare status
0017E3r 2               
0017E3r 2                                             ; FAC2 = FAC2*2
0017E3r 2               LAB_2704
0017E3r 2  06 68              ASL   FAC2_3            ; shift FAC2 mantissa3
0017E5r 2  26 67              ROL   FAC2_2            ; shift FAC2 mantissa2
0017E7r 2  26 66              ROL   FAC2_1            ; shift FAC2 mantissa1
0017E9r 2  B0 CF              BCS   LAB_26F4          ; loop with no compare
0017EBr 2               
0017EBr 2  30 BD              BMI   LAB_26E4          ; loop with compare
0017EDr 2  80 CB              BRA   LAB_26F4          ; loop always with no compare
0017EFr 2               
0017EFr 2               ; do A<<6, save as FAC1 rounding byte, normalise and return
0017EFr 2               
0017EFr 2               LAB_272B
0017EFr 2  4A                 LSR                     ; shift b1 - b0 ..
0017F0r 2  6A                 ROR                     ; ..
0017F1r 2  6A                 ROR                     ; .. to b7 - b6
0017F2r 2  85 6B              STA   FAC1_r            ; save FAC1 rounding byte
0017F4r 2  28                 PLP                     ; dump FAC2-FAC1 compare status
0017F5r 2  80 05              BRA   LAB_273C          ; copy temp to FAC1, normalise and return
0017F7r 2               
0017F7r 2               ; do "Divide by zero" error
0017F7r 2               
0017F7r 2               LAB_2737
0017F7r 2  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
0017F9r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
0017FCr 2               
0017FCr 2               ; copy temp to FAC1 and normalise
0017FCr 2               
0017FCr 2               LAB_273C
0017FCr 2  A5 27              LDA   FACt_1            ; get temp mantissa1
0017FEr 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
001800r 2  A5 28              LDA   FACt_2            ; get temp mantissa2
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001802r 2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
001804r 2  A5 29              LDA   FACt_3            ; get temp mantissa3
001806r 2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
001808r 2  4C rr rr           JMP   LAB_24D5          ; normalise FAC1 and return
00180Br 2               
00180Br 2               ; unpack memory (AY) into FAC1
00180Br 2               
00180Br 2               LAB_UFAC
00180Br 2  85 23              STA   ut1_pl            ; save pointer low byte
00180Dr 2  84 24              STY   ut1_ph            ; save pointer high byte
00180Fr 2  A0 03              LDY   #$03              ; 4 bytes to do
001811r 2  B1 23              LDA   (ut1_pl),Y        ; get last byte
001813r 2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
001815r 2  88                 DEY                     ; decrement index
001816r 2  B1 23              LDA   (ut1_pl),Y        ; get last-1 byte
001818r 2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
00181Ar 2  88                 DEY                     ; decrement index
00181Br 2  B1 23              LDA   (ut1_pl),Y        ; get second byte
00181Dr 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
00181Fr 2  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
001821r 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
001823r 2  88                 DEY                     ; decrement index
001824r 2  B1 23              LDA   (ut1_pl),Y        ; get first byte (exponent)
001826r 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
001828r 2  84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
00182Ar 2  60                 RTS
00182Br 2               
00182Br 2               ; pack FAC1 into Adatal
00182Br 2               
00182Br 2               LAB_276E
00182Br 2  A2 56              LDX   #<Adatal          ; set pointer low byte
00182Dr 2               LAB_2770
00182Dr 2  A0 00              LDY   #>Adatal          ; set pointer high byte
00182Fr 2  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
001831r 2               
001831r 2               ; pack FAC1 into (Lvarpl)
001831r 2               
001831r 2               LAB_PFAC
001831r 2  A6 49              LDX   Lvarpl            ; get destination pointer low byte
001833r 2  A4 4A              LDY   Lvarph            ; get destination pointer high byte
001835r 2               
001835r 2               ; pack FAC1 into (XY)
001835r 2               
001835r 2               LAB_2778
001835r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
001838r 2  86 23              STX   ut1_pl            ; save pointer low byte
00183Ar 2  84 24              STY   ut1_ph            ; save pointer high byte
00183Cr 2  A0 03              LDY   #$03              ; set index
00183Er 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
001840r 2  91 23              STA   (ut1_pl),Y        ; store in destination
001842r 2  88                 DEY                     ; decrement index
001843r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
001845r 2  91 23              STA   (ut1_pl),Y        ; store in destination
001847r 2  88                 DEY                     ; decrement index
001848r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
00184Ar 2  09 7F              ORA   #$7F              ; set bits x111 1111
00184Cr 2  25 5F              AND   FAC1_1            ; AND in FAC1 mantissa1
00184Er 2  91 23              STA   (ut1_pl),Y        ; store in destination
001850r 2  88                 DEY                     ; decrement index
001851r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001853r 2  91 23              STA   (ut1_pl),Y        ; store in destination
001855r 2  84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001857r 2  60                 RTS
001858r 2               
001858r 2               ; round and copy FAC1 to FAC2
001858r 2               
001858r 2               LAB_27AB
001858r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
00185Br 2               
00185Br 2               ; copy FAC1 to FAC2
00185Br 2               
00185Br 2               LAB_27AE
00185Br 2  A2 05              LDX   #$05              ; 5 bytes to copy
00185Dr 2               LAB_27B0
00185Dr 2  B5 5D              LDA   FAC1_e-1,X        ; get byte from FAC1,X
00185Fr 2  95 64              STA   FAC1_o,X          ; save byte at FAC2,X
001861r 2  CA                 DEX                     ; decrement count
001862r 2  D0 F9              BNE   LAB_27B0          ; loop if not all done
001864r 2               
001864r 2  86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
001866r 2               LAB_27B9
001866r 2  60                 RTS
001867r 2               
001867r 2               ; round FAC1
001867r 2               
001867r 2               LAB_27BA
001867r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001869r 2  F0 FB              BEQ   LAB_27B9          ; exit if zero
00186Br 2               
00186Br 2  06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
00186Dr 2  90 F7              BCC   LAB_27B9          ; exit if no overflow
00186Fr 2               
00186Fr 2               ; round FAC1 (no check)
00186Fr 2               
00186Fr 2               LAB_27C2
00186Fr 2  20 rr rr           JSR   LAB_2559          ; increment FAC1 mantissa
001872r 2  D0 F2              BNE   LAB_27B9          ; branch if no overflow
001874r 2               
001874r 2  4C rr rr           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
001877r 2               
001877r 2               ; get FAC1 sign
001877r 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
001877r 2               
001877r 2               LAB_27CA
001877r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001879r 2  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
00187Br 2               
00187Br 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00187Br 2               ; no = 0 check
00187Br 2               
00187Br 2               LAB_27CE
00187Br 2  A5 62              LDA   FAC1_s            ; else get FAC1 sign (b7)
00187Dr 2               
00187Dr 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00187Dr 2               ; no = 0 check, sign in A
00187Dr 2               
00187Dr 2               LAB_27D0
00187Dr 2  2A                 ROL                     ; move sign bit to carry
00187Er 2  A9 FF              LDA   #$FF              ; set byte for -ve result
001880r 2  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
001882r 2               
001882r 2  A9 01              LDA   #$01              ; else set byte for +ve result
001884r 2               LAB_27D7
001884r 2  60                 RTS
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001885r 2               
001885r 2               ; perform SGN()
001885r 2               
001885r 2               LAB_SGN
001885r 2  20 rr rr           JSR   LAB_27CA          ; get FAC1 sign
001888r 2                                             ; return A=$FF/-ve A=$01/+ve
001888r 2               ; save A as integer byte
001888r 2               
001888r 2               LAB_27DB
001888r 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
00188Ar 2  64 60              STZ   FAC1_2            ; clear FAC1 mantissa2
00188Cr 2  A2 88              LDX   #$88              ; set exponent
00188Er 2               
00188Er 2               ; set exp=X, clearFAC1 mantissa3 and normalise
00188Er 2               
00188Er 2               LAB_27E3
00188Er 2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
001890r 2  49 FF              EOR   #$FF              ; complement it
001892r 2  2A                 ROL                     ; sign bit into carry
001893r 2               
001893r 2               ; set exp=X, clearFAC1 mantissa3 and normalise
001893r 2               
001893r 2               LAB_STFA
001893r 2  64 61              STZ   FAC1_3            ; clear FAC1 mantissa3
001895r 2  86 5E              STX   FAC1_e            ; set FAC1 exponent
001897r 2  64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
001899r 2  64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
00189Br 2  4C rr rr           JMP   LAB_24D0          ; do ABS and normalise FAC1
00189Er 2               
00189Er 2               ; perform ABS()
00189Er 2               
00189Er 2               LAB_ABS
00189Er 2  46 62              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
0018A0r 2  60                 RTS
0018A1r 2               
0018A1r 2               ; compare FAC1 with (AY)
0018A1r 2               ; returns A=$00 if FAC1 = (AY)
0018A1r 2               ; returns A=$01 if FAC1 > (AY)
0018A1r 2               ; returns A=$FF if FAC1 < (AY)
0018A1r 2               
0018A1r 2               LAB_27F8
0018A1r 2  85 25              STA   ut2_pl            ; save pointer low byte
0018A3r 2               LAB_27FA
0018A3r 2  84 26              STY   ut2_ph            ; save pointer high byte
0018A5r 2  A0 00              LDY   #$00              ; clear index
0018A7r 2  B1 25              LDA   (ut2_pl),Y        ; get exponent
0018A9r 2  C8                 INY                     ; increment index
0018AAr 2  AA                 TAX                     ; copy (AY) exponent to X
0018ABr 2  F0 CA              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
0018ADr 2                                             ; A=FF,C=1/-ve A=01,C=0/+ve
0018ADr 2               
0018ADr 2  B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
0018AFr 2  45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
0018B1r 2  30 C8              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
0018B3r 2                                             ; A=01,C=0/+ve and return
0018B3r 2               
0018B3r 2  E4 5E              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
0018B5r 2  D0 1A              BNE   LAB_2828          ; branch if different
0018B7r 2               
0018B7r 2  B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
0018B9r 2  09 80              ORA   #$80              ; normalise top bit
0018BBr 2  C5 5F              CMP   FAC1_1            ; compare with FAC1 mantissa1
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0018BDr 2  D0 12              BNE   LAB_2828          ; branch if different
0018BFr 2               
0018BFr 2  C8                 INY                     ; increment index
0018C0r 2  B1 25              LDA   (ut2_pl),Y        ; get mantissa2
0018C2r 2  C5 60              CMP   FAC1_2            ; compare with FAC1 mantissa2
0018C4r 2  D0 0B              BNE   LAB_2828          ; branch if different
0018C6r 2               
0018C6r 2  C8                 INY                     ; increment index
0018C7r 2  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
0018C9r 2  C5 6B              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
0018CBr 2  B1 25              LDA   (ut2_pl),Y        ; get mantissa3
0018CDr 2  E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
0018CFr 2  F0 27              BEQ   LAB_2850          ; exit if mantissa3 equal
0018D1r 2               
0018D1r 2               ; gets here if number <> FAC1
0018D1r 2               
0018D1r 2               LAB_2828
0018D1r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
0018D3r 2  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
0018D5r 2               
0018D5r 2  49 FF              EOR   #$FF              ; else toggle FAC1 sign
0018D7r 2               LAB_282E
0018D7r 2  80 A4              BRA   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
0018D9r 2               
0018D9r 2               ; convert FAC1 floating-to-fixed
0018D9r 2               
0018D9r 2               LAB_2831
0018D9r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
0018DBr 2  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
0018DDr 2               
0018DDr 2  38                 SEC                     ; set carry for subtract
0018DEr 2  E9 98              SBC   #$98              ; subtract maximum integer range exponent
0018E0r 2  24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
0018E2r 2  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
0018E4r 2               
0018E4r 2                                             ; FAC1 was -ve
0018E4r 2  AA                 TAX                     ; copy subtracted exponent
0018E5r 2  A9 FF              LDA   #$FF              ; overflow for -ve number
0018E7r 2  85 64              STA   FAC1_o            ; set FAC1 overflow byte
0018E9r 2  20 rr rr           JSR   LAB_253D          ; twos complement FAC1 mantissa
0018ECr 2  8A                 TXA                     ; restore subtracted exponent
0018EDr 2               LAB_2845
0018EDr 2  A2 5E              LDX   #FAC1_e           ; set index to FAC1
0018EFr 2  C9 F9              CMP   #$F9              ; compare exponent result
0018F1r 2  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
0018F3r 2               
0018F3r 2  20 rr rr           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
0018F6r 2  84 64              STY   FAC1_o            ; clear FAC1 overflow byte
0018F8r 2               LAB_2850
0018F8r 2  60                 RTS
0018F9r 2               
0018F9r 2               ; shift FAC1 A times right
0018F9r 2               
0018F9r 2               LAB_2851
0018F9r 2  A8                 TAY                     ; copy shift count
0018FAr 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
0018FCr 2  29 80              AND   #$80              ; mask sign bit only (x000 0000)
0018FEr 2  46 5F              LSR   FAC1_1            ; shift FAC1 mantissa1
001900r 2  05 5F              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
001902r 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
001904r 2  20 rr rr           JSR   LAB_2592          ; shift FAC1 Y times right
001907r 2  84 64              STY   FAC1_o            ; clear FAC1 overflow byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001909r 2  60                 RTS
00190Ar 2               
00190Ar 2               ; perform INT()
00190Ar 2               
00190Ar 2               LAB_INT
00190Ar 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
00190Cr 2  C9 98              CMP   #$98              ; compare with max int
00190Er 2  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
001910r 2               
001910r 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
001913r 2  84 6B              STY   FAC1_r            ; save FAC1 rounding byte
001915r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001917r 2  84 62              STY   FAC1_s            ; save FAC1 sign (b7)
001919r 2  49 80              EOR   #$80              ; toggle FAC1 sign
00191Br 2  2A                 ROL                     ; shift into carry
00191Cr 2  A9 98              LDA   #$98              ; set new exponent
00191Er 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
001920r 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
001922r 2  85 0D              STA   Temp3             ; save for EXP() function
001924r 2  4C rr rr           JMP   LAB_24D0          ; do ABS and normalise FAC1
001927r 2               
001927r 2               ; clear FAC1 and return
001927r 2               
001927r 2               LAB_287F
001927r 2  85 5F              STA   FAC1_1            ; clear FAC1 mantissa1
001929r 2  85 60              STA   FAC1_2            ; clear FAC1 mantissa2
00192Br 2  85 61              STA   FAC1_3            ; clear FAC1 mantissa3
00192Dr 2  A8                 TAY                     ; clear Y
00192Er 2               LAB_2886
00192Er 2  60                 RTS
00192Fr 2               
00192Fr 2               ; get FAC1 from string
00192Fr 2               ; this routine now handles hex and binary values from strings
00192Fr 2               ; starting with "$" and "%" respectively
00192Fr 2               
00192Fr 2               LAB_2887
00192Fr 2  64 11              STZ   Dtypef            ; clear data type flag, $FF=string, $00=numeric
001931r 2  A2 09              LDX   #$09              ; set index
001933r 2               LAB_288B
001933r 2  74 5A              STZ   numexp,X          ; clear byte
001935r 2  CA                 DEX                     ; decrement index
001936r 2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
001938r 2  90 7E              BCC   LAB_28FE          ; branch if 1st character numeric
00193Ar 2               
00193Ar 2               ; get FAC1 from string .. first character wasn't numeric
00193Ar 2               
00193Ar 2  C9 2D              CMP   #'-'              ; else compare with "-"
00193Cr 2  D0 04              BNE   LAB_289A          ; branch if not "-"
00193Er 2               
00193Er 2  86 63              STX   negnum            ; set flag for -ve number (X = $FF)
001940r 2  80 04              BRA   LAB_289C          ; branch always (go scan and check for hex/bin)
001942r 2               
001942r 2               ; get FAC1 from string .. first character wasn't numeric or -
001942r 2               
001942r 2               LAB_289A
001942r 2  C9 2B              CMP   #'+'              ; else compare with "+"
001944r 2  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
001946r 2               
001946r 2               ; was "+" or "-" to start, so get next character
001946r 2               
001946r 2               LAB_289C
001946r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001949r 2  90 6D              BCC   LAB_28FE          ; branch if numeric character
00194Br 2               
00194Br 2               ; code here for hex and binary numbers
00194Br 2               
00194Br 2               LAB_289D
00194Br 2  C9 24              CMP   #'$'              ; else compare with "$"
00194Dr 2  D0 03              BNE   LAB_NHEX          ; branch if not "$"
00194Fr 2               
00194Fr 2  4C rr rr           JMP   LAB_CHEX          ; branch if "$"
001952r 2               
001952r 2               LAB_NHEX
001952r 2  C9 25              CMP   #'%'              ; else compare with "%"
001954r 2  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
001956r 2               
001956r 2  4C rr rr           JMP   LAB_CBIN          ; branch if "%"
001959r 2               
001959r 2               LAB_289E
001959r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
00195Cr 2               LAB_28A1
00195Cr 2  90 5A              BCC   LAB_28FE          ; branch if numeric character
00195Er 2               
00195Er 2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
00195Er 2               
00195Er 2               LAB_28A3
00195Er 2  C9 2E              CMP   #'.'              ; else compare with "."
001960r 2  F0 2D              BEQ   LAB_28D5          ; branch if "."
001962r 2               
001962r 2               ; get FAC1 from string .. character wasn't numeric, -, + or .
001962r 2               
001962r 2  C9 45              CMP   #'E'              ; else compare with "E"
001964r 2  D0 2F              BNE   LAB_28DB          ; branch if not "E"
001966r 2               
001966r 2                                             ; was "E" so evaluate exponential part
001966r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
001969r 2  90 17              BCC   LAB_28C7          ; branch if numeric character
00196Br 2               
00196Br 2  C9 B3              CMP   #TK_MINUS         ; else compare with token for -
00196Dr 2  F0 0E              BEQ   LAB_28C2          ; branch if token for -
00196Fr 2               
00196Fr 2  C9 2D              CMP   #'-'              ; else compare with "-"
001971r 2  F0 0A              BEQ   LAB_28C2          ; branch if "-"
001973r 2               
001973r 2  C9 B2              CMP   #TK_PLUS          ; else compare with token for +
001975r 2  F0 08              BEQ   LAB_28C4          ; branch if token for +
001977r 2               
001977r 2  C9 2B              CMP   #'+'              ; else compare with "+"
001979r 2  F0 04              BEQ   LAB_28C4          ; branch if "+"
00197Br 2  80 07              BRA   LAB_28C9          ; branch always
00197Dr 2               
00197Dr 2               LAB_28C2
00197Dr 2  66 5D              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
00197Fr 2               LAB_28C4
00197Fr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
001982r 2               LAB_28C7
001982r 2  90 59              BCC   LAB_2925          ; branch if numeric character
001984r 2               
001984r 2               LAB_28C9
001984r 2  24 5D              BIT   expneg            ; test exponent -ve flag
001986r 2  10 0D              BPL   LAB_28DB          ; if +ve go evaluate exponent
001988r 2               
001988r 2                                             ; else do exponent = -exponent
001988r 2  A9 00              LDA   #$00              ; clear result
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00198Ar 2  38                 SEC                     ; set carry for subtract
00198Br 2  E5 5B              SBC   expcnt            ; subtract exponent byte
00198Dr 2  80 08              BRA   LAB_28DD          ; go evaluate exponent
00198Fr 2               
00198Fr 2               LAB_28D5
00198Fr 2  66 5C              ROR   numdpf            ; set decimal point flag
001991r 2  24 5C              BIT   numdpf            ; test decimal point flag
001993r 2  50 C4              BVC   LAB_289E          ; branch if only one decimal point so far
001995r 2               
001995r 2                                             ; evaluate exponent
001995r 2               LAB_28DB
001995r 2  A5 5B              LDA   expcnt            ; get exponent count byte
001997r 2               LAB_28DD
001997r 2  38                 SEC                     ; set carry for subtract
001998r 2  E5 5A              SBC   numexp            ; subtract numerator exponent
00199Ar 2  85 5B              STA   expcnt            ; save exponent count byte
00199Cr 2  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
00199Er 2  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
0019A0r 2               
0019A0r 2                                             ; else go do FAC1/10^(0-expcnt)
0019A0r 2               LAB_28E6
0019A0r 2  20 rr rr           JSR   LAB_26B9          ; divide by 10
0019A3r 2  E6 5B              INC   expcnt            ; increment exponent count byte
0019A5r 2  D0 F9              BNE   LAB_28E6          ; loop until all done
0019A7r 2  80 07              BRA   LAB_28F6          ; branch always
0019A9r 2               
0019A9r 2               LAB_28EF
0019A9r 2  20 rr rr           JSR   LAB_269E          ; multiply by 10
0019ACr 2  C6 5B              DEC   expcnt            ; decrement exponent count byte
0019AEr 2  D0 F9              BNE   LAB_28EF          ; loop until all done
0019B0r 2               
0019B0r 2               LAB_28F6
0019B0r 2  A5 63              LDA   negnum            ; get -ve flag
0019B2r 2  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
0019B4r 2  60                 RTS
0019B5r 2               
0019B5r 2               ; do - FAC1 and return
0019B5r 2               
0019B5r 2               LAB_28FB
0019B5r 2  4C rr rr           JMP   LAB_GTHAN         ; do - FAC1 and return
0019B8r 2               
0019B8r 2               ; do unsigned FAC1*10+number
0019B8r 2               
0019B8r 2               LAB_28FE
0019B8r 2  48                 PHA                     ; save character
0019B9r 2  24 5C              BIT   numdpf            ; test decimal point flag
0019BBr 2  10 02              BPL   LAB_2905          ; skip exponent increment if not set
0019BDr 2               
0019BDr 2  E6 5A              INC   numexp            ; else increment number exponent
0019BFr 2               LAB_2905
0019BFr 2  20 rr rr           JSR   LAB_269E          ; multiply FAC1 by 10
0019C2r 2  68                 PLA                     ; restore character
0019C3r 2  29 0F              AND   #$0F              ; convert to binary
0019C5r 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
0019C8r 2  80 8F              BRA   LAB_289E          ; go do next character
0019CAr 2               
0019CAr 2               ; evaluate new ASCII digit
0019CAr 2               
0019CAr 2               LAB_2912
0019CAr 2  48                 PHA                     ; save digit
0019CBr 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
0019CEr 2  68                 PLA                     ; restore digit
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0019CFr 2  20 rr rr           JSR   LAB_27DB          ; save A as integer byte
0019D2r 2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
0019D4r 2  45 62              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
0019D6r 2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
0019D8r 2  A6 5E              LDX   FAC1_e            ; get FAC1 exponent
0019DAr 2  4C rr rr           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
0019DDr 2               
0019DDr 2               ; evaluate next character of exponential part of number
0019DDr 2               
0019DDr 2               LAB_2925
0019DDr 2  A5 5B              LDA   expcnt            ; get exponent count byte
0019DFr 2  C9 0A              CMP   #$0A              ; compare with 10 decimal
0019E1r 2  90 09              BCC   LAB_2934          ; branch if less
0019E3r 2               
0019E3r 2  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
0019E5r 2  24 5D              BIT   expneg            ; test exponent -ve flag
0019E7r 2  30 0C              BMI   LAB_2942          ; branch if -ve
0019E9r 2               
0019E9r 2  4C rr rr           JMP   LAB_2564          ; else do overflow error
0019ECr 2               
0019ECr 2               LAB_2934
0019ECr 2  0A                 ASL                     ; * 2
0019EDr 2  0A                 ASL                     ; * 4
0019EEr 2  65 5B              ADC   expcnt            ; * 5
0019F0r 2  0A                 ASL                     ; * 10
0019F1r 2  72 6E              ADC   (Bpntrl)          ; add character (will be $30 too much!)
0019F3r 2  E9 2F              SBC   #'0'-1            ; convert character to binary
0019F5r 2               LAB_2942
0019F5r 2  85 5B              STA   expcnt            ; save exponent count byte
0019F7r 2  80 86              BRA   LAB_28C4          ; go get next character
0019F9r 2               
0019F9r 2               ; print " in line [LINE #]"
0019F9r 2               
0019F9r 2               LAB_2953
0019F9r 2  A9 rr              LDA   #<LAB_LMSG        ; point to " in line " message low byte
0019FBr 2  A0 rr              LDY   #>LAB_LMSG        ; point to " in line " message high byte
0019FDr 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
001A00r 2               
001A00r 2                                             ; print Basic line #
001A00r 2  A5 3A              LDA   Clineh            ; get current line high byte
001A02r 2  A6 39              LDX   Clinel            ; get current line low byte
001A04r 2               
001A04r 2               ; print XA as unsigned integer
001A04r 2               
001A04r 2               LAB_295E
001A04r 2  85 5F              STA   FAC1_1            ; save low byte as FAC1 mantissa1
001A06r 2  86 60              STX   FAC1_2            ; save high byte as FAC1 mantissa2
001A08r 2  A2 90              LDX   #$90              ; set exponent to 16d bits
001A0Ar 2  38                 SEC                     ; set integer is +ve flag
001A0Br 2  20 rr rr           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
001A0Er 2  A0 00              LDY   #$00              ; clear index
001A10r 2  98                 TYA                     ; clear A
001A11r 2  20 rr rr           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
001A14r 2  4C rr rr           JMP   LAB_18C3          ; print null terminated string from memory and return
001A17r 2               
001A17r 2               ; convert FAC1 to ASCII string result in (AY)
001A17r 2               ; not any more, moved scratchpad to page 0
001A17r 2               
001A17r 2               LAB_296E
001A17r 2  A0 01              LDY   #$01              ; set index = 1
001A19r 2  A9 20              LDA   #$20              ; character = " " (assume +ve)
001A1Br 2  24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001A1Dr 2  10 02              BPL   LAB_2978          ; branch if +ve
001A1Fr 2               
001A1Fr 2  A9 2D              LDA   #$2D              ; else character = "-"
001A21r 2               LAB_2978
001A21r 2  99 74 00           STA   Decss,Y           ; save leading character (" " or "-")
001A24r 2               LAB_297B
001A24r 2  85 62              STA   FAC1_s            ; clear FAC1 sign (b7)
001A26r 2  84 6C              STY   Sendl             ; save index
001A28r 2  C8                 INY                     ; increment index
001A29r 2  A6 5E              LDX   FAC1_e            ; get FAC1 exponent
001A2Br 2  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
001A2Dr 2               
001A2Dr 2                                             ; exponent was $00 so FAC1 is 0
001A2Dr 2  A9 30              LDA   #'0'              ; set character = "0"
001A2Fr 2  4C rr rr           JMP   LAB_2A89          ; save last character, [EOT] and exit
001A32r 2               
001A32r 2                                             ; FAC1 is some non zero value
001A32r 2               LAB_2989
001A32r 2  A9 00              LDA   #$00              ; clear (number exponent count)
001A34r 2  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
001A36r 2               
001A36r 2  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
001A38r 2               
001A38r 2                                             ; FAC1<1
001A38r 2  A9 rr              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
001A3Ar 2  A0 rr              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
001A3Cr 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001A3Fr 2  A9 FA              LDA   #$FA              ; set number exponent count (-6)
001A41r 2               LAB_299A
001A41r 2  85 5A              STA   numexp            ; save number exponent count
001A43r 2               LAB_299C
001A43r 2  A9 rr              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
001A45r 2  A0 rr              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
001A47r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
001A4Ar 2  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
001A4Cr 2               
001A4Cr 2  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
001A4Er 2               
001A4Er 2                                             ; FAC1 < (AY)
001A4Er 2               LAB_29A7
001A4Er 2  A9 rr              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
001A50r 2  A0 rr              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
001A52r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
001A55r 2  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
001A57r 2  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
001A59r 2               
001A59r 2                                             ; FAC1 <= (AY)
001A59r 2               LAB_29B2
001A59r 2  20 rr rr           JSR   LAB_269E          ; multiply by 10
001A5Cr 2  C6 5A              DEC   numexp            ; decrement number exponent count
001A5Er 2  80 EE              BRA   LAB_29A7          ; go test again (branch always)
001A60r 2               
001A60r 2               LAB_29B9
001A60r 2  20 rr rr           JSR   LAB_26B9          ; divide by 10
001A63r 2  E6 5A              INC   numexp            ; increment number exponent count
001A65r 2  80 DC              BRA   LAB_299C          ; go test again (branch always)
001A67r 2               
001A67r 2               ; now we have just the digits to do
001A67r 2               
001A67r 2               LAB_29C0
001A67r 2  20 rr rr           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
001A6Ar 2               LAB_29C3
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001A6Ar 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
001A6Dr 2  A2 01              LDX   #$01              ; set default digits before dp = 1
001A6Fr 2  A5 5A              LDA   numexp            ; get number exponent count
001A71r 2  18                 CLC                     ; clear carry for add
001A72r 2  69 07              ADC   #$07              ; up to 6 digits before point
001A74r 2  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
001A76r 2               
001A76r 2  C9 08              CMP   #$08              ; A>=8 if n>=1E6
001A78r 2  B0 06              BCS   LAB_29D9          ; branch if >= $08
001A7Ar 2               
001A7Ar 2                                             ; carry is clear
001A7Ar 2  69 FF              ADC   #$FF              ; take 1 from digit count
001A7Cr 2  AA                 TAX                     ; copy to A
001A7Dr 2  A9 02              LDA   #$02              ;.set exponent adjust
001A7Fr 2               LAB_29D8
001A7Fr 2  38                 SEC                     ; set carry for subtract
001A80r 2               LAB_29D9
001A80r 2  E9 02              SBC   #$02              ; -2
001A82r 2  85 5B              STA   expcnt            ; save exponent adjust
001A84r 2  86 5A              STX   numexp            ; save digits before dp count
001A86r 2  8A                 TXA                     ; copy to A
001A87r 2  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
001A89r 2  10 13              BPL   LAB_29F7          ; branch if digits before dp
001A8Br 2               
001A8Br 2               LAB_29E4
001A8Br 2  A4 6C              LDY   Sendl             ; get output string index
001A8Dr 2  A9 2E              LDA   #$2E              ; character "."
001A8Fr 2  C8                 INY                     ; increment index
001A90r 2  99 74 00           STA   Decss,Y           ; save to output string
001A93r 2  8A                 TXA                     ;
001A94r 2  F0 06              BEQ   LAB_29F5          ;
001A96r 2               
001A96r 2  A9 30              LDA   #'0'              ; character "0"
001A98r 2  C8                 INY                     ; increment index
001A99r 2  99 74 00           STA   Decss,Y           ; save to output string
001A9Cr 2               LAB_29F5
001A9Cr 2  84 6C              STY   Sendl             ; save output string index
001A9Er 2               LAB_29F7
001A9Er 2  A0 00              LDY   #$00              ; clear index (point to 100,000)
001AA0r 2  A2 80              LDX   #$80              ;
001AA2r 2               LAB_29FB
001AA2r 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
001AA4r 2  18                 CLC                     ; clear carry for add
001AA5r 2  79 rr rr           ADC   LAB_2A9C,Y        ; add -ve LSB
001AA8r 2  85 61              STA   FAC1_3            ; save FAC1 mantissa3
001AAAr 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
001AACr 2  79 rr rr           ADC   LAB_2A9B,Y        ; add -ve NMSB
001AAFr 2  85 60              STA   FAC1_2            ; save FAC1 mantissa2
001AB1r 2  A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
001AB3r 2  79 rr rr           ADC   LAB_2A9A,Y        ; add -ve MSB
001AB6r 2  85 5F              STA   FAC1_1            ; save FAC1 mantissa1
001AB8r 2  E8                 INX                     ;
001AB9r 2  B0 04              BCS   LAB_2A18          ;
001ABBr 2               
001ABBr 2  10 E5              BPL   LAB_29FB          ; not -ve so try again
001ABDr 2               
001ABDr 2  30 02              BMI   LAB_2A1A          ;
001ABFr 2               
001ABFr 2               LAB_2A18
001ABFr 2  30 E1              BMI   LAB_29FB          ;
001AC1r 2               
001AC1r 2               LAB_2A1A
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001AC1r 2  8A                 TXA                     ;
001AC2r 2  90 04              BCC   LAB_2A21          ;
001AC4r 2               
001AC4r 2  49 FF              EOR   #$FF              ;
001AC6r 2  69 0A              ADC   #$0A              ;
001AC8r 2               LAB_2A21
001AC8r 2  69 2F              ADC   #'0'-1            ; add "0"-1 to result
001ACAr 2  C8                 INY                     ; increment index ..
001ACBr 2  C8                 INY                     ; .. to next less ..
001ACCr 2  C8                 INY                     ; .. power of ten
001ACDr 2  84 47              STY   Cvaral            ; save as current var address low byte
001ACFr 2  A4 6C              LDY   Sendl             ; get output string index
001AD1r 2  C8                 INY                     ; increment output string index
001AD2r 2  AA                 TAX                     ; copy character to X
001AD3r 2  29 7F              AND   #$7F              ; mask out top bit
001AD5r 2  99 74 00           STA   Decss,Y           ; save to output string
001AD8r 2  C6 5A              DEC   numexp            ; decrement # of characters before the dp
001ADAr 2  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
001ADCr 2               
001ADCr 2                                             ; else output the point
001ADCr 2  A9 2E              LDA   #$2E              ; character "."
001ADEr 2  C8                 INY                     ; increment output string index
001ADFr 2  99 74 00           STA   Decss,Y           ; save to output string
001AE2r 2               LAB_2A3B
001AE2r 2  84 6C              STY   Sendl             ; save output string index
001AE4r 2  A4 47              LDY   Cvaral            ; get current var address low byte
001AE6r 2  8A                 TXA                     ; get character back
001AE7r 2  49 FF              EOR   #$FF              ;
001AE9r 2  29 80              AND   #$80              ;
001AEBr 2  AA                 TAX                     ;
001AECr 2  C0 12              CPY   #$12              ; compare index with max
001AEEr 2  D0 B2              BNE   LAB_29FB          ; loop if not max
001AF0r 2               
001AF0r 2                                             ; now remove trailing zeroes
001AF0r 2  A4 6C              LDY   Sendl             ; get output string index
001AF2r 2               LAB_2A4B
001AF2r 2  B9 74 00           LDA   Decss,Y           ; get character from output string
001AF5r 2  88                 DEY                     ; decrement output string index
001AF6r 2  C9 30              CMP   #'0'              ; compare with "0"
001AF8r 2  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
001AFAr 2               
001AFAr 2  C9 2E              CMP   #'.'              ; compare with "."
001AFCr 2  F0 01              BEQ   LAB_2A58          ; branch if was dp
001AFEr 2               
001AFEr 2                                             ; restore last character
001AFEr 2  C8                 INY                     ; increment output string index
001AFFr 2               LAB_2A58
001AFFr 2  A9 2B              LDA   #$2B              ; character "+"
001B01r 2  A6 5B              LDX   expcnt            ; get exponent count
001B03r 2  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
001B05r 2               
001B05r 2                                             ; exponent isn't zero so write exponent
001B05r 2  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
001B07r 2               
001B07r 2  A9 00              LDA   #$00              ; clear A
001B09r 2  38                 SEC                     ; set carry for subtract
001B0Ar 2  E5 5B              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
001B0Cr 2  AA                 TAX                     ; copy exponent count to X
001B0Dr 2  A9 2D              LDA   #'-'              ; character "-"
001B0Fr 2               LAB_2A68
001B0Fr 2  99 76 00           STA   Decss+2,Y         ; save to output string
001B12r 2  A9 45              LDA   #$45              ; character "E"
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001B14r 2  99 75 00           STA   Decss+1,Y         ; save exponent sign to output string
001B17r 2  8A                 TXA                     ; get exponent count back
001B18r 2  A2 2F              LDX   #'0'-1            ; one less than "0" character
001B1Ar 2  38                 SEC                     ; set carry for subtract
001B1Br 2               LAB_2A74
001B1Br 2  E8                 INX                     ; increment 10's character
001B1Cr 2  E9 0A              SBC   #$0A              ; subtract 10 from exponent count
001B1Er 2  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
001B20r 2               
001B20r 2  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
001B22r 2  99 78 00           STA   Decss+4,Y         ; save to output string
001B25r 2  8A                 TXA                     ; copy 10's character
001B26r 2  99 77 00           STA   Decss+3,Y         ; save to output string
001B29r 2  A9 00              LDA   #$00              ; set null terminator
001B2Br 2  99 79 00           STA   Decss+5,Y         ; save to output string
001B2Er 2  80 08              BRA   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
001B30r 2               
001B30r 2                                             ; save last character, [EOT] and exit
001B30r 2               LAB_2A89
001B30r 2  99 74 00           STA   Decss,Y           ; save last character to output string
001B33r 2               
001B33r 2                                             ; set null terminator and exit
001B33r 2               LAB_2A8C
001B33r 2  A9 00              LDA   #$00              ; set null terminator
001B35r 2  99 75 00           STA   Decss+1,Y         ; save after last character
001B38r 2               
001B38r 2                                             ; set string pointer (AY) and exit
001B38r 2               LAB_2A91
001B38r 2  A9 75              LDA   #<Decssp1         ; set result string low pointer
001B3Ar 2  A0 00              LDY   #>Decssp1         ; set result string high pointer
001B3Cr 2  60                 RTS
001B3Dr 2               
001B3Dr 2               ; perform power function
001B3Dr 2               
001B3Dr 2               LAB_POWER
001B3Dr 2  F0 42              BEQ   LAB_EXP           ; go do  EXP()
001B3Fr 2               
001B3Fr 2  A5 65              LDA   FAC2_e            ; get FAC2 exponent
001B41r 2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
001B43r 2               
001B43r 2  4C rr rr           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
001B46r 2               
001B46r 2               LAB_2ABF
001B46r 2  A2 4E              LDX   #<func_l          ; set destination pointer low byte
001B48r 2  A0 00              LDY   #>func_l          ; set destination pointer high byte
001B4Ar 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 into (XY)
001B4Dr 2  A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
001B4Fr 2  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
001B51r 2               
001B51r 2                                             ; else FAC2 is -ve and can only be raised to an
001B51r 2                                             ; integer power which gives an x +j0 result
001B51r 2  20 rr rr           JSR   LAB_INT           ; perform INT
001B54r 2  A9 4E              LDA   #<func_l          ; set source pointer low byte
001B56r 2  A0 00              LDY   #>func_l          ; set source pointer high byte
001B58r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
001B5Br 2  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
001B5Dr 2                                             ; this will leave FAC1 -ve and cause a Function Call
001B5Dr 2                                             ; error when LOG() is called
001B5Dr 2               
001B5Dr 2  98                 TYA                     ; clear sign b7
001B5Er 2  A4 0D              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
001B60r 2                                             ; for possible later negation, b0
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001B60r 2               LAB_2AD9
001B60r 2  20 rr rr           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
001B63r 2  98                 TYA                     ; copy sign back ..
001B64r 2  48                 PHA                     ; .. and save it
001B65r 2  20 rr rr           JSR   LAB_LOG           ; do LOG(n)
001B68r 2  A9 4E              LDA   #<garb_l          ; set pointer low byte
001B6Ar 2  A0 00              LDY   #>garb_l          ; set pointer high byte
001B6Cr 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
001B6Fr 2  20 rr rr           JSR   LAB_EXP           ; go do EXP(n)
001B72r 2  68                 PLA                     ; pull sign from stack
001B73r 2  4A                 LSR                     ; b0 is to be tested, shift to Cb
001B74r 2  90 0A              BCC   LAB_2AF9          ; if no bit then exit
001B76r 2               
001B76r 2                                             ; Perform negation
001B76r 2               ; do - FAC1
001B76r 2               
001B76r 2               LAB_GTHAN
001B76r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001B78r 2  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
001B7Ar 2               
001B7Ar 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001B7Cr 2  49 FF              EOR   #$FF              ; complement it
001B7Er 2  85 62              STA   FAC1_s            ; save FAC1 sign (b7)
001B80r 2               LAB_2AF9
001B80r 2  60                 RTS
001B81r 2               
001B81r 2               ; perform EXP()   (x^e)
001B81r 2               
001B81r 2               LAB_EXP
001B81r 2  A9 rr              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
001B83r 2  A0 rr              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
001B85r 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001B88r 2  A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
001B8Ar 2  69 50              ADC   #$50              ; +$50/$100
001B8Cr 2  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
001B8Er 2               
001B8Er 2  20 rr rr           JSR   LAB_27C2          ; round FAC1 (no check)
001B91r 2               LAB_2B2B
001B91r 2  85 55              STA   FAC2_r            ; save FAC2 rounding byte
001B93r 2  20 rr rr           JSR   LAB_27AE          ; copy FAC1 to FAC2
001B96r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001B98r 2  C9 88              CMP   #$88              ; compare with EXP limit (256d)
001B9Ar 2  90 03              BCC   LAB_2B39          ; branch if less
001B9Cr 2               
001B9Cr 2               LAB_2B36
001B9Cr 2  20 rr rr           JSR   LAB_2690          ; handle overflow and underflow
001B9Fr 2               LAB_2B39
001B9Fr 2  20 rr rr           JSR   LAB_INT           ; perform INT
001BA2r 2  A5 0D              LDA   Temp3             ; get mantissa 3 from INT() function
001BA4r 2  18                 CLC                     ; clear carry for add
001BA5r 2  69 81              ADC   #$81              ; normalise +1
001BA7r 2  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
001BA9r 2               
001BA9r 2  38                 SEC                     ; set carry for subtract
001BAAr 2  E9 01              SBC   #$01              ; now correct for exponent
001BACr 2  48                 PHA                     ; save FAC2 exponent
001BADr 2               
001BADr 2                                             ; swap FAC1 and FAC2
001BADr 2  A2 04              LDX   #$04              ; 4 bytes to do
001BAFr 2               LAB_2B49
001BAFr 2  B5 65              LDA   FAC2_e,X          ; get FAC2,X
001BB1r 2  B4 5E              LDY   FAC1_e,X          ; get FAC1,X
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001BB3r 2  95 5E              STA   FAC1_e,X          ; save FAC1,X
001BB5r 2  94 65              STY   FAC2_e,X          ; save FAC2,X
001BB7r 2  CA                 DEX                     ; decrement count/index
001BB8r 2  10 F5              BPL   LAB_2B49          ; loop if not all done
001BBAr 2               
001BBAr 2  A5 55              LDA   FAC2_r            ; get FAC2 rounding byte
001BBCr 2  85 6B              STA   FAC1_r            ; save as FAC1 rounding byte
001BBEr 2  20 rr rr           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
001BC1r 2  20 rr rr           JSR   LAB_GTHAN         ; do - FAC1
001BC4r 2  A9 rr              LDA   #<LAB_2AFE        ; set counter pointer low byte
001BC6r 2  A0 rr              LDY   #>LAB_2AFE        ; set counter pointer high byte
001BC8r 2  20 rr rr           JSR   LAB_2B84          ; go do series evaluation
001BCBr 2  64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
001BCDr 2  68                 PLA                     ;.get saved FAC2 exponent
001BCEr 2  4C rr rr           JMP   LAB_2675          ; test and adjust accumulators and return
001BD1r 2               
001BD1r 2               ; ^2 then series evaluation
001BD1r 2               
001BD1r 2               LAB_2B6E
001BD1r 2  85 6C              STA   Cptrl             ; save count pointer low byte
001BD3r 2  84 6D              STY   Cptrh             ; save count pointer high byte
001BD5r 2  20 rr rr           JSR   LAB_276E          ; pack FAC1 into Adatal
001BD8r 2  A9 56              LDA   #<Adatal          ; set pointer low byte (Y already $00)
001BDAr 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001BDDr 2  20 rr rr           JSR   LAB_2B88          ; go do series evaluation
001BE0r 2  A9 56              LDA   #<Adatal          ; pointer to original # low byte
001BE2r 2  A0 00              LDY   #>Adatal          ; pointer to original # high byte
001BE4r 2  4C rr rr           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
001BE7r 2               
001BE7r 2               ; series evaluation
001BE7r 2               
001BE7r 2               LAB_2B84
001BE7r 2  85 6C              STA   Cptrl             ; save count pointer low byte
001BE9r 2  84 6D              STY   Cptrh             ; save count pointer high byte
001BEBr 2               LAB_2B88
001BEBr 2  A2 5A              LDX   #<numexp          ; set pointer low byte
001BEDr 2  20 rr rr           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
001BF0r 2  B1 6C              LDA   (Cptrl),Y         ; get constants count
001BF2r 2  85 63              STA   numcon            ; save constants count
001BF4r 2  A4 6C              LDY   Cptrl             ; get count pointer low byte
001BF6r 2  C8                 INY                     ; increment it (now constants pointer)
001BF7r 2  98                 TYA                     ; copy it
001BF8r 2  D0 02              BNE   LAB_2B97          ; skip next if no overflow
001BFAr 2               
001BFAr 2  E6 6D              INC   Cptrh             ; else increment high byte
001BFCr 2               LAB_2B97
001BFCr 2  85 6C              STA   Cptrl             ; save low byte
001BFEr 2  A4 6D              LDY   Cptrh             ; get high byte
001C00r 2               LAB_2B9B
001C00r 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001C03r 2  A5 6C              LDA   Cptrl             ; get constants pointer low byte
001C05r 2  A4 6D              LDY   Cptrh             ; get constants pointer high byte
001C07r 2  18                 CLC                     ; clear carry for add
001C08r 2  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
001C0Ar 2  90 01              BCC   LAB_2BA8          ; skip next if no overflow
001C0Cr 2               
001C0Cr 2  C8                 INY                     ; increment high byte
001C0Dr 2               LAB_2BA8
001C0Dr 2  85 6C              STA   Cptrl             ; save pointer low byte
001C0Fr 2  84 6D              STY   Cptrh             ; save pointer high byte
001C11r 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
001C14r 2  A9 5A              LDA   #<numexp          ; set pointer low byte to partial @ numexp
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001C16r 2  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
001C18r 2  C6 63              DEC   numcon            ; decrement constants count
001C1Ar 2  D0 E4              BNE   LAB_2B9B          ; loop until all done
001C1Cr 2  60                 RTS
001C1Dr 2               
001C1Dr 2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
001C1Dr 2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
001C1Dr 2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
001C1Dr 2               
001C1Dr 2               ; Entropy = 7.997442 bits per byte
001C1Dr 2               ; Optimum compression would reduce these 65536 bytes by 0 percent
001C1Dr 2               
001C1Dr 2               ; Chi square distribution for 65536 samples is 232.01, and
001C1Dr 2               ; randomly would exceed this value 75.00 percent of the time
001C1Dr 2               
001C1Dr 2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
001C1Dr 2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
001C1Dr 2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
001C1Dr 2               
001C1Dr 2               LAB_RND
001C1Dr 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001C1Fr 2  F0 07              BEQ   NextPRN           ; do next random # if zero
001C21r 2               
001C21r 2                                             ; else get seed into random number store
001C21r 2  A2 70              LDX   #Rbyte4           ; set PRNG pointer low byte
001C23r 2  A0 00              LDY   #$00              ; set PRNG pointer high byte
001C25r 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 into (XY)
001C28r 2               NextPRN
001C28r 2  A2 AF              LDX   #$AF              ; set EOR byte
001C2Ar 2  A0 13              LDY   #$13              ; do this nineteen times
001C2Cr 2               LoopPRN
001C2Cr 2  06 71              ASL   Rbyte1            ; shift PRNG most significant byte
001C2Er 2  26 72              ROL   Rbyte2            ; shift PRNG middle byte
001C30r 2  26 73              ROL   Rbyte3            ; shift PRNG least significant byte
001C32r 2  26 70              ROL   Rbyte4            ; shift PRNG extra byte
001C34r 2  90 05              BCC   Ninc1             ; branch if bit 32 clear
001C36r 2               
001C36r 2  8A                 TXA                     ; set EOR byte
001C37r 2  45 71              EOR   Rbyte1            ; EOR PRNG extra byte
001C39r 2  85 71              STA   Rbyte1            ; save new PRNG extra byte
001C3Br 2               Ninc1
001C3Br 2  88                 DEY                     ; decrement loop count
001C3Cr 2  D0 EE              BNE   LoopPRN           ; loop if not all done
001C3Er 2               
001C3Er 2  A2 02              LDX   #$02              ; three bytes to copy
001C40r 2               CopyPRNG
001C40r 2  B5 71              LDA   Rbyte1,X          ; get PRNG byte
001C42r 2  95 5F              STA   FAC1_1,X          ; save FAC1 byte
001C44r 2  CA                 DEX
001C45r 2  10 F9              BPL   CopyPRNG          ; loop if not complete
001C47r 2               
001C47r 2  A9 80              LDA   #$80              ; set the exponent
001C49r 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
001C4Br 2               
001C4Br 2  0A                 ASL                     ; clear A
001C4Cr 2  85 62              STA   FAC1_s            ; save FAC1 sign
001C4Er 2               
001C4Er 2  4C rr rr           JMP   LAB_24D5          ; normalise FAC1 and return
001C51r 2               
001C51r 2               ; perform COS()
001C51r 2               
001C51r 2               LAB_COS
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001C51r 2  A9 rr              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
001C53r 2  A0 rr              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
001C55r 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
001C58r 2               
001C58r 2               ; perform SIN()
001C58r 2               
001C58r 2               LAB_SIN
001C58r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001C5Br 2  A9 rr              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
001C5Dr 2  A0 rr              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
001C5Fr 2  A6 69              LDX   FAC2_s            ; get FAC2 sign (b7)
001C61r 2  20 rr rr           JSR   LAB_26C2          ; divide by (AY) (X=sign)
001C64r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001C67r 2  20 rr rr           JSR   LAB_INT           ; perform INT
001C6Ar 2  64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
001C6Cr 2  20 rr rr           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
001C6Fr 2  A9 rr              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
001C71r 2  A0 rr              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
001C73r 2  20 rr rr           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
001C76r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001C78r 2  48                 PHA                     ; save FAC1 sign
001C79r 2  10 0D              BPL   LAB_2C35          ; branch if +ve
001C7Br 2               
001C7Br 2                                             ; FAC1 sign was -ve
001C7Br 2  20 rr rr           JSR   LAB_244E          ; add 0.5 to FAC1
001C7Er 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001C80r 2  30 09              BMI   LAB_2C38          ; branch if -ve
001C82r 2               
001C82r 2  A5 15              LDA   Cflag             ; get comparison evaluation flag
001C84r 2  49 FF              EOR   #$FF              ; toggle flag
001C86r 2  85 15              STA   Cflag             ; save comparison evaluation flag
001C88r 2               LAB_2C35
001C88r 2  20 rr rr           JSR   LAB_GTHAN         ; do - FAC1
001C8Br 2               LAB_2C38
001C8Br 2  A9 rr              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
001C8Dr 2  A0 rr              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
001C8Fr 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
001C92r 2  68                 PLA                     ; restore FAC1 sign
001C93r 2  10 03              BPL   LAB_2C45          ; branch if was +ve
001C95r 2               
001C95r 2                                             ; else correct FAC1
001C95r 2  20 rr rr           JSR   LAB_GTHAN         ; do - FAC1
001C98r 2               LAB_2C45
001C98r 2  A9 rr              LDA   #<LAB_2C84        ; set pointer low byte to counter
001C9Ar 2  A0 rr              LDY   #>LAB_2C84        ; set pointer high byte to counter
001C9Cr 2  4C rr rr           JMP   LAB_2B6E          ; ^2 then series evaluation and return
001C9Fr 2               
001C9Fr 2               ; perform TAN()
001C9Fr 2               
001C9Fr 2               LAB_TAN
001C9Fr 2  20 rr rr           JSR   LAB_276E          ; pack FAC1 into Adatal
001CA2r 2  64 15              STZ   Cflag             ; clear comparison evaluation flag
001CA4r 2  20 rr rr           JSR   LAB_SIN           ; go do SIN(n)
001CA7r 2  A2 4E              LDX   #<func_l          ; set sin(n) pointer low byte
001CA9r 2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
001CABr 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 into (XY)
001CAEr 2  A9 56              LDA   #<Adatal          ; set n pointer low addr
001CB0r 2  A0 00              LDY   #>Adatal          ; set n pointer high addr
001CB2r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
001CB5r 2  64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
001CB7r 2  A5 15              LDA   Cflag             ; get comparison evaluation flag
001CB9r 2  20 rr rr           JSR   LAB_2C74          ; save flag and go do series evaluation
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001CBCr 2               
001CBCr 2  A9 4E              LDA   #<func_l          ; set sin(n) pointer low byte
001CBEr 2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
001CC0r 2  4C rr rr           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
001CC3r 2               
001CC3r 2               LAB_2C74
001CC3r 2  48                 PHA                     ; save comparison evaluation flag
001CC4r 2  80 C2              BRA   LAB_2C35          ; go do series evaluation
001CC6r 2               
001CC6r 2               ; perform USR()
001CC6r 2               
001CC6r 2               LAB_USR
001CC6r 2  20 03 00           JSR   Usrjmp            ; call user code
001CC9r 2  4C rr rr           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
001CCCr 2               
001CCCr 2               ; perform ATN()
001CCCr 2               
001CCCr 2               LAB_ATN
001CCCr 2  A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
001CCEr 2  48                 PHA                     ; save sign
001CCFr 2  10 03              BPL   LAB_2CA1          ; branch if +ve
001CD1r 2               
001CD1r 2  20 rr rr           JSR   LAB_GTHAN         ; else do - FAC1
001CD4r 2               LAB_2CA1
001CD4r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001CD6r 2  48                 PHA                     ; push exponent
001CD7r 2  C9 81              CMP   #$81              ; compare with 1
001CD9r 2  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
001CDBr 2               
001CDBr 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low byte
001CDDr 2  A0 rr              LDY   #>LAB_259C        ; set 1 pointer high byte
001CDFr 2  20 rr rr           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
001CE2r 2               LAB_2CAF
001CE2r 2  A9 rr              LDA   #<LAB_2CC9        ; set pointer low byte to counter
001CE4r 2  A0 rr              LDY   #>LAB_2CC9        ; set pointer high byte to counter
001CE6r 2  20 rr rr           JSR   LAB_2B6E          ; ^2 then series evaluation
001CE9r 2  68                 PLA                     ; restore old FAC1 exponent
001CEAr 2  C9 81              CMP   #$81              ; compare with 1
001CECr 2  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
001CEEr 2               
001CEEr 2  A9 rr              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
001CF0r 2  A0 rr              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
001CF2r 2  20 rr rr           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
001CF5r 2               LAB_2CC2
001CF5r 2  68                 PLA                     ; restore FAC1 sign
001CF6r 2  10 16              BPL   LAB_2D04          ; exit if was +ve
001CF8r 2               
001CF8r 2  4C rr rr           JMP   LAB_GTHAN         ; else do - FAC1 and return
001CFBr 2               
001CFBr 2               ; perform BITSET
001CFBr 2               
001CFBr 2               LAB_BITSET
001CFBr 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001CFEr 2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
001D00r 2  B0 20              BCS   FCError           ; branch if > 7
001D02r 2               
001D02r 2  A9 00              LDA   #$00              ; clear A
001D04r 2  38                 SEC                     ; set the carry
001D05r 2               S_Bits
001D05r 2  2A                 ROL                     ; shift bit
001D06r 2  CA                 DEX                     ; decrement bit number
001D07r 2  10 FC              BPL   S_Bits            ; loop if still +ve
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001D09r 2               
001D09r 2  E8                 INX                     ; make X = $00
001D0Ar 2  01 0A              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
001D0Cr 2  81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
001D0Er 2               LAB_2D04
001D0Er 2  60                 RTS
001D0Fr 2               
001D0Fr 2               ; perform BITCLR
001D0Fr 2               
001D0Fr 2               LAB_BITCLR
001D0Fr 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001D12r 2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
001D14r 2  B0 0C              BCS   FCError           ; branch if > 7
001D16r 2               
001D16r 2  A9 FF              LDA   #$FF              ; set A
001D18r 2               S_Bitc
001D18r 2  2A                 ROL                     ; shift bit
001D19r 2  CA                 DEX                     ; decrement bit number
001D1Ar 2  10 FC              BPL   S_Bitc            ; loop if still +ve
001D1Cr 2               
001D1Cr 2  E8                 INX                     ; make X = $00
001D1Dr 2  21 0A              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
001D1Fr 2  81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
001D21r 2  60                 RTS
001D22r 2               
001D22r 2               FCError
001D22r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
001D25r 2               
001D25r 2               ; perform BITTST()
001D25r 2               
001D25r 2               LAB_BTST
001D25r 2  20 rr rr           JSR   LAB_IGBY          ; increment BASIC pointer
001D28r 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001D2Br 2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
001D2Dr 2  B0 F3              BCS   FCError           ; branch if > 7
001D2Fr 2               
001D2Fr 2  20 rr rr           JSR   LAB_GBYT          ; get next BASIC byte
001D32r 2  C9 29              CMP   #')'              ; is next character ")"
001D34r 2  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
001D36r 2               
001D36r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
001D39r 2               
001D39r 2               TST_OK
001D39r 2  20 rr rr           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
001D3Cr 2  A9 00              LDA   #$00              ; clear A
001D3Er 2  38                 SEC                     ; set the carry
001D3Fr 2               T_Bits
001D3Fr 2  2A                 ROL                     ; shift bit
001D40r 2  CA                 DEX                     ; decrement bit number
001D41r 2  10 FC              BPL   T_Bits            ; loop if still +ve
001D43r 2               
001D43r 2  E8                 INX                     ; make X = $00
001D44r 2  21 0A              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
001D46r 2  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
001D48r 2               
001D48r 2  A9 FF              LDA   #$FF              ; set for -1 result
001D4Ar 2               LAB_NOTT
001D4Ar 2  4C rr rr           JMP   LAB_27DB          ; go do SGN tail
001D4Dr 2               
001D4Dr 2               ; perform BIN$()
001D4Dr 2               
001D4Dr 2               LAB_BINS
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001D4Dr 2  E0 19              CPX   #$19              ; max + 1
001D4Fr 2  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
001D51r 2               
001D51r 2  86 2A              STX   TempB             ; save # of characters ($00 = leading zero remove)
001D53r 2  A9 18              LDA   #$18              ; need A byte long space
001D55r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long
001D58r 2  A0 17              LDY   #$17              ; set index
001D5Ar 2  A2 18              LDX   #$18              ; character count
001D5Cr 2               NextB1
001D5Cr 2  46 0A              LSR   nums_1            ; shift highest byte
001D5Er 2  66 0B              ROR   nums_2            ; shift middle byte
001D60r 2  66 0C              ROR   nums_3            ; shift lowest byte bit 0 to carry
001D62r 2  8A                 TXA                     ; load with "0"/2
001D63r 2  2A                 ROL                     ; shift in carry
001D64r 2  91 5F              STA   (str_pl),Y        ; save to temp string + index
001D66r 2  88                 DEY                     ; decrement index
001D67r 2  10 F3              BPL   NextB1            ; loop if not done
001D69r 2               
001D69r 2  A5 2A              LDA   TempB             ; get # of characters
001D6Br 2  F0 0A              BEQ   EndBHS            ; branch if truncate
001D6Dr 2               
001D6Dr 2  AA                 TAX                     ; copy length to X
001D6Er 2  38                 SEC                     ; set carry for add !
001D6Fr 2  49 FF              EOR   #$FF              ; 1's complement
001D71r 2  69 18              ADC   #$18              ; add 24d
001D73r 2  F0 1C              BEQ   GoPr2             ; if zero print whole string
001D75r 2  80 0F              BRA   GoPr1             ; else go make output string
001D77r 2               
001D77r 2               ; this is the exit code and is also used by HEX$()
001D77r 2               ; truncate string to remove leading "0"s
001D77r 2               
001D77r 2               EndBHS
001D77r 2  A8                 TAY                     ; clear index (A=0, X=length here)
001D78r 2               NextB2
001D78r 2  B1 5F              LDA   (str_pl),Y        ; get character from string
001D7Ar 2  C9 30              CMP   #'0'              ; compare with "0"
001D7Cr 2  D0 07              BNE   GoPr              ; if not "0" then go print string from here
001D7Er 2               
001D7Er 2  CA                 DEX                     ; decrement character count
001D7Fr 2  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
001D81r 2               
001D81r 2  C8                 INY                     ; else increment index
001D82r 2  80 F4              BRA   NextB2            ; loop always
001D84r 2               
001D84r 2               ; make fixed length output string - ignore overflows!
001D84r 2               
001D84r 2               GoPr3
001D84r 2  E8                 INX                     ; need at least 1 character
001D85r 2               GoPr
001D85r 2  98                 TYA                     ; copy result
001D86r 2               GoPr1
001D86r 2  18                 CLC                     ; clear carry for add
001D87r 2  65 5F              ADC   str_pl            ; add low address
001D89r 2  85 5F              STA   str_pl            ; save low address
001D8Br 2  A9 00              LDA   #$00              ; do high byte
001D8Dr 2  65 60              ADC   str_ph            ; add high address
001D8Fr 2  85 60              STA   str_ph            ; save high address
001D91r 2               GoPr2
001D91r 2  86 5E              STX   str_ln            ; X holds string length
001D93r 2  20 rr rr           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
001D96r 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put address
001D99r 2                                             ; and length on descriptor stack and update stack pointers
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001D99r 2               
001D99r 2               BinFErr
001D99r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
001D9Cr 2               
001D9Cr 2               ; perform HEX$()
001D9Cr 2               
001D9Cr 2               LAB_HEXS
001D9Cr 2  E0 07              CPX   #$07              ; max + 1
001D9Er 2  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
001DA0r 2               
001DA0r 2  86 2A              STX   TempB             ; save # of characters
001DA2r 2               
001DA2r 2  A9 06              LDA   #$06              ; need 6 bytes for string
001DA4r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long
001DA7r 2  A0 05              LDY   #$05              ; set string index
001DA9r 2               
001DA9r 2  A5 0C              LDA   nums_3            ; get lowest byte
001DABr 2  20 rr rr           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
001DAEr 2  A5 0B              LDA   nums_2            ; get middle byte
001DB0r 2  20 rr rr           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
001DB3r 2  A5 0A              LDA   nums_1            ; get highest byte
001DB5r 2  20 rr rr           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
001DB8r 2               
001DB8r 2  A2 06              LDX   #$06              ; character count
001DBAr 2  A5 2A              LDA   TempB             ; get # of characters
001DBCr 2  F0 B9              BEQ   EndBHS            ; branch if truncate
001DBEr 2               
001DBEr 2  AA                 TAX                     ; copy length to X
001DBFr 2  38                 SEC                     ; set carry for add !
001DC0r 2  49 FF              EOR   #$FF              ; 1's complement
001DC2r 2  69 06              ADC   #$06              ; add 6d
001DC4r 2  F0 CB              BEQ   GoPr2             ; if zero print whole string
001DC6r 2  80 BE              BRA   GoPr1             ; else go make output string (branch always)
001DC8r 2               
001DC8r 2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
001DC8r 2               
001DC8r 2               LAB_A2HX
001DC8r 2  AA                 TAX                     ; save byte
001DC9r 2  29 0F              AND   #$0F              ; mask off top bits
001DCBr 2  20 rr rr           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
001DCEr 2  8A                 TXA                     ; get byte back
001DCFr 2  4A                 LSR                     ; /2  shift high nibble to low nibble
001DD0r 2  4A                 LSR                     ; /4
001DD1r 2  4A                 LSR                     ; /8
001DD2r 2  4A                 LSR                     ; /16
001DD3r 2               LAB_AL2X
001DD3r 2  C9 0A              CMP   #$0A              ; set carry for +1 if >9
001DD5r 2  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
001DD7r 2  69 06              ADC   #$06              ; adjust for A to F
001DD9r 2               LAB_AL20
001DD9r 2  69 30              ADC   #'0'              ; add ASCII "0"
001DDBr 2  91 5F              STA   (str_pl),Y        ; save to temp string
001DDDr 2  88                 DEY                     ; decrement counter
001DDEr 2  60                 RTS
001DDFr 2               
001DDFr 2               LAB_NLTO
001DDFr 2  85 5E              STA   FAC1_e            ; save FAC1 exponent
001DE1r 2  A9 00              LDA   #$00              ; clear sign compare
001DE3r 2               LAB_MLTE
001DE3r 2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001DE5r 2  8A                 TXA                     ; restore character
001DE6r 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001DE9r 2               
001DE9r 2               ; gets here if the first character was "$" for hex
001DE9r 2               ; get hex number
001DE9r 2               
001DE9r 2               LAB_CHEX
001DE9r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
001DECr 2  90 0A              BCC   LAB_ISHN          ; branch if numeric character
001DEEr 2               
001DEEr 2  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
001DF0r 2  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
001DF2r 2  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
001DF4r 2  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
001DF6r 2               
001DF6r 2  69 0A              ADC   #$0A              ; convert to nibble
001DF8r 2               LAB_ISHN
001DF8r 2  29 0F              AND   #$0F              ; convert to binary
001DFAr 2  AA                 TAX                     ; save nibble
001DFBr 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001DFDr 2  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
001DFFr 2               
001DFFr 2  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
001E01r 2  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
001E03r 2               
001E03r 2               LAB_MLTO
001E03r 2  4C rr rr           JMP   LAB_2564          ; do overflow error and warm start
001E06r 2               
001E06r 2               LAB_NXCH
001E06r 2  AA                 TAX                     ; save bit
001E07r 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001E09r 2  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
001E0Br 2               
001E0Br 2  E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*2)
001E0Dr 2  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
001E0Fr 2               
001E0Fr 2  A9 00              LDA   #$00              ; clear sign compare
001E11r 2               LAB_MLBT
001E11r 2  85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001E13r 2  8A                 TXA                     ; restore bit
001E14r 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
001E17r 2               
001E17r 2               ; gets here if the first character was  "%" for binary
001E17r 2               ; get binary number
001E17r 2               
001E17r 2               LAB_CBIN
001E17r 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
001E1Ar 2  49 30              EOR   #'0'              ; convert "0" to 0 etc.
001E1Cr 2  C9 02              CMP   #$02              ; compare with max+1
001E1Er 2  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
001E20r 2               
001E20r 2               LAB_EXCH
001E20r 2  4C rr rr           JMP   LAB_28F6          ; evaluate -ve flag and return
001E23r 2               
001E23r 2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
001E23r 2               
001E23r 2               CTRLC
001E23r 2  AD 7F 05           LDA   ccflag            ; get [CTRL-C] check flag
001E26r 2  D0 18              BNE   LAB_FBA2          ; exit if inhibited
001E28r 2               
001E28r 2  20 rr rr           JSR   V_INPT            ; scan input device
001E2Br 2  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
001E2Dr 2               
001E2Dr 2  8D 80 05           STA   ccbyte            ; save received byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001E30r 2  A2 20              LDX   #$20              ; "life" timer for bytes
001E32r 2  8E 81 05           STX   ccnull            ; set countdown
001E35r 2  4C rr rr           JMP   LAB_1636          ; return to BASIC
001E38r 2               
001E38r 2               LAB_FBA0
001E38r 2  AE 81 05           LDX   ccnull            ; get countdown byte
001E3Br 2  F0 03              BEQ   LAB_FBA2          ; exit if finished
001E3Dr 2               
001E3Dr 2  CE 81 05           DEC   ccnull            ; else decrement countdown
001E40r 2               LAB_FBA2
001E40r 2  60                 RTS
001E41r 2               
001E41r 2               INGET
001E41r 2  20 rr rr           JSR   V_INPT            ; call scan input device
001E44r 2  B0 09              BCS   LAB_FB95          ; if byte go reset timer
001E46r 2               
001E46r 2  AD 81 05           LDA   ccnull            ; get countdown
001E49r 2  F0 07              BEQ   LAB_FB96          ; exit if empty
001E4Br 2               
001E4Br 2  AD 80 05           LDA   ccbyte            ; get last received byte
001E4Er 2  38                 SEC                     ; flag we got a byte
001E4Fr 2               LAB_FB95
001E4Fr 2  9C 81 05           STZ   ccnull            ; clear timer because we got a byte
001E52r 2               LAB_FB96
001E52r 2  60                 RTS
001E53r 2               
001E53r 2               ; MAX() MIN() pre process
001E53r 2               
001E53r 2               LAB_MMPP
001E53r 2  20 rr rr           JSR   LAB_EVEZ          ; process expression
001E56r 2  4C rr rr           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
001E59r 2               
001E59r 2               ; perform MAX()
001E59r 2               
001E59r 2               LAB_MAX
001E59r 2  20 rr rr           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
001E5Cr 2                                             ; pull FAC2 and compare with FAC1
001E5Cr 2  10 FB              BPL   LAB_MAX           ; branch if no swap to do
001E5Er 2               
001E5Er 2  A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
001E60r 2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
001E62r 2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
001E64r 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1
001E67r 2  80 F0              BRA   LAB_MAX           ; go do next (branch always)
001E69r 2               
001E69r 2               ; perform MIN()
001E69r 2               
001E69r 2               LAB_MIN
001E69r 2  20 rr rr           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
001E6Cr 2                                             ; pull FAC2 and compare with FAC1
001E6Cr 2  30 FB              BMI   LAB_MIN           ; branch if no swap to do
001E6Er 2  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
001E70r 2               
001E70r 2  A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
001E72r 2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
001E74r 2  85 66              STA   FAC2_1            ; save FAC2 mantissa1
001E76r 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1
001E79r 2  80 EE              BRA   LAB_MIN           ; go do next (branch always)
001E7Br 2               
001E7Br 2               ; exit routine. don't bother returning to the loop code
001E7Br 2               ; check for correct exit, else so syntax error
001E7Br 2               
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001E7Br 2               LAB_MMEC
001E7Br 2  C9 29              CMP   #')'              ; is it end of function?
001E7Dr 2  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
001E7Fr 2               
001E7Fr 2  68                 PLA                     ; dump return address low byte
001E80r 2  68                 PLA                     ; dump return address high byte
001E81r 2  4C rr rr           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
001E84r 2               
001E84r 2               LAB_MMSE
001E84r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
001E87r 2               
001E87r 2               ; check for next, evaluate and return or exit
001E87r 2               ; this is the routine that does most of the work
001E87r 2               
001E87r 2               LAB_PHFA
001E87r 2  20 rr rr           JSR   LAB_GBYT          ; get next BASIC byte
001E8Ar 2  C9 2C              CMP   #','              ; is there more ?
001E8Cr 2  D0 ED              BNE   LAB_MMEC          ; if not go do end check
001E8Er 2               
001E8Er 2                                             ; push FAC1
001E8Er 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
001E91r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign
001E93r 2  09 7F              ORA   #$7F              ; set all non sign bits
001E95r 2  25 5F              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
001E97r 2  48                 PHA                     ; push on stack
001E98r 2  A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
001E9Ar 2  48                 PHA                     ; push on stack
001E9Br 2  A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
001E9Dr 2  48                 PHA                     ; push on stack
001E9Er 2  A5 5E              LDA   FAC1_e            ; get FAC1 exponent
001EA0r 2  48                 PHA                     ; push on stack
001EA1r 2               
001EA1r 2  20 rr rr           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
001EA4r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
001EA7r 2                                             ; else do type mismatch
001EA7r 2               
001EA7r 2                                             ; pop FAC2 (MAX/MIN expression so far)
001EA7r 2  68                 PLA                     ; pop exponent
001EA8r 2  85 65              STA   FAC2_e            ; save FAC2 exponent
001EAAr 2  68                 PLA                     ; pop mantissa3
001EABr 2  85 68              STA   FAC2_3            ; save FAC2 mantissa3
001EADr 2  68                 PLA                     ; pop mantissa1
001EAEr 2  85 67              STA   FAC2_2            ; save FAC2 mantissa2
001EB0r 2  68                 PLA                     ; pop sign/mantissa1
001EB1r 2  85 66              STA   FAC2_1            ; save FAC2 sign/mantissa1
001EB3r 2  85 69              STA   FAC2_s            ; save FAC2 sign
001EB5r 2               
001EB5r 2                                             ; compare FAC1 with (packed) FAC2
001EB5r 2  A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
001EB7r 2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
001EB9r 2  4C rr rr           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
001EBCr 2                                             ; returns A=$00 if FAC1 = (AY)
001EBCr 2                                             ; returns A=$01 if FAC1 > (AY)
001EBCr 2                                             ; returns A=$FF if FAC1 < (AY)
001EBCr 2               
001EBCr 2               ; perform WIDTH
001EBCr 2               
001EBCr 2               LAB_WDTH
001EBCr 2  C9 2C              CMP   #','              ; is next byte ","
001EBEr 2  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
001EC0r 2               
001EC0r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001EC3r 2  8A                 TXA                     ; copy width to A
001EC4r 2  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
001EC6r 2               
001EC6r 2  E0 10              CPX   #$10              ; else make min width = 16d
001EC8r 2  90 45              BCC   TabErr            ; if less do function call error and exit
001ECAr 2               
001ECAr 2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
001ECAr 2               ; tab size greater than the line length.
001ECAr 2               
001ECAr 2  E4 16              CPX   TabSiz            ; compare with tab size
001ECCr 2  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
001ECEr 2               
001ECEr 2  86 16              STX   TabSiz            ; else make tab size = terminal width
001ED0r 2               LAB_NSTT
001ED0r 2  86 08              STX   TWidth            ; set the terminal width
001ED2r 2  20 rr rr           JSR   LAB_GBYT          ; get BASIC byte back
001ED5r 2  F0 1A              BEQ   WExit             ; exit if no following
001ED7r 2               
001ED7r 2  C9 2C              CMP   #','              ; else is it ","
001ED9r 2  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
001EDBr 2               
001EDBr 2               LAB_TBSZ
001EDBr 2  20 rr rr           JSR   LAB_SGBY          ; scan and get byte parameter
001EDEr 2  8A                 TXA                     ; copy TAB size
001EDFr 2  30 2E              BMI   TabErr            ; if >127 do function call error and exit
001EE1r 2               
001EE1r 2  E0 01              CPX   #$01              ; compare with min-1
001EE3r 2  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
001EE5r 2               
001EE5r 2  A5 08              LDA   TWidth            ; set flags for width
001EE7r 2  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
001EE9r 2               
001EE9r 2  E4 08              CPX   TWidth            ; compare TAB with width
001EEBr 2  F0 02              BEQ   LAB_SVTB          ; ok if =
001EEDr 2  B0 20              BCS   TabErr            ; branch if too big
001EEFr 2               
001EEFr 2               LAB_SVTB
001EEFr 2  86 16              STX   TabSiz            ; save TAB size
001EF1r 2               
001EF1r 2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
001EF1r 2               ; position on a line that still has at least one whole tab width between it
001EF1r 2               ; and the end of the line.
001EF1r 2               
001EF1r 2               WExit
001EF1r 2  A5 08              LDA   TWidth            ; get width
001EF3r 2  F0 06              BEQ   LAB_SULP          ; branch if infinite line
001EF5r 2               
001EF5r 2  C5 16              CMP   TabSiz            ; compare with tab size
001EF7r 2  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
001EF9r 2               
001EF9r 2  85 16              STA   TabSiz            ; else make tab size = terminal width
001EFBr 2               LAB_SULP
001EFBr 2  38                 SEC                     ; set carry for subtract
001EFCr 2               LAB_WDLP
001EFCr 2  E5 16              SBC   TabSiz            ; subtract tab size
001EFEr 2  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
001F00r 2               
001F00r 2  65 16              ADC   TabSiz            ; add tab size back
001F02r 2  18                 CLC                     ; clear carry for add
001F03r 2  65 16              ADC   TabSiz            ; add tab size back again
001F05r 2  85 09              STA   Iclim             ; save for now
001F07r 2  A5 08              LDA   TWidth            ; get width back
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001F09r 2  38                 SEC                     ; set carry for subtract
001F0Ar 2  E5 09              SBC   Iclim             ; subtract remainder
001F0Cr 2  85 09              STA   Iclim             ; save tab column limit
001F0Er 2               LAB_NOSQ
001F0Er 2  60                 RTS
001F0Fr 2               
001F0Fr 2               TabErr
001F0Fr 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
001F12r 2               
001F12r 2               ; perform SQR()
001F12r 2               
001F12r 2               LAB_SQR
001F12r 2  A5 62              LDA   FAC1_s            ; get FAC1 sign
001F14r 2  30 F9              BMI   TabErr            ; if -ve do function call error
001F16r 2               
001F16r 2  A5 5E              LDA   FAC1_e            ; get exponent
001F18r 2  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
001F1Ar 2               
001F1Ar 2                                             ; else do root
001F1Ar 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001F1Dr 2               
001F1Dr 2  64 29              STZ   FACt_3            ; clear remainder
001F1Fr 2  64 28              STZ   FACt_2            ; ..
001F21r 2  64 27              STZ   FACt_1            ; ..
001F23r 2  64 2A              STZ   TempB             ; ..
001F25r 2               
001F25r 2  64 61              STZ   FAC1_3            ; clear root
001F27r 2  64 60              STZ   FAC1_2            ; ..
001F29r 2  64 5F              STZ   FAC1_1            ; ..
001F2Br 2               
001F2Br 2  A2 18              LDX   #$18              ; 24 pairs of bits to do
001F2Dr 2  A5 65              LDA   FAC2_e            ; get exponent
001F2Fr 2  4A                 LSR                     ; check odd/even
001F30r 2  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
001F32r 2               
001F32r 2               LAB_SQE1
001F32r 2  06 68              ASL   FAC2_3            ; shift highest bit of number ..
001F34r 2  26 67              ROL   FAC2_2            ; ..
001F36r 2  26 66              ROL   FAC2_1            ; ..
001F38r 2  26 29              ROL   FACt_3            ; .. into remainder
001F3Ar 2  26 28              ROL   FACt_2            ; ..
001F3Cr 2  26 27              ROL   FACt_1            ; ..
001F3Er 2  26 2A              ROL   TempB             ; .. never overflows
001F40r 2               LAB_SQE2
001F40r 2  06 68              ASL   FAC2_3            ; shift highest bit of number ..
001F42r 2  26 67              ROL   FAC2_2            ; ..
001F44r 2  26 66              ROL   FAC2_1            ; ..
001F46r 2  26 29              ROL   FACt_3            ; .. into remainder
001F48r 2  26 28              ROL   FACt_2            ; ..
001F4Ar 2  26 27              ROL   FACt_1            ; ..
001F4Cr 2  26 2A              ROL   TempB             ; .. never overflows
001F4Er 2               
001F4Er 2  06 61              ASL   FAC1_3            ; root = root * 2
001F50r 2  26 60              ROL   FAC1_2            ; ..
001F52r 2  26 5F              ROL   FAC1_1            ; .. never overflows
001F54r 2               
001F54r 2  A5 61              LDA   FAC1_3            ; get root low byte
001F56r 2  2A                 ROL                     ; *2
001F57r 2  85 0D              STA   Temp3             ; save partial low byte
001F59r 2  A5 60              LDA   FAC1_2            ; get root low mid byte
001F5Br 2  2A                 ROL                     ; *2
001F5Cr 2  85 0E              STA   Temp3+1           ; save partial low mid byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001F5Er 2  A5 5F              LDA   FAC1_1            ; get root high mid byte
001F60r 2  2A                 ROL                     ; *2
001F61r 2  85 0F              STA   Temp3+2           ; save partial high mid byte
001F63r 2  A9 00              LDA   #$00              ; get root high byte (always $00)
001F65r 2  2A                 ROL                     ; *2
001F66r 2  85 10              STA   Temp3+3           ; save partial high byte
001F68r 2               
001F68r 2                                             ; carry clear for subtract +1
001F68r 2  A5 29              LDA   FACt_3            ; get remainder low byte
001F6Ar 2  E5 0D              SBC   Temp3             ; subtract partial low byte
001F6Cr 2  85 0D              STA   Temp3             ; save partial low byte
001F6Er 2               
001F6Er 2  A5 28              LDA   FACt_2            ; get remainder low mid byte
001F70r 2  E5 0E              SBC   Temp3+1           ; subtract partial low mid byte
001F72r 2  85 0E              STA   Temp3+1           ; save partial low mid byte
001F74r 2               
001F74r 2  A5 27              LDA   FACt_1            ; get remainder high mid byte
001F76r 2  E5 0F              SBC   Temp3+2           ; subtract partial high mid byte
001F78r 2  A8                 TAY                     ; copy partial high mid byte
001F79r 2               
001F79r 2  A5 2A              LDA   TempB             ; get remainder high byte
001F7Br 2  E5 10              SBC   Temp3+3           ; subtract partial high byte
001F7Dr 2  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
001F7Fr 2               
001F7Fr 2  85 2A              STA   TempB             ; save remainder high byte
001F81r 2               
001F81r 2  84 27              STY   FACt_1            ; save remainder high mid byte
001F83r 2               
001F83r 2  A5 0E              LDA   Temp3+1           ; get remainder low mid byte
001F85r 2  85 28              STA   FACt_2            ; save remainder low mid byte
001F87r 2               
001F87r 2  A5 0D              LDA   Temp3             ; get partial low byte
001F89r 2  85 29              STA   FACt_3            ; save remainder low byte
001F8Br 2               
001F8Br 2  E6 61              INC   FAC1_3            ; increment root low byte (never any rollover)
001F8Dr 2               LAB_SQNS
001F8Dr 2  CA                 DEX                     ; decrement bit pair count
001F8Er 2  D0 A2              BNE   LAB_SQE1          ; loop if not all done
001F90r 2               
001F90r 2  38                 SEC                     ; set carry for subtract
001F91r 2  A5 65              LDA   FAC2_e            ; get exponent
001F93r 2  E9 80              SBC   #$80              ; normalise
001F95r 2  6A                 ROR                     ; /2 and re-bias to $80
001F96r 2  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
001F98r 2  85 5E              STA   FAC1_e            ; save it
001F9Ar 2  4C rr rr           JMP   LAB_24D5          ; normalise FAC1 and return
001F9Dr 2               
001F9Dr 2               ; perform VARPTR()
001F9Dr 2               
001F9Dr 2               LAB_VARPTR
001F9Dr 2  20 rr rr           JSR   LAB_IGBY          ; increment and scan memory
001FA0r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
001FA3r 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
001FA6r 2  A4 47              LDY   Cvaral            ; get var address low byte
001FA8r 2  A5 48              LDA   Cvarah            ; get var address high byte
001FAAr 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
001FADr 2               
001FADr 2               ; perform PI
001FADr 2               
001FADr 2               LAB_PI
001FADr 2  A9 rr              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
001FAFr 2  A0 rr              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001FB1r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
001FB4r 2  C6 5E              DEC   FAC1_e            ; make result = PI
001FB6r 2  60                 RTS
001FB7r 2               
001FB7r 2               ; perform TWOPI
001FB7r 2               
001FB7r 2               LAB_TWOPI
001FB7r 2  A9 rr              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
001FB9r 2  A0 rr              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
001FBBr 2  4C rr rr           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
001FBEr 2               
001FBEr 2               ; character get subroutine - ROM based
001FBEr 2               
001FBEr 2               ; the target address for the LDA at LAB_GBYT is the BASIC execute pointer.
001FBEr 2               ; block is no longer copied to page zero and uses a CMOS instruction/address mode.
001FBEr 2               ; 16-bit pointer is located in page zero.
001FBEr 2               
001FBEr 2               ; increment and scan memory
001FBEr 2               LAB_IGBY
001FBEr 2  E6 6E              INC   Bpntrl            ; increment BASIC execute pointer low byte
001FC0r 2  D0 02              BNE   LAB_GBYT          ; branch if no carry, else
001FC2r 2  E6 6F              INC   Bpntrh            ; increment BASIC execute pointer high byte
001FC4r 2               
001FC4r 2               ; scan memory
001FC4r 2               LAB_GBYT
001FC4r 2  B2 6E              LDA   (Bpntrl)          ; get byte to scan (addr set by call routine)
001FC6r 2  C9 A9              CMP   #TK_ELSE          ; compare with the token for ELSE
001FC8r 2  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
001FCAr 2               
001FCAr 2  C9 3A              CMP   #':'              ; compare with ":"
001FCCr 2  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
001FCEr 2               
001FCEr 2  C9 20              CMP   #' '              ; compare with " "
001FD0r 2  F0 EC              BEQ   LAB_IGBY          ; if " " go do next
001FD2r 2               
001FD2r 2               ; changes per Mike Barry, saves a couple clock cycles
001FD2r 2  49 30              EOR #'0'                ; convert to binary
001FD4r 2  C9 0A              CMP #10                 ; clear carry if decimal digit
001FD6r 2  49 30              EOR #'0'                ; convert back to ASCII
001FD8r 2               
001FD8r 2               LAB_2D05
001FD8r 2  60                 RTS
001FD9r 2               
001FD9r 2               LAB_EXIT
001FD9r 2  4C rr rr          JMP    V_EXIT            ; exit back to C02 Monitor Warm start soft vector
001FDCr 2               
001FDCr 2               LAB_LOAD
001FDCr 2               ; To Load a program you need to start loading at Smeml/h
001FDCr 2               ; then find the end of program (two $00), using Itempl/h,
001FDCr 2               ; then clear other variables and call BASIC cleanup
001FDCr 2               ;
001FDCr 2               ; The variables used by the C02 Monitor are:
001FDCr 2               ; PTRL/H, plus set the Block count to 1 and clear the OPXMDM flag
001FDCr 2               ;
001FDCr 2               ; LOAD command
001FDCr 2               
001FDCr 2  A5 2B             LDA     Smeml            ; get start address
001FDEr 2  85 DA             STA     PTRL             ; put it in XMODEM pointer
001FE0r 2  A5 2C             LDA     Smemh            ;
001FE2r 2  85 DB             STA     PTRH             ;
001FE4r 2               
001FE4r 2  A9 01             LDA    #$01              ; get count of one
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

001FE6r 2  85 DC             STA    BLKNO             ; set Xmodem block count
001FE8r 2  64 D6             STZ    OPXMDM            ; clear OPXMDM flag
001FEAr 2  20 rr rr          JSR    V_LOAD            ; call XMODEM receive vector
001FEDr 2               
001FEDr 2               ; Program loaded into memory, likely padded with $1A from Xmodem protocol
001FEDr 2               ; use get_basmem routine to find the end program memory, then reset the pointers
001FEDr 2               ; and call LAB_1319 to cleanup EhBasic.
001FEDr 2               ; NOTE: Modified routine using OPXMDM Bit7 to indicate a LOAD was done and
001FEDr 2               ; print the Ready message after cleanup.
001FEDr 2               
001FEDr 2  20 rr rr          JSR     get_basmem       ; find end of program space
001FF0r 2  A5 0A             LDA     Itempl           ; get start of free memory low byte address
001FF2r 2  A4 0B             LDY     Itemph           ; get start of free memory high byte address
001FF4r 2  85 2D             STA     Svarl            ; and set variables and strings pointers
001FF6r 2  85 2F             STA     Sarryl           ; to the start of free memory
001FF8r 2  85 31             STA     Earryl           ;
001FFAr 2  84 2E             STY     Svarh            ;
001FFCr 2  84 30             STY     Sarryh           ;
001FFEr 2  84 32             STY     Earryh           ;
002000r 2  F7 D6             SMB7    OPXMDM           ; set upper bit in flag (print Ready msg)
002002r 2  4C rr rr          JMP     LAB_1319         ; cleanup and Return to BASIC
002005r 2               
002005r 2               LAB_SAVE
002005r 2               ; To Save a program you need to save start to end of program
002005r 2               ; marked by two consecutive $00.
002005r 2               ;
002005r 2               ; The Xmodem Save routine in the C02 Monitor expects it's variables
002005r 2               ; to be set before making the call via the JMP to V_SAVE.
002005r 2               
002005r 2               ; The variables used by the C02 Monitor are:
002005r 2               ; - Source address (SCRL/H), Length (LENL/H), plus
002005r 2               ; - the Block count set to one and the OPXMDM flag cleared.
002005r 2               ;
002005r 2               ; SAVE command
002005r 2               
002005r 2  20 rr rr          JSR    get_basmem        ; find end of program space
002008r 2  A6 2B             LDX    Smeml             ;
00200Ar 2  A5 2C             LDA    Smemh             ; get start address of BASIC program
00200Cr 2  86 C8             STX    SRCL              ;
00200Er 2  85 C9             STA    SRCH              ; save in xmodem pointer
002010r 2               
002010r 2  A5 0A             LDA    Itempl            ; get end of memory low byte
002012r 2  38                SEC                      ; set carry flag for subtract
002013r 2  E5 2B             SBC    Smeml             ; subtract start of memory low byte
002015r 2  85 CC             STA    LENL              ; store to Monitor length low byte
002017r 2               
002017r 2  A5 0B             LDA    Itemph            ; get end of memory high byte
002019r 2  E5 2C             SBC    Smemh             ; subtract start of memory high byte
00201Br 2  85 CD             STA    LENH              ; save to Monitor length high byte
00201Dr 2               
00201Dr 2  A9 01             LDA    #$01              ; get count of one
00201Fr 2  85 DC             STA    BLKNO             ; set Xmodem block count
002021r 2  64 D6             STZ    OPXMDM            ; clear OPXMDM flag
002023r 2               
002023r 2  80 2E             BRA    V_SAVE            ; call Xmodem SAVE vector and return
002025r 2               
002025r 2               ; Basic program code links line numbers via the first two bytes of
002025r 2               ; the program code starting at (Smeml) pointing to the next line of
002025r 2               ; Basic code. The end is marked by two consecutive $00 bytes.
002025r 2               ;
002025r 2               ; This routine, starts at (smeml) which points to the next line of
002025r 2               ; Basic code, then calculates the address to the next line after that
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002025r 2               ; and continues till it locates the last line.
002025r 2               ;
002025r 2               ; Once the end of Basic program space is found, (Itempl) is updated
002025r 2               ; by two, which points to the start of free memory.
002025r 2               
002025r 2               get_basmem
002025r 2  A5 2B             LDA     Smeml            ; get start address
002027r 2  85 0A             STA     Itempl           ; and save to
002029r 2  A5 2C             LDA     Smemh            ; temp pointer
00202Br 2  85 0B             STA     Itemph           ; high and low byte
00202Dr 2  A0 01             LDY     #$01             ; set Y reg for offset of 1
00202Fr 2               
00202Fr 2               scan_bas
00202Fr 2  B2 0A             LDA     (Itempl)         ; get BASIC low byte line address
002031r 2  AA                TAX                      ; save to X reg (could be next line low address)
002032r 2  F0 08             BEQ     chk_next         ; if zero, might be end, branch and check
002034r 2  B1 0A             LDA     (Itempl),y       ; else, get high byte line address
002036r 2               upd_bas
002036r 2  85 0B             STA     Itemph           ; update high byte line address
002038r 2  86 0A             STX     Itempl           ; update low byte line address
00203Ar 2  80 F3             BRA     scan_bas         ; branch back to find next line
00203Cr 2               
00203Cr 2               chk_next
00203Cr 2  B1 0A             LDA     (Itempl),y       ; get next byte, BASIC high byte line address
00203Er 2  D0 F6             BNE     upd_bas          ; if non-zero, branch to update line address
002040r 2               
002040r 2  20 rr rr          JSR     inc_line         ; else increment line address twice
002043r 2               inc_line
002043r 2  E6 0A             INC     Itempl           ; increment low byte count
002045r 2  D0 02             BNE     skp_ith          ; if not zero, skip high byte increment
002047r 2  E6 0B             INC     Itemph           ; else, increment high byte count
002049r 2               skp_ith
002049r 2  60                RTS                      ; return to caller
00204Ar 2               
00204Ar 2               ; system dependant I/O vectors
00204Ar 2               ; these are in RAM and are set by the monitor at start-up
00204Ar 2               
00204Ar 2               V_INPT
00204Ar 2  6C 84 05           JMP   (VEC_IN)          ; non halting scan input device
00204Dr 2               V_OUTP
00204Dr 2  6C 86 05           JMP   (VEC_OUT)         ; send byte to output device
002050r 2               V_LOAD
002050r 2  6C 88 05           JMP   (VEC_LD)          ; load BASIC program
002053r 2               V_SAVE
002053r 2  6C 8A 05           JMP   (VEC_SV)          ; save BASIC program
002056r 2               V_EXIT
002056r 2  6C 8C 05           JMP   (VEC_EXIT)        ; warm start C02 Monitor
002059r 2               
002059r 2               ; The rest are tables messages and code for RAM
002059r 2               
002059r 2               ; the rest of the code is tables and BASIC start-up code
002059r 2               ; monitor routines required are added below for initialization
002059r 2               
002059r 2               PG4_TABS
002059r 2  00                 .byte $00               ; ctrl-c flag - $00 = enabled
00205Ar 2  00                 .byte $00               ; ctrl-c byte - GET needs this
00205Br 2  00                 .byte $00               ; ctrl-c byte timeout - GET needs this
00205Cr 2  rr rr              .word CTRLC             ; ctrl-c check vector
00205Er 2               ;
00205Er 2  48 FF              .word $FF48           	; byte in from C02BIOS (no waiting)
002060r 2  4E FF              .word $FF4E           	; byte out from C02BIOS
002062r 2  45 FF              .word $FF45           	; null load JMP for EhBASIC (Reserve)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002064r 2  45 FF              .word $FF45           	; null save JMP for EhBASIC (Reserve)
002066r 2  72 FF              .word $FF72             ; Warm start JMP for C02 Monitor
002068r 2               
002068r 2               PG4_TABE
002068r 2               
002068r 2               ; page zero initialisation table $00-$0B inclusive
002068r 2               
002068r 2               StrTab
002068r 2  4C                 .byte $4C               ; JMP opcode
002069r 2  rr rr              .word LAB_1274          ; warm start vector
00206Br 2               
00206Br 2  4C                 .byte $4C               ; JMP opcode
00206Cr 2  rr rr              .word LAB_FCER          ; initial user function vector ("Function call" error)
00206Er 2               
00206Er 2  00                 .byte $00               ; default NULL count
00206Fr 2  00                 .byte $00               ; clear terminal position
002070r 2  50                 .byte $50               ; default terminal width byte = 80
002071r 2  F2                 .byte $F2               ; default limit for TAB = 14
002072r 2  00 08              .word Ram_base          ; start of user RAM
002074r 2               EndTab
002074r 2               
002074r 2               LAB_SMSG
002074r 2  20 42 79 74        .byte " Bytes free",$00
002078r 2  65 73 20 66  
00207Cr 2  72 65 65 00  
002080r 2               
002080r 2               ; numeric constants and series
002080r 2               ; cleaned up to removed commented lines which were replaced
002080r 2               
002080r 2                                             ; constants and series for LOG(n)
002080r 2               LAB_25A0
002080r 2  02                 .byte $02               ; counter
002081r 2  80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
002085r 2  80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
002089r 2  82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
00208Dr 2               
00208Dr 2               LAB_25AD
00208Dr 2  80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
002091r 2               LAB_25B1
002091r 2  81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
002095r 2               LAB_25B5
002095r 2  80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
002099r 2               LAB_25B9
002099r 2  80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
00209Dr 2               
00209Dr 2                                             ; numeric PRINT constants
00209Dr 2               LAB_2947
00209Dr 2  91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
0020A1r 2               LAB_294B
0020A1r 2  94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
0020A5r 2               LAB_294F
0020A5r 2  94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
0020A9r 2               
0020A9r 2                                             ; EXP(n) constants and series
0020A9r 2               LAB_2AFA
0020A9r 2  81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427 (1/LOG base 2 e)
0020ADr 2               LAB_2AFE
0020ADr 2  06                 .byte $06               ; counter
0020AEr 2  74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
0020B2r 2  77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
0020B6r 2  7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
0020BAr 2  7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0020BEr 2  7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
0020C2r 2  80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
0020C6r 2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
0020CAr 2               
0020CAr 2                                             ; trigonometric constants and series
0020CAr 2               LAB_2C78
0020CAr 2  81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
0020CEr 2               LAB_2C84
0020CEr 2  04                 .byte $04               ; counter
0020CFr 2  86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
0020D3r 2  87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
0020D7r 2  87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
0020DBr 2  86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
0020DFr 2               LAB_2C7C
0020DFr 2  83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
0020E3r 2               
0020E3r 2               LAB_2CC9
0020E3r 2  08                 .byte $08               ; counter
0020E4r 2  78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
0020E8r 2  7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
0020ECr 2  7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
0020F0r 2  7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
0020F4r 2  7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
0020F8r 2  7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
0020FCr 2  7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
002100r 2  7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
002104r 2               
002104r 2               LAB_1D96    = *+1          ; $00,$00 used for undefined variables
002104r 2               LAB_259C
002104r 2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
002108r 2               LAB_2AFD
002108r 2  81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC, must be on the same page as +1.00
00210Cr 2               
00210Cr 2                                             ; misc constants
00210Cr 2               LAB_1DF7
00210Cr 2  90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
00210Dr 2               LAB_2A96
00210Dr 2  80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
002111r 2               LAB_2C80
002111r 2  7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
002115r 2               LAB_26B5
002115r 2  84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
002119r 2               
002119r 2               ; This table is used in converting numbers to ASCII.
002119r 2               
002119r 2               LAB_2A9A
002119r 2               LAB_2A9B = LAB_2A9A+1
002119r 2               LAB_2A9C = LAB_2A9B+1
002119r 2  FE 79 60           .byte $FE,$79,$60       ; -100000
00211Cr 2  00 27 10           .byte $00,$27,$10       ; 10000
00211Fr 2  FF FC 18           .byte $FF,$FC,$18       ; -1000
002122r 2  00 00 64           .byte $00,$00,$64       ; 100
002125r 2  FF FF F6           .byte $FF,$FF,$F6       ; -10
002128r 2  00 00 01           .byte $00,$00,$01       ; 1
00212Br 2               
00212Br 2               LAB_CTBL
00212Br 2  rr rr              .word LAB_END-1         ; END
00212Dr 2  rr rr              .word LAB_FOR-1         ; FOR
00212Fr 2  rr rr              .word LAB_NEXT-1        ; NEXT
002131r 2  rr rr              .word LAB_DATA-1        ; DATA
002133r 2  rr rr              .word LAB_INPUT-1       ; INPUT
002135r 2  rr rr              .word LAB_DIM-1         ; DIM
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002137r 2  rr rr              .word LAB_READ-1        ; READ
002139r 2  rr rr              .word LAB_LET-1         ; LET
00213Br 2  rr rr              .word LAB_DEC-1         ; DEC new command
00213Dr 2  rr rr              .word LAB_GOTO-1        ; GOTO
00213Fr 2  rr rr              .word LAB_RUN-1         ; RUN
002141r 2  rr rr              .word LAB_IF-1          ; IF
002143r 2  rr rr              .word LAB_RESTORE-1     ; RESTORE modified command
002145r 2  rr rr              .word LAB_GOSUB-1       ; GOSUB
002147r 2  rr rr              .word LAB_RETURN-1      ; RETURN
002149r 2  rr rr              .word LAB_REM-1         ; REM
00214Br 2  rr rr              .word LAB_STOP-1        ; STOP
00214Dr 2  rr rr              .word LAB_ON-1          ; ON modified command
00214Fr 2  rr rr              .word LAB_NULL-1        ; NULL modified command
002151r 2  rr rr              .word LAB_INC-1         ; INC new command
002153r 2  rr rr              .word LAB_WAIT-1        ; WAIT
002155r 2  rr rr              .word LAB_LOAD-1        ; LOAD
002157r 2  rr rr              .word LAB_SAVE-1        ; SAVE
002159r 2  rr rr              .word LAB_DEF-1         ; DEF
00215Br 2  rr rr              .word LAB_POKE-1        ; POKE
00215Dr 2  rr rr              .word LAB_DOKE-1        ; DOKE new command
00215Fr 2  rr rr              .word LAB_CALL-1        ; CALL new command
002161r 2  rr rr              .word LAB_DO-1          ; DO new command
002163r 2  rr rr              .word LAB_LOOP-1        ; LOOP new command
002165r 2  rr rr              .word LAB_PRINT-1       ; PRINT
002167r 2  rr rr              .word LAB_CONT-1        ; CONT
002169r 2  rr rr              .word LAB_LIST-1        ; LIST
00216Br 2  rr rr              .word LAB_CLEAR-1       ; CLEAR
00216Dr 2  rr rr              .word LAB_NEW-1         ; NEW
00216Fr 2  rr rr              .word LAB_WDTH-1        ; WIDTH new command
002171r 2  rr rr              .word LAB_GET-1         ; GET new command
002173r 2  rr rr              .word LAB_SWAP-1        ; SWAP new command
002175r 2  rr rr              .word LAB_BITSET-1      ; BITSET new command
002177r 2  rr rr              .word LAB_BITCLR-1      ; BITCLR new command
002179r 2  rr rr              .word V_EXIT-1          ; EXIT new command (exits to C02 Monitor)
00217Br 2               
00217Br 2               ; function pre process routine table
00217Br 2               
00217Br 2               LAB_FTPL
00217Br 2               LAB_FTPM    = LAB_FTPL+$01
00217Br 2  rr rr              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
00217Dr 2  rr rr              .word LAB_PPFN-1        ; INT(n)          "
00217Fr 2  rr rr              .word LAB_PPFN-1        ; ABS(n)          "
002181r 2  rr rr              .word LAB_EVEZ-1        ; USR(x)    process any expression
002183r 2  rr rr              .word LAB_1BF7-1        ; FRE(x)          "
002185r 2  rr rr              .word LAB_1BF7-1        ; POS(x)          "
002187r 2  rr rr              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
002189r 2  rr rr              .word LAB_PPFN-1        ; RND(n)          "
00218Br 2  rr rr              .word LAB_PPFN-1        ; LOG(n)          "
00218Dr 2  rr rr              .word LAB_PPFN-1        ; EXP(n)          "
00218Fr 2  rr rr              .word LAB_PPFN-1        ; COS(n)          "
002191r 2  rr rr              .word LAB_PPFN-1        ; SIN(n)          "
002193r 2  rr rr              .word LAB_PPFN-1        ; TAN(n)          "
002195r 2  rr rr              .word LAB_PPFN-1        ; ATN(n)          "
002197r 2  rr rr              .word LAB_PPFN-1        ; PEEK(n)         "
002199r 2  rr rr              .word LAB_PPFN-1        ; DEEK(n)         "
00219Br 2  00 00              .word $0000             ; SADD()    none
00219Dr 2  rr rr              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
00219Fr 2  rr rr              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
0021A1r 2  rr rr              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
0021A3r 2  rr rr              .word LAB_PPFS-1        ; ASC($)          "
0021A5r 2  rr rr              .word LAB_PPFS-1        ; UCASE$($)       "
0021A7r 2  rr rr              .word LAB_PPFS-1        ; LCASE$($)       "
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0021A9r 2  rr rr              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
0021ABr 2  rr rr              .word LAB_BHSS-1        ; HEX$(n)         "
0021ADr 2  rr rr              .word LAB_BHSS-1        ; BIN$(n)         "
0021AFr 2  00 00              .word $0000             ; BITTST()  none
0021B1r 2  rr rr              .word LAB_MMPP-1        ; MAX()     process numeric expression
0021B3r 2  rr rr              .word LAB_MMPP-1        ; MIN()           "
0021B5r 2  rr rr              .word LAB_PPBI-1        ; PI        advance pointer
0021B7r 2  rr rr              .word LAB_PPBI-1        ; TWOPI           "
0021B9r 2  00 00              .word $0000             ; VARPTR()  none
0021BBr 2  rr rr              .word LAB_LRMS-1        ; LEFT$()   process string expression
0021BDr 2  rr rr              .word LAB_LRMS-1        ; RIGHT$()        "
0021BFr 2  rr rr              .word LAB_LRMS-1        ; MID$()          "
0021C1r 2               
0021C1r 2               ; action addresses for functions
0021C1r 2               
0021C1r 2               LAB_FTBL
0021C1r 2               LAB_FTBM    = LAB_FTBL+$01
0021C1r 2  rr rr              .word LAB_SGN-1         ; SGN()
0021C3r 2  rr rr              .word LAB_INT-1         ; INT()
0021C5r 2  rr rr              .word LAB_ABS-1         ; ABS()
0021C7r 2  rr rr              .word LAB_USR-1         ; USR()
0021C9r 2  rr rr              .word LAB_FRE-1         ; FRE()
0021CBr 2  rr rr              .word LAB_POS-1         ; POS()
0021CDr 2  rr rr              .word LAB_SQR-1         ; SQR()
0021CFr 2  rr rr              .word LAB_RND-1         ; RND() modified function
0021D1r 2  rr rr              .word LAB_LOG-1         ; LOG()
0021D3r 2  rr rr              .word LAB_EXP-1         ; EXP()
0021D5r 2  rr rr              .word LAB_COS-1         ; COS()
0021D7r 2  rr rr              .word LAB_SIN-1         ; SIN()
0021D9r 2  rr rr              .word LAB_TAN-1         ; TAN()
0021DBr 2  rr rr              .word LAB_ATN-1         ; ATN()
0021DDr 2  rr rr              .word LAB_PEEK-1        ; PEEK()
0021DFr 2  rr rr              .word LAB_DEEK-1        ; DEEK() new function
0021E1r 2  rr rr              .word LAB_SADD-1        ; SADD() new function
0021E3r 2  rr rr              .word LAB_LENS-1        ; LEN()
0021E5r 2  rr rr              .word LAB_STRS-1        ; STR$()
0021E7r 2  rr rr              .word LAB_VAL-1         ; VAL()
0021E9r 2  rr rr              .word LAB_ASC-1         ; ASC()
0021EBr 2  rr rr              .word LAB_UCASE-1       ; UCASE$() new function
0021EDr 2  rr rr              .word LAB_LCASE-1       ; LCASE$()  new function
0021EFr 2  rr rr              .word LAB_CHRS-1        ; CHR$()
0021F1r 2  rr rr              .word LAB_HEXS-1        ; HEX$() new function
0021F3r 2  rr rr              .word LAB_BINS-1        ; BIN$() new function
0021F5r 2  rr rr              .word LAB_BTST-1        ; BITTST() new function
0021F7r 2  rr rr              .word LAB_MAX-1         ; MAX() new function
0021F9r 2  rr rr              .word LAB_MIN-1         ; MIN() new function
0021FBr 2  rr rr              .word LAB_PI-1          ; PI new function
0021FDr 2  rr rr              .word LAB_TWOPI-1       ; TWOPI new function
0021FFr 2  rr rr              .word LAB_VARPTR-1      ; VARPTR() new function
002201r 2  rr rr              .word LAB_LEFT-1        ; LEFT$()
002203r 2  rr rr              .word LAB_RIGHT-1       ; RIGHT$()
002205r 2  rr rr              .word LAB_MIDS-1        ; MID$()
002207r 2               
002207r 2               ; hierarchy and action addresses for operator
002207r 2               
002207r 2               LAB_OPPT
002207r 2  79                 .byte $79               ; +
002208r 2  rr rr              .word LAB_ADD-1
00220Ar 2  79                 .byte $79               ; -
00220Br 2  rr rr              .word LAB_SUBTRACT-1
00220Dr 2  7B                 .byte $7B               ; *
00220Er 2  rr rr              .word LAB_MULTIPLY-1
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002210r 2  7B                 .byte $7B               ; /
002211r 2  rr rr              .word LAB_DIVIDE-1
002213r 2  7F                 .byte $7F               ; ^
002214r 2  rr rr              .word LAB_POWER-1
002216r 2  50                 .byte $50               ; AND
002217r 2  rr rr              .word LAB_AND-1
002219r 2  46                 .byte $46               ; EOR new operator
00221Ar 2  rr rr              .word LAB_EOR-1
00221Cr 2  46                 .byte $46               ; OR
00221Dr 2  rr rr              .word LAB_OR-1
00221Fr 2  56                 .byte $56               ; >> new operator
002220r 2  rr rr              .word LAB_RSHIFT-1
002222r 2  56                 .byte $56               ; << new operator
002223r 2  rr rr              .word LAB_LSHIFT-1
002225r 2  7D                 .byte $7D               ; >
002226r 2  rr rr              .word LAB_GTHAN-1
002228r 2  5A                 .byte $5A               ; =
002229r 2  rr rr              .word LAB_EQUAL-1
00222Br 2  64                 .byte $64               ; <
00222Cr 2  rr rr              .word LAB_LTHAN-1
00222Er 2               
00222Er 2               ; keywords start with ..
00222Er 2               ; this is the first character table and must be in alphabetic order
00222Er 2               
00222Er 2               TAB_1STC
00222Er 2  2A                 .byte "*"
00222Fr 2  2B                 .byte "+"
002230r 2  2D                 .byte "-"
002231r 2  2F                 .byte "/"
002232r 2  3C                 .byte "<"
002233r 2  3D                 .byte "="
002234r 2  3E                 .byte ">"
002235r 2  3F                 .byte "?"
002236r 2  41                 .byte "A"
002237r 2  42                 .byte "B"
002238r 2  43                 .byte "C"
002239r 2  44                 .byte "D"
00223Ar 2  45                 .byte "E"
00223Br 2  46                 .byte "F"
00223Cr 2  47                 .byte "G"
00223Dr 2  48                 .byte "H"
00223Er 2  49                 .byte "I"
00223Fr 2  4C                 .byte "L"
002240r 2  4D                 .byte "M"
002241r 2  4E                 .byte "N"
002242r 2  4F                 .byte "O"
002243r 2  50                 .byte "P"
002244r 2  52                 .byte "R"
002245r 2  53                 .byte "S"
002246r 2  54                 .byte "T"
002247r 2  55                 .byte "U"
002248r 2  56                 .byte "V"
002249r 2  57                 .byte "W"
00224Ar 2  5E                 .byte "^"
00224Br 2  00                 .byte $00               ; table terminator
00224Cr 2               
00224Cr 2               ; pointers to keyword tables
00224Cr 2               
00224Cr 2               TAB_CHRT
00224Cr 2  rr rr              .word TAB_STAR          ; table for "*"
00224Er 2  rr rr              .word TAB_PLUS          ; table for "+"
002250r 2  rr rr              .word TAB_MNUS          ; table for "-"
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002252r 2  rr rr              .word TAB_SLAS          ; table for "/"
002254r 2  rr rr              .word TAB_LESS          ; table for "<"
002256r 2  rr rr              .word TAB_EQUL          ; table for "="
002258r 2  rr rr              .word TAB_MORE          ; table for ">"
00225Ar 2  rr rr              .word TAB_QEST          ; table for "?"
00225Cr 2  rr rr              .word TAB_ASCA          ; table for "A"
00225Er 2  rr rr              .word TAB_ASCB          ; table for "B"
002260r 2  rr rr              .word TAB_ASCC          ; table for "C"
002262r 2  rr rr              .word TAB_ASCD          ; table for "D"
002264r 2  rr rr              .word TAB_ASCE          ; table for "E"
002266r 2  rr rr              .word TAB_ASCF          ; table for "F"
002268r 2  rr rr              .word TAB_ASCG          ; table for "G"
00226Ar 2  rr rr              .word TAB_ASCH          ; table for "H"
00226Cr 2  rr rr              .word TAB_ASCI          ; table for "I"
00226Er 2  rr rr              .word TAB_ASCL          ; table for "L"
002270r 2  rr rr              .word TAB_ASCM          ; table for "M"
002272r 2  rr rr              .word TAB_ASCN          ; table for "N"
002274r 2  rr rr              .word TAB_ASCO          ; table for "O"
002276r 2  rr rr              .word TAB_ASCP          ; table for "P"
002278r 2  rr rr              .word TAB_ASCR          ; table for "R"
00227Ar 2  rr rr              .word TAB_ASCS          ; table for "S"
00227Cr 2  rr rr              .word TAB_ASCT          ; table for "T"
00227Er 2  rr rr              .word TAB_ASCU          ; table for "U"
002280r 2  rr rr              .word TAB_ASCV          ; table for "V"
002282r 2  rr rr              .word TAB_ASCW          ; table for "W"
002284r 2  rr rr              .word TAB_POWR          ; table for "^"
002286r 2               
002286r 2               ; tables for each start character, note if a longer keyword with the same start
002286r 2               ; letters as a shorter one exists then it must come first, else the list is in
002286r 2               ; alphabetical order as follows ..
002286r 2               
002286r 2               ; [keyword,token
002286r 2               ; [keyword,token]]
002286r 2               ; end marker (#$00)
002286r 2               
002286r 2               TAB_STAR
002286r 2  B4 00              .byte TK_MUL,$00        ; *
002288r 2               TAB_PLUS
002288r 2  B2 00              .byte TK_PLUS,$00       ; +
00228Ar 2               TAB_MNUS
00228Ar 2  B3 00              .byte TK_MINUS,$00      ; -
00228Cr 2               TAB_SLAS
00228Cr 2  B5 00              .byte TK_DIV,$00        ; /
00228Er 2               TAB_LESS
00228Er 2               LBB_LSHIFT
00228Er 2  3C BB              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
002290r 2  BE                 .byte TK_LT             ; <
002291r 2  00                 .byte $00
002292r 2               TAB_EQUL
002292r 2  BD 00              .byte TK_EQUAL,$00      ; =
002294r 2               TAB_MORE
002294r 2               LBB_RSHIFT
002294r 2  3E BA              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
002296r 2  BC                 .byte TK_GT             ; >
002297r 2  00                 .byte $00
002298r 2               TAB_QEST
002298r 2  9D 00              .byte TK_PRINT,$00      ; ?
00229Ar 2               TAB_ASCA
00229Ar 2               LBB_ABS
00229Ar 2  42 53 28 C1        .byte "BS(",TK_ABS      ; ABS(
00229Er 2               LBB_AND
00229Er 2  4E 44 B7           .byte "ND",TK_AND       ; AND
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0022A1r 2               LBB_ASC
0022A1r 2  53 43 28 D3        .byte "SC(",TK_ASC      ; ASC(
0022A5r 2               LBB_ATN
0022A5r 2  54 4E 28 CC        .byte "TN(",TK_ATN      ; ATN(
0022A9r 2  00                 .byte $00
0022AAr 2               TAB_ASCB
0022AAr 2               LBB_BINS
0022AAr 2  49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
0022AEr 2  D8           
0022AFr 2               LBB_BITCLR
0022AFr 2  49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
0022B3r 2  52 A6        
0022B5r 2               LBB_BITSET
0022B5r 2  49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
0022B9r 2  54 A5        
0022BBr 2               LBB_BITTST
0022BBr 2  49 54 54 53        .byte "ITTST(",TK_BITTST
0022BFr 2  54 28 D9     
0022C2r 2                                             ; BITTST(
0022C2r 2  00                 .byte $00
0022C3r 2               TAB_ASCC
0022C3r 2               LBB_CALL
0022C3r 2  41 4C 4C 9A        .byte "ALL",TK_CALL     ; CALL
0022C7r 2               LBB_CHRS
0022C7r 2  48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
0022CBr 2  D6           
0022CCr 2               LBB_CLEAR
0022CCr 2  4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
0022D0r 2  A0           
0022D1r 2               LBB_CONT
0022D1r 2  4F 4E 54 9E        .byte "ONT",TK_CONT     ; CONT
0022D5r 2               LBB_COS
0022D5r 2  4F 53 28 C9        .byte "OS(",TK_COS      ; COS(
0022D9r 2  00                 .byte $00
0022DAr 2               TAB_ASCD
0022DAr 2               LBB_DATA
0022DAr 2  41 54 41 83        .byte "ATA",TK_DATA     ; DATA
0022DEr 2               LBB_DEC
0022DEr 2  45 43 88           .byte "EC",TK_DEC       ; DEC
0022E1r 2               LBB_DEEK
0022E1r 2  45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
0022E5r 2  CE           
0022E6r 2               LBB_DEF
0022E6r 2  45 46 97           .byte "EF",TK_DEF       ; DEF
0022E9r 2               LBB_DIM
0022E9r 2  49 4D 85           .byte "IM",TK_DIM       ; DIM
0022ECr 2               LBB_DOKE
0022ECr 2  4F 4B 45 99        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
0022F0r 2               LBB_DO
0022F0r 2  4F 9B              .byte "O",TK_DO         ; DO
0022F2r 2  00                 .byte $00
0022F3r 2               TAB_ASCE
0022F3r 2               LBB_ELSE
0022F3r 2  4C 53 45 A9        .byte "LSE",TK_ELSE     ; ELSE
0022F7r 2               LBB_END
0022F7r 2  4E 44 80           .byte "ND",TK_END       ; END
0022FAr 2               LBB_EOR
0022FAr 2  4F 52 B8           .byte "OR",TK_EOR       ; EOR
0022FDr 2               LBB_EXP
0022FDr 2  58 50 28 C8        .byte "XP(",TK_EXP      ; EXP(
002301r 2               LBB_EXIT
002301r 2  58 49 54 A7        .byte "XIT",TK_EXIT     ; EXIT
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002305r 2  00                 .byte $00
002306r 2               TAB_ASCF
002306r 2               LBB_FN
002306r 2  4E AB              .byte "N",TK_FN         ; FN
002308r 2               LBB_FOR
002308r 2  4F 52 81           .byte "OR",TK_FOR       ; FOR
00230Br 2               LBB_FRE
00230Br 2  52 45 28 C3        .byte "RE(",TK_FRE      ; FRE(
00230Fr 2  00                 .byte $00
002310r 2               TAB_ASCG
002310r 2               LBB_GET
002310r 2  45 54 A3           .byte "ET",TK_GET       ; GET
002313r 2               LBB_GOSUB
002313r 2  4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
002317r 2  8D           
002318r 2               LBB_GOTO
002318r 2  4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
00231Cr 2  00                 .byte $00
00231Dr 2               TAB_ASCH
00231Dr 2               LBB_HEXS
00231Dr 2  45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
002321r 2  D7           
002322r 2  00                 .byte $00
002323r 2               TAB_ASCI
002323r 2               LBB_IF
002323r 2  46 8B              .byte "F",TK_IF         ; IF
002325r 2               LBB_INC
002325r 2  4E 43 93           .byte "NC",TK_INC       ; INC
002328r 2               LBB_INPUT
002328r 2  4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
00232Cr 2  84           
00232Dr 2               LBB_INT
00232Dr 2  4E 54 28 C0        .byte "NT(",TK_INT      ; INT(
002331r 2  00                 .byte $00
002332r 2               TAB_ASCL
002332r 2               LBB_LCASES
002332r 2  43 41 53 45        .byte "CASE$(",TK_LCASES
002336r 2  24 28 D5     
002339r 2                                             ; LCASE$(
002339r 2               LBB_LEFTS
002339r 2  45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
00233Dr 2  28 DF        
00233Fr 2               LBB_LEN
00233Fr 2  45 4E 28 D0        .byte "EN(",TK_LEN      ; LEN(
002343r 2               LBB_LET
002343r 2  45 54 87           .byte "ET",TK_LET       ; LET
002346r 2               LBB_LIST
002346r 2  49 53 54 9F        .byte "IST",TK_LIST     ; LIST
00234Ar 2               LBB_LOAD
00234Ar 2  4F 41 44 95        .byte "OAD",TK_LOAD     ; LOAD
00234Er 2               LBB_LOG
00234Er 2  4F 47 28 C7        .byte "OG(",TK_LOG      ; LOG(
002352r 2               LBB_LOOP
002352r 2  4F 4F 50 9C        .byte "OOP",TK_LOOP     ; LOOP
002356r 2  00                 .byte $00
002357r 2               TAB_ASCM
002357r 2               LBB_MAX
002357r 2  41 58 28 DA        .byte "AX(",TK_MAX      ; MAX(
00235Br 2               LBB_MIDS
00235Br 2  49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
00235Fr 2  E1           
002360r 2               LBB_MIN
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002360r 2  49 4E 28 DB        .byte "IN(",TK_MIN      ; MIN(
002364r 2  00                 .byte $00
002365r 2               TAB_ASCN
002365r 2               LBB_NEW
002365r 2  45 57 A1           .byte "EW",TK_NEW       ; NEW
002368r 2               LBB_NEXT
002368r 2  45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
00236Cr 2               LBB_NOT
00236Cr 2  4F 54 AE           .byte "OT",TK_NOT       ; NOT
00236Fr 2               LBB_NULL
00236Fr 2  55 4C 4C 92        .byte "ULL",TK_NULL     ; NULL
002373r 2  00                 .byte $00
002374r 2               TAB_ASCO
002374r 2               LBB_ON
002374r 2  4E 91              .byte "N",TK_ON         ; ON
002376r 2               LBB_OR
002376r 2  52 B9              .byte "R",TK_OR         ; OR
002378r 2  00                 .byte $00
002379r 2               TAB_ASCP
002379r 2               LBB_PEEK
002379r 2  45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
00237Dr 2  CD           
00237Er 2               LBB_PI
00237Er 2  49 DC              .byte "I",TK_PI         ; PI
002380r 2               LBB_POKE
002380r 2  4F 4B 45 98        .byte "OKE",TK_POKE     ; POKE
002384r 2               LBB_POS
002384r 2  4F 53 28 C4        .byte "OS(",TK_POS      ; POS(
002388r 2               LBB_PRINT
002388r 2  52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
00238Cr 2  9D           
00238Dr 2  00                 .byte $00
00238Er 2               TAB_ASCR
00238Er 2               LBB_READ
00238Er 2  45 41 44 86        .byte "EAD",TK_READ     ; READ
002392r 2               LBB_REM
002392r 2  45 4D 8F           .byte "EM",TK_REM       ; REM
002395r 2               LBB_RESTORE
002395r 2  45 53 54 4F        .byte "ESTORE",TK_RESTORE
002399r 2  52 45 8C     
00239Cr 2                                             ; RESTORE
00239Cr 2               LBB_RETURN
00239Cr 2  45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
0023A0r 2  4E 8E        
0023A2r 2               LBB_RIGHTS
0023A2r 2  49 47 48 54        .byte "IGHT$(",TK_RIGHTS
0023A6r 2  24 28 E0     
0023A9r 2                                             ; RIGHT$(
0023A9r 2               LBB_RND
0023A9r 2  4E 44 28 C6        .byte "ND(",TK_RND      ; RND(
0023ADr 2               LBB_RUN
0023ADr 2  55 4E 8A           .byte "UN",TK_RUN       ; RUN
0023B0r 2  00                 .byte $00
0023B1r 2               TAB_ASCS
0023B1r 2               LBB_SADD
0023B1r 2  41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
0023B5r 2  CF           
0023B6r 2               LBB_SAVE
0023B6r 2  41 56 45 96        .byte "AVE",TK_SAVE     ; SAVE
0023BAr 2               LBB_SGN
0023BAr 2  47 4E 28 BF        .byte "GN(",TK_SGN      ; SGN(
0023BEr 2               LBB_SIN
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0023BEr 2  49 4E 28 CA        .byte "IN(",TK_SIN      ; SIN(
0023C2r 2               LBB_SPC
0023C2r 2  50 43 28 AC        .byte "PC(",TK_SPC      ; SPC(
0023C6r 2               LBB_SQR
0023C6r 2  51 52 28 C5        .byte "QR(",TK_SQR      ; SQR(
0023CAr 2               LBB_STEP
0023CAr 2  54 45 50 AF        .byte "TEP",TK_STEP     ; STEP
0023CEr 2               LBB_STOP
0023CEr 2  54 4F 50 90        .byte "TOP",TK_STOP     ; STOP
0023D2r 2               LBB_STRS
0023D2r 2  54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
0023D6r 2  D1           
0023D7r 2               LBB_SWAP
0023D7r 2  57 41 50 A4        .byte "WAP",TK_SWAP     ; SWAP
0023DBr 2  00                 .byte $00
0023DCr 2               TAB_ASCT
0023DCr 2               LBB_TAB
0023DCr 2  41 42 28 A8        .byte "AB(",TK_TAB      ; TAB(
0023E0r 2               LBB_TAN
0023E0r 2  41 4E 28 CB        .byte "AN(",TK_TAN      ; TAN(
0023E4r 2               LBB_THEN
0023E4r 2  48 45 4E AD        .byte "HEN",TK_THEN     ; THEN
0023E8r 2               LBB_TO
0023E8r 2  4F AA              .byte "O",TK_TO         ; TO
0023EAr 2               LBB_TWOPI
0023EAr 2  57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
0023EEr 2  DD           
0023EFr 2  00                 .byte $00
0023F0r 2               TAB_ASCU
0023F0r 2               LBB_UCASES
0023F0r 2  43 41 53 45        .byte "CASE$(",TK_UCASES
0023F4r 2  24 28 D4     
0023F7r 2                                             ; UCASE$(
0023F7r 2               LBB_UNTIL
0023F7r 2  4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
0023FBr 2  B0           
0023FCr 2               LBB_USR
0023FCr 2  53 52 28 C2        .byte "SR(",TK_USR      ; USR(
002400r 2  00                 .byte $00
002401r 2               TAB_ASCV
002401r 2               LBB_VAL
002401r 2  41 4C 28 D2        .byte "AL(",TK_VAL      ; VAL(
002405r 2               LBB_VPTR
002405r 2  41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
002409r 2  52 28 DE     
00240Cr 2  00                 .byte $00
00240Dr 2               TAB_ASCW
00240Dr 2               LBB_WAIT
00240Dr 2  41 49 54 94        .byte "AIT",TK_WAIT     ; WAIT
002411r 2               LBB_WHILE
002411r 2  48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
002415r 2  B1           
002416r 2               LBB_WIDTH
002416r 2  49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
00241Ar 2  A2           
00241Br 2  00                 .byte $00
00241Cr 2               TAB_POWR
00241Cr 2  B6 00              .byte TK_POWER,$00      ; ^
00241Er 2               
00241Er 2               ; new decode table for LIST
00241Er 2               ; Table is ..
00241Er 2               ; byte - keyword length, keyword first character
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

00241Er 2               ; word - pointer to rest of keyword from dictionary
00241Er 2               
00241Er 2               ; note if length is 1 then the pointer is ignored
00241Er 2               
00241Er 2               LAB_KEYT
00241Er 2  03 45              .byte 3,'E'
002420r 2  rr rr              .word LBB_END           ; END
002422r 2  03 46              .byte 3,'F'
002424r 2  rr rr              .word LBB_FOR           ; FOR
002426r 2  04 4E              .byte 4,'N'
002428r 2  rr rr              .word LBB_NEXT          ; NEXT
00242Ar 2  04 44              .byte 4,'D'
00242Cr 2  rr rr              .word LBB_DATA          ; DATA
00242Er 2  05 49              .byte 5,'I'
002430r 2  rr rr              .word LBB_INPUT         ; INPUT
002432r 2  03 44              .byte 3,'D'
002434r 2  rr rr              .word LBB_DIM           ; DIM
002436r 2  04 52              .byte 4,'R'
002438r 2  rr rr              .word LBB_READ          ; READ
00243Ar 2  03 4C              .byte 3,'L'
00243Cr 2  rr rr              .word LBB_LET           ; LET
00243Er 2  03 44              .byte 3,'D'
002440r 2  rr rr              .word LBB_DEC           ; DEC
002442r 2  04 47              .byte 4,'G'
002444r 2  rr rr              .word LBB_GOTO          ; GOTO
002446r 2  03 52              .byte 3,'R'
002448r 2  rr rr              .word LBB_RUN           ; RUN
00244Ar 2  02 49              .byte 2,'I'
00244Cr 2  rr rr              .word LBB_IF            ; IF
00244Er 2  07 52              .byte 7,'R'
002450r 2  rr rr              .word LBB_RESTORE       ; RESTORE
002452r 2  05 47              .byte 5,'G'
002454r 2  rr rr              .word LBB_GOSUB         ; GOSUB
002456r 2  06 52              .byte 6,'R'
002458r 2  rr rr              .word LBB_RETURN        ; RETURN
00245Ar 2  03 52              .byte 3,'R'
00245Cr 2  rr rr              .word LBB_REM           ; REM
00245Er 2  04 53              .byte 4,'S'
002460r 2  rr rr              .word LBB_STOP          ; STOP
002462r 2  02 4F              .byte 2,'O'
002464r 2  rr rr              .word LBB_ON            ; ON
002466r 2  04 4E              .byte 4,'N'
002468r 2  rr rr              .word LBB_NULL          ; NULL
00246Ar 2  03 49              .byte 3,'I'
00246Cr 2  rr rr              .word LBB_INC           ; INC
00246Er 2  04 57              .byte 4,'W'
002470r 2  rr rr              .word LBB_WAIT          ; WAIT
002472r 2  04 4C              .byte 4,'L'
002474r 2  rr rr              .word LBB_LOAD          ; LOAD
002476r 2  04 53              .byte 4,'S'
002478r 2  rr rr              .word LBB_SAVE          ; SAVE
00247Ar 2  03 44              .byte 3,'D'
00247Cr 2  rr rr              .word LBB_DEF           ; DEF
00247Er 2  04 50              .byte 4,'P'
002480r 2  rr rr              .word LBB_POKE          ; POKE
002482r 2  04 44              .byte 4,'D'
002484r 2  rr rr              .word LBB_DOKE          ; DOKE
002486r 2  04 43              .byte 4,'C'
002488r 2  rr rr              .word LBB_CALL          ; CALL
00248Ar 2  02 44              .byte 2,'D'
00248Cr 2  rr rr              .word LBB_DO            ; DO
00248Er 2  04 4C              .byte 4,'L'
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002490r 2  rr rr              .word LBB_LOOP          ; LOOP
002492r 2  05 50              .byte 5,'P'
002494r 2  rr rr              .word LBB_PRINT         ; PRINT
002496r 2  04 43              .byte 4,'C'
002498r 2  rr rr              .word LBB_CONT          ; CONT
00249Ar 2  04 4C              .byte 4,'L'
00249Cr 2  rr rr              .word LBB_LIST          ; LIST
00249Er 2  05 43              .byte 5,'C'
0024A0r 2  rr rr              .word LBB_CLEAR         ; CLEAR
0024A2r 2  03 4E              .byte 3,'N'
0024A4r 2  rr rr              .word LBB_NEW           ; NEW
0024A6r 2  05 57              .byte 5,'W'
0024A8r 2  rr rr              .word LBB_WIDTH         ; WIDTH
0024AAr 2  03 47              .byte 3,'G'
0024ACr 2  rr rr              .word LBB_GET           ; GET
0024AEr 2  04 53              .byte 4,'S'
0024B0r 2  rr rr              .word LBB_SWAP          ; SWAP
0024B2r 2  06 42              .byte 6,'B'
0024B4r 2  rr rr              .word LBB_BITSET        ; BITSET
0024B6r 2  06 42              .byte 6,'B'
0024B8r 2  rr rr              .word LBB_BITCLR        ; BITCLR
0024BAr 2  04 45              .byte 4,"E"
0024BCr 2  rr rr              .word LBB_EXIT          ; EXIT
0024BEr 2               
0024BEr 2               ; secondary commands (can't start a statement)
0024BEr 2               
0024BEr 2  04 54              .byte 4,'T'
0024C0r 2  rr rr              .word LBB_TAB           ; TAB
0024C2r 2  04 45              .byte 4,'E'
0024C4r 2  rr rr              .word LBB_ELSE          ; ELSE
0024C6r 2  02 54              .byte 2,'T'
0024C8r 2  rr rr              .word LBB_TO            ; TO
0024CAr 2  02 46              .byte 2,'F'
0024CCr 2  rr rr              .word LBB_FN            ; FN
0024CEr 2  04 53              .byte 4,'S'
0024D0r 2  rr rr              .word LBB_SPC           ; SPC
0024D2r 2  04 54              .byte 4,'T'
0024D4r 2  rr rr              .word LBB_THEN          ; THEN
0024D6r 2  03 4E              .byte 3,'N'
0024D8r 2  rr rr              .word LBB_NOT           ; NOT
0024DAr 2  04 53              .byte 4,'S'
0024DCr 2  rr rr              .word LBB_STEP          ; STEP
0024DEr 2  05 55              .byte 5,'U'
0024E0r 2  rr rr              .word LBB_UNTIL         ; UNTIL
0024E2r 2  05 57              .byte 5,'W'
0024E4r 2  rr rr              .word LBB_WHILE         ; WHILE
0024E6r 2               
0024E6r 2               ; opperators
0024E6r 2               
0024E6r 2  01 2B              .byte 1,'+'
0024E8r 2  00 00              .word $0000             ; +
0024EAr 2  01 2D              .byte 1,'-'
0024ECr 2  00 00              .word $0000             ; -
0024EEr 2  01 2A              .byte 1,'*'
0024F0r 2  00 00              .word $0000             ; *
0024F2r 2  01 2F              .byte 1,'/'
0024F4r 2  00 00              .word $0000             ; /
0024F6r 2  01 5E              .byte 1,'^'
0024F8r 2  00 00              .word $0000             ; ^
0024FAr 2  03 41              .byte 3,'A'
0024FCr 2  rr rr              .word LBB_AND           ; AND
0024FEr 2  03 45              .byte 3,'E'
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002500r 2  rr rr              .word LBB_EOR           ; EOR
002502r 2  02 4F              .byte 2,'O'
002504r 2  rr rr              .word LBB_OR            ; OR
002506r 2  02 3E              .byte 2,'>'
002508r 2  rr rr              .word LBB_RSHIFT        ; >>
00250Ar 2  02 3C              .byte 2,'<'
00250Cr 2  rr rr              .word LBB_LSHIFT        ; <<
00250Er 2  01 3E              .byte 1,'>'
002510r 2  00 00              .word $0000             ; >
002512r 2  01 3D              .byte 1,'='
002514r 2  00 00              .word $0000             ; =
002516r 2  01 3C              .byte 1,'<'
002518r 2  00 00              .word $0000             ; <
00251Ar 2               
00251Ar 2               ; functions
00251Ar 2               
00251Ar 2  04 53              .byte 4,'S'             ;
00251Cr 2  rr rr              .word LBB_SGN           ; SGN
00251Er 2  04 49              .byte 4,'I'             ;
002520r 2  rr rr              .word LBB_INT           ; INT
002522r 2  04 41              .byte 4,'A'             ;
002524r 2  rr rr              .word LBB_ABS           ; ABS
002526r 2  04 55              .byte 4,'U'             ;
002528r 2  rr rr              .word LBB_USR           ; USR
00252Ar 2  04 46              .byte 4,'F'             ;
00252Cr 2  rr rr              .word LBB_FRE           ; FRE
00252Er 2  04 50              .byte 4,'P'             ;
002530r 2  rr rr              .word LBB_POS           ; POS
002532r 2  04 53              .byte 4,'S'             ;
002534r 2  rr rr              .word LBB_SQR           ; SQR
002536r 2  04 52              .byte 4,'R'             ;
002538r 2  rr rr              .word LBB_RND           ; RND
00253Ar 2  04 4C              .byte 4,'L'             ;
00253Cr 2  rr rr              .word LBB_LOG           ; LOG
00253Er 2  04 45              .byte 4,'E'             ;
002540r 2  rr rr              .word LBB_EXP           ; EXP
002542r 2  04 43              .byte 4,'C'             ;
002544r 2  rr rr              .word LBB_COS           ; COS
002546r 2  04 53              .byte 4,'S'             ;
002548r 2  rr rr              .word LBB_SIN           ; SIN
00254Ar 2  04 54              .byte 4,'T'             ;
00254Cr 2  rr rr              .word LBB_TAN           ; TAN
00254Er 2  04 41              .byte 4,'A'             ;
002550r 2  rr rr              .word LBB_ATN           ; ATN
002552r 2  05 50              .byte 5,'P'             ;
002554r 2  rr rr              .word LBB_PEEK          ; PEEK
002556r 2  05 44              .byte 5,'D'             ;
002558r 2  rr rr              .word LBB_DEEK          ; DEEK
00255Ar 2  05 53              .byte 5,'S'             ;
00255Cr 2  rr rr              .word LBB_SADD          ; SADD
00255Er 2  04 4C              .byte 4,'L'             ;
002560r 2  rr rr              .word LBB_LEN           ; LEN
002562r 2  05 53              .byte 5,'S'             ;
002564r 2  rr rr              .word LBB_STRS          ; STR$
002566r 2  04 56              .byte 4,'V'             ;
002568r 2  rr rr              .word LBB_VAL           ; VAL
00256Ar 2  04 41              .byte 4,'A'             ;
00256Cr 2  rr rr              .word LBB_ASC           ; ASC
00256Er 2  07 55              .byte 7,'U'             ;
002570r 2  rr rr              .word LBB_UCASES        ; UCASE$
002572r 2  07 4C              .byte 7,'L'             ;
002574r 2  rr rr              .word LBB_LCASES        ; LCASE$
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

002576r 2  05 43              .byte 5,'C'             ;
002578r 2  rr rr              .word LBB_CHRS          ; CHR$
00257Ar 2  05 48              .byte 5,'H'             ;
00257Cr 2  rr rr              .word LBB_HEXS          ; HEX$
00257Er 2  05 42              .byte 5,'B'             ;
002580r 2  rr rr              .word LBB_BINS          ; BIN$
002582r 2  07 42              .byte 7,'B'             ;
002584r 2  rr rr              .word LBB_BITTST        ; BITTST
002586r 2  04 4D              .byte 4,'M'             ;
002588r 2  rr rr              .word LBB_MAX           ; MAX
00258Ar 2  04 4D              .byte 4,'M'             ;
00258Cr 2  rr rr              .word LBB_MIN           ; MIN
00258Er 2  02 50              .byte 2,'P'             ;
002590r 2  rr rr              .word LBB_PI            ; PI
002592r 2  05 54              .byte 5,'T'             ;
002594r 2  rr rr              .word LBB_TWOPI         ; TWOPI
002596r 2  07 56              .byte 7,'V'             ;
002598r 2  rr rr              .word LBB_VPTR          ; VARPTR
00259Ar 2  06 4C              .byte 6,'L'             ;
00259Cr 2  rr rr              .word LBB_LEFTS         ; LEFT$
00259Er 2  07 52              .byte 7,'R'             ;
0025A0r 2  rr rr              .word LBB_RIGHTS        ; RIGHT$
0025A2r 2  05 4D              .byte 5,'M'             ;
0025A4r 2  rr rr              .word LBB_MIDS          ; MID$
0025A6r 2               
0025A6r 2               ; BASIC messages, mostly error messages
0025A6r 2               
0025A6r 2               LAB_BAER
0025A6r 2  rr rr              .word ERR_NF            ;$00 NEXT without FOR
0025A8r 2  rr rr              .word ERR_SN            ;$02 syntax
0025AAr 2  rr rr              .word ERR_RG            ;$04 RETURN without GOSUB
0025ACr 2  rr rr              .word ERR_OD            ;$06 out of data
0025AEr 2  rr rr              .word ERR_FC            ;$08 function call
0025B0r 2  rr rr              .word ERR_OV            ;$0A overflow
0025B2r 2  rr rr              .word ERR_OM            ;$0C out of memory
0025B4r 2  rr rr              .word ERR_US            ;$0E undefined statement
0025B6r 2  rr rr              .word ERR_BS            ;$10 array bounds
0025B8r 2  rr rr              .word ERR_DD            ;$12 double dimension array
0025BAr 2  rr rr              .word ERR_D0            ;$14 divide by 0
0025BCr 2  rr rr              .word ERR_ID            ;$16 illegal direct
0025BEr 2  rr rr              .word ERR_TM            ;$18 type mismatch
0025C0r 2  rr rr              .word ERR_LS            ;$1A long string
0025C2r 2  rr rr              .word ERR_ST            ;$1C string too complex
0025C4r 2  rr rr              .word ERR_CN            ;$1E continue error
0025C6r 2  rr rr              .word ERR_UF            ;$20 undefined function
0025C8r 2  rr rr              .word ERR_LD            ;$22 LOOP without DO
0025CAr 2               
0025CAr 2               ; I may implement these two errors to force definition of variables and
0025CAr 2               ; dimensioning of arrays before use.
0025CAr 2               
0025CAr 2               ;     .word ERR_UV            ;$24 undefined variable
0025CAr 2               
0025CAr 2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
0025CAr 2               
0025CAr 2               ;     .word ERR_UA            ;$26 undimensioned array
0025CAr 2               
0025CAr 2  4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
0025CEr 2  20 77 69 74  
0025D2r 2  68 6F 75 74  
0025DBr 2  53 79 6E 74  ERR_SN      .byte "Syntax",$00
0025DFr 2  61 78 00     
0025E2r 2  52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0025E6r 2  52 4E 20 77  
0025EAr 2  69 74 68 6F  
0025F7r 2  4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
0025FBr 2  6F 66 20 44  
0025FFr 2  41 54 41 00  
002603r 2  46 75 6E 63  ERR_FC      .byte "Function call",$00
002607r 2  74 69 6F 6E  
00260Br 2  20 63 61 6C  
002611r 2  4F 76 65 72  ERR_OV      .byte "Overflow",$00
002615r 2  66 6C 6F 77  
002619r 2  00           
00261Ar 2  4F 75 74 20  ERR_OM      .byte "Out of memory",$00
00261Er 2  6F 66 20 6D  
002622r 2  65 6D 6F 72  
002628r 2  55 6E 64 65  ERR_US      .byte "Undefined statement",$00
00262Cr 2  66 69 6E 65  
002630r 2  64 20 73 74  
00263Cr 2  41 72 72 61  ERR_BS      .byte "Array bounds",$00
002640r 2  79 20 62 6F  
002644r 2  75 6E 64 73  
002649r 2  44 6F 75 62  ERR_DD      .byte "Double dimension",$00
00264Dr 2  6C 65 20 64  
002651r 2  69 6D 65 6E  
00265Ar 2  44 69 76 69  ERR_D0      .byte "Divide by zero",$00
00265Er 2  64 65 20 62  
002662r 2  79 20 7A 65  
002669r 2  49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
00266Dr 2  67 61 6C 20  
002671r 2  64 69 72 65  
002678r 2  54 79 70 65  ERR_TM      .byte "Type mismatch",$00
00267Cr 2  20 6D 69 73  
002680r 2  6D 61 74 63  
002686r 2  53 74 72 69  ERR_LS      .byte "String too long",$00
00268Ar 2  6E 67 20 74  
00268Er 2  6F 6F 20 6C  
002696r 2  53 74 72 69  ERR_ST      .byte "String too complex",$00
00269Ar 2  6E 67 20 74  
00269Er 2  6F 6F 20 63  
0026A9r 2  43 61 6E 27  ERR_CN      .byte "Can't continue",$00
0026ADr 2  74 20 63 6F  
0026B1r 2  6E 74 69 6E  
0026B8r 2  55 6E 64 65  ERR_UF      .byte "Undefined function",$00
0026BCr 2  66 69 6E 65  
0026C0r 2  64 20 66 75  
0026CBr 2  4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
0026CFr 2  20 77 69 74  
0026D3r 2  68 6F 75 74  
0026DBr 2               
0026DBr 2               ;ERR_UV     .byte "Undefined variable",$00
0026DBr 2               
0026DBr 2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
0026DBr 2               
0026DBr 2               ;ERR_UA     .byte "Undimensioned array",$00
0026DBr 2               
0026DBr 2  0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
0026DFr 2  65 61 6B 00  
0026E3r 2  20 45 72 72  LAB_EMSG    .byte " Error",$00
0026E7r 2  6F 72 00     
0026EAr 2  20 69 6E 20  LAB_LMSG    .byte " in line ",$00
0026EEr 2  6C 69 6E 65  
0026F2r 2  20 00        
0026F4r 2  0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/basic.s

0026F8r 2  61 64 79 0D  
0026FCr 2  0A 00        
0026FEr 2               
0026FEr 2  20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
002702r 2  72 61 20 69  
002706r 2  67 6E 6F 72  
00270Fr 2  20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
002713r 2  6F 20 66 72  
002717r 2  6F 6D 20 73  
002722r 2               
002722r 1               	.include "bios.s"
002722r 2               .segment "BIOS"
000000r 2               ;******************************************************************************
000000r 2               ; $F800	;2KB reserved for BIOS
000000r 2               ;******************************************************************************
000000r 2               ;START OF BIOS CODE
000000r 2               ;******************************************************************************
000000r 2               ; C02BIOS version used here is 1.4
000000r 2               ;
000000r 2               ; Contains the base BIOS routines in top 1KB of EEPROM
000000r 2               ; - Pages $F8/$F9 512 bytes for BIOS (65C51/65C22), NMI Panic routine
000000r 2               ; - Pages $FA-$ED reserved for BIOS expansion
000000r 2               ; - Page $02 reserved for HW (8-I/O devices, 16 bytes wide and 1-I/O device, 128 bytes wide)
000000r 2               ; - Page ($FF) JMP table, CPU startup, 64 bytes Soft Vectors and HW Config data
000000r 2               ;		- does I/O init and handles NMI/BRK/IRQ pre-/post-processing routines
000000r 2               ;		- sends BIOS message string to console
000000r 2               ;	- Additional code added to handle XMODEM transfers
000000r 2               ;		- allows a null character to be received into the buffer
000000r 2               ;		- CRC bytes can be zero, original code would invoke BRK routine
000000r 2               ;		- Uses the XMFLAG flag which is set/cleared during Xmodem xfers
000000r 2               ;		- Now uses BBR instruction to check XMFLAG - saves a byte
000000r 2               ;		-	Now uses BBR instruction to check BRK condition - saves a byte
000000r 2               ; - BEEP moved to main monitor code, JMP entry replaced with CHRIN_NW
000000r 2               ; - Input/Feedback from "BDD" - modified CHR-I/O routines - saves 12 bytes
000000r 2               ;******************************************************************************
000000r 2               ;	The following 16 functions are provided by BIOS and available via the JMP
000000r 2               ;	Table as the last 16 entries from $FF48 - $FF75 as:
000000r 2               ;	$FF48 CHRIN_NW (character input from console, no waiting, set carry if none)
000000r 2               ;	$FF4B CHRIN (character input from console)
000000r 2               ;	$FF4E CHROUT (character output to console)
000000r 2               ;	$FF51 SETDLY (set delay value for milliseconds and 16-bit counter)
000000r 2               ;	$FF54 MSDELAY (execute millisecond delay 1-256 milliseconds)
000000r 2               ;	$FF57 LGDELAY (execute long delay; millisecond delay * 16-bit count)
000000r 2               ;	$FF5A XLDELAY (execute extra long delay; 8-bit count * long delay)
000000r 2               ;	$FF5D SETPORT (set VIA port A or B for input or output)
000000r 2               ;	$FF60 RDPORT (read from VIA port A or B)
000000r 2               ;	$FF63 WRPORT (write to VIA port A or B)
000000r 2               ;	$FF66 INITVEC (initialize soft vectors at $0300 from ROM)
000000r 2               ;	$FF69 INITCFG (initialize soft config values at $0320 from ROM)
000000r 2               ;	$FF6C INITCON (initialize 65C51 console 19.2K, 8-N-1 RTS/CTS)
000000r 2               ;	$FF6F INITVIA (initialize 65C22 default port, timers and interrupts)
000000r 2               ;	$FF72 MONWARM (warm start Monitor - jumps to page $03)
000000r 2               ;	$FF75 MONCOLD (cold start Monitor - jumps to page $03)
000000r 2               ;******************************************************************************
000000r 2               ; Character In and Out routines for Console I/O buffer
000000r 2               ;******************************************************************************
000000r 2               ;
000000r 2               ;CHRIN routines
000000r 2               ;CHRIN_NW uses CHRIN, returns if a character is not available from the buffer
000000r 2               ; with carry flag clear, else returns with character in A reg and carry flag set
000000r 2               ;CHRIN waitd for a character to be in the buffer, then returns with carry flag set
000000r 2               ;	receive is IRQ driven / buffered with a fixed size of 128 bytes
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

000000r 2               ;
000000r 2  18           CHRIN_NW	CLC	;Clear Carry flag for no character (2)
000001r 2  A5 E7        					LDA	ICNT	;Get character count (3)
000003r 2  D0 05        					BNE	GET_CH	;Branch if buffer is not empty (2/3)
000005r 2  60           					RTS	;and return to caller (6)
000006r 2               ;
000006r 2               ;CHRIN waits for a character and retuns with it in the A reg
000006r 2               ;
000006r 2  A5 E7        CHRIN			LDA	ICNT	;Get character count (3)
000008r 2  F0 FC        					BEQ	CHRIN	;If zero (no character, loop back) (2/3)
00000Ar 2               ;
00000Ar 2  5A           GET_CH		PHY	;Save Y reg (3)
00000Br 2  A4 E8        					LDY	IHEAD	;Get the buffer head pointer (3)
00000Dr 2  B9 00 03     					LDA	IBUF,Y	;Get the character from the buffer (4)
000010r 2               ;
000010r 2  E6 E8        					INC	IHEAD	;Increment head pointer (5)
000012r 2  77 E8        					RMB7	IHEAD	;Strip off bit 7, 128 bytes only (5)
000014r 2               ;
000014r 2  C6 E7        					DEC	ICNT	;Decrement the buffer count (5)
000016r 2  7A           					PLY	;Restore Y Reg (4)
000017r 2  38           					SEC	;Set Carry flag for character available (2)
000018r 2  60           					RTS	;Return to caller with character in A reg (6)
000019r 2               ;
000019r 2               ;CHROUT routine: takes the character in the A reg and places it in the xmit buffer
000019r 2               ; the character sent in the A reg is preserved on exit
000019r 2               ;	transmit is IRQ driven / buffered with a fixed size of 128 bytes
000019r 2               ;
000019r 2               ;	- 8/10/2014 - modified this routine to always set the Xmit interrupt active with each
000019r 2               ;	character placed into the output buffer. There appears to be a highly intermittant bug
000019r 2               ;	in both the 6551 and 65C51 where the Xmit interrupt turns itself off, the code itself
000019r 2               ;	is not doing it as the OIE flag was never reset and this only happens in the IRQ routine
000019r 2               ;	The I/O and service routines now appear to work in a stable manner on all 6551 and 65C51
000019r 2               ;	Note: OIE flag no longer needed/used due to bug workaround
000019r 2               ;
000019r 2               CHROUT
000019r 2  8D 20 02     				STA SIODAT
00001Cr 2  20 rr rr     				JSR delay_6551
00001Fr 2  60           				RTS
000020r 2               
000020r 2               delay_6551:
000020r 2  5A           	phy				;Save Y Reg
000021r 2  DA           	phx				;Save X Reg
000022r 2  A0 08        	ldy		#8		;Get delay value (clock rate in MHz 8 clock cycles)
000024r 2               	; ldy		#1		;Get delay value (clock rate in MHz 1 clock cycles)
000024r 2               
000024r 2               @clock_loop:
000024r 2  A2 CC        	ldx		#$CC	;Seed X reg, $11 works for 115200 baud, $66 for 19200, $CC for 9600
000026r 2               @baud_loop:
000026r 2  CA           	dex				;Decrement low index
000027r 2  D0 FD        	bne		@baud_loop	 ;Loop back until done
000029r 2  88           	dey				;Decrease by one
00002Ar 2  D0 F8        	bne		@clock_loop	 ;Loop until done
00002Cr 2  FA           	plx				;Restore X Reg
00002Dr 2  7A           	ply				;Restore Y Reg
00002Er 2  60           	rts				;Delay done, return
00002Fr 2               
00002Fr 2               
00002Fr 2               ; CHROUT		PHY	;save Y reg	(3)
00002Fr 2               ; OUTCH			LDY	OCNT	;get character output count in buffer	(3)
00002Fr 2               ; 					BMI	OUTCH	;check against limit, loop back if full	(2/3)
00002Fr 2               ; ;
00002Fr 2               ; 					LDY	OTAIL	;Get the buffer tail pointer	(3)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

00002Fr 2               ; 					STA	OBUF,Y	;Place character in the buffer	(5)
00002Fr 2               ; ;
00002Fr 2               ; 					INC	OTAIL	;Increment Tail pointer (5)
00002Fr 2               ; 					RMB7	OTAIL	;Strip off bit 7, 128 bytes only (5)
00002Fr 2               ; 					INC	OCNT	;Increment character count	(5)
00002Fr 2               ; ;
00002Fr 2               ; 					LDY	#$01	;Get mask for xmit on	(2)
00002Fr 2               ; 					STY	SIOCOM	;Turn on xmit irq	(4)
00002Fr 2               ; ;
00002Fr 2               ; OUTC2			PLY	;Restore Y reg	(4)
00002Fr 2               ; 					RTS	;Return	to caller (6)
00002Fr 2               ;
00002Fr 2               ;******************************************************************************
00002Fr 2               ;SET DELAY routine
00002Fr 2               ; This routine sets up the MSDELAY values and can also set the Long Delay variable
00002Fr 2               ; On entry, A reg = millisecond count, X reg = High multipler, Y reg = Low multipler
00002Fr 2               ;	these values are used by the EXE_MSDLY and EXE_LGDLY routines
00002Fr 2               ;	values for MSDELAY are $00-$FF ($00 = 256 times)
00002Fr 2               ;	values for Long Delay are $0000-$FFFF (0-65535 times)
00002Fr 2               ;	longest delay is 65,535*256*1ms = 16,776,960 * 0.001 = 16,776.960 seconds
00002Fr 2               ;
00002Fr 2  85 F6        SET_DLY		STA	SETIM	;Save millisecond count (3)
000031r 2  84 F7        					STY	DELLO	;Save Low multipler (3)
000033r 2  86 F8        					STX	DELHI	;Save High Multipler (3)
000035r 2  60           					RTS	;Return to caller (6)
000036r 2               ;
000036r 2               ;EXE MSDELAY routine
000036r 2               ;	This routine is the core delay routine
000036r 2               ;	It sets the count value from SETIM variable, enables the MATCH flag, then starts
000036r 2               ;	Timer 2 and waits for the IRQ routine to decrement to zero and clear the MATCH flag
000036r 2               ;	note: 3 clock cycles (JMP table) to get here on a standard call
000036r 2               ;	- 11 clock cycles to start T2, 15 clock cycles to return after MATCH cleared
000036r 2               ;	- starting T2 first to help normalize overall delay time
000036r 2               ;	- total of 37 clock cycles overhead in this routine
000036r 2               ;
000036r 2  48           EXE_MSDLY	PHA	;Save A Reg (3)
000037r 2  AD 29 04     					LDA	LOAD_6522+$07	;Get T2H value (4)
00003Ar 2  8D 19 02     					STA	Via1T2CH	;Reload T2 and enable interrupt (4)
00003Dr 2  F7 F5        					SMB7	MATCH	;Set MATCH flag bit (5)
00003Fr 2  A5 F6        					LDA	SETIM	;Get delay seed value (3)
000041r 2  85 F4        					STA	MSDELAY	;Set MS delay value (3)
000043r 2               ;
000043r 2  FF F5 FD     MATCH_LP	BBS7	MATCH,MATCH_LP	;Test MATCH flag, loop until cleared (5)
000046r 2  68           					PLA	;Restore A Reg (4)
000047r 2  60           					RTS	;Return to caller (6)
000048r 2               ;
000048r 2               ;EXE LONG Delay routine
000048r 2               ;	This routine is the 16-bit multiplier for the MS DELAY routine
000048r 2               ;	It loads the 16-bit count from DELLO/DELHI, then loops the MSDELAY
000048r 2               ;	routine until the 16-bit count is decremented to zero
000048r 2               ;
000048r 2  DA           EXE_LGDLY	PHX	;Save X Reg (4)
000049r 2  5A           					PHY	;Save Y Reg (4)
00004Ar 2  A6 F8        					LDX	DELHI	;Get high byte count (3)
00004Cr 2  E8           					INX	;Increment by one (checks for $00 vs $FF) (2)
00004Dr 2  A4 F7        					LDY	DELLO	;Get low byte count (3)
00004Fr 2  F0 06        					BEQ	SKP_DLL	;If zero, skip to high count (2/3)
000051r 2  20 rr rr     DO_DLL		JSR	EXE_MSDLY	;Call millisecond delay (6)
000054r 2  88           					DEY	;Decrement low count (2)
000055r 2  D0 FA        					BNE	DO_DLL	;Branch back until done (2/3)
000057r 2               ;
000057r 2  CA           SKP_DLL		DEX	;Decrement high byte index (2)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

000058r 2  D0 F7        					BNE	DO_DLL	;Loop back to DLL (will run 256 times) (2/3)
00005Ar 2  7A           					PLY	;Restore Y Reg (3)
00005Br 2  FA           					PLX	;Restore X Reg (3)
00005Cr 2  60           					RTS	;Return to caller (6)
00005Dr 2               ;
00005Dr 2               ;EXE EXTRA LONG Delay routine
00005Dr 2               ;	This routine uses XDL variable as an 8-bit count
00005Dr 2               ;	and calls the EXE LONG Delay routine XDL times
00005Dr 2               ;	- On entry, XDL contains the number of interations
00005Dr 2  20 rr rr     EXE_XLDLY	JSR	EXE_LGDLY	;Call the Long Delay routine (6)
000060r 2  C6 F9        					DEC	XDL	;Decrement count (5)
000062r 2  D0 F9        					BNE	EXE_XLDLY	;Loop back until XDL times out (2/3)
000064r 2  60           					RTS	;Done, return to caller (6)
000065r 2               ;
000065r 2               ;******************************************************************************
000065r 2               ; I/O PORT routines for 6522
000065r 2               ;	- Allows port A or B setup for input or output
000065r 2               ;	- Allows data to be read from Port A or B
000065r 2               ;	- Allows data to be written to Port A or B
000065r 2               ;	- Routines are Non-buffered and no HW handshaking
000065r 2               ;	- Page zero variables are used: IO_DIR, IO_IN, IO_OUT
000065r 2               ;
000065r 2               ;	6522 Port Config routine
000065r 2               ;	- Allows Port A or B to be configured for input or output
000065r 2               ;	- On entry, X reg contains port number (1=A, 0=B)
000065r 2               ;	- A reg contains config mask; bit=0 for Input, bit=1 for Output
000065r 2               ;	- on exit, A reg contain Port DDR value, X reg contains port #
000065r 2               ;	- Carry set if error, cleared if OK
000065r 2               ;
000065r 2  9D 12 02     SET_PORT	STA	Via1DDRB,X	;Store config Mask to the correct port (5)
000068r 2  85 FB        					STA	IO_DIR	;Save Mask for compare (3)
00006Ar 2  BD 12 02     					LDA	Via1DDRB,X	;Load config Mask back from port (4)
00006Dr 2  C5 FB        					CMP	IO_DIR	;Compare to config MASK (3)
00006Fr 2  B0 02        					BCS	PORT_OK	;Branch if same (2/3)
000071r 2  38           					SEC	;Set Carry for bad compare (2)
000072r 2  60           					RTS	;Return to caller (6)
000073r 2  18           PORT_OK		CLC	;Clear Carry flag for no error (2)
000074r 2  60           					RTS	;Return to caller (6)
000075r 2               ;
000075r 2               ;	Port Input routine
000075r 2               ;	- On entry, X reg contains port number (1=A, 0=B)
000075r 2               ;	- On exit, A reg contains read data, X reg contains port #
000075r 2               ;	- Carry set if error on read, cleared if OK
000075r 2               ;	- Requested Port is read twice and compared for error,
000075r 2               ;	- this implies port data input does not change too quickly
000075r 2               ;
000075r 2  BD 10 02     IN_PORT		LDA	Via1PRB,X	;Read Port data (4)
000078r 2  85 FC        					STA	IO_IN	;Save Read data (3)
00007Ar 2  BD 10 02     					LDA	Via1PRB,X	;Read Port a second time (4)
00007Dr 2  C5 FC        					CMP	IO_IN	;Compare against previous read (3)
00007Fr 2  B0 F2        					BCS	PORT_OK	;Branch if same (2/3)
000081r 2  38           					SEC	;Set Carry for bad compare (2)
000082r 2  60           					RTS	;Return to caller (6)
000083r 2               ;
000083r 2               ;	Port Output routine
000083r 2               ;	- On entry, X reg contains port number (1=A, 0=B)
000083r 2               ;	- A reg contain data to write to port
000083r 2               ;	- On exit, A reg contains Port data, X reg contains port #
000083r 2               ;	- Carry set if error on write, cleared if OK
000083r 2               ;
000083r 2  9D 10 02     OUT_PORT	STA	Via1PRB,X	;Write Port data (5)
000086r 2  85 FD        					STA	IO_OUT	;Save data to output to port (3)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

000088r 2  BD 10 02     					LDA	Via1PRB,X	;Read Port data back (4)
00008Br 2  C5 FD        					CMP	IO_OUT	;Compare against previous read (3)
00008Dr 2  B0 E4        					BCS	PORT_OK	;Branch if same (2/3)
00008Fr 2  38           					SEC	;Set Carry for bad compare (2)
000090r 2  60           					RTS	;Return to caller (6)
000091r 2               ;
000091r 2               ;******************************************************************************
000091r 2               ;
000091r 2               ;START OF PANIC ROUTINE
000091r 2               ; The Panic routine is for debug of system problems, i.e., a crash
000091r 2               ; The design requires a debounced NMI trigger button which is manually operated
000091r 2               ; when the system crashes or malfunctions, press the NMI (panic) button
000091r 2               ; The NMI vectored routine will perform the following tasks:
000091r 2               ; 1- Save registers in page $00
000091r 2               ; 2- Save pages $00, $01, $02 and $03 at location $0400-$07FF
000091r 2               ; 3- Overlay the I/O page ($FE) at location $0780
000091r 2               ; 4- Zero I/O buffer pointers
000091r 2               ; Call the ROM routines to init the vectors and config data (page $03)
000091r 2               ; Call ROM routines to init the 6551 and 6522 devices
000091r 2               ; Restart the Monitor via warm start vector
000091r 2               ; No memory is cleared except the required pointers to restore the system
000091r 2               ;	- suggest invoking the Register command afterwards to get the details saved
000091r 2               ;
000091r 2               NMI_VECTOR	;This is the ROM start for NMI Panic handler
000091r 2  85 E6        					STA	AREG	;Save A Reg (3)
000093r 2  86 E5        					STX	XREG	;Save X Reg (3)
000095r 2  84 E4        					STY	YREG	;Save Y Reg (3)
000097r 2  68           					PLA	;Get Processor Status 	      (3)
000098r 2  85 E2        					STA	PREG	;Save in PROCESSOR STATUS preset/result (3)
00009Ar 2  BA           					TSX	;Get Stack pointer (2)
00009Br 2  86 E3        					STX	SREG	;Save STACK POINTER (3)
00009Dr 2  68           					PLA	;Pull RETURN address from STACK (3)
00009Er 2  85 E0        					STA	PCL	;Store Low byte (3)
0000A0r 2  68           					PLA	;Pull high byte (3)
0000A1r 2  85 E1        					STA	PCH	;Store High byte (3)
0000A3r 2               ;
0000A3r 2  A0 00        					LDY	#$00	;Zero Y reg (2)
0000A5r 2  A2 04        					LDX	#$04	;Set index to 4 pages (2)
0000A7r 2  86 03        					STX	$03	;Set to high order (3)
0000A9r 2  64 02        					STZ	$02	;Zero remaining pointers (3)
0000ABr 2  64 01        					STZ	$01 ;(3)
0000ADr 2  64 00        					STZ	$00 ;(3)
0000AFr 2               ;
0000AFr 2  B1 00        PLP0			LDA	($00),Y	;get byte (4)
0000B1r 2  91 02        					STA	($02),Y	;store byte (6)
0000B3r 2  88           					DEY	;Decrement index (2)
0000B4r 2  D0 F9        					BNE	PLP0	;Loop back till done (2/3)
0000B6r 2               ;
0000B6r 2  E6 03        					INC	$03	;Increment page address (5)
0000B8r 2  E6 01        					INC	$01	;Increment page address (5)
0000BAr 2  CA           					DEX	;Decrement page index (2)
0000BBr 2  D0 F2        					BNE	PLP0	;Branch back and do next page (2/3)
0000BDr 2               ;
0000BDr 2  BD 00 FE     IO_LOOP		LDA	$FE00,X	;Get I/O Page (X reg already at #$00) (4)
0000C0r 2  9D 80 07     					STA	$0780,X	;Overlay I/O page to Vector Save (5)
0000C3r 2  E8           					INX	;Increment index (2)
0000C4r 2  10 F7        					BPL	IO_LOOP	;Loop back until done (128 bytes) (2/3)
0000C6r 2               ;
0000C6r 2  A2 06        					LDX	#$06	;Get count of 6 (2)
0000C8r 2  74 E6        PAN_LP1		STZ	ICNT-1,X	;Zero out console I/O pointers (4)
0000CAr 2  CA           					DEX	;Decrement index (2)
0000CBr 2  D0 FB        					BNE	PAN_LP1	;Branch back till done (2/3)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

0000CDr 2               ;
0000CDr 2  20 rr rr     					JSR	INIT_PG03	;Xfer default Vectors/HW Config to $0300 (6)
0000D0r 2  20 rr rr     					JSR	INIT_IO	;Init I/O - Console, Timers, Ports (6)
0000D3r 2               ;
0000D3r 2  6C 06 04     					JMP	(NMIRTVEC0)	;Jump to Monitor Warm Start Vector (5)
0000D6r 2               ;
0000D6r 2               ;*************************************
0000D6r 2               ;* BRK/IRQ Interrupt service routine *
0000D6r 2               ;*************************************
0000D6r 2               ;
0000D6r 2               ;The pre-process routine located in page $FF soft-vectors to here:
0000D6r 2               ;	The following routines handle BRK and IRQ
0000D6r 2               ;	The BRK handler saves CPU details for register display
0000D6r 2               ;	- A Monitor can provide a disassembly of the last executed instruction
0000D6r 2               ;	- An ASCII null character ($00) is also handled here
0000D6r 2               ;
0000D6r 2               ;6551 handler
0000D6r 2               ;	The 6551 IRQ routine handles both transmit and receive via IRQ
0000D6r 2               ;	- each has it's own 128 circular buffer
0000D6r 2               ;	- Xmit IRQ is controlled by the handler and the CHROUT routine
0000D6r 2               ;
0000D6r 2               ;6522 handler
0000D6r 2               ; The 6522 IRQ routine handles Timer1 interrupts used for a RTC
0000D6r 2               ;	- resolution is set for 4ms (250 interrupts per second)
0000D6r 2               ;	- recommended CPU clock rate is 2MHz minimum
0000D6r 2               ; Timer2 provides an accurate delay with resolution to 1ms
0000D6r 2               ;	- timer service/match routine are IRQ driven with dedicated handler
0000D6r 2               ;
0000D6r 2  58           BREAKEY		CLI	;Enable IRQ (2)
0000D7r 2               ;
0000D7r 2  7A           BRKINSTR0	PLY	;Restore Y reg (4)
0000D8r 2  FA           					PLX	;Restore X Reg (4)
0000D9r 2  68           					PLA	;Restore A Reg (4)
0000DAr 2  85 E6        					STA	AREG	;Save A Reg (3)
0000DCr 2  86 E5        					STX	XREG	;Save X Reg (3)
0000DEr 2  84 E4        					STY	YREG	;Save Y Reg (3)
0000E0r 2  68           					PLA	;Get Processor Status (4)
0000E1r 2  85 E2        					STA	PREG	;Save in PROCESSOR STATUS preset/result (2)
0000E3r 2  BA           					TSX	;Xfrer STACK pointer to X reg (2)
0000E4r 2  86 E3        					STX	SREG	;Save STACK pointer (4)
0000E6r 2               ;
0000E6r 2  FA           					PLX	;Pull Low RETURN address from STACK then save it (4)
0000E7r 2  86 E0        					STX	PCL	;Store program counter Low byte (3)
0000E9r 2  86 C0        					STX	INDEXL	;Seed Indexl for DIS_LINE (3)
0000EBr 2  7A           					PLY	;Pull High RETURN address from STACK then save it (4)
0000ECr 2  84 E1        					STY	PCH	;Store program counter High byte (3)
0000EEr 2  84 C1        					STY	INDEXH	;Seed Indexh for DIS_LINE (3)
0000F0r 2  4F E2 09     					BBR4	PREG,DO_NULL	;Check for BRK bit set (5)
0000F3r 2               ;
0000F3r 2               ; The following three subroutines are contained in the base Monitor code
0000F3r 2               ; These calls do a register display and disassembles the line of code
0000F3r 2               ; that caused the BRK to occur. Other code can be added if required
0000F3r 2               ;	- if replaced with new code, either replace or remove this routine
0000F3r 2               ;
0000F3r 2  20 rr rr     					JSR	PRSTAT1	;Display CPU status (6)
0000F6r 2  20 rr rr     					JSR	DECINDEX	;Decrement Index location (point to BRK ID Byte) (6)
0000F9r 2  20 rr rr     					JSR	DIS_LINE	;Disassemble current instruction (6)
0000FCr 2               ;
0000FCr 2  A9 00        DO_NULL		LDA	#$00	;Clear all PROCESSOR STATUS REGISTER bits (2)
0000FEr 2  48           					PHA	; (3)
0000FFr 2  28           					PLP	; (4)
000100r 2  64 E9        					STZ	ITAIL	;Zero out input buffer / reset pointers (3)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

000102r 2  64 E8        					STZ	IHEAD	; (3)
000104r 2  64 E7        					STZ	ICNT	; (3)
000106r 2  6C 08 04     					JMP	(BRKRTVEC0)	;Done BRK service process, re-enter monitor (3)
000109r 2               ;
000109r 2               ;new full duplex IRQ handler (54 clock cycles overhead to this point - includes return)
000109r 2               ;
000109r 2  AD 21 02     INTERUPT0	LDA	SIOSTAT	;Get status register, xfer irq bit to n flag (4)
00010Cr 2  10 08        					BPL	REGEXT	;if clear no 6551 irq, exit, else (2/3) (7 clock cycles to exit - take branch)
00010Er 2               ;
00010Er 2  89 08        ASYNC			BIT #%00001000	;check receive bit (2)
000110r 2  D0 0B        					BNE RCVCHR	;get received character (2/3) (11 clock cycles to jump to RCV)
000112r 2               					; BIT #%00010000	;check xmit bit (2)
000112r 2               					; BNE XMTCHR	;send xmit character (2/3) (15 clock cycles to jump to XMIT)
000112r 2               ;no bits on means CTS went high
000112r 2  09 10        					ORA #%00010000 ;add CTS high mask to current status (2)
000114r 2  85 ED        IRQEXT		STA STTVAL ;update status value (3) (19 clock cycles to here for CTS fallout)
000116r 2               ;
000116r 2  6C 0A 04     REGEXT		JMP	(IRQRTVEC0) ;handle next irq (5)
000119r 2               ;
000119r 2  A9 0C        BUFFUL		LDA #%00001100 ;buffer overflow flag (2)
00011Br 2  80 F7        					BRA IRQEXT ;branch to exit (3)
00011Dr 2               ;
00011Dr 2  AD 20 02     RCVCHR		LDA SIODAT	;get character from 6551 (4)
000120r 2  D0 03        					BNE	RCV0	;If not a null character, handle as usual and put into buffer	(2/3)
000122r 2  6F FE B1     					BBR6	XMFLAG,BREAKEY	;If Xmodem not active, handle BRK (5)
000125r 2               ;
000125r 2  A4 E7        RCV0			LDY ICNT	;get buffer counter (3)
000127r 2  30 F0        					BMI	BUFFUL	;check against limit, branch if full (2/3)
000129r 2               ;
000129r 2  A4 E9        					LDY ITAIL ;room in buffer (3)
00012Br 2  99 00 03     					STA IBUF,Y ;store into buffer (5)
00012Er 2  E6 E9        					INC	ITAIL	;Increment tail pointer (5)
000130r 2  77 E9        					RMB7	ITAIL	;Strip off bit 7, 128 bytes only (5)
000132r 2  E6 E7        					INC ICNT ;increment character count (5)
000134r 2               ;
000134r 2  AD 21 02     					LDA SIOSTAT ;get 6551 status reg (4)
000137r 2  29 10        					AND #%00010000 ;check for xmit (2)
000139r 2  F0 DB        					BEQ REGEXT	;exit (2/3) (40 if exit, else 39 and drop to XMT)
00013Br 2               ;
00013Br 2  A5 EA        XMTCHR		LDA OCNT ;any characters to xmit? (3)
00013Dr 2  F0 10        					BEQ NODATA ;no, turn off xmit (2/3)
00013Fr 2               ;
00013Fr 2  A4 EB        OUTDAT		LDY OHEAD ;get pointer to buffer (3)
000141r 2  B9 80 03     					LDA OBUF,Y ;get the next character (4)
000144r 2  8D 20 02     					STA SIODAT ;send the data (4)
000147r 2               ;
000147r 2  E6 EB        					INC	OHEAD	;Increment Head pointer (5)
000149r 2  77 EB        					RMB7	OHEAD	;Strip off bit 7, 128 bytes only (5)
00014Br 2  C6 EA        					DEC OCNT ;decrement counter (5)
00014Dr 2  D0 C7        					BNE	REGEXT	;If not zero, exit and continue normal stuff (2/3) (31 if branch, 30 if continue)
00014Fr 2               ;
00014Fr 2  A0 09        NODATA		LDY	#$09	;get mask for xmit off / rcv on (2)
000151r 2  8C 22 02     					STY SIOCOM ;turn off xmit irq bits (5)
000154r 2  80 C0        					BRA REGEXT ;exit (3) (13 clock cycles added for turning off xmt)
000156r 2               ;
000156r 2               ;******************************************************************************
000156r 2               ;
000156r 2               ;Start of the 6522 BIOS code. Supports basic timer function
000156r 2               ; A time of day clock is implemented with a resolution of 4ms
000156r 2               ; Timer ticks is set at 250 ticks per second. Page zero holds
000156r 2               ; all variables for ticks, seconds, minutes, hours, days
000156r 2               ; To keep things simple, days is two bytes so can handle 0-65535 days,
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

000156r 2               ; which is about 179 years. Additional calculations can be made if
000156r 2               ; required for a particular application
000156r 2               ;
000156r 2               ;	Timer Delay Match routine:
000156r 2               ;	This provides an accurate and consistent time delay
000156r 2               ; using Timer 2 of the 6522. It is configured as a one-shot timer
000156r 2               ;	set for 1 millisecond based on clock rate (see config table)
000156r 2               ;	It uses an 8-bit value for countdown to reset a MATCH flag on timeout
000156r 2               ;	Value can be 1-256 milliseconds ($00 = 256)
000156r 2               ;	This routine must also reset the counter if MSDELAY has not decremented
000156r 2               ;	to zero, which completes the timer delay
000156r 2               ; The delay routine sets the MSDELAY value and MATCH flag to $80,
000156r 2               ; then monitors the MATCH flag which is cleared after the delay
000156r 2               ;
000156r 2               ;	Note that each Timer has it's own exit vector. By default they point to the
000156r 2               ;	following IRQ vector (6551 service routine). This allows either timer to be
000156r 2               ;	used as a refresh routine by inserting additional code in either loop. The RTC
000156r 2               ;	should not be changed, but Timer2 can be provided the user track it's use versus
000156r 2               ;	the standard delay routines which also use Timer2
000156r 2               ;	NOTE: 24 clock cycles via IRQ vector to get here
000156r 2               ;
000156r 2               ;Basic use of timer services includes:
000156r 2               ;		RTC - time (relative timestamp)
000156r 2               ;		Internal delay and timing routines
000156r 2               ;		Background refresh tasks
000156r 2               ;
000156r 2  AD 1D 02     INTERUPT1	LDA	Via1IFR	;Get IRQ flag register, xfer irq bit to n flag (4)
000159r 2  10 4F        					BPL	REGEXT1	;if set, 6522 caused irq,(do not branch) (2/3) (7 clock cycles to exit - take branch)
00015Br 2  89 20        					BIT	#%00100000	;check T2 interrupt bit (2)
00015Dr 2  D0 08        					BNE	DECMSD	;If active, handle T2 timer (MS delay) (2/3)
00015Fr 2  89 40        					BIT #%01000000	;check T1 interrupt bit (2)
000161r 2  D0 18        					BNE	INCRTC	;If active, handle T1 timer (RTC) (2/3)
000163r 2               ; 					BIT #%00000010	;check CA1 interrupt bit (2)
000163r 2               ; 					BEQ NO_KBD
000163r 2               ; 					JSR kb_handle
000163r 2               ; NO_KBD
000163r 2  85 FA        					STA	STVVAL	;Save in status before exit (3)
000165r 2  80 43        					BRA REGEXT1	;branch to next IRQ source, exit (3)
000167r 2               ;
000167r 2  2C 18 02     DECMSD		BIT	Via1T2CL	;Clear interrupt for T2 (4)
00016Ar 2  C6 F4        					DEC	MSDELAY	;Decrement 1ms millisecond delay count (5)
00016Cr 2  D0 05        					BNE	RESET_T2	;If not zero, re-enable T2 and exit (2/3)
00016Er 2  64 F5        					STZ	MATCH	;Else, clear match flag (3) (25 clock cycles to clear MATCH)
000170r 2  6C 12 04     REGEXT2		JMP	(VECINSRT1)	;Done with timer handler, exit (5)
000173r 2               ;
000173r 2  AD 29 04     RESET_T2	LDA	LOAD_6522+$07	;Get T2H value (4)
000176r 2  8D 19 02     					STA	Via1T2CH	;Reload T2 and re-enable interrupt (4) (31 clock cycles to restart T2)
000179r 2  80 F5        					BRA	REGEXT2	;Done with timer handler, exit (3)
00017Br 2               ;
00017Br 2  2C 14 02     INCRTC		BIT	Via1T1CL	;Clear interrupt for T1 (4)
00017Er 2  C6 EE        					DEC	TICKS	;Decrement RTC tick count (5)
000180r 2  D0 28        					BNE	REGEXT1	;Exit if not zero (2/3)
000182r 2  A9 FA        					LDA	#DF_TICKS ;Get default tick count (2)
000184r 2  85 EE        					STA	TICKS	;Reset Tick count (3)
000186r 2               ;
000186r 2  E6 EF        					INC	SECS	;Increment seconds (5)
000188r 2  A5 EF        					LDA	SECS	;Load it to Areg (3)
00018Ar 2  C9 3C        					CMP	#60	;Check for 60 seconds (2)
00018Cr 2  90 1C        					BCC	REGEXT1	;If not, exit (2/3)
00018Er 2  64 EF        					STZ	SECS	;Else, reset seconds, inc Minutes (3)
000190r 2               ;
000190r 2  E6 F0        					INC	MINS	;Increment Minutes (5)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

000192r 2  A5 F0        					LDA	MINS	;Load it to Areg (3)
000194r 2  C9 3C        					CMP	#60	;Check for 60 minutes (2)
000196r 2  90 12        					BCC	REGEXT1	;If not, exit (2/3)
000198r 2  64 F0        					STZ	MINS	;Else, reset Minutes, inc Hours (3)
00019Ar 2               ;
00019Ar 2  E6 F1        					INC	HOURS	;Increment Hours (5)
00019Cr 2  A5 F1        					LDA	HOURS	;Get it to Areg (3)
00019Er 2  C9 18        					CMP	#24	;Check for 24 hours (2)
0001A0r 2  90 08        					BCC	REGEXT1	;If not, exit (2/3)
0001A2r 2  64 F1        					STZ	HOURS	;Else, reset hours, inc Days (3)
0001A4r 2               ;
0001A4r 2  E6 F2        					INC	DAYSL	;Increment low-order Days (5)
0001A6r 2  D0 02        					BNE	REGEXT1	;If not zero, exit (2/3)
0001A8r 2  E6 F3        					INC	DAYSH	;Else increment high-order Days (5)
0001AAr 2               ;
0001AAr 2  6C 10 04     REGEXT1		JMP	(VECINSRT0) ;handle next irq (5)
0001ADr 2               ;
0001ADr 2  20 rr rr     INIT_PG03	JSR	INIT_VEC	;Init the Vectors first (6)
0001B0r 2               ;
0001B0r 2  A0 40        INIT_CFG	LDY	#$40	;Get offset to data (2)
0001B2r 2  80 02        					BRA	DATA_XFER	;Go move the data to page $03 (3)
0001B4r 2  A0 20        INIT_VEC	LDY	#$20	;Get offset to data (2)
0001B6r 2               ;
0001B6r 2  78           DATA_XFER	SEI	;Disable Interrupts, can be called via JMP table (2)
0001B7r 2  A2 20        					LDX	#$20	;Set count for 32 bytes (2)
0001B9r 2               DATA_XFLP
0001B9r 2  B9 rr rr     					LDA	VEC_TABLE-1,Y	;Get ROM table data (4)
0001BCr 2  99 FF 03     					STA	SOFTVEC-1,Y	;Store in Soft table location (5)
0001BFr 2  88           					DEY	;Decrement index (2)
0001C0r 2  CA           					DEX	;Decrement count (2)
0001C1r 2  D0 F6        					BNE	DATA_XFLP	;Loop back till done (2/3)
0001C3r 2  58           					CLI	;re-enable interupts (2)
0001C4r 2  60           					RTS	;Return to caller (6)
0001C5r 2               ;
0001C5r 2               INIT_6551
0001C5r 2               ;Init the 65C51
0001C5r 2  78           					SEI	;Disable Interrupts (2)
0001C6r 2  9C 21 02     					STZ	SIOSTAT	;write to status reg, reset 6551 (3)
0001C9r 2  64 ED        					STZ	STTVAL	;zero status pointer (3)
0001CBr 2  A2 02        					LDX	#$02	;Get count of 2 (2)
0001CDr 2               INIT_6551L
0001CDr 2  BD 1F 04     					LDA	LOAD_6551-1,X	;Get Current 6551 config parameters (4)
0001D0r 2  9D 21 02     					STA	SIOBase+1,X	;Write to current 6551 device (5)
0001D3r 2  CA           					DEX	;Decrement count (2)
0001D4r 2  D0 F7        					BNE	INIT_6551L	;Loop back until done (2/3)
0001D6r 2  58           					CLI	;Re-enable Interrupts (2)
0001D7r 2  60           					RTS	;Return to caller (6)
0001D8r 2               ;
0001D8r 2  20 rr rr     INIT_IO		JSR	INIT_6551	;Init the Console first (6)
0001DBr 2               ;
0001DBr 2               INIT_6522
0001DBr 2               ;Init the 65C22
0001DBr 2  78           					SEI	;Disable Interrupts (2)
0001DCr 2  64 FA        					STZ	STVVAL	;zero status pointer (3)
0001DEr 2  A2 0D        					LDX  #$0D	;Get Count of 13 (2)
0001E0r 2               INIT_6522L
0001E0r 2  BD 21 04     					LDA	LOAD_6522-1,X	;Get soft parameters (4)
0001E3r 2  9D 11 02     					STA	Via1Base+1,X	;Load into 6522 chip (5)
0001E6r 2  CA           					DEX	;Decrement to next parameter (2)
0001E7r 2  D0 F7        					BNE	INIT_6522L	;Branch back till all are loaded (2/3)
0001E9r 2  58           					CLI	;Re-enable IRQ (2)
0001EAr 2               ; INIT_KBD
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/bios.s

0001EAr 2               ; 					JSR kb_init
0001EAr 2               
0001EAr 2  60           RET				RTS	;Return to caller (6)
0001EBr 2               ;
0001EBr 2               ;END OF BIOS CODE
0001EBr 2               
0001EBr 1               	; .include "keyboard.s"
0001EBr 1               	.include "top.s"
0001EBr 2               .segment "TOP"
000000r 2               ;******************************************************************************
000000r 2               ; $FF00	;JMP Table, HW Vectors, Cold Init and Vector handlers
000000r 2               ;******************************************************************************
000000r 2               ; START OF TOP PAGE - DO NOT MOVE FROM THIS ADDRESS!!
000000r 2               ;******************************************************************************
000000r 2               ;JUMP Table starts here:
000000r 2               ;	- BIOS calls are from the top down - total of 16
000000r 2               ;	- Monitor calls are from the bottom up
000000r 2               ;	- Reserved calls are in the shrinking middle
000000r 2               ;
000000r 2  4C rr rr     					JMP	RDLINE
000003r 2  4C rr rr     					JMP	RDCHAR
000006r 2  4C rr rr     					JMP	HEXIN2
000009r 2  4C rr rr     					JMP	HEXIN4
00000Cr 2  4C rr rr     					JMP	HEX2ASC
00000Fr 2  4C rr rr     					JMP	BIN2ASC
000012r 2  4C rr rr     					JMP	ASC2BIN
000015r 2  4C rr rr     					JMP	DOLLAR
000018r 2  4C rr rr     					JMP	PRBYTE
00001Br 2  4C rr rr     					JMP	PRWORD
00001Er 2  4C rr rr     					JMP	PRASC
000021r 2  4C rr rr     					JMP	PROMPT
000024r 2  4C rr rr     					JMP	PROMPTR
000027r 2  4C rr rr     					JMP	CONTINUE
00002Ar 2  4C rr rr     					JMP	CROUT
00002Dr 2  4C rr rr     					JMP	SPC
000030r 2  4C rr rr     					JMP	UPTIME
000033r 2  4C rr rr     					JMP	RET
000036r 2  4C rr rr     					JMP	RET
000039r 2  4C rr rr     					JMP	RET
00003Cr 2  4C rr rr     					JMP	RET
00003Fr 2  4C rr rr     					JMP	RET
000042r 2  4C rr rr     					JMP	RET
000045r 2  4C rr rr     					JMP	RET
000048r 2  4C rr rr     					JMP	CHRIN_NW
00004Br 2  4C rr rr     					JMP	CHRIN
00004Er 2  4C rr rr     					JMP	CHROUT
000051r 2  4C rr rr     					JMP	SET_DLY
000054r 2  4C rr rr     					JMP	EXE_MSDLY
000057r 2  4C rr rr     					JMP	EXE_LGDLY
00005Ar 2  4C rr rr     					JMP	EXE_XLDLY
00005Dr 2  4C rr rr     					JMP	SET_PORT
000060r 2  4C rr rr     					JMP	IN_PORT
000063r 2  4C rr rr     					JMP	OUT_PORT
000066r 2  4C rr rr     					JMP	INIT_VEC
000069r 2  4C rr rr     					JMP	INIT_CFG
00006Cr 2  4C rr rr     					JMP	INIT_6551
00006Fr 2  4C rr rr     					JMP	INIT_6522
000072r 2  6C 0E 04     					JMP	(WRMMNVEC0)
000075r 2  6C 0C 04     CMBV			JMP	(CLDMNVEC0)
000078r 2               ;
000078r 2  D8           COLDSTRT	CLD	;Clear decimal mode in case of software call (Zero Ram calls this) (2)
000079r 2  78           					SEI	;Disable Interrupt for same reason as above (2)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/top.s

00007Ar 2  A2 00        					LDX	#$00	;Index for length of page (2)
00007Cr 2  74 00        PAGE0_LP	STZ	$00,X	;Zero out Page Zero (4)
00007Er 2  CA           					DEX	;Decrement index (2)
00007Fr 2  D0 FB        					BNE	PAGE0_LP	;Loop back till done (2/3)
000081r 2  CA           					DEX	;LDX #$FF ;-) (2)
000082r 2  9A           					TXS	;Set Stack Pointer (2)
000083r 2               ;
000083r 2  20 rr rr     					JSR	INIT_PG03	;Xfer default Vectors/HW Config to $0300 (6)
000086r 2  20 rr rr     					JSR	INIT_IO	;Init I/O - Console, Timers, Ports (6)
000089r 2               ;
000089r 2               ; Send BIOS init msg to console
000089r 2               ;	- note: X reg is zero on return from INIT_IO
000089r 2  BD rr rr     BMSG_LP		LDA	BIOS_MSG,X	;Get BIOS init msg (4)
00008Cr 2  F0 E7        					BEQ	CMBV	;If zero, msg done, goto cold start monitor (2/3)
00008Er 2  20 rr rr     					JSR	CHROUT	;Send to console (6)
000091r 2  E8           					INX	;Increment Index (2)
000092r 2  80 F5        					BRA	BMSG_LP	;Loop back until done (3)
000094r 2               ;
000094r 2               IRQ_VECTOR	;This is the ROM start for the BRK/IRQ handler
000094r 2  48           					PHA	;Save A Reg (3)
000095r 2  DA           					PHX	;Save X Reg (3)
000096r 2  5A           					PHY	;Save Y Reg (3)
000097r 2  BA           					TSX	;Get Stack pointer (2)
000098r 2  BD 04 01     					LDA	$0100+4,X	;Get Status Register (4)
00009Br 2  29 10        					AND	#$10	;Mask for BRK bit set (2)
00009Dr 2  D0 03        					BNE	DO_BRK	;If set, handle BRK (2/3)
00009Fr 2  6C 04 04     					JMP	(IRQVEC0)	;Jump to Soft vectored IRQ Handler (5) (24 clock cycles to vector routine)
0000A2r 2  6C 02 04     DO_BRK		JMP	(BRKVEC0)	;Jump to Soft vectored BRK Handler (5) (25 clock cycles to vector routine)
0000A5r 2               ;
0000A5r 2               IRQ_EXIT0	;This is the standard return for the IRQ/BRK handler routines
0000A5r 2  7A           					PLY	;Restore Y Reg (4)
0000A6r 2  FA           					PLX	;Restore X Reg (4)
0000A7r 2  68           					PLA	;Restore A Reg (4)
0000A8r 2  40           					RTI	;Return from IRQ/BRK routine (6) (18 clock cycles from vector jump to IRQ end)
0000A9r 2               ;
0000A9r 2               ;******************************************************************************
0000A9r 2               ;
0000A9r 2               ;START OF BIOS DEFAULT VECTOR DATA AND HARDWARE CONFIGURATION DATA
0000A9r 2               ;
0000A9r 2               ;The default location for the NMI/BRK/IRQ Vector data is at location $0400
0000A9r 2               ; details of the layout are listed at the top of the source file
0000A9r 2               ;	there are 8 main vectors and 8 vector inserts, one is used for the 6522
0000A9r 2               ;
0000A9r 2               ;The default location for the hardware configuration data is at location $0420
0000A9r 2               ; it is mostly a freeform table which gets copied from ROM to page $04
0000A9r 2               ; the default size for the config table is 32 bytes, 17 bytes are free
0000A9r 2               ;
0000A9r 2               VEC_TABLE	;Vector table data for default ROM handlers
0000A9r 2               ;Vector set 0
0000A9r 2  rr rr        					.WORD	NMI_VECTOR	;NMI Location in ROM
0000ABr 2  rr rr        					.WORD	BRKINSTR0	;BRK Location in ROM
0000ADr 2  rr rr        					.WORD	INTERUPT1	;IRQ Location in ROM
0000AFr 2               ;
0000AFr 2  rr rr        					.WORD	WRM_MON	;NMI return handler in ROM
0000B1r 2  rr rr        					.WORD	WRM_MON	;BRK return handler in ROM
0000B3r 2  rr rr        					.WORD	IRQ_EXIT0	;IRQ return handler in ROM
0000B5r 2               ;
0000B5r 2  rr rr        					.WORD	MONITOR	;Monitor Cold start
0000B7r 2  rr rr        					.WORD	WRM_MON	;Monitor Warm start
0000B9r 2               ;
0000B9r 2               ;Vector Inserts (total of 8)
0000B9r 2               ; these can be used as required, one is used by default for the 6522
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/top.s

0000B9r 2               ; as NMI/BRK/IRQ and the Monitor are vectored, all can be extended
0000B9r 2               ; by using these reserved vectors.
0000B9r 2  rr rr        					.WORD	INTERUPT0	;Insert 0 Location - for 6522 timer1
0000BBr 2  rr rr        					.WORD	INTERUPT0	;Insert 1 Location - for 6522 timer2
0000BDr 2  FF FF        					.WORD	$FFFF	;Insert 2 Location
0000BFr 2  FF FF        					.WORD	$FFFF	;Insert 3 Location
0000C1r 2  FF FF        					.WORD	$FFFF	;Insert 4 Location
0000C3r 2  FF FF        					.WORD	$FFFF	;Insert 5 Location
0000C5r 2  FF FF        					.WORD	$FFFF	;Insert 6 Location
0000C7r 2  FF FF        					.WORD	$FFFF	;Insert 7 Location
0000C9r 2               ;
0000C9r 2               CFG_TABLE	;Configuration table for hardware devices
0000C9r 2               ;
0000C9r 2               CFG_6551	;2 bytes required for 6551
0000C9r 2               ; Command Register bit definitions:
0000C9r 2               ; Bit 7/6	= Parity Control: 0,0 = Odd Parity
0000C9r 2               ; Bit 5		= Parity enable: 0 = No Parity
0000C9r 2               ; Bit 4		= Receiver Echo mode: 0 = Normal
0000C9r 2               ; Bit 3/2	= Transmitter Interrupt Control:
0000C9r 2               ; Bit 1		= Receiver Interrupt Control: 0 = Enabled / 1 = Disabled
0000C9r 2               ; Bit 0		= DTR Control: 1 = DTR Ready
0000C9r 2               ;
0000C9r 2               ; Default for setup:		%00001001 ($09)
0000C9r 2               ; Default for transmit:	%00000101 ($05)
0000C9r 2  09           					.BYTE	$09	;Default 65C51 Command register, transmit/receiver IRQ output enabled)
0000CAr 2               ;
0000CAr 2               ; Baud Select Register:
0000CAr 2               ; Bit 7		= Stop Bit: 0 = 1 Stop Bit
0000CAr 2               ; Bit 6/5	= Word Length: 00 = 8 bits
0000CAr 2               ; Bit 4		= Receiver Clock Source: 0 = External Clk 1 = Baud Rate Gen
0000CAr 2               ; Bit 3-0	= Baud Rate Table: 1111 = 19.2K Baud (default)
0000CAr 2               ;
0000CAr 2               ; Default for setup:		%00011111 ($1F) - 19.2K, 8 data, 1 stop)
0000CAr 2  10           					.BYTE	$10	;Default 65C51 Control register, (115.2K,no parity,8 data bits,1 stop bit)
0000CBr 2               ;
0000CBr 2               CFG_6522	;13 bytes required for 6522
0000CBr 2               ;Timer 1 load value is based on CPU clock frequency for 4 milliseconds - RTC use
0000CBr 2               ; Note that 2 needs to be subtracted from the count value, i.e., 16000 needs to be 15998, etc.
0000CBr 2               ; This corresponds to the W65C22 datasheet showing N+2 between interrupts in continuous mode
0000CBr 2               ; 16MHz = 63998, 10MHz = 39998, 8MHz = 31998, 6MHz = 23998, 5MHz = 19998, 4MHz = 15998, 2MHz = 7998
0000CBr 2               ; 16MHz = $F9FE, 10MHz = $9C3E, 8MHz = $7CFE, 6MHz = $5DBE, 5MHz = $4E1E, 4MHz = $3E7E, 2MHz = $1F3E
0000CBr 2               ;
0000CBr 2               ;Timer 2 load value is based on CPU clock frequency for 1 millisecond - delay use
0000CBr 2               ;	- Timer 2 value needs to be adjusted to compensate for the time to respond to the interrupt
0000CBr 2               ;	- and reset the timer for another 1ms countdown, which is 55 clock cycles
0000CBr 2               ;	- As Timer 2 counts clock cycles, each of the values should be adjusted by subtracting 55+2
0000CBr 2               ;	16MHz = 15943,	10MHz = 9943,		8MHz = 7943,	6MHz = 5943,	5MHz = 4943,	4MHz = 3943,	2MHz = 1943
0000CBr 2               ; 16MHz = $3E47,	10MHz = $26D7,	8MHz = $1F07,	6MHz = $1737,	5MHz = $134F,	4MHz = $0F67,	2MHz = $0797
0000CBr 2               ;
0000CBr 2               ; only the ports that are needed for config are shown below:
0000CBr 2               ;
0000CBr 2  00           					.BYTE	$00	;Data Direction register Port B
0000CCr 2  00           					.BYTE	$00	;Data Direction register Port A
0000CDr 2  FE           					.BYTE	$FE	;T1CL - set for CPU clock as above - $04
0000CEr 2  7C           					.BYTE	$7C	;T1CH - to 4ms (250 interupts per second) - $05
0000CFr 2  00           					.BYTE	$00	;T1LL - T1 counter latch low
0000D0r 2  00           					.BYTE	$00	;T1LH - T1 counter latch high
0000D1r 2  07           					.BYTE	$07	;T2CL - T2 counter low count - set for 1ms (adjusted)
0000D2r 2  1F           					.BYTE	$1F	;T2CH - T2 counter high count - used for delay timer
0000D3r 2  00           					.BYTE	$00	;SR - Shift register
0000D4r 2  40           					.BYTE	$40	;ACR - Aux control register
0000D5r 2  01           					.BYTE	$01	;PCR - Peripheral control register
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/top.s

0000D6r 2  7F           					.BYTE	$7F	;IFR - Interrupt flag register (clear all)
0000D7r 2  E2           					.BYTE	$E2	;IER - Interrupt enable register (enable T1/T2)
0000D8r 2  FF           					.BYTE	$FF	;Free config byte
0000D9r 2               ;
0000D9r 2               ;Reserved for additional I/O devices (16 bytes total)
0000D9r 2  FF FF FF FF  					.BYTE	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
0000DDr 2  FF FF FF FF  
0000E1r 2  FF FF FF FF  					.BYTE	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
0000E5r 2  FF FF FF FF  
0000E9r 2               ;
0000E9r 2               ;END OF BIOS VECTOR DATA AND HARDWARE DEFAULT CONFIGURATION DATA
0000E9r 2               ;******************************************************************************
0000E9r 2               ;
0000E9r 2               ;******************************************************************************
0000E9r 2               ;BIOS init message - sent before jumping to the monitor coldstart vector
0000E9r 2               ;******************************************************************************
0000E9r 2  0D 0A        BIOS_MSG	.BYTE	$0D,$0A
0000EBr 2  42 49 4F 53  					.BYTE	"BIOS 1.4 "
0000EFr 2  20 31 2E 34  
0000F3r 2  20           
0000F4r 2  38 4D 48 7A  					.BYTE	"8MHz"
0000F8r 2  00           					.BYTE	$00	;Terminate string
0000F9r 2               
0000F9r 2               .segment "VECTORS"
000000r 2               ;******************************************************************************
000000r 2               ; $FFFA	; 65C02 Vector Table
000000r 2               ;******************************************************************************
000000r 2  00 04        					.WORD	NMIVEC0	;NMI
000002r 2  rr rr        					.WORD	COLDSTRT	;RESET
000004r 2  rr rr        					.WORD	IRQ_VECTOR	;IRQ
000006r 2               
000006r 1               
000006r 1               ;******************************************************************************
000006r 1               ;******************************************************************************
000006r 1               ;Character input buffer address: $0300-$037F - 128 bytes
000006r 1               ;Character output buffer address: $0380-$03FF - 128 bytes
000006r 1               ;Managed by full-duplex IRQ service routine
000006r 1               ;
000006r 1               IBUF			=	$0300	;INPUT BUFFER  128 BYTES - BIOS use only
000006r 1               OBUF			=	$0380	;OUTPUT BUFFER 128 BYTES - BIOS use only
000006r 1               ;
000006r 1               ;******************************************************************************
000006r 1               SOFTVEC		=	$0400	;Start of soft vectors
000006r 1               ;
000006r 1               ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM
000006r 1               ; The soft vectors are structured to allow inserting additional routines either before
000006r 1               ; or after the core routines. This allows flexibility and changing of routine priority
000006r 1               ;
000006r 1               ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
000006r 1               ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
000006r 1               ; returns to the ROM handler for each. The following 2 vectors are the cold and warm
000006r 1               ; entry points for the Monitor. After the basic initialization, the monitor is entered
000006r 1               ;
000006r 1               ;The following vector set allows inserts for any of the above vectors
000006r 1               ; there are a total of 8 Inserts which occupy 16 bytes. They can be used as required
000006r 1               ; note that the first two are used for the 6522 timer routines
000006r 1               ;
000006r 1               NMIVEC0		=	SOFTVEC	;NMI Interrupt Vector 0
000006r 1               BRKVEC0		=	SOFTVEC+2	;BRK Interrupt Vector 0
000006r 1               IRQVEC0		=	SOFTVEC+4	;INTERRUPT VECTOR 0
000006r 1               ;
000006r 1               NMIRTVEC0	=	SOFTVEC+6	;NMI Return Handler 0
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000006r 1               BRKRTVEC0	=	SOFTVEC+8	;BRK Return Handler 0
000006r 1               IRQRTVEC0	=	SOFTVEC+10	;IRQ Return Handler 0
000006r 1               ;
000006r 1               CLDMNVEC0	=	SOFTVEC+12	;Cold Monitor Entry Vector 0
000006r 1               WRMMNVEC0	=	SOFTVEC+14	;Warm Monitor Entry Vector 0
000006r 1               ;
000006r 1               VECINSRT0	=	SOFTVEC+16	;1st Vector Insert (Timer support)
000006r 1               VECINSRT1	=	SOFTVEC+18	;1st Vector Insert (Timer support)
000006r 1               VECINSRT2	=	SOFTVEC+20	;1st Vector Insert
000006r 1               VECINSRT3	=	SOFTVEC+22	;1st Vector Insert
000006r 1               VECINSRT4	=	SOFTVEC+24	;1st Vector Insert
000006r 1               VECINSRT5	=	SOFTVEC+26	;1st Vector Insert
000006r 1               VECINSRT6	=	SOFTVEC+28	;1st Vector Insert
000006r 1               VECINSRT7	=	SOFTVEC+30	;1st Vector Insert
000006r 1               ;
000006r 1               ;******************************************************************************
000006r 1               SOFTCFG		= SOFTVEC+32	;Start of hardware config parameters
000006r 1               ;
000006r 1               ;Soft Config values below are loaded from ROM and are the default I/O setup
000006r 1               ;configuration data that the INIT_65xx routines use. As a result, you can write a
000006r 1               ;routine to change the I/O configuration data and use the standard ROM routines
000006r 1               ;to initialize the I/O without restarting or changing ROM. A Reset (cold or coded)
000006r 1               ;will reinitialize the I/O with the ROM default I/O configuration
000006r 1               ;
000006r 1               ;There are a total of 32 Bytes configuration data reserved starting at $0320
000006r 1               ;
000006r 1               LOAD_6551	=	SOFTCFG	;6551 SOFT config data start
000006r 1               LOAD_6522	=	SOFTCFG+2	;6522 SOFT config data start
000006r 1               ;
000006r 1               ;Defaults for RTC ticks - number of IRQs for 1 second
000006r 1               DF_TICKS	=	250	;clock timer set for 4 milliseconds, so 250 x 4ms = 1 second
000006r 1               ;
000006r 1               ; Search Buffer is 16 bytes in length
000006r 1               ; Used to hold search string for text and hex data
000006r 1               SRCHBUFF	=	$440	;Located in Page $04 following HW config data
000006r 1               ;
000006r 1               ; Xmodem/CRC Loader also provides Motorola S19 Record sense and load
000006r 1               ; Designed to handle the S19 records from the WDC Assembler/Linker package
000006r 1               ; This requires a 44 byte buffer to parse each valid S1 record
000006r 1               ; Located just before the 132 Byte Xmodem frame buffer
000006r 1               ; There are a total of 176 bytes of Buffer associated with the Xmodem/CRC Loader
000006r 1               ;
000006r 1               ; Valid S-record headers are "S1" and "S9"
000006r 1               ; For S1, the maximum length is "19" hex. The last S1 record can be less
000006r 1               ; S9 record is always the last record with no data
000006r 1               ; WDC Linker also appends a CR/LF to the end of each record for a total 44 bytes
000006r 1               ;
000006r 1               SRBUFF		=	$0450	;Start of Motorola S-record buffer, 44 bytes in length
000006r 1               ;
000006r 1               ; Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked
000006r 1               ; for proper header and frame number, CRC-16 on the data, then moved to user RAM
000006r 1               ;
000006r 1               RBUFF			=	$047C	;Xmodem temp 132 byte receive buffer
000006r 1               ;
000006r 1               ;Additional Xmodem variables, etc.
000006r 1               ;
000006r 1               ; XMODEM Control Character Constants
000006r 1               SOH				=	$01	;Start of Block Header
000006r 1               EOT				=	$04	;End of Text marker
000006r 1               ACK				=	$06	;Good Block Acknowledge
000006r 1               NAK				=	$15	;Bad Block acknowledged
000006r 1               CAN				=	$18	;Cancel character
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000006r 1               ;
000006r 1               ;******************************************************************************
000006r 1               ;
000006r 1               BURN_BYTE	=	$0000	;Location in RAM for BYTE write routine
000006r 1               ;
000006r 1               ;******************************************************************************
000006r 1               ;I/O Page Base Address
000006r 1               IOPAGE		=	$0200
000006r 1               ;
000006r 1               ;VIA1 device address:
000006r 1               Via1Base	=	IOPAGE+$10	;65C22 VIA base address here
000006r 1               Via1PRB		=  Via1Base+0	;Port B I/O register
000006r 1               Via1PRA		=  Via1Base+1	;Port A I/O register
000006r 1               Via1DDRB	=  Via1Base+2	;Port B data direction
000006r 1               Via1DDRA  =  Via1Base+3	;Port A data direction
000006r 1               Via1T1CL  =  Via1Base+4	;Timer 1 Low byte count
000006r 1               Via1T1CH  =  Via1Base+5	;Timer 1 High byte count
000006r 1               Via1T1LL  =  Via1Base+6	;Timer 1 Low byte latch
000006r 1               Via1TALH  =  Via1Base+7	;Timer 1 High byte latch
000006r 1               Via1T2CL  =  Via1Base+8	;Timer 2 Low byte count/latch
000006r 1               Via1T2CH  =  Via1Base+9	;Timer 2 High byte count
000006r 1               Via1SR    =  Via1Base+10	;Shift Register
000006r 1               Via1ACR   =  Via1Base+11	;Aux control register
000006r 1               Via1PCR   =  Via1Base+12	;Peripheral control register
000006r 1               Via1IFR   =  Via1Base+13	;Interrupt flag register
000006r 1               Via1IER   =  Via1Base+14	;Interrupt enable register
000006r 1               Via1PRA1  =  Via1Base+15	;Port A echo register
000006r 1               ;
000006r 1               ;VIA2 device address:
000006r 1               Via2Base	=	IOPAGE	;65C22 VIA base address here
000006r 1               Via2PRB		=  Via2Base+0	;Port B I/O register
000006r 1               Via2PRA		=  Via2Base+1	;Port A I/O register
000006r 1               Via2DDRB	=  Via2Base+2	;Port B data direction
000006r 1               Via2DDRA  =  Via2Base+3	;Port A data direction
000006r 1               Via2T1CL  =  Via2Base+4	;Timer 1 Low byte count
000006r 1               Via2T1CH  =  Via2Base+5	;Timer 1 High byte count
000006r 1               Via2T1LL  =  Via2Base+6	;Timer 1 Low byte latch
000006r 1               Via2TALH  =  Via2Base+7	;Timer 1 High byte latch
000006r 1               Via2T2CL  =  Via2Base+8	;Timer 2 Low byte count/latch
000006r 1               Via2T2CH  =  Via2Base+9	;Timer 2 High byte count
000006r 1               Via2SR    =  Via2Base+10	;Shift Register
000006r 1               Via2ACR   =  Via2Base+11	;Aux control register
000006r 1               Via2PCR   =  Via2Base+12	;Peripheral control register
000006r 1               Via2IFR   =  Via2Base+13	;Interrupt flag register
000006r 1               Via2IER   =  Via2Base+14	;Interrupt enable register
000006r 1               Via2PRA1  =  Via2Base+15	;Port A echo register
000006r 1               ;
000006r 1               ;ACIA device address:
000006r 1               SIOBase		=	IOPAGE+$20	;6551 Base HW address
000006r 1               SIODAT		=	SIOBase+0	;ACIA data register
000006r 1               SIOSTAT		=	SIOBase+1	;ACIA status register
000006r 1               SIOCOM		=	SIOBase+2 ;ACIA command register
000006r 1               SIOCON		=	SIOBase+3 ;ACIA control register
000006r 1               ;
000006r 1               .segment "MONITOR"
000000r 1               ;******************************************************************************
000000r 1               ; $E000    ;6KB reserved for monitor $E000 through $F7FF
000000r 1               ;******************************************************************************
000000r 1               ;START OF MONITOR CODE
000000r 1               ;*******************************************
000000r 1               ;*                C02 Monitor              *
000000r 1               ;*******************************************
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000000r 1               ;*  This is the Monitor Cold start vector  *
000000r 1               ;*******************************************
000000r 1  A9 14        MONITOR		LDA	#$14	;Get intro msg / BEEP
000002r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000005r 1               ;
000005r 1               ;*******************************************
000005r 1               ;*           Command input loop            *
000005r 1               ;*******************************************
000005r 1               ;*  This in the Monitor Warm start vector  *
000005r 1               ;*******************************************
000005r 1  A2 FF        WRM_MON		LDX	#$FF	;Initialize Stack pointer
000007r 1  9A           					TXS	;Xfer to stack
000008r 1  64 D5        					STZ	CMDFLAG	;Clear Command flag
00000Ar 1  A9 16        					LDA	#$16	;Get prompt msg
00000Cr 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00000Fr 1               ;
00000Fr 1  20 rr rr     CMON			JSR	RDCHAR	;Wait for keystroke (converts to upper-case)
000012r 1  A2 1D        					LDX	#MONTAB-MONCMD-1	;Get command list count
000014r 1  DD rr rr     CMD_LP		CMP	MONCMD,X	;Compare to command list
000017r 1  D0 0D        					BNE	CMD_DEC	;Check for next command and loop
000019r 1  48           					PHA	;Save keystroke
00001Ar 1  8A           					TXA	;Xfer Command index to A reg
00001Br 1  0A           					ASL	A	;Multiply keystroke value by 2
00001Cr 1  AA           					TAX	;Get monitor command processor address from table MONTAB
00001Dr 1  68           					PLA	;Restore keystroke (some commands send keystroke to terminal)
00001Er 1  20 rr rr     					JSR	DOCMD	;Call selected monitor command processor as a subroutine
000021r 1  80 E2        					BRA	WRM_MON	;Command processed, branch and wait for next command
000023r 1  7C rr rr     DOCMD			JMP	(MONTAB,X)	;Execute CMD from Table
000026r 1               ;
000026r 1  CA           CMD_DEC		DEX	;Decrement index count
000027r 1  10 EB        					BPL	CMD_LP	;If more to check, loop back
000029r 1  20 rr rr     					JSR	BEEP	;Beep for error,
00002Cr 1  80 E1        					BRA	CMON	;re-enter monitor
00002Er 1               ;
00002Er 1               ;***********************************************
00002Er 1               ;* Basic Subroutines used by multiple routines *
00002Er 1               ;***********************************************
00002Er 1               ;
00002Er 1               ;ASC2BIN subroutine: Convert 2 ASCII HEX digits to a binary (byte) value
00002Er 1               ;Enter: A register = high digit, Y register = low digit
00002Er 1               ;Return: A register = binary value
00002Er 1  20 rr rr     ASC2BIN		JSR	BINARY	;Convert high digit to 4-bit nibble
000031r 1  0A           					ASL	A	;Shift to high nibble
000032r 1  0A           					ASL	A
000033r 1  0A           					ASL	A
000034r 1  0A           					ASL	A
000035r 1  85 D2        					STA	TEMP1	;Store it in temp area
000037r 1  98           					TYA	;Get Low digit
000038r 1  20 rr rr     					JSR	BINARY	;Convert low digit to 4-bit nibble
00003Br 1  05 D2        					ORA	TEMP1	;OR in the high nibble
00003Dr 1  60           					RTS	;Return to caller
00003Er 1               ;
00003Er 1  38           BINARY		SEC	;Set carry for subtraction
00003Fr 1  E9 30        					SBC	#$30	;Subtract $30 from ASCII HEX digit
000041r 1  C9 0A        					CMP	#$0A	;Check for result < 10
000043r 1  90 02        					BCC	BNOK	;Branch if 0-9
000045r 1  E9 07        					SBC	#$07	;Else, subtract 7 for A-F
000047r 1  60           BNOK			RTS	;Return to caller
000048r 1               ;
000048r 1               ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
000048r 1               ;Enter: A register contains byte value to convert
000048r 1               ;Return: A register = high digit, Y register = low digit
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000048r 1  48           BIN2ASC		PHA	;Save A Reg on stack
000049r 1  29 0F        					AND	#$0F	;Mask off high nibble
00004Br 1  20 rr rr     					JSR	ASCII	;Convert nibble to ASCII HEX digit
00004Er 1  A8           					TAY	;Move to Y Reg
00004Fr 1  68           					PLA	;Get character back from stack
000050r 1  4A           					LSR	A	;Shift high nibble to lower 4 bits
000051r 1  4A           					LSR	A
000052r 1  4A           					LSR	A
000053r 1  4A           					LSR	A
000054r 1               ;
000054r 1  C9 0A        ASCII			CMP	#$0A	;Check for 10 or less
000056r 1  90 03        					BCC	ASOK	;Branch if less than 10
000058r 1  18           					CLC	;Clear carry for addition
000059r 1  69 07        					ADC	#$07	;Add $07 for A-F
00005Br 1  69 30        ASOK			ADC	#$30	;Add $30 for ASCII
00005Dr 1  60           					RTS	;Return to caller
00005Er 1               ;
00005Er 1               ;HEX2ASC - Accepts 16-bit Hexadecimal value and converts to an ASCII decimal string
00005Er 1               ;Input is via the A and Y registers and output is up to 5 ASCII digits in DATABUFF
00005Er 1               ;The High Byte is in the Y register and Low Byte is in the A register
00005Er 1               ;Output data is placed in variable DATABUFF and terminated with an null character
00005Er 1               ;PROMPTR routine is used to print the ASCII decimal value
00005Er 1               ;Routine based on Michael Barry's code. Saved many bytes ;-)
00005Er 1               ;
00005Er 1  85 BC        HEX2ASC		STA	BINVALL	;Save Low byte
000060r 1  84 BD        					STY	BINVALH	;Save High byte
000062r 1  A2 05        					LDX	#5	;Get ASCII buffer offset
000064r 1  74 B4        					STZ	DATABUFF,X	;Zero last buffer byte for null end
000066r 1               ;
000066r 1  A9 00        CNVERT		LDA	#$00	;Clear remainder
000068r 1  A0 10        					LDY	#16	;Set loop count for 16-bits
00006Ar 1               ;
00006Ar 1  C9 05        DVLOOP		CMP	#$05	;Partial remainder >= 10/2
00006Cr 1  90 02        					BCC	DVLOOP2	;Branch if less
00006Er 1  E9 05        					SBC	#$05	;Update partial, set carry
000070r 1               ;
000070r 1  26 BC        DVLOOP2		ROL	BINVALL	;Shift carry into dividend
000072r 1  26 BD        					ROL	BINVALH	;Which will be quotient
000074r 1  2A           					ROL	A	;Rotate A reg
000075r 1  88           					DEY	;Decrement count
000076r 1  D0 F2        					BNE	DVLOOP	;Branch back until done
000078r 1  09 30        					ORA	#$30	;Or in bits for ASCII
00007Ar 1               ;
00007Ar 1  CA           					DEX	;Decrement buffer index
00007Br 1  95 B4        					STA	DATABUFF,X	;Store value into buffer
00007Dr 1               ;
00007Dr 1  A5 BC        					LDA	BINVALL	;Get the Low byte
00007Fr 1  05 BD        					ORA	BINVALH	;OR in the High byte (check for zero)
000081r 1  D0 E3        					BNE	CNVERT	;Branch back until done
000083r 1  86 D2        					STX	TEMP1	;Save buffer offset
000085r 1               ;
000085r 1               ;Conversion is complete, get the string address,
000085r 1               ;add offset, then call prompt routine and return
000085r 1               ; note DATABUFF is fixed location in Page 0
000085r 1               ; carry flag need not be cleared as result can never
000085r 1               ; set flag after ADC instruction, Y Reg always zero
000085r 1               ;
000085r 1  A9 B4        					LDA	#<DATABUFF	;Get Low byte Address
000087r 1  65 D2        					ADC	TEMP1	;Add in buffer offset (no leading zeros)
000089r 1  A0 00        					LDY	#>DATABUFF	;Get High byte address
00008Br 1  4C rr rr     					JMP	PROMPTR	;Send to terminal and return
00008Er 1               ;
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00008Er 1               ;SETUP subroutine: Request HEX address input from terminal
00008Er 1  20 rr rr     SETUP			JSR	CHROUT	;Send command keystroke to terminal
000091r 1  20 rr rr     					JSR	SPC	;Send [SPACE] to terminal
000094r 1  80 03        					BRA	HEXIN4	;Request a 0-4 digit HEX address input from terminal
000096r 1               ;
000096r 1               ;HEX input subroutines:
000096r 1               ;Request 1 to 4 ASCII HEX digits from terminal, then convert digits into a binary value
000096r 1               ;HEXIN2 - returns value in A reg and Y reg only (Y reg always $00)
000096r 1               ;HEXIN4 - returns values in A reg, Y reg and INDEXL/INDEXH
000096r 1               ;For 1 to 4 digits entered, HEXDATAH and HEXDATAL contain the output
000096r 1               ;Variable BUFIDX will contain the number of digits entered
000096r 1               ;HEX2 - Prints MSG# in A reg then calls HEXIN2
000096r 1               ;HEX4 - Prints MSG# in A reg then calls HEXIN4
000096r 1               ;
000096r 1  20 rr rr     HEX4			JSR	PROMPT	;Print MSG # from A reg
000099r 1  A2 04        HEXIN4		LDX	#$04	;Set for number of characters allowed
00009Br 1  20 rr rr     					JSR	HEXINPUT	;Convert digits
00009Er 1  84 C1        					STY	INDEXH	;Store to INDEXH
0000A0r 1  85 C0        					STA	INDEXL	;Store to INDEXL
0000A2r 1  60           					RTS	;Return to caller
0000A3r 1               ;
0000A3r 1  20 rr rr     HEX2			JSR	PROMPT	;Print MSG # from A reg
0000A6r 1  A2 02        HEXIN2		LDX	#$02	;Set for number of characters allowed
0000A8r 1               ;
0000A8r 1               ;HEXINPUT subroutine: request 1 to 4 HEX digits from terminal,
0000A8r 1               ;then convert ASCII HEX to HEX
0000A8r 1               ;Setup RDLINE subroutine parameters:
0000A8r 1  20 rr rr     HEXINPUT	JSR	DOLLAR	;Send "$" to console
0000ABr 1  20 rr rr     					JSR	RDLINE	;Request ASCII HEX input from terminal
0000AEr 1  F0 28        					BEQ	HINEXIT	;Exit if none (Z flag already set)
0000B0r 1  64 BA        					STZ	HEXDATAH	;Clear Upper HEX byte
0000B2r 1  64 BB        					STZ	HEXDATAL	;Clear Lower HEX byte
0000B4r 1  A0 02        					LDY	#$02	;Set index for 2 bytes
0000B6r 1  5A           ASCLOOP		PHY	;Save it to stack
0000B7r 1  B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
0000B9r 1  A8           					TAY	;Xfer to Y Reg (LSD)
0000BAr 1  CA           					DEX	;Decrement input count
0000BBr 1  F0 04        					BEQ	NO_UPNB	;Branch if no upper nibble
0000BDr 1  B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
0000BFr 1  80 02        					BRA	DO_UPNB	;Branch to include upper nibble
0000C1r 1  A9 30        NO_UPNB		LDA	#$30	;Load ASCII "0" (MSD)
0000C3r 1  20 rr rr     DO_UPNB		JSR	ASC2BIN	;Convert ASCII digits to binary value
0000C6r 1  7A           					PLY	;Get index from stack
0000C7r 1  99 B9 00     					STA	HEXDATAH-1,Y	;Write byte to indexed HEX input buffer location
0000CAr 1  E0 00        					CPX	#$00	;Any more digits?
0000CCr 1  F0 04        					BEQ	HINDONE	;If not, exit
0000CEr 1  88           					DEY	;Else, decrement to next byte set
0000CFr 1  CA           					DEX	;Decrement index count
0000D0r 1  D0 E4        					BNE	ASCLOOP	;Loop back for next byte
0000D2r 1  A4 BA        HINDONE		LDY	HEXDATAH	;Get High Byte
0000D4r 1  A5 BB        					LDA	HEXDATAL	;Get Low Byte
0000D6r 1  A6 CE        					LDX	BUFIDX	;Get input count (Z flag)
0000D8r 1  60           HINEXIT		RTS	;And return to caller
0000D9r 1               ;
0000D9r 1               ;Routines to update pointers for memory operations
0000D9r 1               ;
0000D9r 1               ;UPD_STL subroutine: Increments Source and Target pointers
0000D9r 1               ;UPD_TL subroutine: Increments Target pointers only
0000D9r 1               ; then drops into decrement length pointer. Used by multiple commands
0000D9r 1  E6 C8        UPD_STL		INC	SRCL	;Increment source low byte
0000DBr 1  D0 02        					BNE	UPD_TL	;Check for rollover
0000DDr 1  E6 C9        					INC	SRCH	;Increment source high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0000DFr 1  E6 CA        UPD_TL		INC	TGTL	;Increment target low byte
0000E1r 1  D0 02        					BNE	DECLEN	;Check for rollover
0000E3r 1  E6 CB        					INC	TGTH	;Increment target high byte
0000E5r 1               ;
0000E5r 1               ;DECLEN subroutine: decrement 16-bit variable LENL/LENH
0000E5r 1  A5 CC        DECLEN		LDA	LENL	;Get length low byte
0000E7r 1  D0 02        					BNE	SKP_LENH	;Test for LENL = zero
0000E9r 1  C6 CD        					DEC	LENH	;Else decrement length high byte
0000EBr 1  C6 CC        SKP_LENH	DEC	LENL	;Decrement length low byte
0000EDr 1  60           					RTS	;Return to caller
0000EEr 1               ;
0000EEr 1               ;DECINDEX subroutine: decrement 16 bit variable INDEXL/INDEXH
0000EEr 1  A5 C0        DECINDEX	LDA	INDEXL	;Get index low byte
0000F0r 1  D0 02        					BNE	SKP_IDXH	;Test for INDEXL = zero
0000F2r 1  C6 C1        					DEC	INDEXH	;Decrement index high byte
0000F4r 1  C6 C0        SKP_IDXH	DEC	INDEXL	;Decrement index low byte
0000F6r 1  60           					RTS	;Return to caller
0000F7r 1               ;
0000F7r 1               ;INCINDEX subroutine: increment 16 bit variable INDEXL/INDEXH
0000F7r 1  E6 C0        INCINDEX	INC	INDEXL	;Increment index low byte
0000F9r 1  D0 02        					BNE	SKP_IDX	;If not zero, skip high byte
0000FBr 1  E6 C1        					INC	INDEXH	;Increment index high byte
0000FDr 1  60           SKP_IDX		RTS	;Return to caller
0000FEr 1               ;
0000FEr 1               ;Output routines for formatting, backspaces, CR/LF, BEEP, etc.
0000FEr 1               ; all routines preserve the A reg on exit.
0000FEr 1               ;
0000FEr 1               ;BEEP subroutine: Send ASCII [BELL] to terminal
0000FEr 1  48           BEEP			PHA	;Save A reg on Stack
0000FFr 1  A9 07        					LDA	#$07	;Get ASCII [BELL] to terminal
000101r 1  80 2E        					BRA	SENDIT	;Branch to send
000103r 1               ;
000103r 1               ;BSOUT subroutine: send a Backspace to terminal
000103r 1  20 rr rr     BSOUT			JSR	BSOUT2	;Send an ASCII backspace
000106r 1  20 rr rr     					JSR	SPC	;Send space to clear out character
000109r 1  48           BSOUT2		PHA	;Save character in A reg
00010Ar 1  A9 08        					LDA	#$08	;Send another Backspace to return
00010Cr 1  80 23        BRCHOUT		BRA	SENDIT	;Branch to send
00010Er 1               ;
00010Er 1  20 rr rr     BSOUT3T		JSR	BSOUT2	;Send a Backspace 3 times
000111r 1  20 rr rr     BSOUT2T		JSR	BSOUT2	;Send a Backspace 2 times
000114r 1  80 F3        					BRA	BSOUT2	;Send a Backspace and return
000116r 1               ;
000116r 1               ;SPC subroutines: Send a Space to terminal 1,2 or 4 times
000116r 1  20 rr rr     SPC4			JSR	SPC2	;Send 4 Spaces to terminal
000119r 1  20 rr rr     SPC2			JSR	SPC	;Send 2 Spaces to terminal
00011Cr 1  48           SPC				PHA	;Save character in A reg
00011Dr 1  A9 20        					LDA	#$20	;Get ASCII Space
00011Fr 1  80 10        					BRA	SENDIT	;Branch to send
000121r 1               ;
000121r 1               ;DOLLAR subroutine: Send "$" to terminal
000121r 1  48           DOLLAR		PHA	;Save A reg on STACK
000122r 1  A9 24        					LDA	#$24	;Get ASCII "$"
000124r 1  80 0B        					BRA	SENDIT	;Branch to send
000126r 1               ;
000126r 1               ;Send CR,LF to terminal
000126r 1  20 rr rr     CR2				JSR	CROUT	;Send CR,LF to terminal
000129r 1  48           CROUT			PHA	;Save A reg
00012Ar 1  A9 0D        					LDA	#$0D	;Get ASCII Return
00012Cr 1  20 rr rr     					JSR	CHROUT	;Send to terminal
00012Fr 1  A9 0A        					LDA	#$0A	;Get ASCII Linefeed
000131r 1  20 rr rr     SENDIT		JSR	CHROUT	;Send to terminal
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000134r 1  68           					PLA	;Restore A reg
000135r 1  60           					RTS	;Return to caller
000136r 1               ;
000136r 1               ;GLINE subroutine: Send a horizontal line to terminal
000136r 1               ; used by memory display only, does not preserve any registers
000136r 1               ;
000136r 1  A2 4F        GLINE			LDX	#$4F	;Load index for 79 decimal
000138r 1  A9 7E        					LDA	#$7E	;Get "~" character
00013Ar 1  20 rr rr     GLINEL		JSR	CHROUT	;Send to terminal (draw a line)
00013Dr 1  CA           					DEX	;Decrement count
00013Er 1  D0 FA        					BNE	GLINEL	;Branch back until done
000140r 1  60           					RTS	;Return to caller
000141r 1               ;
000141r 1               ;Routines to output 8/16-bit Binary Data and Ascii characters
000141r 1               ;
000141r 1               ;PRASC subroutine: Print A-reg as ASCII, else print "."
000141r 1               ;Printable ASCII byte values = $20 through $7E
000141r 1  C9 7F        PRASC			CMP	#$7F	;Check for first 128
000143r 1  B0 04        					BCS	PERIOD	;If = or higher, branch
000145r 1  C9 20        					CMP	#$20	;Check for control characters
000147r 1  B0 02        					BCS	ASCOUT	;If space or higher, branch and print
000149r 1  A9 2E        PERIOD		LDA	#$2E	;Else, print a "."
00014Br 1  4C rr rr     ASCOUT		JMP	CHROUT	;Send byte in A-Reg, then return
00014Er 1               ;
00014Er 1               ;PRBYTE subroutine:
00014Er 1               ; Converts a single Byte to 2 HEX ASCII characters and sends to console
00014Er 1               ; on entry, A reg contains the Byte to convert/send
00014Er 1               ; Register contents are preserved on entry/exit
00014Er 1  48           PRBYTE		PHA	;Save A register
00014Fr 1  5A           					PHY	;Save Y register
000150r 1  20 rr rr     PRBYT2		JSR	BIN2ASC	;Convert A reg to 2 ASCII Hex characters
000153r 1  20 rr rr     					JSR	CHROUT	;Print high nibble from A reg
000156r 1  98           					TYA	;Transfer low nibble to A reg
000157r 1  20 rr rr     					JSR	CHROUT	;Print low nibble from A reg
00015Ar 1  7A           					PLY	;Restore Y Register
00015Br 1  68           					PLA	;Restore A Register
00015Cr 1  60           					RTS	;And return to caller
00015Dr 1               ;
00015Dr 1               ;PRINDEX	subroutine:
00015Dr 1               ; Used by Memory Dump and Text Entry routines
00015Dr 1               ; Prints a $ sign followed by the current value of INDEXH/L
00015Dr 1  20 rr rr     PRINDEX		JSR	DOLLAR	;Print a $ sign
000160r 1  A5 C1        					LDA	INDEXH	;Get Index high byte
000162r 1  A4 C0        					LDY	INDEXL	;Get Index low byte
000164r 1               ;
000164r 1               ;PRWORD	subroutine:
000164r 1               ;	Converts a 16-bit word to 4 HEX ASCII characters and sends to console
000164r 1               ; on entry, A reg contains High Byte, Y reg contains Low Byte
000164r 1               ; Register contents are preserved on entry/exit
000164r 1  48           PRWORD		PHA	;Save A register
000165r 1  5A           					PHY	;Save Y register
000166r 1  20 rr rr     					JSR	PRBYTE	;Convert and print one HEX character (00-FF)
000169r 1  98           					TYA	;Get Low byte value
00016Ar 1  80 E4        					BRA	PRBYT2	;Finish up Low Byte and exit
00016Cr 1               ;
00016Cr 1               ;RDLINE subroutine: Store keystrokes in buffer until [RETURN] key it struck
00016Cr 1               ;Used only for Hex entry, so only (0-9,A-F) are accepted entries
00016Cr 1               ;Lower-case alpha characters are converted to upper-case.
00016Cr 1               ;On entry, X reg = buffer length. On exit, X reg = buffer count
00016Cr 1               ;[BACKSPACE] key removes keystrokes from buffer.
00016Cr 1               ;[ESCAPE] key aborts then re-enters monitor.
00016Cr 1  86 CF        RDLINE		STX	BUFLEN	;Store buffer length
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00016Er 1  64 CE        					STZ	BUFIDX	;Zero buffer index
000170r 1  20 rr rr     RDLOOP		JSR	RDCHAR	;Get character from terminal, convert LC2UC
000173r 1  C9 1B        					CMP	#$1B	;Check for ESC key
000175r 1  F0 36        					BEQ	RDNULL	;If yes, exit back to Monitor
000177r 1  C9 0D        NOTESC		CMP	#$0D	;Check for C/R
000179r 1  F0 2B        					BEQ	EXITRD	;Exit if yes
00017Br 1  C9 08        					CMP	#$08	;Check for Backspace
00017Dr 1  F0 1C        					BEQ	RDBKSP	;If yes handle backspace
00017Fr 1  C9 30        TSTHEX		CMP	#$30	;Check for '0' or higher
000181r 1  90 0A        					BCC	INPERR	;Branch to error if less than '0'
000183r 1  C9 47        					CMP	#$47	;Check for 'G' ('F'+1)
000185r 1  B0 06        					BCS	INPERR	;Branch to error if 'G' or higher
000187r 1  A6 CE        FULTST		LDX	BUFIDX	;Get the current buffer index
000189r 1  E4 CF        					CPX	BUFLEN	;Compare to length for space
00018Br 1  90 05        					BCC	STRCHR	;Branch to store in buffer
00018Dr 1  20 rr rr     INPERR		JSR	BEEP	;Else, error, send Bell to terminal
000190r 1  80 DE        					BRA	RDLOOP	;Branch back to RDLOOP
000192r 1  95 B0        STRCHR		STA	INBUFF,X	;Store keystroke in buffer
000194r 1  20 rr rr     					JSR	CHROUT	;Send keystroke to terminal
000197r 1  E6 CE        					INC	BUFIDX	;Increment buffer index
000199r 1  80 D5        					BRA	RDLOOP	;Branch back to RDLOOP
00019Br 1  A5 CE        RDBKSP		LDA	BUFIDX	;Check if buffer is empty
00019Dr 1  F0 EE        					BEQ	INPERR	;Branch if yes
00019Fr 1  C6 CE        					DEC	BUFIDX	;Else, decrement buffer index
0001A1r 1  20 rr rr     					JSR	BSOUT	;Send Backspace to terminal
0001A4r 1  80 CA        					BRA	RDLOOP	;Loop back and continue
0001A6r 1  A6 CE        EXITRD		LDX	BUFIDX	;Get keystroke count (Z flag)
0001A8r 1  D0 0F        					BNE	AOK	;If data entered, normal exit
0001AAr 1  FF D5 0C     					BBS7	CMDFLAG,AOK	;Branch if CMD flag active
0001ADr 1  6C 0E 04     RDNULL		JMP	(WRMMNVEC0)	;Quit to Monitor warm start
0001B0r 1               ;
0001B0r 1               ;RDCHAR subroutine: Waits for a keystroke to be entered.
0001B0r 1               ; if keystroke is a lower-case alphabetical, convert it to upper-case
0001B0r 1  20 rr rr     RDCHAR		JSR	CHRIN	;Request keystroke input from terminal
0001B3r 1  C9 61        					CMP	#$61	;Check for lower case value range
0001B5r 1  90 02        					BCC	AOK	;Branch if < $61, control code/upper-case/numeric
0001B7r 1  E9 20        					SBC	#$20	;Subtract $20 to convert to upper case
0001B9r 1  60           AOK				RTS	;Character received, return to caller
0001BAr 1               ;
0001BAr 1               ;Continue routine, called by commands to confirm execution
0001BAr 1               ;when No is confirmed, return address removed from stack
0001BAr 1               ;and the exit goes back to the monitor loop.
0001BAr 1               ;Short version prompts for (Y/N) only.
0001BAr 1  A9 00        CONTINUE	LDA	#$00	;Get msg "cont? (Y/N)" to terminal
0001BCr 1  80 02        					BRA	SH_CONT	;Branch down
0001BEr 1  A9 01        CONTINUE2	LDA	#$01	;Get short msg "(Y/N)" only
0001C0r 1  20 rr rr     SH_CONT		JSR	PROMPT	;Send to terminal
0001C3r 1  20 rr rr     TRY_AGN		JSR	RDCHAR	;Get keystroke from terminal
0001C6r 1  C9 59        					CMP	#$59	;"Y" key?
0001C8r 1  F0 0B        					BEQ	DOCONT	;if yes, continue/exit
0001CAr 1  C9 4E        					CMP	#$4E	;if "N", quit/exit
0001CCr 1  F0 05        					BEQ	DONTCNT	;Return if not ESC
0001CEr 1  20 rr rr     					JSR	BEEP	;Send Beep to console
0001D1r 1  80 F0        					BRA	TRY_AGN	;Loop back, try again
0001D3r 1  68           DONTCNT		PLA	;Else remove return address
0001D4r 1  68           					PLA	;discard it,
0001D5r 1  60           DOCONT		RTS	;Return
0001D6r 1               ;
0001D6r 1               ;******************************
0001D6r 1               ;* Monitor command processors *
0001D6r 1               ;******************************
0001D6r 1               ;
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0001D6r 1               ;[,] Delay Setup Routine
0001D6r 1               ;	This routine gets hex input via the console
0001D6r 1               ;	- first is a hex byte ($00-$FF) for the millisecond count
0001D6r 1               ;	- second is a hex word ($0000-$FFFF) for the delay multiplier
0001D6r 1               ;		these are stored in variables SETIM, DELLO/DELHI
0001D6r 1               ;
0001D6r 1  A9 17        SET_DELAY	LDA	#$17	;Get millisecond delay message
0001D8r 1  20 rr rr     					JSR	HEX2	;Use short cut version for print and input
0001DBr 1  85 F6        					STA	SETIM	;Else store millisecond count in variable
0001DDr 1  A9 18        GETMULT		LDA	#$18	;Get Multiplier message
0001DFr 1  20 rr rr     					JSR	HEX4	;Use short cut version for print and input
0001E2r 1  85 F7        					STA	DELLO	;Store Low byte
0001E4r 1  84 F8        					STY	DELHI	;Store High byte
0001E6r 1  60           					RTS	;Return to caller
0001E7r 1               ;
0001E7r 1               ;[\] Execute XL Delay
0001E7r 1               ; Get an 8-bit value for extra long delay, execute is entered
0001E7r 1  A9 19        SET_XLDLY	LDA	#$19	;Get XL Loop message
0001E9r 1  20 rr rr     					JSR	HEX2	;Use short cut version for print and input
0001ECr 1  85 F9        					STA	XDL	;Save delay value
0001EEr 1  A9 0D        					LDA	#$0D	;Get ASCII C/R
0001F0r 1  20 rr rr     					JSR	CHROUT	;Send C/R (shows delay has been executed, no L/F)
0001F3r 1  4C rr rr     					JMP	EXE_XLDLY	;Execute Extra Long delay loop
0001F6r 1               ;
0001F6r 1               ;[(] INIMACRO command: Initialize keystroke input buffer
0001F6r 1               ;initializes buffer head/tail pointers and resets buffer count to zero
0001F6r 1               ;input buffer appears empty so command macro starts at the head of the buffer
0001F6r 1  64 DD        INIMACRO	STZ	LPCNTL	;Zero Loop count low byte
0001F8r 1  64 DE        					STZ	LPCNTH	;Zero Loop count high byte
0001FAr 1  64 DF        					STZ	LPCNTF	;Zero Loop count flag
0001FCr 1               ;
0001FCr 1  A9 2D        LP_CNT_FL	LDA	#$2D	;Get Loop Count msg
0001FEr 1  20 rr rr     					JSR	PROMPT	;send to console
000201r 1  A9 01        					LDA	#$01	;Get short msg "(Y/N)" only
000203r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000206r 1  20 rr rr     					JSR	RDCHAR	;Get keystroke from terminal
000209r 1  C9 59        					CMP	#$59	;"Y" key?
00020Br 1  F0 09        					BEQ	DOLOOPS	;if yes, set loop flag
00020Dr 1  C9 4E        					CMP	#$4E	;if "N", quit/exit
00020Fr 1  F0 07        					BEQ	NOLOOPS	;if no, don't set loop flag
000211r 1  20 rr rr     					JSR	BEEP	;Neither y/n selected, sound bell
000214r 1  80 E6        					BRA	LP_CNT_FL	;Branch back, try again
000216r 1               ;
000216r 1  F7 DF        DOLOOPS		SMB7	LPCNTF	;Set high order bit of Loop flag
000218r 1  64 E7        NOLOOPS		STZ	ICNT	;Zero Input buffer count
00021Ar 1  64 E9        					STZ	ITAIL	;Zero Input buffer tail pointer
00021Cr 1  64 E8        MACINI		STZ	IHEAD	;Zero Input buffer head pointer
00021Er 1  60           DONEFILL	RTS	;Return to caller
00021Fr 1               ;
00021Fr 1               ;[)] RUNMACRO command: Run monitor command macro. This will indicate that there
00021Fr 1               ;are 128 keystrokes in the keystroke input buffer. The monitor will process these
00021Fr 1               ;as if they were received from the terminal (typed-in by the user). Because the
00021Fr 1               ;last keystroke stored in the keystroke buffer was ")", this will loop continuously
00021Fr 1               ;Use [BREAK] to exit macro
00021Fr 1  A9 7F        RUNMACRO	LDA	#$7F	;Set keystroke buffer tail pointer to $7F
000221r 1  85 E9        					STA	ITAIL	;Push tail pointer to end
000223r 1  1A           					INC	A	;Increment to $80 for buffer count (full)
000224r 1  85 E7        					STA	ICNT	;Make count show as full
000226r 1  7F DF 15     					BBR7	LPCNTF,NOLP_CNT	;If Loop flag clear, branch around it
000229r 1  E6 DD        					INC	LPCNTL	;Increment loops low byte
00022Br 1  D0 02        					BNE	SKP_LPC	;If not zero, skip high byte
00022Dr 1  E6 DE        					INC	LPCNTH	;Increment loops high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00022Fr 1  A9 2E        SKP_LPC		LDA	#$2E	;Get Loops msg
000231r 1  20 rr rr     					JSR	PROMPT	;Send to console
000234r 1  A5 DD        					LDA	LPCNTL	;Get Loop count low
000236r 1  A4 DE        					LDY	LPCNTH	;Get Loop count high
000238r 1  20 rr rr     					JSR	HEX2ASC	;Print Loop count
00023Br 1  20 rr rr     					JSR	CROUT	;Send C/R to console
00023Er 1  80 DC        NOLP_CNT	BRA	MACINI	;Zero Head pointer and exit
000240r 1               ;
000240r 1               ;[C] Compare one memory range to another and display any addresses which do not match
000240r 1               ;[M] Move routine uses this section for parameter input, then branches to MOVER below
000240r 1               ;[F] Fill routine uses this section for parameter input but requires a fill byte value
000240r 1               ;[CTRL-P] Program EEPROM uses this section for parameter input and to write the EEPROM
000240r 1               ;Uses source, target and length input parameters. errors in compare are shown in target space
000240r 1               ;
000240r 1  A9 05        FM_INPUT	LDA	#$05	;Send "val: " to terminal
000242r 1  20 rr rr     					JSR	HEX2	;Use short cut version for print and input
000245r 1  AA           					TAX	;Xfer fill byte to X reg
000246r 1  20 rr rr     					JSR	CONTINUE	;Handle continue prompt
000249r 1               ;
000249r 1               ;Memory fill routine: parameter gathered below with Move/Fill, then a jump to here
000249r 1               ;Xreg contains fill byte value
000249r 1  A5 CC        FILL_LP		LDA	LENL	;Get length low byte
00024Br 1  05 CD        					ORA	LENH	;OR in length high byte
00024Dr 1  F0 CF        					BEQ	DONEFILL	;Exit if zero
00024Fr 1  8A           					TXA	;Get fill byte
000250r 1  92 CA        					STA	(TGTL)	;Store in target location
000252r 1  20 rr rr     					JSR	UPD_TL	;Update Target/Length pointers
000255r 1  80 F2        					BRA	FILL_LP	;Loop back until done
000257r 1               ;
000257r 1               ;Compare/Move/Fill memory operations enter here, branches as required
000257r 1               ;
000257r 1  85 D3        CPMVFL		STA	TEMP2	;Save command character
000259r 1  20 rr rr     					JSR	CHROUT	;Print command character (C/M/F)
00025Cr 1  C9 46        					CMP	#$46	;Check for F - fill memory
00025Er 1  D0 0B        					BNE	PRGE_E	;If not continue normal parameter input
000260r 1  A9 03        					LDA	#$03	;Get msg " addr:"
000262r 1  80 12        					BRA	F_INPUT	;Branch to handle parameter input
000264r 1               ;
000264r 1               ;EEPROM wrte operation enters here
000264r 1               ;
000264r 1  A9 21        PROGEE		LDA	#$21	;Get PRG_EE msg
000266r 1  20 rr rr     					JSR	PROMPT	;send to terminal
000269r 1  64 D3        					STZ	TEMP2	;Clear (Compare/Fill/Move) / error flag
00026Br 1               ;
00026Br 1  A9 06        PRGE_E		LDA	#$06	;Send " src:" to terminal
00026Dr 1  20 rr rr     					JSR	HEX4	;Use short cut version for print and input
000270r 1  85 C8        					STA	SRCL	;Else, store source address in variable SRCL,SRCH
000272r 1  84 C9        					STY	SRCH	;Store high address
000274r 1  A9 07        					LDA	#$07	;Send " tgt:" to terminal
000276r 1  20 rr rr     F_INPUT		JSR	HEX4	;Use short cut version for print and input
000279r 1  85 CA        					STA	TGTL	;Else, store target address in variable TGTL,TGTH
00027Br 1  84 CB        					STY	TGTH	;Store high address
00027Dr 1  A9 04        					LDA	#$04	;Send " len:" to terminal
00027Fr 1  20 rr rr     					JSR	HEX4	;Use short cut version for print and input
000282r 1  85 CC        					STA	LENL	;ELSE, store length address in variable LENL,LENH
000284r 1  84 CD        					STY	LENH	;Store high address
000286r 1               ;
000286r 1               ; All input parameters for Source, Target and Length entered
000286r 1  A5 D3        					LDA	TEMP2	;Get Command character
000288r 1  C9 46        					CMP	#$46	;Check for fill memory
00028Ar 1  F0 B4        					BEQ	FM_INPUT	;Handle the remaining input
00028Cr 1  C9 43        					CMP	#$43	;Test for Compare
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00028Er 1  F0 35        					BEQ	COMPLP	;Branch if yes
000290r 1  C9 4D        					CMP	#$4D	;Check for Move
000292r 1  F0 5A        					BEQ	MOVER	;Branch if yes
000294r 1               ;
000294r 1  A9 22        PROG_EE		LDA	#$22	;Get warning msg
000296r 1  20 rr rr     					JSR	PROMPT	;Send to console
000299r 1  20 rr rr     					JSR	CONTINUE2	;Prompt for y/n
00029Cr 1               ;
00029Cr 1               ;Programming of the EEPROM is now confirmed by user
00029Cr 1               ; This routine will copy the core move and test routine
00029Cr 1               ; from ROM to RAM, then call COMPLP to write and compare
00029Cr 1               ; as I/O can generate interrupts which point to ROM routines,
00029Cr 1               ; all interrupts must be disabled during the sequence.
00029Cr 1               ;
00029Cr 1               ;Send message to console for writing EEPROM
00029Cr 1  A9 23        					LDA	#$23	;Get write message
00029Er 1  20 rr rr     					JSR	PROMPT	;Send to console
0002A1r 1  A5 EA        OC_LOOP		LDA	OCNT	;Check output buffer count
0002A3r 1  D0 FC        					BNE	OC_LOOP	;Loop back until buffer sent
0002A5r 1               ;
0002A5r 1               ;Xfer byte write code to RAM for execution
0002A5r 1  A2 15        					LDX	#BYTE_WRE-BYTE_WRS+1	;Get length of byte write code
0002A7r 1  BD rr rr     BYTE_XFER	LDA	BYTE_WRS-1,X	;Get code
0002AAr 1  95 FF        					STA	<(BURN_BYTE-1),X	;Write code to RAM
0002ACr 1  CA           					DEX	;Decrement index
0002ADr 1  D0 F8        					BNE	BYTE_XFER	;Loop back until done
0002AFr 1               ;
0002AFr 1  F7 D3        PROG_EEP	SMB7	TEMP2	;Set EEPROM write active mask
0002B1r 1  20 rr rr     					JSR	COMPLP	;Call routine to write/compare
0002B4r 1  6F D3 04     					BBR6	TEMP2,PRG_GOOD	;Skip down if no error
0002B7r 1  A9 25        					LDA	#$25	;Get Prog failed message
0002B9r 1  80 07        					BRA	BRA_PRMPT	;Branch to Prompt routine
0002BBr 1               ;
0002BBr 1  A9 24        PRG_GOOD	LDA	#$24	;Get completed message
0002BDr 1  20 rr rr     					JSR	PROMPT	;Send to console
0002C0r 1  A9 26        					LDA	#$26	;Get warning message for RTC and Reset
0002C2r 1  4C rr rr     BRA_PRMPT	JMP	PROMPT	;Send to console and exit
0002C5r 1               ;
0002C5r 1  A5 CC        COMPLP		LDA	LENL	;Get low byte of length
0002C7r 1  05 CD        					ORA	LENH	;OR in High byte of length
0002C9r 1  F0 71        					BEQ	QUITMV	;If zero, nothing to compare/write
0002CBr 1  7F D3 03     					BBR7	TEMP2,SKP_BURN	;Skip burn if bit 7 clear
0002CEr 1  20 00 00     					JSR	BURN_BYTE	;Else Burn a byte to EEPROM
0002D1r 1  B2 C8        SKP_BURN	LDA	(SRCL)	;Else load source
0002D3r 1  D2 CA        					CMP	(TGTL)	;Compare to source
0002D5r 1  F0 12        					BEQ	CMP_OK	;If compare is good, continue
0002D7r 1               ;
0002D7r 1  E7 D3        					SMB6	TEMP2	;Set bit 6 of TEMP2 flag (compare error)
0002D9r 1  20 rr rr     					JSR	SPC2	;Send 2 spaces
0002DCr 1  20 rr rr     					JSR	DOLLAR	;Print $ sign
0002DFr 1  A5 CB        					LDA	TGTH	;Get high byte of address
0002E1r 1  A4 CA        					LDY	TGTL	;Get Low byte of address
0002E3r 1  20 rr rr     					JSR	PRWORD	;Print word
0002E6r 1  20 rr rr     					JSR	SPC	;Add 1 space for formatting
0002E9r 1               ;
0002E9r 1  20 rr rr     CMP_OK		JSR	UPD_STL	;Update pointers
0002ECr 1  80 D7        					BRA	COMPLP	;Loop back until done
0002EEr 1               ;
0002EEr 1               ;Parameters for move memory entered and validated
0002EEr 1               ; now make decision on which direction to do the actual move
0002EEr 1               ; if overlapping, move from end to start, else from start to end
0002EEr 1  20 rr rr     MOVER			JSR	CONTINUE	;Prompt to continue move
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0002F1r 1  38           					SEC	;Set carry flag for subtract
0002F2r 1  A5 CA        					LDA	TGTL	;Get target lo byte
0002F4r 1  E5 C8        					SBC	SRCL	;Subtract source lo byte
0002F6r 1  AA           					TAX	;Move to X reg temporarily
0002F7r 1  A5 CB        					LDA	TGTH	;Get target hi byte
0002F9r 1  E5 C9        					SBC	SRCH	;Subtract source hi byte
0002FBr 1  A8           					TAY	;Move to Y reg temporarily
0002FCr 1  8A           					TXA	;Xfer lo byte difference to A reg
0002FDr 1  C5 CC        					CMP	LENL	;Compare to lo byte length
0002FFr 1  98           					TYA	;Xfer hi byte difference to A reg
000300r 1  E5 CD        					SBC	LENH	;Subtract length lo byte
000302r 1  90 0F        					BCC	RIGHT	;If carry is clear, overwrite condition exists
000304r 1               ;Move memory block first byte to last byte, no overlap condition
000304r 1  A5 CC        MVNO_LP		LDA	LENL	;Get length low byte
000306r 1  05 CD        					ORA	LENH	;OR in length high byte
000308r 1  F0 32        					BEQ	QUITMV	;Exit if zero bytes to move
00030Ar 1  B2 C8        					LDA	(SRCL)	;Load source data
00030Cr 1  92 CA        					STA	(TGTL)	;Store as target data
00030Er 1  20 rr rr     					JSR	UPD_STL	;Update Source/Target/Length variables
000311r 1  80 F1        					BRA	MVNO_LP	;Branch back until length is zero
000313r 1               ;
000313r 1               ;Move memory block last byte to first byte
000313r 1               ; avoids overwrite in source/target overlap
000313r 1  A6 CD        RIGHT			LDX	LENH	;Get the length hi byte count
000315r 1  18           					CLC	;Clear carry flag for add
000316r 1  8A           					TXA	;Xfer High page to A reg
000317r 1  65 C9        					ADC	SRCH	;Add in source hi byte
000319r 1  85 C9        					STA	SRCH	;Store in source hi byte
00031Br 1  18           					CLC	;Clear carry for add
00031Cr 1  8A           					TXA	;Xfer High page to A reg
00031Dr 1  65 CB        					ADC	TGTH	;Add to target hi byte
00031Fr 1  85 CB        					STA	TGTH	;Store to target hi byte
000321r 1  E8           					INX	;Increment high page value for use below in loop
000322r 1  A4 CC        					LDY	LENL	;Get length lo byte
000324r 1  F0 0E        					BEQ	MVPG	;If zero no partial page to move
000326r 1  88           					DEY	;Else, decrement page byte index
000327r 1  F0 07        					BEQ	MVPAG	;If zero, no pages to move
000329r 1  B1 C8        MVPRT			LDA	(SRCL),Y	;Load source data
00032Br 1  91 CA        					STA	(TGTL),Y	;Store to target data
00032Dr 1  88           					DEY	;Decrement index
00032Er 1  D0 F9        					BNE  MVPRT	;Branch back until partial page moved
000330r 1  B1 C8        MVPAG			LDA	(SRCL),Y	;Load source data
000332r 1  91 CA        					STA	(TGTL),Y	;Store to target data
000334r 1  88           MVPG			DEY	;Decrement page count
000335r 1  C6 C9        					DEC	SRCH	;Decrement source hi page
000337r 1  C6 CB        					DEC	TGTH	;Decrement target hi page
000339r 1  CA           					DEX	;Decrement page count
00033Ar 1  D0 ED        					BNE	MVPRT	;Loop back until all pages moved
00033Cr 1  60           QUITMV		RTS	;Return to caller
00033Dr 1               ;
00033Dr 1  78           BYTE_WRS	SEI	;Disable interrupts
00033Er 1  B2 C8        					LDA	(SRCL)	;Get source byte
000340r 1  92 CA        					STA	(TGTL)	;Write to target byte
000342r 1  B2 CA        					LDA	(TGTL)	;Read target byte (EEPROM)
000344r 1  29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
000346r 1  85 D4        BYTE_WLP	STA	TEMP3	;Store in Temp location
000348r 1  B2 CA        					LDA	(TGTL)	;Read target byte again (EEPROM)
00034Ar 1  29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
00034Cr 1  C5 D4        					CMP	TEMP3	;Compare to last read (toggles if write mode)
00034Er 1  D0 F6        					BNE	BYTE_WLP	;Branch back if not done
000350r 1  58           					CLI	;Re-enable interrupts
000351r 1  60           BYTE_WRE	RTS	;Return to caller
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000352r 1               ;
000352r 1               ;[D] HEX/TEXT DUMP command:
000352r 1               ; Display in HEX followed by TEXT the contents of 256 consecutive memory addresses
000352r 1  F7 D5        MDUMP			SMB7	CMDFLAG	;Set Command flag
000354r 1  20 rr rr     					JSR	SETUP	;Request HEX address input from terminal
000357r 1  D0 08        					BNE	LINED	;Branch if new address entered (Z flag set already)
000359r 1  A5 C2        					LDA	TEMP1L	;Else, point to next consecutive memory page
00035Br 1  85 C0        					STA	INDEXL	;address saved during last memory dump
00035Dr 1  A5 C3        					LDA	TEMP1H	;xfer high byte of address
00035Fr 1  85 C1        					STA	INDEXH	;save in pointer
000361r 1  20 rr rr     LINED			JSR	DMPGR	;Send address offsets to terminal
000364r 1  20 rr rr     					JSR	GLINE	;Send horizontal line to terminal
000367r 1  20 rr rr     					JSR	CROUT	;Send CR,LF to terminal
00036Ar 1  A2 10        					LDX	#$10	;Set line count for 16 rows
00036Cr 1  20 rr rr     DLINE			JSR	SPC4	;Send 4 Spaces to terminal
00036Fr 1  20 rr rr     					JSR	PRINDEX	;Print INDEX value
000372r 1  20 rr rr     					JSR	SPC2	;Send 2 Spaces to terminal
000375r 1  A0 00        					LDY	#$00	;Initialize line byte counter
000377r 1  B1 C0        GETBYT		LDA	(INDEXL),Y	;Read indexed byte
000379r 1  20 rr rr     					JSR	PRBYTE	;Display byte as a HEX value
00037Cr 1  20 rr rr     					JSR	SPC	;Send Space to terminal
00037Fr 1  C8           					INY	;Increment index
000380r 1  C0 10        					CPY	#$10	;Check for all 16
000382r 1  D0 F3        					BNE	GETBYT	;loop back until 16 bytes have been displayed
000384r 1  20 rr rr     					JSR	SPC	;Send a space
000387r 1  B2 C0        GETBYT2		LDA	(INDEXL)	;Read indexed byte
000389r 1  20 rr rr     					JSR	PRASC	;Print ASCII character
00038Cr 1  20 rr rr     					JSR	INCINDEX	;Increment index
00038Fr 1  88           					DEY	;Decrement count (from 16)
000390r 1  D0 F5        					BNE	GETBYT2	;loop back until 16 bytes have been displayed
000392r 1  20 rr rr     					JSR	CROUT	;else, send CR,LF to terminal
000395r 1  A5 C0        					LDA	INDEXL	;Get current index low
000397r 1  85 C2        					STA	TEMP1L	;Save to temp1 low
000399r 1  A5 C1        					LDA	INDEXH	;Get current index high
00039Br 1  85 C3        					STA	TEMP1H	;Save to temp1 high
00039Dr 1  CA           					DEX	;Decrement line count
00039Er 1  D0 CC        					BNE	DLINE	;Branch back until all 16 done
0003A0r 1  20 rr rr     					JSR	GLINE	;Send horizontal line to terminal
0003A3r 1               ;DMPGR subroutine: Send address offsets to terminal
0003A3r 1  A9 02        DMPGR			LDA	#$02	;Get msg for "addr:" to terminal
0003A5r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
0003A8r 1  20 rr rr     					JSR	SPC2	;Add two additional spaces
0003ABr 1  A2 00        					LDX	#$00	;Zero index count
0003ADr 1  8A           MDLOOP		TXA	;Send "00" thru "0F", separated by 1 Space, to terminal
0003AEr 1  20 rr rr     					JSR	PRBYTE	;Print byte value
0003B1r 1  20 rr rr     					JSR	SPC	;Add a space
0003B4r 1  E8           					INX	;Increment the count
0003B5r 1  E0 10        					CPX	#$10	;Check for 16
0003B7r 1  D0 F4        					BNE	MDLOOP	;Loop back until done
0003B9r 1               ;	Print the ASCII text header "0123456789ABCDEF"
0003B9r 1  20 rr rr     					JSR	SPC	;Send a space
0003BCr 1  A2 00        					LDX	#$00	;Zero X reg for "0"
0003BEr 1  8A           MTLOOP		TXA	;Xfer to A reg
0003BFr 1  20 rr rr     					JSR	BIN2ASC	;Convert Byte to two ASCII digits
0003C2r 1  98           					TYA	;Xfer the low nibble character to A reg
0003C3r 1  20 rr rr     					JSR	CHROUT	;Send least significant HEX to terminal
0003C6r 1  E8           					INX	;Increment to next HEX character
0003C7r 1  E0 10        					CPX	#$10	;Check for 16
0003C9r 1  D0 F3        					BNE	MTLOOP	;branch back till done
0003CBr 1  4C rr rr     					JMP	CROUT	;Do a CR/LF and return
0003CEr 1               ;
0003CEr 1               ;[E] Examine/Edit command: Display in HEX then change the contents of a specified memory address
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0003CEr 1  20 rr rr     CHANGE		JSR	SETUP	;Request HEX address input from terminal
0003D1r 1  20 rr rr     CHNG_LP		JSR	SPC2	;Send 2 spaces
0003D4r 1  B2 C0        					LDA	(INDEXL)	;Read specified address
0003D6r 1  20 rr rr     					JSR	PRBYTE	;Display HEX value read
0003D9r 1  20 rr rr     					JSR	BSOUT3T ;Send 3 Backspaces
0003DCr 1  20 rr rr     					JSR	HEXIN2	;Get input, result in A reg
0003DFr 1  92 C0        					STA	(INDEXL)	;Save entered value at Index pointer
0003E1r 1  D2 C0        					CMP	(INDEXL)	;Compare to ensure a match
0003E3r 1  F0 05        					BEQ	CHOK	;Branch if compare is good
0003E5r 1  A9 3F        					LDA	#$3F	;Get "?" for bad compare
0003E7r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
0003EAr 1  20 rr rr     CHOK			JSR	INCINDEX	;Increment Index
0003EDr 1  80 E2        					BRA	CHNG_LP	;Loop to continue command
0003EFr 1               ;
0003EFr 1               ;[G] GO command: Begin executing program code at a specified address
0003EFr 1               ;Prompts the user for a start address, places it in COMLO/COMHI
0003EFr 1               ;If no address entered, uses default address at COMLO/COMHI
0003EFr 1               ;Loads the A,X,Y,P registers from presets and does a JSR to the routine
0003EFr 1               ;Upon return, registers are saved back to presets for display later
0003EFr 1               ;Also saves the stack pointer and status register upon return
0003EFr 1               ;Stack pointer is not changed due to constant IRQ service routines
0003EFr 1  F7 D5        GO				SMB7	CMDFLAG	;Set Command flag
0003F1r 1  20 rr rr     					JSR	SETUP	;Get HEX address (A/Y regs hold 16-bit value)
0003F4r 1  F0 04        					BEQ	EXEC_GO	;If not, setup registers and execute (Z flag set already)
0003F6r 1  85 BE        					STA	COMLO	;Save entered address to pointer low byte
0003F8r 1  84 BF        					STY	COMHI	;Save entered address to pointer hi byte
0003FAr 1               ;Preload all 65C02 MPU registers from monitor's preset/result variables
0003FAr 1  A5 E2        EXEC_GO		LDA	PREG	;Load processor status register preset
0003FCr 1  48           					PHA	;Push it to the stack
0003FDr 1  A5 E6        					LDA	AREG	;Load A-Reg preset
0003FFr 1  A6 E5        					LDX	XREG	;Load X-Reg preset
000401r 1  A4 E4        					LDY	YREG	;Load Y-Reg preset
000403r 1  28           					PLP	;Pull the processor status register
000404r 1               ;Call user program code as a subroutine
000404r 1  20 rr rr     					JSR	DOCOM	;Execute code at specified address
000407r 1               ;Store all 65C02 MPU registers to monitor's preset/result variables: store results
000407r 1  08           					PHP	;Save the processor status register to the stack
000408r 1  85 E6        					STA	AREG	;Store A-Reg result
00040Ar 1  86 E5        					STX	XREG	;Store X-Reg result
00040Cr 1  84 E4        					STY	YREG	;Store Y-Reg result
00040Er 1  68           					PLA	;Get the processor status register
00040Fr 1  85 E2        					STA	PREG	;Store the result
000411r 1  BA           					TSX	;Xfer stack pointer to X-reg
000412r 1  86 E3        					STX	SREG	;Store the result
000414r 1  D8           					CLD	;Clear BCD mode in case of sloppy user code ;-)
000415r 1  60           TXT_EXT		RTS	;Return to caller
000416r 1  6C BE 00     DOCOM			JMP	(COMLO)	;Execute the command
000419r 1               ;
000419r 1               ;[T] LOCATE TEXT STRING command: search memory for an entered text string
000419r 1               ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
000419r 1               ;SRCHTXT subroutine: request 1 - 16 character text string from terminal, followed by Return
000419r 1               ;[ESCAPE] aborts, [BACKSPACE] erases last keystroke. String will be stored in SRCHBUFF
000419r 1  A9 08        SRCHTXT		LDA	#$08	;Get msg " find text:"
00041Br 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00041Er 1  A2 00        					LDX	#$00	;Initialize index/byte counter
000420r 1  20 rr rr     STLOOP		JSR	CHRIN	;Get input from terminal
000423r 1  C9 0D        					CMP	#$0D	;Check for C/R
000425r 1  F0 3B        					BEQ	SRCHRDY	;Branch to search engine
000427r 1  C9 1B        					CMP	#$1B	;Check for ESC
000429r 1  F0 EA        					BEQ	TXT_EXT	;Exit to borrowed RTS
00042Br 1  C9 08        					CMP	#$08	;Check for B/S
00042Dr 1  D0 09        					BNE	STBRA	;If not, store character into buffer
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00042Fr 1  8A           					TXA	;Xfer count to A reg
000430r 1  F0 EE        					BEQ	STLOOP	;Branch to input if zero
000432r 1  20 rr rr     					JSR	BSOUT	;Else, send B/S to terminal
000435r 1  CA           					DEX	;Decrement index/byte counter
000436r 1  80 E8        					BRA	STLOOP	;Branch back and continue
000438r 1  9D 40 04     STBRA			STA	SRCHBUFF,X	;Store character in buffer location
00043Br 1  20 rr rr     					JSR	CHROUT	;Send character to terminal
00043Er 1  E8           					INX	;Increment counter
00043Fr 1  E0 10        					CPX	#$10	;Check count for 16
000441r 1  D0 DD        					BNE	STLOOP	;Loop back for another character
000443r 1  80 1D        					BRA	SRCHRDY	;Branch to search engine
000445r 1               ;
000445r 1               ;[H] LOCATE BYTE STRING command: search memory for an entered byte string
000445r 1               ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
000445r 1               ;SRCHBYT subroutine: request 0 - 16 byte string from terminal, each byte followed by Return
000445r 1               ;[ESCAPE] aborts. HEX data will be stored in SRCHBUFF
000445r 1  F7 D5        SRCHBYT		SMB7	CMDFLAG	;Set Command flag
000447r 1  A9 09        					LDA	#$09	;Get msg " find bin:"
000449r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00044Cr 1  A2 00        					LDX	#$00	;Initialize index
00044Er 1  DA           SBLOOP		PHX	;Save index on stack
00044Fr 1  20 rr rr     					JSR	HEXIN2	;Request HEX byte
000452r 1  20 rr rr     					JSR	SPC	;Send space to terminal
000455r 1  FA           					PLX	;Restore index from stack
000456r 1  A4 CE        					LDY	BUFIDX	;Get # of characters entered
000458r 1  F0 08        					BEQ	SRCHRDY ;Branch if no characters
00045Ar 1  9D 40 04     					STA	SRCHBUFF,X ;Else, store in buffer
00045Dr 1  E8           					INX	;Increment index
00045Er 1  E0 10        					CPX	#$10	;Check for 16 (max)
000460r 1  D0 EC        					BNE	SBLOOP	;Loop back until done/full
000462r 1  86 D0        SRCHRDY		STX	IDX	;Save input character count
000464r 1  E0 00        					CPX	#$00	;Check buffer count
000466r 1  F0 AD        					BEQ	TXT_EXT	;Exit if no bytes in buffer
000468r 1  A9 0C        					LDA	#$0C	;Else, get msg "Searching.."
00046Ar 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00046Dr 1               ;
00046Dr 1               ;SENGINE subroutine: Scan memory range $0800 through $FFFF for exact match to string
00046Dr 1               ;contained in buffer SRCHBUFF (1 to 16 bytes/characters). Display address of first
00046Dr 1               ;byte/character of each match found until the end of memory is reached.
00046Dr 1  A9 08        SENGINE		LDA	#$08	;Initialize address to $0800: skip over $0000 through $07FF
00046Fr 1  85 C1        					STA	INDEXH	;Store high byte
000471r 1  64 C0        					STZ	INDEXL ;Zero low byte
000473r 1  A2 00        SENGBR2		LDX	#$00	;Initialize buffer index
000475r 1  B2 C0        SENGBR3		LDA	(INDEXL)	;Read current memory location
000477r 1  DD 40 04     					CMP	SRCHBUFF,X	;Compare to search buffer
00047Ar 1  F0 05        					BEQ	SENGBR1	;Branch for a match
00047Cr 1  20 rr rr     					JSR	SINCPTR	;Increment pointer, test for end of memory
00047Fr 1  80 F2        					BRA	SENGBR2	;Loop back to continue
000481r 1  20 rr rr     SENGBR1		JSR	SINCPTR	;Increment pointer, test for end of memory
000484r 1  E8           					INX	;Increment buffer index
000485r 1  E4 D0        					CPX	IDX	;Compare buffer index to address index
000487r 1  D0 EC        					BNE	SENGBR3	;Loop back until done
000489r 1  38           					SEC	;Subtract buffer index from memory pointer; Set carry
00048Ar 1  A5 C0        					LDA	INDEXL	;Get current address for match lo byte
00048Cr 1  E5 D0        					SBC	IDX	;Subtract from buffer index
00048Er 1  85 C0        					STA	INDEXL	;Save it back to lo address pointer
000490r 1  A5 C1        					LDA	INDEXH	;Get current address for match hi byte
000492r 1  E9 00        					SBC	#$00	;Subtract carry flag
000494r 1  85 C1        					STA	INDEXH	;Save it back to hi address pointer
000496r 1  A9 0B        					LDA	#$0B	;Get msg "found"
000498r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00049Br 1  A9 3A        					LDA	#':'	;Get Ascii colon
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00049Dr 1  20 rr rr     					JSR	CHROUT	;Send to console
0004A0r 1  20 rr rr     					JSR	PRINDEX	;Print Index address
0004A3r 1  A9 0D        					LDA	#$0D	;Get msg "(n)ext? "
0004A5r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
0004A8r 1  20 rr rr     					JSR	RDCHAR	;Get input from terminal
0004ABr 1  C9 4E        					CMP	#$4E	;Check for "(n)ext"
0004ADr 1  D0 38        					BNE	NCAREG	;Exit if not requesting next
0004AFr 1  20 rr rr     					JSR	SINCPTR	;Increment address pointer, test for end of memory
0004B2r 1  80 BF        					BRA	SENGBR2	;Branch back and continue till done
0004B4r 1               ;
0004B4r 1               ;Increment memory address pointer. If pointer high byte = 00 (end of searchable ROM memory),
0004B4r 1               ;send "not found" to terminal then return to monitor
0004B4r 1  20 rr rr     SINCPTR		JSR	INCINDEX	;Increment Index pointer
0004B7r 1  A5 C1        					LDA	INDEXH	;Check for wrap to $0000
0004B9r 1  D0 2C        					BNE	NCAREG	;If not, return
0004BBr 1  68           					PLA	;Else, Pull return address from stack
0004BCr 1  68           					PLA	;and exit with msg
0004BDr 1  A9 0A        					LDA	#$0A	;Get msg "not found"
0004BFr 1  4C rr rr     					JMP	PROMPT	;Send msg to terminal and exit
0004C2r 1               ;
0004C2r 1               ;[P] Processor Status command: Display then change PS preset/result
0004C2r 1  A9 0E        PRG				LDA	#$0E	;Get MSG # for Processor Status register
0004C4r 1  80 0E        					BRA	REG_UPT	;Finish register update
0004C6r 1               ;
0004C6r 1               ;[S] Stack Pointer command: Display then change SP preset/result
0004C6r 1  A9 0F        SRG				LDA	#$0F	;Get MSG # for Stack register
0004C8r 1  80 0A        					BRA	REG_UPT	;Finish Register update
0004CAr 1               ;
0004CAr 1               ;[Y] Y-Register command: Display then change Y-reg preset/result
0004CAr 1  A9 10        YRG				LDA	#$10	;Get MSG # for Y Reg
0004CCr 1  80 06        					BRA	REG_UPT	;Finish register update
0004CEr 1               ;
0004CEr 1               ;[X] X-Register command: Display then change X-reg preset/result
0004CEr 1  A9 11        XRG				LDA	#$11	;Get MSG # for X Reg
0004D0r 1  80 02        					BRA	REG_UPT	;Finish register update
0004D2r 1               ;
0004D2r 1               ;[A] A-Register command: Display then change A-reg preset/result
0004D2r 1  A9 12        ARG				LDA	#$12	;Get MSG # for A reg
0004D4r 1               ;
0004D4r 1  48           REG_UPT		PHA	;Save MSG # to stack
0004D5r 1  AA           					TAX	;Xfer to X reg
0004D6r 1  20 rr rr     					JSR	PROMPT	;Print Register message
0004D9r 1  B5 D4        					LDA	PREG-$0E,X	;Read Register (A,X,Y,S,P) preset/result
0004DBr 1  20 rr rr     					JSR	PRBYTE	;Display HEX value of register
0004DEr 1  20 rr rr     					JSR	SPC	;Send [SPACE] to terminal
0004E1r 1  20 rr rr     					JSR	HEXIN2	;Get up to 2 HEX characters
0004E4r 1  FA           					PLX	;Get MSG # from stack
0004E5r 1  95 D4        					STA	PREG-$0E,X	;Write register (A,X,Y,S,P) preset/result
0004E7r 1  60           NCAREG		RTS	;Return to caller
0004E8r 1               ;
0004E8r 1               ;[R] REGISTERS command: Display contents of all preset/result memory locations
0004E8r 1  20 rr rr     PRSTAT		JSR	CHROUT	;Send "R" to terminal
0004EBr 1  A9 13        PRSTAT1		LDA	#$13	;Get Header msg
0004EDr 1  20 rr rr     					JSR	PROMPT	;Send to terminal
0004F0r 1  A5 E1        					LDA	PCH	;Get PC high byte
0004F2r 1  A4 E0        					LDY	PCL	;Get PC low byte
0004F4r 1  20 rr rr     					JSR	PRWORD	;Print 16-bit word
0004F7r 1  20 rr rr     					JSR	SPC	;Send 1 space
0004FAr 1               ;
0004FAr 1  A2 04        					LDX	#$04	;Set for count of 4
0004FCr 1  B5 E2        REGPLOOP	LDA	PREG,X	;Start with A reg variable
0004FEr 1  20 rr rr     					JSR	PRBYTE	;Print it
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000501r 1  20 rr rr     					JSR	SPC	;Send 1 space
000504r 1  CA           					DEX	;Decrement count
000505r 1  D0 F5        					BNE	REGPLOOP	;Loop back till all 4 are sent
000507r 1               ;
000507r 1  A5 E2        					LDA	PREG	;Get Status register preset
000509r 1  A2 08        					LDX	#$08	;Get the index count for 8 bits
00050Br 1  0A           SREG_LP		ASL	A	;Shift bit into Carry
00050Cr 1  48           					PHA	;Save current (shifted) SR value
00050Dr 1  A9 30        					LDA	#$30	;Load an Ascii zero
00050Fr 1  69 00        					ADC	#$00	;Add zero (with Carry)
000511r 1  20 rr rr     					JSR	CHROUT	;Print bit value (0 or 1)
000514r 1  68           					PLA	;Get current (shifted) SR value
000515r 1  CA           					DEX	;Decrement bit count
000516r 1  D0 F3        					BNE	SREG_LP	;Loop back until all 8 printed
000518r 1  4C rr rr     					JMP	CROUT	;Send CR/LF and return
00051Br 1               ;
00051Br 1               ;[I] command: TEXT ENTRY enter ASCII text beginning at a specified address
00051Br 1  20 rr rr     TEXT			JSR	SETUP	;Send "I" command, handle setup
00051Er 1  20 rr rr     EDJMP1		JSR	CROUT	;Send CR,LF to terminal
000521r 1  85 C4        					STA	TEMP2L	;Save current edit address
000523r 1  84 C5        					STY	TEMP2H	;Save high byte
000525r 1  20 rr rr     EDJMP2		JSR	CHRIN	;Request a keystroke from terminal
000528r 1  C9 1B        					CMP	#$1B	;Check for end text entry
00052Ar 1  F0 3C        					BEQ	EDITDUN	;Branch and close out if yes
00052Cr 1  C9 0D        					CMP	#$0D	;Else, check for Return key
00052Er 1  D0 12        					BNE	ENOTRET	;Branch if not
000530r 1  92 C0        					STA	(INDEXL)	;Save CR to current Index pointer
000532r 1  20 rr rr     					JSR	INCINDEX	;Increment edit memory address pointer
000535r 1  A9 0A        					LDA	#$0A	;Get a LF character
000537r 1  92 C0        					STA	(INDEXL)	;Store it in memory
000539r 1  20 rr rr     					JSR	INCINDEX	;Increment edit memory address pointer
00053Cr 1  A5 C0        					LDA	INDEXL	;Get Start of next line
00053Er 1  A4 C1        					LDY	INDEXH	;and the high byte
000540r 1  80 DC        					BRA	EDJMP1	;Loop back to continue
000542r 1  C9 08        ENOTRET		CMP	#$08	;Check for backspace character
000544r 1  F0 0A        					BEQ	EDBKSPC	;Branch if yes
000546r 1  92 C0        					STA	(INDEXL)	;Else, save to current Index pointer
000548r 1  20 rr rr     					JSR	CHROUT	;Send keystroke to terminal
00054Br 1  20 rr rr     					JSR	INCINDEX	;Increment edit memory address pointer
00054Er 1  80 D5        					BRA	EDJMP2	;Loop back to EDJMP2
000550r 1               ;Handle Backspace, don't allow past starting address
000550r 1  A5 C0        EDBKSPC		LDA	INDEXL	;Get current index low byte
000552r 1  C5 C4        					CMP	TEMP2L	;Compare to initial start address
000554r 1  D0 06        					BNE	EDDOBKS	;if not equal, perform backspace
000556r 1  A5 C1        					LDA	INDEXH	;Get current index high byte
000558r 1  C5 C5        					CMP	TEMP2H	;Compare to initial start address
00055Ar 1  F0 C9        					BEQ	EDJMP2	;If same, branch to input loop
00055Cr 1  20 rr rr     EDDOBKS		JSR	BSOUT	;Send backspace to terminal
00055Fr 1  20 rr rr     					JSR	DECINDEX	;Decrement edit memory address pointer
000562r 1  A9 00        					LDA	#$00	;Get a null character
000564r 1  92 C0        					STA	(INDEXL)	;Store in place of character
000566r 1  80 BD        					BRA	EDJMP2	;LOOP back to EDJMP2
000568r 1  20 rr rr     EDITDUN		JSR	CR2	;Send 2 CR,LF to terminal
00056Br 1  4C rr rr     					JMP	PRINDEX	;Print INDEX value
00056Er 1               ;
00056Er 1               ;[CTRL-B] Start Enhanced Basic:
00056Er 1  A9 2F        EHBASIC		LDA	#$2F	;Get EhBasic intro Msg
000570r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000573r 1               ;
000573r 1  20 rr rr     EHB_TRY2	JSR	RDCHAR	;Get character (LC2UC)
000576r 1  C9 43        					CMP	#'C'	;Check for Cold start
000578r 1  F0 09        					BEQ	EHB_COLD	;If yes, go Cold Start
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00057Ar 1  C9 57        					CMP	#'W'	;Check for Warm start
00057Cr 1  F0 08        					BEQ	EHB_WARM	;If yes. go Warm start
00057Er 1  20 rr rr     					JSR	BEEP	;Else, beep for entry error
000581r 1  80 F0        					BRA	EHB_TRY2	;Branch back and try again
000583r 1               ;
000583r 1  4C 00 B0     EHB_COLD	JMP	$B000	;Cold start ROM vector
000586r 1               ;
000586r 1  4C 00 00     EHB_WARM	JMP	$0000	;Warm start soft vector
000589r 1               ;
000589r 1               ;[CTRL-D]	Disassembler
000589r 1  A9 2B        DSSMBLR		LDA	#$2B	;Intro Message
00058Br 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00058Er 1  A9 03        					LDA	#$03	;Msg 03 -" addr:"
000590r 1  20 rr rr     					JSR	HEX4	;Print msg and get address
000593r 1  20 rr rr     					JSR	CROUT	;Send CR,LF to terminal
000596r 1  A2 16        RPT_LST		LDX	#$16	;Set list count to 22
000598r 1  DA           DIS_LOOP	PHX	;Push count to stack
000599r 1  20 rr rr     					JSR	DIS_LINE	;Disassemble 1 instruction
00059Cr 1  FA           					PLX	;Pull count from stack
00059Dr 1  CA           					DEX	;Decrement count
00059Er 1  D0 F8        					BNE	DIS_LOOP	;Loop back till list count is zero
0005A0r 1  20 rr rr     LST_LOOP	JSR	CHRIN	;Get input from terminal
0005A3r 1  C9 0D        					CMP	#$0D	;Check for Return key
0005A5r 1  F0 32        					BEQ	EXT_LIST	;Exit if Return
0005A7r 1  C9 20        					CMP	#$20	;Check for Space
0005A9r 1  D0 EB        					BNE	RPT_LST	;If not, go back and list another page
0005ABr 1  20 rr rr     					JSR	DIS_LINE	;Else, Disassemble one line
0005AEr 1  80 F0        					BRA	LST_LOOP	;Branch back and continue
0005B0r 1               ;
0005B0r 1               ;DISASSEMBLE LINE: disassemble 1 instruction from working address
0005B0r 1  20 rr rr     DIS_LINE	JSR	PRINDEX	;Print working address
0005B3r 1  20 rr rr     					JSR	SPC2	;Send 2 spaces to terminal
0005B6r 1  B2 C0        					LDA	(INDEXL)	;Read opcode from working memory pointer
0005B8r 1  85 D6        					STA	OPCODE	;Save opcode
0005BAr 1  20 rr rr     					JSR	PRB_SPC2	;Print byte, 2 spaces
0005BDr 1  4A           					LSR	A	;Divide by 2 / shift low order bit into carry flag
0005BEr 1  AA           					TAX	;Xfer Opcode /2 to X reg
0005BFr 1  BD rr rr     					LDA	HDLR_IDX,X	;Get Pointer to handler table
0005C2r 1  B0 04        					BCS	USE_RGHT	;If carry set use low nibble (odd)
0005C4r 1  4A           					LSR	A	;Else shift upper nibble to lower nibble (even)
0005C5r 1  4A           					LSR	A
0005C6r 1  4A           					LSR	A
0005C7r 1  4A           					LSR	A
0005C8r 1  29 0F        USE_RGHT	AND	#$0F	;Mask off high nibble
0005CAr 1  0A           					ASL	A	;Multiply by 2 for index
0005CBr 1  AA           					TAX	;Use handler pointer to index handler table
0005CCr 1  20 rr rr     					JSR	DODISL	;Call disassembler handler
0005CFr 1  20 rr rr     					JSR	CROUT	;Send CR,LF to terminal
0005D2r 1  64 D3        					STZ	TEMP2	;Clear all flag bits
0005D4r 1               ;
0005D4r 1               ;INCNDX routine: increment working address pointer then read it
0005D4r 1  20 rr rr     INCNDX		JSR	INCINDEX	;Increment working address pointer
0005D7r 1  B2 C0        					LDA	(INDEXL)	;Read from working memory address
0005D9r 1  60           EXT_LIST	RTS	;Done, return to caller/exit
0005DAr 1               ;
0005DAr 1  7C rr rr     DODISL		JMP	(HDLR_TAB,X)	;Execute address mode handler
0005DDr 1               ;
0005DDr 1               ;THREE BYTE routine: display operand bytes then mnemonic for three-byte instruction
0005DDr 1               ;TWO BYTE routine: display operand byte then mnemonic for two-byte instruction
0005DDr 1  F7 D3        TRI_BYTE	SMB7	TEMP2	;Set Flag bit for 3-byte instruction
0005DFr 1  20 rr rr     TWO_BYTE	JSR	GET_NEXT	;Read, display operand byte
0005E2r 1  85 D8        					STA	CRCLO	;Save operand byte in CRCLO
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0005E4r 1  7F D3 0A     					BBR7	TEMP2,TWO_BYTSPC	;Branch for 2-byte is clear
0005E7r 1  20 rr rr     					JSR	GET_NEXT	;Read, display operand high byte
0005EAr 1  85 D7        					STA	CRCHI	;Save operand high byte in CRCHI
0005ECr 1  80 06        					BRA	THREE_BYTSPC	;Send 2 spaces, send Mnemonic, return
0005EEr 1               ;
0005EEr 1               ;IMPLIED disassembler handler: single byte instructions: implied mode
0005EEr 1               ;(note: ACC_MODE handler calls this)
0005EEr 1  20 rr rr     IMPLIED		JSR	SPC4	;Send 4 spaces
0005F1r 1  20 rr rr     TWO_BYTSPC		JSR	SPC4	;Send 4 spaces
0005F4r 1  20 rr rr     THREE_BYTSPC		JSR	SPC2	;Send 2 spaces
0005F7r 1               ;
0005F7r 1               ;PRT_MNEM subroutine: send 3 character mnemonic to terminal
0005F7r 1               ; Mnemonic indexed by opcode byte. Sends "???" if byte is not a valid opcode
0005F7r 1  A4 D6        PRT_MNEM	LDY	OPCODE	;Get current Opcode as index
0005F9r 1  BE rr rr     					LDX	MNE_PTAB,Y	;Get opcode pointer from table
0005FCr 1  BD rr rr     					LDA	DIS_NMEM,X	;Get left byte
0005FFr 1  85 DA        					STA	PTRL	;Store it to pointer
000601r 1  BD rr rr     					LDA	DIS_NMEM+1,X	;Get right byte
000604r 1  85 DB        					STA	PTRH	;Store it to pointer
000606r 1  A2 03        					LDX	#$03	;Set count for 3 characters
000608r 1  A9 00        NEXT_NME	LDA	#$00	;Zero A reg
00060Ar 1  A0 05        					LDY	#$05	;Set count for 5 bits per character
00060Cr 1  06 DB        LOOP_NME	ASL	PTRH	;Shift right byte into carry
00060Er 1  26 DA        					ROL	PTRL	;Rotate left byte byte into A reg
000610r 1  2A           					ROL	A	;Rotate into A reg
000611r 1  88           					DEY	;Decrement bit count
000612r 1  D0 F8        					BNE	LOOP_NME	;Loop back till 5 bits in A reg
000614r 1  69 3F        					ADC	#$3F	;Add $3F to convert to Ascii
000616r 1  20 rr rr     					JSR	CHROUT	;Send the character to terminal
000619r 1  CA           					DEX	;Decrement character count
00061Ar 1  D0 EC        					BNE	NEXT_NME	;Loop back till 3 characters sent
00061Cr 1  80 06        					BRA	BR_SPC2	;Send 2 spaces to terminal, return
00061Er 1               ;
00061Er 1               ;GET_NEXT subroutine: increment/read working address
00061Er 1               ; Display byte, send 2 spaces to terminal (displays operand byte(s))
00061Er 1  20 rr rr     GET_NEXT	JSR	INCNDX	;Increment working index
000621r 1  20 rr rr     PRB_SPC2	JSR	PRBYTE	;Display Byte from working index
000624r 1  4C rr rr     BR_SPC2		JMP	SPC2	;Send 2 spaces to terminal and return
000627r 1               ;
000627r 1               ;Disassembler handlers:
000627r 1               ;
000627r 1               ;LF_BRKT subroutine: send "(" to terminal
000627r 1  A9 28        LF_BRKT		LDA	#$28	;Get "("
000629r 1  80 0F        					BRA	BR_COUT	;Send to terminal and return
00062Br 1               ;
00062Br 1               ;ZP_IMMEDIATE: two byte instructions: zero-page immediate mode
00062Br 1  20 rr rr     ZP_IMED		JSR	TWO_BYTE	;Display operand byte, then mnemonic
00062Er 1  A9 23        					LDA	#$23	;Get "#" character
000630r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
000633r 1  80 1B        					BRA	PRT1_OP	;Display operand byte again, return
000635r 1               ;
000635r 1               ;ACC_MODE: single byte A reg mode instructions: implied mode
000635r 1  20 rr rr     ACC_MODE	JSR	IMPLIED	;Send 10 spaces to terminal then display mnemonic
000638r 1  A9 41        					LDA	#$41	;Get "A" character
00063Ar 1  4C rr rr     BR_COUT		JMP	CHROUT	;Send it and return
00063Dr 1               ;
00063Dr 1               ;ABSOLUTE: three byte instructions: absolute mode
00063Dr 1  20 rr rr     ABSOLUTE	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
000640r 1               ;
000640r 1               ;Print 2 Operands: display operand bytes of a three-byte instruction
000640r 1  20 rr rr     PRT2_OP		JSR	DOLLAR	;Send "$" to terminal
000643r 1  A5 D7        					LDA	CRCHI	;Load operand high byte
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000645r 1  20 rr rr     					JSR	PRBYTE	;Send to terminal
000648r 1  A5 D8        BR_PRBTE	LDA	CRCLO	;Load operand low byte
00064Ar 1  4C rr rr     					JMP	PRBYTE	;Send to terminal and return
00064Dr 1               ;
00064Dr 1               ;ZP_ABS: two byte instructions: zero-page absolute
00064Dr 1  20 rr rr     ZP_ABS		JSR	TWO_BYTE	;Display operand byte, then mnemonic
000650r 1               ;
000650r 1               ;Print 1 Operand byte: display operand byte of a two-byte instruction
000650r 1  20 rr rr     PRT1_OP		JSR	DOLLAR	;Send "$" to terminal
000653r 1  80 F3        					BRA	BR_PRBTE	;Branch to complete
000655r 1               ;
000655r 1               ;INDIRECT: two or three byte instructions: indirect modes
000655r 1  A5 D6        INDIRECT	LDA	OPCODE	;Read saved opcode byte
000657r 1  C9 6C        					CMP	#$6C	;Check for JMP(INDIRECT)
000659r 1  D0 13        					BNE	ZP_IND	;Branch if not
00065Br 1               ;
00065Br 1  20 rr rr     					JSR	TRI_BYTE	;Display operand bytes, then mnemonic
00065Er 1  20 rr rr     					JSR	LF_BRKT	;Send "(" to terminal
000661r 1  20 rr rr     					JSR	PRT2_OP	;Display operand bytes again
000664r 1  80 0B        					BRA	RT_BRKT	;Send ")" to terminal, return
000666r 1               ;
000666r 1               ;Following group is used multiple times, space savings
000666r 1  20 rr rr     DSPLY3		JSR	TWO_BYTE	;Display operand byte, then mnemonic
000669r 1  20 rr rr     					JSR	LF_BRKT	;Send "(" to terminal
00066Cr 1  80 E2        					BRA	PRT1_OP	;Display operand byte again, return
00066Er 1               ;
00066Er 1               ;this is for a two byte instruction: zero page indirect mode
00066Er 1  20 rr rr     ZP_IND		JSR	DSPLY3	;Do the 3 routines
000671r 1               ;
000671r 1               ;RT_BRKT subroutine: send ")" to terminal
000671r 1  A9 29        RT_BRKT		LDA	#$29	;Get ")"
000673r 1  80 C5        					BRA	BR_COUT	;Send to terminal and return
000675r 1               ;
000675r 1               ;ZP_ABS_X: two byte instructions: zero-page absolute indexed by X mode
000675r 1  20 rr rr     ZP_ABS_X	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
000678r 1               ;
000678r 1               ;Print Comma,X: send ",X" to terminal
000678r 1  A9 2C        COM_X			LDA	#$2C	;Get ","
00067Ar 1  20 rr rr     					JSR	CHROUT	;Send to terminal
00067Dr 1  A9 58        					LDA	#$58	;Get "X"
00067Fr 1  80 B9        					BRA	BR_COUT	;Send to terminal, return
000681r 1               ;
000681r 1               ;ZP_ABS_Y: two byte instructions: zero-page absolute indexed by Y mode
000681r 1  20 rr rr     ZP_ABS_Y	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
000684r 1               ;
000684r 1               ;Print Comma,Y: send ",Y" to terminal
000684r 1  A9 2C        COM_Y			LDA	#$2C	;Get ","
000686r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
000689r 1  A9 59        					LDA	#$59	;Get "Y"
00068Br 1  80 AD        					BRA	BR_COUT	;Send to terminal, return
00068Dr 1               ;
00068Dr 1               ;ABS_Y: three byte instructions: absolute indexed by Y mode
00068Dr 1               ;ABS_X: three byte instructions: absolute indexed by X mode
00068Dr 1  E7 D3        ABS_Y			SMB6	TEMP2
00068Fr 1  20 rr rr     ABS_X			JSR	TRI_BYTE	;Display operand bytes, then mnemonic
000692r 1  20 rr rr     					JSR	PRT2_OP	;Display operand bytes again
000695r 1  EF D3 EC     					BBS6	TEMP2,COM_Y
000698r 1  80 DE        					BRA	COM_X	;Send ",X" to terminal, return
00069Ar 1               ;
00069Ar 1               ;ZP_IND_X: two byte instructions: zero-page indirect pre-indexed by X mode
00069Ar 1  20 rr rr     ZP_IND_X	JSR	DSPLY3	;Do the 3 routines
00069Dr 1  20 rr rr     					JSR	COM_X	;Send ",X" to terminal
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0006A0r 1  80 CF        					BRA	RT_BRKT	;Send ")" to terminal, return
0006A2r 1               ;
0006A2r 1               ;ZP_IND_Y: two byte instructions: zero-page indirect post-indexed by Y mode
0006A2r 1  20 rr rr     ZP_IND_Y	JSR	DSPLY3	;Do the 3 routines
0006A5r 1  20 rr rr     					JSR	RT_BRKT	;Send ")" to terminal
0006A8r 1  80 DA        					BRA	COM_Y	;Send ",Y" to terminal, return
0006AAr 1               ;
0006AAr 1               ;IND_ABS_X: three byte instruction: JMP (INDIRECT,X) 16 bit indirect
0006AAr 1  20 rr rr     IND_ABS_X	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
0006ADr 1  20 rr rr     					JSR	LF_BRKT	;Send "(" to terminal
0006B0r 1  20 rr rr     					JSR	PRT2_OP	;Display operand bytes again
0006B3r 1  20 rr rr     					JSR	COM_X	;Send ",X" to terminal
0006B6r 1  80 B9        					BRA	RT_BRKT	;Send ")" to terminal then done INDABSX handler, RETURN
0006B8r 1               ;
0006B8r 1               ;ZP_XMB: two byte instructions: zero page set/clear memory bit
0006B8r 1  20 rr rr     ZP_XMB		JSR	SRMB	;Display operand byte, mnemonic, isolate bit selector from opcode
0006BBr 1  C9 08        					CMP	#$08	;Check if 0-7 or 8-F
0006BDr 1  90 02        					BCC	SRBIT	;Just add $30 (0-7)
0006BFr 1  E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
0006C1r 1  18           SRBIT			CLC	;Convert bit selector value to an ASCII decimal digit
0006C2r 1  69 30        					ADC	#$30	;add "0" to bit selector value
0006C4r 1  20 rr rr     					JSR	CHROUT	;Send digit to terminal
0006C7r 1  20 rr rr     					JSR	SPC	;Send a space to terminal
0006CAr 1  80 84        					BRA	PRT1_OP	;Display operand byte again then return
0006CCr 1               ;
0006CCr 1               ;ZP_BBX: three byte instruction: branch on zero-page bit set/clear
0006CCr 1  20 rr rr     ZP_BBX		JSR	SRMB2	;Display operand bytes, mnemonic, isolate bit selector from opcode
0006CFr 1  C9 08        					CMP	#$08	;Check if $0-$7 or $8-$F
0006D1r 1  90 02        					BCC	SRBIT2	;Just add $30 ($0-$7)
0006D3r 1  E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
0006D5r 1  20 rr rr     SRBIT2		JSR	SRBIT	;Convert and display bit selector digit
0006D8r 1  A5 D7        					LDA	CRCHI	;Move second operand to first operand position:
0006DAr 1  85 D8        					STA	CRCLO	;CRCLO = branch offset
0006DCr 1  20 rr rr     					JSR	SPC	;Send a space to terminal
0006DFr 1  80 03        					BRA	BBX_REL	;Display branch target address then return
0006E1r 1               ;
0006E1r 1               ;RELATIVE BRANCH: two byte relative branch mode
0006E1r 1               ;BBX_REL: three byte relative branch mode
0006E1r 1               ;both calculate then display relative branch target address
0006E1r 1  20 rr rr     REL_BRA		JSR	TWO_BYTE	;Display operand byte, then mnemonic
0006E4r 1  20 rr rr     BBX_REL		JSR	DOLLAR	;Send "$" to terminal
0006E7r 1  20 rr rr     					JSR	INCINDEX	;Increment working address, ref for branch offset
0006EAr 1  A5 D8        					LDA	CRCLO	;Get branch operand value
0006ECr 1  30 0A        					BMI	BRA_MINUS	;Check for $80 or higher (if branch is + or -)
0006EEr 1  18           					CLC	;Clear carry for add
0006EFr 1  65 C0        					ADC	INDEXL	;Add to Index lo
0006F1r 1  A8           					TAY	;Xfer to Y reg
0006F2r 1  A5 C1        					LDA	INDEXH	;Get Index Hi
0006F4r 1  69 00        					ADC	#$00	;Add result from Carry flag to A reg
0006F6r 1  80 0F        					BRA	REL_EXT	;Print offset, cleanup, return
0006F8r 1  49 FF        BRA_MINUS	EOR	#$FF	;Get 1's complement of offset
0006FAr 1  1A           					INC	A	;Increment by 1
0006FBr 1  85 D4        					STA  TEMP3	;Save result
0006FDr 1  38           					SEC	;Set carry for subtract
0006FEr 1  A5 C0        					LDA	INDEXL	;Get address low
000700r 1  E5 D4        					SBC	TEMP3	;Subtract branch offset
000702r 1  A8           					TAY	;Xfer to Y reg
000703r 1  A5 C1        					LDA	INDEXH	;Get address high
000705r 1  E9 00        					SBC	#$00	;Subtract carry flag
000707r 1  20 rr rr     REL_EXT		JSR	PRWORD	;Send address to terminal
00070Ar 1  4C rr rr     					JMP	DECINDEX	;Decrement working address, return
00070Dr 1               ;
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00070Dr 1               ;SRMB2 subroutine: display 2 operand bytes, mnemonic, isolate bit selector from opcode
00070Dr 1               ;SRMB subroutine: display 1 operand byte, mnemonic, isolate bit selector from opcode
00070Dr 1  B2 C0        SRMB2			LDA	(INDEXL)	;Read from working index
00070Fr 1  48           					PHA	;Save byte to stack
000710r 1  20 rr rr     					JSR	TRI_BYTE	;Display operand bytes and mnemonic
000713r 1  80 06        					BRA	SRM	;Skip down
000715r 1  B2 C0        SRMB			LDA	(INDEXL)	;Read from working index
000717r 1  48           					PHA	;Save byte on STACK
000718r 1  20 rr rr     					JSR	TWO_BYTE	;Display operand byte and mnemonic
00071Br 1  20 rr rr     SRM				JSR	BSOUT2T	;Send 2 Backspaces
00071Er 1  68           					PLA	;Restore byte from stack
00071Fr 1  4A           					LSR	A	;Shift high nibble to low nibble
000720r 1  4A           					LSR	A
000721r 1  4A           					LSR	A
000722r 1  4A           					LSR	A
000723r 1  60           NOCHAR		RTS	;Done SRMB2/SRMB, return
000724r 1               ;
000724r 1               ;END OF DISASSEMBLER CODE
000724r 1               ;
000724r 1               ;[CNTRL-V] Version command:
000724r 1  A9 15        VER				LDA	#$15	;Get Intro substring (version)
000726r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000729r 1  A0 rr        					LDY	#>BIOS_MSG	;Get high offset
00072Br 1  A9 rr        					LDA	#<BIOS_MSG	;Get low offset
00072Dr 1  84 C7        PROMPTR		STY	PROMPTH	;Store hi byte
00072Fr 1  85 C6        					STA	PROMPTL	;Store lo byte
000731r 1  80 0E        					BRA	PROMPT2	;Print message
000733r 1               ;
000733r 1               ;[CNTRL-Q] Query command:
000733r 1  A9 2C        QUERY			LDA	#$2C	;Get Query msg #
000735r 1               ;
000735r 1               ;PROMPT routine: Send indexed text string to terminal. Index is A reg
000735r 1               ;string buffer address is stored in variable PROMPTL, PROMPTH
000735r 1               ;Routine is placed here in the Commands area to save ROM space
000735r 1  0A           PROMPT		ASL	A	;Multiply by two for msg table index
000736r 1  A8           					TAY	;Xfer to index
000737r 1  B9 rr rr     					LDA	MSG_TABLE,Y	;Get low byte address
00073Ar 1  85 C6        					STA	PROMPTL	;Store in Buffer pointer
00073Cr 1  B9 rr rr     					LDA	MSG_TABLE+1,Y	;Get high byte address
00073Fr 1  85 C7        					STA	PROMPTH	;Store in Buffer pointer
000741r 1               ;
000741r 1  B2 C6        PROMPT2		LDA	(PROMPTL)	;Get string data
000743r 1  F0 DE        					BEQ	NOCHAR	;If null character, exit (borrowed RTS)
000745r 1  20 rr rr     					JSR	CHROUT	;Send character to terminal
000748r 1  E6 C6        					INC	PROMPTL	;Increment low byte index
00074Ar 1  D0 F5        					BNE	PROMPT2	;Loop back for next character
00074Cr 1  E6 C7        					INC	PROMPTH	;Increment high byte index
00074Er 1  80 F1        					BRA	PROMPT2	;Loop back and continue printing
000750r 1               ;
000750r 1               ;[CNTL-T] UPTIME command: Sends a string to the terminal showing the uptime
000750r 1               ; of the system since the last system reset. This routine uses the RTC values
000750r 1               ; for Days, Hours, Minutes and seconds. It converts each to BCD and outputs
000750r 1               ; to the terminal with text fields. The routine does not calculate months/years
000750r 1               ;
000750r 1  A9 1A        UPTIME		LDA	#$1A	;Get Uptime message
000752r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000755r 1               ;
000755r 1  A2 1B        					LDX	#$1B	;Get Days message
000757r 1  A5 F2        					LDA	DAYSL	;Get Days low byte
000759r 1  A4 F3        					LDY	DAYSH	;Get Days high byte
00075Br 1  20 rr rr     					JSR	DO16TIME	;Convert and send to terminal
00075Er 1               ;
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00075Er 1  A2 1C        					LDX	#$1C	;Get Hours message
000760r 1  A5 F1        					LDA	HOURS	;Get Current Hours (low byte)
000762r 1  20 rr rr     					JSR	DO8TIME	;Convert and send to terminal
000765r 1               ;
000765r 1  A2 1D        					LDX	#$1D	;Get Minutes message
000767r 1  A5 F0        					LDA	MINS	;Get Current Minutes (low byte)
000769r 1  20 rr rr     					JSR	DO8TIME	;Convert and send to terminal
00076Cr 1               ;
00076Cr 1  A2 1E        					LDX	#$1E	;Get seconds message
00076Er 1  A5 EF        					LDA	SECS	;Get Current Seconds (low byte)
000770r 1               ;
000770r 1  A0 00        DO8TIME		LDY	#$00	;Zero high byte
000772r 1  DA           DO16TIME	PHX	;Push message number to stack
000773r 1  20 rr rr     					JSR	HEX2ASC	;Convert and print ASCII string
000776r 1  68           					PLA	;Pull message number from stack
000777r 1  80 BC        					BRA	PROMPT	;Branch to Prompt
000779r 1               ;
000779r 1               ;[CNTRL-L] Xmodem/CRC Loader command: receives a file from console via Xmodem protocol
000779r 1               ; no cable swapping needed, uses existing console port and buffer via the terminal program
000779r 1               ; not a full blown Xmodem/CRC implementation, only does CRC-16 checking, no fallback
000779r 1               ; designed specifically for direct attach to host machine via com port
000779r 1               ; can handle full 8-bit binary transfers without error
000779r 1               ; tested with ExtraPutty and TeraTerm (Note: TeraTerm doesn't respond to CAN properly)
000779r 1               ;
000779r 1               ; Added support for Motorola S-Record formatted files automatically
000779r 1               ; A parameter input is used as either a Load address for any non-S-record file
000779r 1               ; If the received file has a valid S-Record format, the parameter is used as a
000779r 1               ; positive address Offset applied to the specified load address in the S-record file
000779r 1               ; supported format is S19 as created by the WDC Tools linker.
000779r 1               ; Note: this code supports the execution address in the final S9 record, but WDC Tools
000779r 1               ; does not provide any ability to put this into their code build. WDC are aware of this
000779r 1               ;
000779r 1  F7 D5        XMODEM		SMB7	CMDFLAG	;Set Command flag
00077Br 1  64 FE        					STZ	XMFLAG	;Clear Xmodem flag
00077Dr 1  A9 01        					LDA	#$01	;Set block count to one
00077Fr 1  85 DC        					STA	BLKNO	;Save it for starting block #
000781r 1  A9 27        					LDA	#$27	;Get Xmodem intro msg
000783r 1  20 rr rr     					JSR	HEX4	;Print Msg, get Hex load address/S-record Offset
000786r 1  20 rr rr     					JSR	CROUT	;Send a C/R to show input entered
000789r 1  E0 00        					CPX	#$00	;Check for input entered (if non-zero, use new data)
00078Br 1  D0 03        					BNE	XLINE	;Branch if data entered
00078Dr 1  8A           					TXA	;Xfer to A reg (LDA #$00)
00078Er 1  A0 08        					LDY	#$08	;Set High byte ($0800)
000790r 1  85 DA        XLINE			STA	PTRL	;Store to Lo pointer
000792r 1  84 DB        					STY	PTRH	;Store to Hi pointer
000794r 1               ;Wait for 5 seconds for user to setup xfer from terminal
000794r 1  A9 02        					LDA	#$02	;Load milliseconds = 2 ms
000796r 1  A2 0A        					LDX	#$0A	;Load High multipler to 10 decimal
000798r 1  A0 FA        					LDY	#$FA	;Load Low multipler to 250 decimal
00079Ar 1  20 rr rr     					JSR	SET_DLY	;Set Delay parameters
00079Dr 1  20 rr rr     					JSR	EXE_LGDLY	;Call long delay for 5 seconds
0007A0r 1               ;
0007A0r 1  A9 43        STRT_XFER	LDA	#'C'	;Send "C" character for CRC mode
0007A2r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
0007A5r 1  20 rr rr     CHR_DLY		JSR	EXE_MSDLY	;Delay 2 milliseconds
0007A8r 1  A5 E7        					LDA	ICNT	;Check input buffer count
0007AAr 1  D0 38        					BNE	STRT_BLK	;If a character is in, branch
0007ACr 1  88           					DEY	;Decrement loop count (250 1st time only)
0007ADr 1  D0 F6        					BNE	CHR_DLY	;Branch and check again 250/256 times
0007AFr 1  80 EF        					BRA	STRT_XFER	;Else, branch and send another "C"
0007B1r 1               ;
0007B1r 1  A9 06        XDONE			LDA	#ACK	;Last block, get ACK character
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0007B3r 1  20 rr rr     					JSR	CHROUT	;Send final ACK
0007B6r 1  A0 02        					LDY	#$02	;Get delay count
0007B8r 1  A9 28        					LDA	#$28	;Get Good xfer message number
0007BAr 1  20 rr rr     FLSH_DLY	JSR NOLOOPS	;Zero input buffer pointers
0007BDr 1  48           					PHA	;Save Message number
0007BEr 1  A9 FA        					LDA	#$FA	;Load milliseconds = 250 ms
0007C0r 1  A2 00        					LDX	#$00	;Load High multipler to 0 decimal
0007C2r 1  20 rr rr     					JSR	SET_DLY	;Set Delay parameters
0007C5r 1  20 rr rr     					JSR	EXE_LGDLY	;Execute delay, (wait to get terminal back)
0007C8r 1  68           					PLA	;Get message number back
0007C9r 1  C9 29        					CMP	#$29	;Check for error msg#
0007CBr 1  F0 14        					BEQ	SHRT_EXIT	;Do only one message
0007CDr 1  48           					PHA	;Save MSG number
0007CEr 1  7F FE 0F     					BBR7	XMFLAG,END_LOAD	;Branch if no S-record
0007D1r 1  A9 2A        					LDA	#$2A	;Get S-Record load address msg
0007D3r 1  20 rr rr     					JSR	PROMPT	;Printer header msg
0007D6r 1  A5 C9        					LDA	SRCH	;Get source high byte
0007D8r 1  A4 C8        					LDY	SRCL	;Get source low byte
0007DAr 1  20 rr rr     					JSR	PRWORD	;Print Hex address
0007DDr 1  20 rr rr     					JSR	CROUT	;Print C/R and return
0007E0r 1  68           END_LOAD	PLA	;Get Message number
0007E1r 1  4C rr rr     SHRT_EXIT	JMP	PROMPT	;Print Message and exit
0007E4r 1               ;
0007E4r 1  20 rr rr     STRT_BLK	JSR	CHRIN	;Get a character
0007E7r 1  C9 1B        					CMP	#$1B	;Is it escape - quit?
0007E9r 1  F0 0A        					BEQ	XM_END	;If yes, exit
0007EBr 1  C9 01        					CMP	#SOH	;Start of header?
0007EDr 1  F0 07        					BEQ	GET_BLK	;If yes, branch and receive block
0007EFr 1  C9 04        					CMP	#EOT	;End of Transmission?
0007F1r 1  F0 BE        					BEQ	XDONE	;If yes, branch and exit
0007F3r 1  80 63        					BRA	STRT_ERR	;Else branch to error
0007F5r 1  60           XM_END		RTS	;Cancelled by user, return
0007F6r 1               ;
0007F6r 1  E7 FE        GET_BLK		SMB6	XMFLAG	;Set bit 6 for Xmodem xfer
0007F8r 1  A2 00        					LDX	#$00	;Zero index for block receive
0007FAr 1               ;
0007FAr 1  20 rr rr     GET_BLK1	JSR	CHRIN	;Get a character
0007FDr 1  9D 7C 04     					STA	RBUFF,X	;Move into buffer
000800r 1  E8           					INX	;Increment buffer index
000801r 1  E0 84        					CPX	#$84	;Compare size (<01><FE><128 bytes><CRCH><CRCL>)
000803r 1  D0 F5        					BNE	GET_BLK1	;If not done, loop back and continue
000805r 1  67 FE        					RMB6	XMFLAG	;Reset Xmodem xfer bit (allows break)
000807r 1               ;
000807r 1  AD 7C 04     					LDA	RBUFF	;Get block number from buffer
00080Ar 1  C5 DC        					CMP	BLKNO	;Compare to expected block number
00080Cr 1  D0 07        					BNE	RESTRT	;If not correct, restart the block
00080Er 1  49 FF        					EOR	#$FF	;one's complement of block number
000810r 1  CD 7D 04     					CMP	RBUFF+1	;Compare with expected one's complement of block number
000813r 1  F0 07        					BEQ	BLK_OKAY	;Branch if compare is good
000815r 1               ;
000815r 1  A9 15        RESTRT		LDA	#NAK	;Get NAK character
000817r 1  20 rr rr     RESTRT2		JSR	CHROUT	;Send to xfer program
00081Ar 1  80 C8        					BRA	STRT_BLK	;Restart block transfer
00081Cr 1               ;
00081Cr 1  A9 0A        BLK_OKAY	LDA	#$0A	;Set retry value to 10
00081Er 1  85 D9        					STA	CRCCNT	;Save it to CRC retry count
000820r 1  64 D8        					STZ	CRCLO	;Reset the CRC value by (3)
000822r 1  64 D7        					STZ	CRCHI	;putting all bits off (3)
000824r 1  A0 00        					LDY #$00	;Set index for data offset (2)
000826r 1  B9 7E 04     CALCCRC		LDA	RBUFF+2,Y	;Get first data byte (4)
000829r 1  08           					PHP	;Save status reg (3)
00082Ar 1  A2 08        					LDX	#$08	;Load index for 8 bits (2)
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00082Cr 1  45 D7        					EOR	CRCHI	;XOR High CRC byte
00082Er 1  06 D8        CRCLOOP		ASL	CRCLO	;Shift carry to CRC low byte (4)
000830r 1  2A           					ROL	A	;Shift bit to carry flag (2)
000831r 1  90 0A        					BCC	CRCLP1	;Branch if MSB is 1 (2/3)
000833r 1  49 10        					EOR	#$10	;Exclusive OR with polynomial (2)
000835r 1  48           					PHA	;Save result on stack (3)
000836r 1  A5 D8        					LDA	CRCLO	;Get CRC low byte (3)
000838r 1  49 21        					EOR	#$21	;Exclusive OR with polynomial (2)
00083Ar 1  85 D8        					STA	CRCLO	;Save it back (3)
00083Cr 1  68           					PLA	;Get previous result (4)
00083Dr 1  CA           CRCLP1		DEX	;Decrement index (2)
00083Er 1  D0 EE        					BNE	CRCLOOP	;Loop back for all 8 bits (2/3)
000840r 1  85 D7        					STA	CRCHI	;Update CRC high byte (3)
000842r 1  28           					PLP ;Restore status reg (4)
000843r 1  C8           					INY	;Increment index to the next data byte (2)
000844r 1  10 E0        					BPL	CALCCRC	;Branch back until all 128 fed to CRC routine (2/3)
000846r 1  B9 7E 04     					LDA	RBUFF+2,Y	;Get received CRC hi byte (4)
000849r 1  C5 D7        					CMP	CRCHI	;Compare against calculated CRC hi byte (3)
00084Br 1  D0 07        					BNE	BADCRC	;If bad CRC, handle error (2/3)
00084Dr 1  B9 7F 04     					LDA	RBUFF+3,Y	;Get CRC lo byte (4)
000850r 1  C5 D8        					CMP	CRCLO	;Compare against calculated CRC lo byte (3)
000852r 1  F0 15        					BEQ	GOODCRC	;If good, go move frame to memory (2/3)
000854r 1               ;
000854r 1               ;CRC was bad... need to retry and receive the last frame again
000854r 1               ;Decrement the CRC retry count, send a NAK and try again
000854r 1               ;Count allows up to 10 retries, then cancels the transfer
000854r 1               ;
000854r 1  C6 D9        BADCRC		DEC	CRCCNT	;Decrement retry count
000856r 1  D0 0C        					BNE	CRCRTRY	;Retry again if count not zero
000858r 1  A9 18        STRT_ERR	LDA	#CAN	;Else get Cancel code
00085Ar 1  20 rr rr     					JSR	CHROUT	;Send it to terminal program
00085Dr 1  A0 08        					LDY	#$08	;Set delay multiplier
00085Fr 1  A9 29        					LDA	#$29	;Get message for receive error
000861r 1  4C rr rr     					JMP	FLSH_DLY	;Do a flush, delay and exit
000864r 1  20 rr rr     CRCRTRY		JSR	NOLOOPS	;Zero Input buffer pointers
000867r 1  80 AC        					BRA	RESTRT	;Send NAK and retry
000869r 1               ;
000869r 1               ;Block has been received, check for S19 record transfer
000869r 1  FF FE 2D     GOODCRC		BBS7	XMFLAG,XFER_S19	;Branch if bit 7 set (active S-record)
00086Cr 1  A5 DC        					LDA	BLKNO	;Else, check current block number
00086Er 1  3A           					DEC	A	;Check for block 1 only (first time thru)
00086Fr 1  F0 16        					BEQ	TEST_S19	;If yes, test for S19 record
000871r 1               ;
000871r 1  A2 00        MOVE_BLK	LDX	#$00	;Zero index offset to data
000873r 1  BD 7E 04     COPYBLK		LDA	RBUFF+2,X	;Get data byte from buffer
000876r 1  92 DA        					STA	(PTRL)	;Store to target address
000878r 1  E6 DA        					INC	PTRL	;Incrememnt low address byte
00087Ar 1  D0 02        					BNE	COPYBLK2	;Check for hi byte loop
00087Cr 1  E6 DB        					INC	PTRH	;Increment hi byte address
00087Er 1  E8           COPYBLK2	INX	;Point to next data byte
00087Fr 1  10 F2        					BPL	COPYBLK	;Loop back until done (128)
000881r 1  E6 DC        INCBLK		INC	BLKNO	;Increment block number
000883r 1  A9 06        					LDA	#ACK	;Get ACK character
000885r 1  80 90        					BRA	RESTRT2	;Send ACK and continue xfer
000887r 1               ;
000887r 1  AD 7E 04     TEST_S19	LDA	RBUFF+2	;Get first character
00088Ar 1  C9 53        					CMP	#'S'	;Check for S character
00088Cr 1  D0 E3        					BNE	MOVE_BLK	;If not equal, no S-record, move block
00088Er 1  AD 7F 04     					LDA	RBUFF+3	;Get second character
000891r 1  C9 31        					CMP	#'1'	;Check for 1 character
000893r 1  D0 DC        					BNE	MOVE_BLK	;If not equal, no S-record, move block
000895r 1  F7 FE        					SMB7	XMFLAG	;Set bit 7 for S-record xfer
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000897r 1  64 D1        					STZ	IDY	;Zero index for SRBUFF
000899r 1               ;
000899r 1               ; S-record transfer routine
000899r 1               ;	Xmodem is a 128 byte data block, S-record is variable, up to 44 byte block
000899r 1               ;	need to move a record at a time to the SRBUFF based on length, check as valid,
000899r 1               ;	then calculate address and transfer to that location
000899r 1               ;	once the Xmodem buffer is empty, loop back to get the next frame
000899r 1               ;	and continue processing S-records until completed
000899r 1               ;
000899r 1               ;At first entry here, pointer IDY is zero
000899r 1               ;At all entries here, a 128 byte block has been received
000899r 1               ;The S-record length needs to be calculated, then the proper count moved
000899r 1               ;to the SRBUFF location and both pointers (IDX/IDY) updated
000899r 1               ;
000899r 1  64 D0        XFER_S19	STZ	IDX	;Zero offset to RBUFF
00089Br 1  A6 D0        S19_LOOP2	LDX	IDX	;Load current offset to RBUFF
00089Dr 1  A4 D1        					LDY	IDY	;Get S-Record offset
00089Fr 1  BD 7E 04     S19_LOOP	LDA	RBUFF+2,X	;Get S-Record data
0008A2r 1  99 50 04     					STA	SRBUFF,Y	;Save it to the S-record buffer
0008A5r 1  E8           					INX	;Increment offset to RBUFF
0008A6r 1  E0 81        					CPX	#$81	;Check for end of RBUFF data
0008A8r 1  F0 0E        					BEQ	NXT_FRAME	;If yes, go back and get another frame
0008AAr 1  C8           					INY	;Increment S-Rec size
0008ABr 1  C0 2C        					CPY	#$2C	;Check for size match
0008ADr 1  D0 F0        					BNE	S19_LOOP	;Branch back until done
0008AFr 1  86 D0        					STX	IDX	;Update running offset to RBUFF
0008B1r 1  64 D1        					STZ	IDY	;Reset SRBUFF index pointer
0008B3r 1  20 rr rr     					JSR	SREC_PROC	;Process the S-Record and store in memory
0008B6r 1  80 E3        					BRA	S19_LOOP2	;Branch back and get another record
0008B8r 1  84 D1        NXT_FRAME	STY	IDY	;Save SRBUFF offset
0008BAr 1  80 C5        INCBLK2		BRA	INCBLK	;Increment block and get next frame
0008BCr 1               ;
0008BCr 1  AD 51 04     SREC_PROC	LDA	SRBUFF+1	;Get the Record type character
0008BFr 1  C9 31        					CMP	#'1'	;Check for S1 record
0008C1r 1  F0 6A        					BEQ	S1_PROC	;Process a S1 record
0008C3r 1  C9 39        					CMP	#'9'	;Check for S9 (final) record
0008C5r 1  F0 55        					BEQ	S9_PROC	;Process a S9 record
0008C7r 1  68           SREC_ERR	PLA	;Else, pull return address
0008C8r 1  68           					PLA	;of two bytes from stack
0008C9r 1  80 8D        					BRA	STRT_ERR	;Branch to Xmodem error/exit routine
0008CBr 1               ;
0008CBr 1  AC 53 04     SR_PROC		LDY	SRBUFF+3	;Get record length LS character
0008CEr 1  AD 52 04     					LDA	SRBUFF+2	;Get record length MS character
0008D1r 1  20 rr rr     					JSR	ASC2BIN	;Convert to single byte for length
0008D4r 1  1A           					INC	A	;Add one to length to include checksum
0008D5r 1  85 D4        					STA	TEMP3	;Save record length
0008D7r 1               ;
0008D7r 1               ; If record length is less, than the difference needs to be subtracted from IDX
0008D7r 1               ; which reflects either the last record (S9) or a S1 record of a lesser length
0008D7r 1               ;
0008D7r 1  38           					SEC	;Set carry for subtract
0008D8r 1  A9 14        					LDA	#20	;Get default count
0008DAr 1  E5 D4        					SBC	TEMP3	;Subtract actual length
0008DCr 1  0A           					ASL	A	;Multiply by two for characters pairs
0008DDr 1  85 D3        					STA	TEMP2	;Save it to temp
0008DFr 1               ;
0008DFr 1  38           					SEC	;Set carry for subtract
0008E0r 1  A5 D0        					LDA	IDX	;Get RBUFF index
0008E2r 1  E5 D3        					SBC	TEMP2	;Subtract difference
0008E4r 1  85 D0        					STA	IDX	;Update IDX
0008E6r 1               ;
0008E6r 1  A2 00        SR_COMP		LDX	#$00	;Zero Index
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0008E8r 1  A0 00        					LDY	#$00	;Zero Index
0008EAr 1  5A           SR_CMPLP	PHY	;Save Y reg index
0008EBr 1  BC 53 04     					LDY	SRBUFF+3,X	;get LS character
0008EEr 1  BD 52 04     					LDA	SRBUFF+2,X	;Get MS character
0008F1r 1  20 rr rr     					JSR	ASC2BIN	;Convert two ASCII characters to HEX byte
0008F4r 1  7A           					PLY	;Restore Y reg index
0008F5r 1  99 50 04     					STA	SRBUFF,Y	;Store in SRBUFF starting at front
0008F8r 1  E8           					INX	;Increment X reg twice
0008F9r 1  E8           					INX	;points to next character pair
0008FAr 1  C8           					INY	;Increment Y reg once for offset to SRBUFF
0008FBr 1  C6 D4        					DEC	TEMP3	;Decrement character count
0008FDr 1  D0 EB        					BNE	SR_CMPLP	;Branch back until done
0008FFr 1               ;
0008FFr 1               ; SRBUFF now has the compressed HEX data, which is:
0008FFr 1               ; 1 byte for length, 2 bytes for the load address,
0008FFr 1               ; up to 16 bytes for data and 1 byte checksum
0008FFr 1               ; Now calculate the checksum and ensure valid S-record content
0008FFr 1               ;
0008FFr 1  64 D8        					STZ	CRCLO	;Zero Checksum location
000901r 1  AE 50 04     					LDX	SRBUFF	;Load index with record length
000904r 1  A0 00        					LDY	#$00	;Zero index
000906r 1  18           SR_CHKSM	CLC	;Clear carry for add
000907r 1  B9 50 04     					LDA	SRBUFF,Y	;Get Srec byte
00090Ar 1  65 D8        					ADC	CRCLO	;Add in checksum Temp
00090Cr 1  85 D8        					STA	CRCLO	;Update checksum Temp
00090Er 1  C8           					INY	;Increment offset
00090Fr 1  CA           					DEX	;Decrement count
000910r 1  D0 F4        					BNE	SR_CHKSM	;Branch back until done
000912r 1               ;
000912r 1  A9 FF        					LDA	#$FF	;Get all bits on
000914r 1  45 D8        					EOR	CRCLO	;Exclusive OR TEMP for one's complement
000916r 1  D9 50 04     					CMP	SRBUFF,Y	;Compare to last byte (which is checksum)
000919r 1  D0 AC        					BNE	SREC_ERR	;If bad, exit out
00091Br 1  60           					RTS	;Return to caller
00091Cr 1               ;
00091Cr 1  20 rr rr     S9_PROC		JSR	SR_PROC	;Process the S-Record and checksum
00091Fr 1  AD 51 04     					LDA	SRBUFF+1	;Get MSB load address
000922r 1  85 BF        					STA	COMHI	;Store to execution pointer
000924r 1  AD 52 04     					LDA	SRBUFF+2	;Get LSB load address
000927r 1  85 BE        					STA	COMLO	;Store to execution pointer
000929r 1  68           					PLA	;Pull return address
00092Ar 1  68           					PLA	;second byte
00092Br 1  80 8D        					BRA	INCBLK2	;Branch back to close out transfer
00092Dr 1               ;
00092Dr 1  20 rr rr     S1_PROC		JSR	SR_PROC	;Process the S-Record and checksum
000930r 1               ;
000930r 1               ; Valid binary S-Record decoded at SRBUFF
000930r 1               ; Calculate offset from input, add to specified load address
000930r 1               ; and store into memory, then loop back until done
000930r 1               ;
000930r 1               ; Offset is stored in PTR L/H from initial input
000930r 1               ; if no input entered, BUFIDX is zero and PTR L/H is preset to $0800
000930r 1               ; so checking for BUFIDX being zero bypasses adding the offset,
000930r 1               ; if BUFIDX is non zero, then PTR L/H contains the offset address
000930r 1               ; which is added to TGT L/H moving the S-record data to memory
000930r 1               ;
000930r 1  AD 51 04     					LDA	SRBUFF+1	;Get MS load address
000933r 1  85 CB        					STA	TGTH	;Store to target pointer
000935r 1  AD 52 04     					LDA	SRBUFF+2	;Get LS load address
000938r 1  85 CA        					STA	TGTL	;Store to target pointer
00093Ar 1  A5 CE        					LDA	BUFIDX	;Check input count for offset required
00093Cr 1  F0 11        					BEQ	NO_OFFSET	;If Zero, no offset was entered
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00093Er 1               ;
00093Er 1               ; Add in offset contained at PTR L/H to TGT L/H
00093Er 1               ;
00093Er 1  18           					CLC	;Clear carry for add
00093Fr 1  A5 DA        					LDA	PTRL	;Get LS offset
000941r 1  65 CA        					ADC	TGTL	;Add to TGTL address
000943r 1  90 02        					BCC	SKIP_HB	;Skip increment HB if no carry
000945r 1  E6 CB        					INC	TGTH	;Else increment TGTH by one
000947r 1  85 CA        SKIP_HB		STA	TGTL	;Save TGTL
000949r 1  A5 DB        					LDA	PTRH	;Get MS offset
00094Br 1  65 CB        					ADC	TGTH	;Add to TGTH
00094Dr 1  85 CB        					STA	TGTH	;Save it
00094Fr 1               ;
00094Fr 1               ; Check for first Block and load SRC H/L with load address
00094Fr 1               ;
00094Fr 1  A5 DC        NO_OFFSET	LDA	BLKNO	;Get Block number
000951r 1  3A           					DEC	A	;Decrement to test for block one
000952r 1  D0 0E        					BNE	NO_OFFST2	;If not first block, skip around
000954r 1  A5 D0        					LDA	IDX	;Get running count for first block
000956r 1  C9 2C        					CMP	#$2C	;First S-record?
000958r 1  D0 08        					BNE	NO_OFFST2	;If yes, setup load address pointer
00095Ar 1  A5 CA        					LDA	TGTL	;Get starting address Lo byte
00095Cr 1  85 C8        					STA	SRCL	;Save it as Source Lo byte
00095Er 1  A5 CB        					LDA	TGTH	;Get starting address Hi byte
000960r 1  85 C9        					STA	SRCH	;Save it as Source Hi byte
000962r 1               ;
000962r 1  AE 50 04     NO_OFFST2	LDX	SRBUFF	;Get record length
000965r 1  CA           					DEX	;Decrement by 3
000966r 1  CA           					DEX	; to only transfer the data
000967r 1  CA           					DEX	; and not the count and load address
000968r 1  A0 00        					LDY	#$00	;Zero index
00096Ar 1  B9 53 04     MVE_SREC	LDA	SRBUFF+3,Y	;Get offset to data in record
00096Dr 1  91 CA        					STA	(TGTL),Y	;Store it to memory
00096Fr 1  C8           					INY	;Increment index
000970r 1  CA           					DEX	;Decrement record count
000971r 1  D0 F7        					BNE	MVE_SREC	;Branch back until done
000973r 1  60           					RTS	;Return to caller
000974r 1               ;
000974r 1               ;[CNTL-R]	Reset System command: Resets system by calling Coldstart routine
000974r 1               ;	Page zero is cleared, vectors and config data re-initialized from ROM
000974r 1               ;	All I/O devices reset from initial ROM parameters, Monitor cold start entered
000974r 1               ;
000974r 1  A9 20        SYS_RST		LDA	#$20	;Get msg "Reset System"
000976r 1  87 D5        					SMB0	CMDFLAG	;Set bit zero
000978r 1  80 02        					BRA	RST_ONLY	;Branch below and handle reset
00097Ar 1               ;
00097Ar 1               ;[CNTL-Z] Zero command: zero RAM from $0100-$7FFF and Reset
00097Ar 1  A9 1F        ZERO			LDA	#$1F	;Get msg "Zero RAM/Reset System"
00097Cr 1  20 rr rr     RST_ONLY	JSR	PROMPT	;Send to terminal
00097Fr 1  20 rr rr     					JSR	CONTINUE	;Prompt for Continue
000982r 1  8F D5 12     					BBS0	CMDFLAG,DO_COLD	;Branch if reset only
000985r 1  78           					SEI	;Disable IRQs
000986r 1  A9 01        					LDA	#$01	;Initialize address pointer to $0100
000988r 1  85 01        					STA	$01	;Store to pointer high byte
00098Ar 1  64 00        					STZ	$00	;Zero address low byte
00098Cr 1  3A           					DEC	A	;LDA #$00
00098Dr 1  92 00        ZEROLOOP	STA	($00)	;Write $00 to current address
00098Fr 1  E6 00        					INC	$00	;Increment address pointer
000991r 1  D0 FA        					BNE	ZEROLOOP
000993r 1  E6 01        					INC	$01
000995r 1  10 F6        					BPL	ZEROLOOP	;LOOP back IF address pointer < $8000
000997r 1  4C rr rr     DO_COLD		JMP	COLDSTRT	;Jump to coldstart vector
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00099Ar 1               ;
00099Ar 1               ;END OF MONITOR CODE
00099Ar 1               ;******************************************************************************
00099Ar 1               ;
00099Ar 1               ;******************************************************************************
00099Ar 1               ;START OF MONITOR DATA
00099Ar 1               ;******************************************************************************
00099Ar 1               ;
00099Ar 1               ;* Monitor command & jump table *
00099Ar 1               ;
00099Ar 1               ;There are two parts to the monitor command and jump table;
00099Ar 1               ; first is the list of commands, which are one byte each. Alpha command characters are upper case
00099Ar 1               ; second is the 16-bit address table that correspond to the command routines for each command character
00099Ar 1               ;
00099Ar 1  02           MONCMD		.BYTE $02 ;[CNTRL-B] Enter EhBasic
00099Br 1  04           					.BYTE	$04	;[CNTRL-D]	Disassembler
00099Cr 1  0C           					.BYTE	$0C	;[CNTRL-L]	Xmodem/CRC Loader
00099Dr 1  10           					.BYTE	$10	;[CNTRL-P]	Program EEPROM
00099Er 1  11           					.BYTE	$11	;[CNTRL-Q]	Query Monitor Commands
00099Fr 1  12           					.BYTE	$12	;[CNTRL-R]	Reset - same as power up
0009A0r 1  14           					.BYTE	$14	;[CNTRL-T]	Uptime display since reset
0009A1r 1  16           					.BYTE	$16	;[CNTRL-V]	Display Monitor Version
0009A2r 1  1A           					.BYTE	$1A	;[CNTRL-Z]	Zero Memory - calls reset
0009A3r 1  28           					.BYTE	$28	;(	Init Macro
0009A4r 1  29           					.BYTE	$29	;)	Run Macro
0009A5r 1  2C           					.BYTE	$2C	;,	Setup Delay parameters
0009A6r 1  2E           					.BYTE	$2E	;.	Execute Millisecond Delay
0009A7r 1  2F           					.BYTE	$2F	;/	Execute Long Delay
0009A8r 1  5C           					.BYTE	$5C	;\	Load and Go Extra Long Delay
0009A9r 1  41           					.BYTE	$41	;A	Display/Edit A register
0009AAr 1  43           					.BYTE	$43	;C	Compare memory block
0009ABr 1  44           					.BYTE	$44	;D	Display Memory contents in HEX/TEXT
0009ACr 1  45           					.BYTE	$45	;E	Examine/Edit memory
0009ADr 1  46           					.BYTE	$46	;F	Fill memory block
0009AEr 1  47           					.BYTE	$47	;G	Go execute to <addr>
0009AFr 1  48           					.BYTE	$48	;H	Hex byte string search
0009B0r 1  49           					.BYTE	$49	;I	Input Text string
0009B1r 1  4D           					.BYTE	$4D	;M	Move memory block
0009B2r 1  50           					.BYTE	$50	;P	Display/Edit CPU status reg
0009B3r 1  52           					.BYTE	$52	;R	Display Registers
0009B4r 1  53           					.BYTE	$53	;S	Display/Edit stack pointer
0009B5r 1  54           					.BYTE	$54	;T	Text character string search
0009B6r 1  58           					.BYTE	$58	;X	Display/Edit X register
0009B7r 1  59           					.BYTE	$59	;Y	Display/Edit Y register
0009B8r 1               ;
0009B8r 1  rr rr        MONTAB		.WORD EHBASIC ;[CNTRL-B] $02 Start EhBasic
0009BAr 1  rr rr        					.WORD	DSSMBLR	;[CNTRL-D] $04	Disassembler
0009BCr 1  rr rr        					.WORD	XMODEM	;[CNTL-L]	$0C	Xmodem download, use send from terminal program
0009BEr 1  rr rr        					.WORD	PROGEE ;[CNTL-P]	$10	Program the EEPROM
0009C0r 1  rr rr        					.WORD	QUERY	;[CNTL-Q]	$11	Query Monitor Commands
0009C2r 1  rr rr        					.WORD	SYS_RST	;[CNTL-R]	$12	Reset CO2Monitor
0009C4r 1  rr rr        					.WORD	UPTIME	;[CNTL-T]	$14	System uptime from Reset - sec/min/hr/days
0009C6r 1  rr rr        					.WORD	VER	;[CNTL-V]	$16	Display Monitor Version level
0009C8r 1  rr rr        					.WORD	ZERO	;[CNTL-Z]	$1A	Zero memory ($0100-$7FFF) then Reset
0009CAr 1  rr rr        					.WORD	INIMACRO	; (	$28	Clear keystroke input buffer, reset buffer pointer
0009CCr 1  rr rr        					.WORD	RUNMACRO	; )	$29	Run keystroke macro from start of keystroke buffer
0009CEr 1  rr rr        					.WORD	SET_DELAY	; .	$2C	Setup Delay Parameters
0009D0r 1  rr rr        					.WORD	EXE_MSDLY	; ,	$2E	Perform Millisecond Delay
0009D2r 1  rr rr        					.WORD	EXE_LGDLY	;	/	$2F Execute Long Delay
0009D4r 1  rr rr        					.WORD	SET_XLDLY	;	\	$5C Load and Go Extra Long Delay
0009D6r 1  rr rr        					.WORD	ARG	; A	$41	Examine/change ACCUMULATOR preset/result
0009D8r 1  rr rr        					.WORD	CPMVFL	; C	$43	Compare command - new
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

0009DAr 1  rr rr        					.WORD	MDUMP	; D	$44	HEX/TEXT dump from specified memory address
0009DCr 1  rr rr        					.WORD	CHANGE	; E	$45	Examine/change a memory location's contents
0009DEr 1  rr rr        					.WORD	CPMVFL	; F	$46	Fill a specified memory range with a specified value
0009E0r 1  rr rr        					.WORD	GO	; G	$47	Begin program code execution at a specified address
0009E2r 1  rr rr        					.WORD	SRCHBYT	; H	$48	Search memory for a specified byte string
0009E4r 1  rr rr        					.WORD	TEXT	; I	$49 Input text string into memory
0009E6r 1  rr rr        					.WORD	CPMVFL	; M	$4D	Copy a specified memory range to a specified target address
0009E8r 1  rr rr        					.WORD	PRG	; P	$50	Examine/change PROCESSOR STATUS REGISTER preset/result
0009EAr 1  rr rr        					.WORD	PRSTAT	; R	$52	Display all preset/result contents
0009ECr 1  rr rr        					.WORD	SRG	; S	$53	Examine/change STACK POINTER preset/result
0009EEr 1  rr rr        					.WORD	SRCHTXT	; T	$54	Search memory for a specified text string
0009F0r 1  rr rr        					.WORD	XRG	; X	$58	Examine/change X-REGISTER preset/result
0009F2r 1  rr rr        					.WORD	YRG	; Y	$59	Examine/change Y-REGISTER preset/result
0009F4r 1               ;
0009F4r 1               ;******************************************************************************
0009F4r 1               ;C02Monitor message strings used with PROMPT routine, terminated with $00
0009F4r 1               ;
0009F4r 1  20 63 6F 6E  MSG_00		.BYTE " cont?"
0009F8r 1  74 3F        
0009FAr 1  28 79 2F 6E  MSG_01		.BYTE	"(y/n)"
0009FEr 1  29           
0009FFr 1  00           					.BYTE $00
000A00r 1  0D 0A        MSG_02		.BYTE $0D,$0A
000A02r 1  20 20 20     					.BYTE	"   "
000A05r 1  20 61 64 64  MSG_03		.BYTE	" addr:"
000A09r 1  72 3A        
000A0Br 1  00           					.BYTE $00
000A0Cr 1  20 6C 65 6E  MSG_04		.BYTE " len:"
000A10r 1  3A           
000A11r 1  00           					.BYTE $00
000A12r 1  20 76 61 6C  MSG_05		.BYTE " val:"
000A16r 1  3A           
000A17r 1  00           					.BYTE $00
000A18r 1  20 73 72 63  MSG_06		.BYTE " src:"
000A1Cr 1  3A           
000A1Dr 1  00           					.BYTE $00
000A1Er 1  20 74 67 74  MSG_07		.BYTE " tgt:"
000A22r 1  3A           
000A23r 1  00           					.BYTE $00
000A24r 1  20 66 69 6E  MSG_08		.BYTE " find txt:"
000A28r 1  64 20 74 78  
000A2Cr 1  74 3A        
000A2Er 1  00           					.BYTE $00
000A2Fr 1  20 66 69 6E  MSG_09		.BYTE " find bin:"
000A33r 1  64 20 62 69  
000A37r 1  6E 3A        
000A39r 1  00           					.BYTE $00
000A3Ar 1  6E 6F 74 20  MSG_0A		.BYTE "not "
000A3Er 1  66 6F 75 6E  MSG_0B		.BYTE "found"
000A42r 1  64           
000A43r 1  00           					.BYTE $00
000A44r 1  0D 0A        MSG_0C		.BYTE $0D,$0A
000A46r 1  73 65 61 72  					.BYTE "search- "
000A4Ar 1  63 68 2D 20  
000A4Er 1  00           					.BYTE $00
000A4Fr 1  0D 0A        MSG_0D		.BYTE $0D,$0A
000A51r 1  28 6E 29 65  					.BYTE "(n)ext? "
000A55r 1  78 74 3F 20  
000A59r 1  00           					.BYTE $00
000A5Ar 1  53 52 3A 24  MSG_0E		.BYTE "SR:$"
000A5Er 1  00           					.BYTE $00
000A5Fr 1  53 50 3A 24  MSG_0F		.BYTE "SP:$"
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000A63r 1  00           					.BYTE $00
000A64r 1  59 52 3A 24  MSG_10		.BYTE "YR:$"
000A68r 1  00           					.BYTE $00
000A69r 1  58 52 3A 24  MSG_11		.BYTE "XR:$"
000A6Dr 1  00           					.BYTE $00
000A6Er 1  41 43 3A 24  MSG_12		.BYTE "AC:$"
000A72r 1  00           					.BYTE $00
000A73r 1  0D 0A        MSG_13		.BYTE	$0D,$0A
000A75r 1  20 20 20 50  					.BYTE "   PC  AC XR YR SP NV-BDIZC",$0D,$0A
000A79r 1  43 20 20 41  
000A7Dr 1  43 20 58 52  
000A92r 1  3B 20        					.BYTE "; "
000A94r 1  00           					.BYTE $00
000A95r 1  0D 0A        MSG_14		.BYTE $0D,$0A
000A97r 1  43 30 32 4D  					.BYTE "C02Monitor (c)2016 K.E.Maier",$07
000A9Br 1  6F 6E 69 74  
000A9Fr 1  6F 72 20 28  
000AB4r 1  0D 0A        MSG_15		.BYTE $0D,$0A
000AB6r 1  56 65 72 73  					.BYTE "Version 1.4"
000ABAr 1  69 6F 6E 20  
000ABEr 1  31 2E 34     
000AC1r 1  00           					.BYTE $00
000AC2r 1  0D 0A        MSG_16		.BYTE $0D,$0A
000AC4r 1  3B 2D        					.BYTE ";-"
000AC6r 1  00           					.BYTE $00
000AC7r 1  20 64 65 6C  MSG_17		.BYTE	" delay ms:"
000ACBr 1  61 79 20 6D  
000ACFr 1  73 3A        
000AD1r 1  00           					.BYTE	$00
000AD2r 1  20 6D 75 6C  MSG_18		.BYTE	" mult:"
000AD6r 1  74 3A        
000AD8r 1  00           					.BYTE	$00
000AD9r 1  20 64 65 6C  MSG_19		.BYTE	" delay xl:"
000ADDr 1  61 79 20 78  
000AE1r 1  6C 3A        
000AE3r 1  00           					.BYTE	$00
000AE4r 1  55 70 74 69  MSG_1A		.BYTE	"Uptime: "
000AE8r 1  6D 65 3A 20  
000AECr 1  00           					.BYTE	$00
000AEDr 1  20 44 61 79  MSG_1B		.BYTE	" Days, "
000AF1r 1  73 2C 20     
000AF4r 1  00           					.BYTE	$00
000AF5r 1  20 48 6F 75  MSG_1C		.BYTE	" Hours, "
000AF9r 1  72 73 2C 20  
000AFDr 1  00           					.BYTE	$00
000AFEr 1  20 4D 69 6E  MSG_1D		.BYTE	" Minutes, "
000B02r 1  75 74 65 73  
000B06r 1  2C 20        
000B08r 1  00           					.BYTE	$00
000B09r 1  20 53 65 63  MSG_1E		.BYTE	" Seconds"
000B0Dr 1  6F 6E 64 73  
000B11r 1  00           					.BYTE	$00
000B12r 1  5A 65 72 6F  MSG_1F		.BYTE "Zero RAM/"
000B16r 1  20 52 41 4D  
000B1Ar 1  2F           
000B1Br 1  52 65 73 65  MSG_20		.BYTE	"Reset,"
000B1Fr 1  74 2C        
000B21r 1  00           					.BYTE	$00
000B22r 1  50 72 6F 67  MSG_21		.BYTE	"Program EEPROM",$0D,$0A
000B26r 1  72 61 6D 20  
000B2Ar 1  45 45 50 52  
000B32r 1  00           					.BYTE	$00
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000B33r 1  0D 0A        MSG_22		.BYTE	$0D,$0A
000B35r 1  41 72 65 20  					.BYTE	"Are you sure? "
000B39r 1  79 6F 75 20  
000B3Dr 1  73 75 72 65  
000B43r 1  00           					.BYTE	$00
000B44r 1  0D 0A        MSG_23		.BYTE	$0D,$0A
000B46r 1  57 72 69 74  					.BYTE	"Writing EEPROM."
000B4Ar 1  69 6E 67 20  
000B4Er 1  45 45 50 52  
000B55r 1  00           					.BYTE	$00
000B56r 1  0D 0A        MSG_24		.BYTE	$0D,$0A
000B58r 1  45 45 50 52  					.BYTE	"EEPROM Write Complete!"
000B5Cr 1  4F 4D 20 57  
000B60r 1  72 69 74 65  
000B6Er 1  00           					.BYTE	$00
000B6Fr 1  0D 0A        MSG_25		.BYTE	$0D,$0A
000B71r 1  45 45 50 52  					.BYTE	"EEPROM Write Failed!",$0D,$0A
000B75r 1  4F 4D 20 57  
000B79r 1  72 69 74 65  
000B87r 1  48 61 72 64  					.BYTE	"Hardware or EEPROM jumper!"
000B8Br 1  77 61 72 65  
000B8Fr 1  20 6F 72 20  
000BA1r 1  0D 0A        MSG_26		.BYTE	$0D,$0A
000BA3r 1  52 54 43 20  					.BYTE	"RTC time error, check/reset!"
000BA7r 1  74 69 6D 65  
000BABr 1  20 65 72 72  
000BBFr 1  00           					.BYTE	$00
000BC0r 1  58 4D 4F 44  MSG_27		.BYTE	"XMODEM Loader, <Esc> to abort, or",$0D,$0A
000BC4r 1  45 4D 20 4C  
000BC8r 1  6F 61 64 65  
000BE3r 1  4C 6F 61 64  					.BYTE	"Load Address/S-Record Offset:"
000BE7r 1  20 41 64 64  
000BEBr 1  72 65 73 73  
000C00r 1  00           					.BYTE	$00
000C01r 1  0D 0A        MSG_28		.BYTE	$0D,$0A
000C03r 1  44 6F 77 6E  					.BYTE	"Download Complete!",$0A
000C07r 1  6C 6F 61 64  
000C0Br 1  20 43 6F 6D  
000C16r 1  00           					.BYTE	$00
000C17r 1  0D 0A        MSG_29		.BYTE	$0D,$0A
000C19r 1  44 6F 77 6E  					.BYTE	"Download Error!",$0A
000C1Dr 1  6C 6F 61 64  
000C21r 1  20 45 72 72  
000C29r 1  00           					.BYTE	$00
000C2Ar 1  0D 0A        MSG_2A		.BYTE $0D,$0A
000C2Cr 1  53 2D 52 65  					.BYTE "S-Record load at:$"
000C30r 1  63 6F 72 64  
000C34r 1  20 6C 6F 61  
000C3Er 1  00           					.BYTE $00
000C3Fr 1  0D 0A        MSG_2B		.BYTE	$0D,$0A
000C41r 1  44 69 73 61  					.BYTE	"Disassembly from"
000C45r 1  73 73 65 6D  
000C49r 1  62 6C 79 20  
000C51r 1  00           					.BYTE	$00
000C52r 1  0D 0A 0A     MSG_2C		.BYTE	$0D,$0A,$0A
000C55r 1  4D 65 6D 6F  					.BYTE	"Memory Ops: "
000C59r 1  72 79 20 4F  
000C5Dr 1  70 73 3A 20  
000C61r 1  5B 43 5D 6F  					.BYTE	"[C]ompare, "
000C65r 1  6D 70 61 72  
000C69r 1  65 2C 20     
000C6Cr 1  5B 44 5D 69  					.BYTE	"[D]isplay, "
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000C70r 1  73 70 6C 61  
000C74r 1  79 2C 20     
000C77r 1  5B 45 5D 64  					.BYTE	"[E]dit, "
000C7Br 1  69 74 2C 20  
000C7Fr 1  5B 46 5D 69  					.BYTE	"[F]ill, "
000C83r 1  6C 6C 2C 20  
000C87r 1  5B 47 5D 6F  					.BYTE	"[G]o Exec,",$0D,$0A
000C8Br 1  20 45 78 65  
000C8Fr 1  63 2C 0D 0A  
000C93r 1  5B 48 5D 65  					.BYTE	"[H]ex Find, "
000C97r 1  78 20 46 69  
000C9Br 1  6E 64 2C 20  
000C9Fr 1  5B 49 5D 6E  					.BYTE	"[I]nput Text, "
000CA3r 1  70 75 74 20  
000CA7r 1  54 65 78 74  
000CADr 1  5B 4D 5D 6F  					.BYTE	"[M]ove, "
000CB1r 1  76 65 2C 20  
000CB5r 1  5B 54 5D 65  					.BYTE	"[T]ext Find",$0D,$0A,$0A
000CB9r 1  78 74 20 46  
000CBDr 1  69 6E 64 0D  
000CC3r 1  52 65 67 69  					.BYTE	"Registers: "
000CC7r 1  73 74 65 72  
000CCBr 1  73 3A 20     
000CCEr 1  52 2C 41 2C  					.BYTE	"R,A,X,Y,S,P",$0D,$0A,$0A
000CD2r 1  58 2C 59 2C  
000CD6r 1  53 2C 50 0D  
000CDCr 1  54 69 6D 65  					.BYTE	"Timer: "
000CE0r 1  72 3A 20     
000CE3r 1  2C 3D 20 73  					.BYTE	",= set ms|mult, "
000CE7r 1  65 74 20 6D  
000CEBr 1  73 7C 6D 75  
000CF3r 1  2E 3D 20 65  					.BYTE	".= exe ms, "
000CF7r 1  78 65 20 6D  
000CFBr 1  73 2C 20     
000CFEr 1  2F 3D 20 65  					.BYTE	"/= exe ms*mult, "
000D02r 1  78 65 20 6D  
000D06r 1  73 2A 6D 75  
000D0Er 1  5C 3D 20 65  					.BYTE	"\= exe (?)*ms*mult",$0D,$0A,$0A
000D12r 1  78 65 20 28  
000D16r 1  3F 29 2A 6D  
000D23r 1  4D 61 63 72  					.BYTE	"Macro: "
000D27r 1  6F 3A 20     
000D2Ar 1  28 3D 20 49  					.BYTE	"(= Init "
000D2Er 1  6E 69 74 20  
000D32r 1  29 3D 20 52  					.BYTE	")= Run",$0D,$0A,$0A
000D36r 1  75 6E 0D 0A  
000D3Ar 1  0A           
000D3Br 1  43 54 52 4C  					.BYTE	"CTRL[?]: "
000D3Fr 1  5B 3F 5D 3A  
000D43r 1  20           
000D44r 1  5B 44 5D 69  					.BYTE	"[D]isassemble, "
000D48r 1  73 61 73 73  
000D4Cr 1  65 6D 62 6C  
000D53r 1  5B 4C 5D 6F  					.BYTE	"[L]oader, "
000D57r 1  61 64 65 72  
000D5Br 1  2C 20        
000D5Dr 1  5B 50 5D 72  					.BYTE	"[P]rogram, "
000D61r 1  6F 67 72 61  
000D65r 1  6D 2C 20     
000D68r 1  5B 51 5D 75  					.BYTE	"[Q]uery Cmds,",$0D,$0A
000D6Cr 1  65 72 79 20  
000D70r 1  43 6D 64 73  
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000D77r 1  5B 52 5D 65  					.BYTE	"[R]eset, "
000D7Br 1  73 65 74 2C  
000D7Fr 1  20           
000D80r 1  5B 54 5D 69  					.BYTE	"[T]ime up, "
000D84r 1  6D 65 20 75  
000D88r 1  70 2C 20     
000D8Br 1  5B 56 5D 65  					.BYTE	"[V]ersion, "
000D8Fr 1  72 73 69 6F  
000D93r 1  6E 2C 20     
000D96r 1  5B 5A 5D 65  					.BYTE	"[Z]ero RAM",$0A
000D9Ar 1  72 6F 20 52  
000D9Er 1  41 4D 0A     
000DA1r 1  00           					.BYTE	$00
000DA2r 1  0D 0A        MSG_2D		.BYTE	$0D,$0A
000DA4r 1  53 68 6F 77  					.BYTE	"Show Loop count "
000DA8r 1  20 4C 6F 6F  
000DACr 1  70 20 63 6F  
000DB4r 1  00           					.BYTE	$00
000DB5r 1  0D 0A        MSG_2E		.BYTE	$0D,$0A
000DB7r 1  4C 6F 6F 70  					.BYTE	"Loops: "
000DBBr 1  73 3A 20     
000DBEr 1  00           					.BYTE	$00
000DBFr 1  0D 0A        MSG_2F  .BYTE     $0D,$0A
000DC1r 1  36 35 43 30          .BYTE     "65C02 Enhanced BASIC Version 2.22p5C02"
000DC5r 1  32 20 45 6E  
000DC9r 1  68 61 6E 63  
000DE7r 1  0D 0A                .BYTE     $0D,$0A
000DE9r 1  20 5B 43 5D          .BYTE     " [C]old/[W]arm start?"
000DEDr 1  6F 6C 64 2F  
000DF1r 1  5B 57 5D 61  
000DFEr 1  00                   .BYTE     $00
000DFFr 1               ;
000DFFr 1               MSG_TABLE	;Message table - contains addresses as words of each message sent via the PROMPT routine
000DFFr 1  rr rr        					.WORD MSG_00
000E01r 1  rr rr        					.WORD	MSG_01
000E03r 1  rr rr        					.WORD	MSG_02
000E05r 1  rr rr        					.WORD	MSG_03
000E07r 1  rr rr        					.WORD	MSG_04
000E09r 1  rr rr        					.WORD	MSG_05
000E0Br 1  rr rr        					.WORD	MSG_06
000E0Dr 1  rr rr        					.WORD	MSG_07
000E0Fr 1  rr rr        					.WORD	MSG_08
000E11r 1  rr rr        					.WORD	MSG_09
000E13r 1  rr rr        					.WORD	MSG_0A
000E15r 1  rr rr        					.WORD	MSG_0B
000E17r 1  rr rr        					.WORD	MSG_0C
000E19r 1  rr rr        					.WORD	MSG_0D
000E1Br 1  rr rr        					.WORD	MSG_0E
000E1Dr 1  rr rr        					.WORD	MSG_0F
000E1Fr 1  rr rr        					.WORD	MSG_10
000E21r 1  rr rr        					.WORD	MSG_11
000E23r 1  rr rr        					.WORD	MSG_12
000E25r 1  rr rr        					.WORD	MSG_13
000E27r 1  rr rr        					.WORD	MSG_14
000E29r 1  rr rr        					.WORD	MSG_15
000E2Br 1  rr rr        					.WORD	MSG_16
000E2Dr 1  rr rr        					.WORD	MSG_17
000E2Fr 1  rr rr        					.WORD	MSG_18
000E31r 1  rr rr        					.WORD	MSG_19
000E33r 1  rr rr        					.WORD	MSG_1A
000E35r 1  rr rr        					.WORD	MSG_1B
000E37r 1  rr rr        					.WORD	MSG_1C
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000E39r 1  rr rr        					.WORD	MSG_1D
000E3Br 1  rr rr        					.WORD	MSG_1E
000E3Dr 1  rr rr        					.WORD	MSG_1F
000E3Fr 1  rr rr        					.WORD	MSG_20
000E41r 1  rr rr        					.WORD	MSG_21
000E43r 1  rr rr        					.WORD	MSG_22
000E45r 1  rr rr        					.WORD	MSG_23
000E47r 1  rr rr        					.WORD	MSG_24
000E49r 1  rr rr        					.WORD	MSG_25
000E4Br 1  rr rr        					.WORD	MSG_26
000E4Dr 1  rr rr        					.WORD	MSG_27
000E4Fr 1  rr rr        					.WORD	MSG_28
000E51r 1  rr rr        					.WORD	MSG_29
000E53r 1  rr rr        					.WORD	MSG_2A
000E55r 1  rr rr        					.WORD	MSG_2B
000E57r 1  rr rr        					.WORD	MSG_2C
000E59r 1  rr rr        					.WORD	MSG_2D
000E5Br 1  rr rr        					.WORD	MSG_2E
000E5Dr 1  rr rr        					.WORD	MSG_2F
000E5Fr 1               ;
000E5Fr 1               ;******************************************************************************
000E5Fr 1               ;START OF DISASSEMBLER DATA
000E5Fr 1               ;
000E5Fr 1               ;Pointer for address mode handlers.
000E5Fr 1               ;Each byte contains handler pointer for two opcodes;
000E5Fr 1               ;Upper nibble for odd, lower nibble for even
000E5Fr 1  26 00 33 3E  HDLR_IDX	.BYTE	$26,$00,$33,$3E,$02,$10,$88,$8F
000E63r 1  02 10 88 8F  
000E67r 1  C7 B0 34 4E  					.BYTE	$C7,$B0,$34,$4E,$0A,$10,$89,$9F
000E6Br 1  0A 10 89 9F  
000E6Fr 1  86 00 33 3E  					.BYTE	$86,$00,$33,$3E,$02,$10,$88,$8F
000E73r 1  02 10 88 8F  
000E77r 1  C7 B0 44 4E  					.BYTE	$C7,$B0,$44,$4E,$0A,$10,$99,$9F
000E7Br 1  0A 10 99 9F  
000E7Fr 1  06 00 03 3E  					.BYTE	$06,$00,$03,$3E,$02,$10,$88,$8F
000E83r 1  02 10 88 8F  
000E87r 1  C7 B0 04 4E  					.BYTE	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
000E8Br 1  0A 00 09 9F  
000E8Fr 1  06 00 33 3E  					.BYTE	$06,$00,$33,$3E,$02,$10,$B8,$8F
000E93r 1  02 10 B8 8F  
000E97r 1  C7 B0 44 4E  					.BYTE	$C7,$B0,$44,$4E,$0A,$00,$D9,$9F
000E9Br 1  0A 00 D9 9F  
000E9Fr 1  C6 00 33 3E  					.BYTE	$C6,$00,$33,$3E,$02,$00,$88,$8F
000EA3r 1  02 00 88 8F  
000EA7r 1  C7 B0 44 5E  					.BYTE	$C7,$B0,$44,$5E,$0A,$00,$89,$9F
000EABr 1  0A 00 89 9F  
000EAFr 1  26 20 33 3E  					.BYTE	$26,$20,$33,$3E,$02,$00,$88,$8F
000EB3r 1  02 00 88 8F  
000EB7r 1  C7 B0 44 5E  					.BYTE	$C7,$B0,$44,$5E,$0A,$00,$99,$AF
000EBBr 1  0A 00 99 AF  
000EBFr 1  26 00 33 3E  					.BYTE	$26,$00,$33,$3E,$02,$00,$88,$8F
000EC3r 1  02 00 88 8F  
000EC7r 1  C7 B0 04 4E  					.BYTE	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
000ECBr 1  0A 00 09 9F  
000ECFr 1  26 00 33 3E  					.BYTE	$26,$00,$33,$3E,$02,$00,$88,$8F
000ED3r 1  02 00 88 8F  
000ED7r 1  C7 B0 04 4E  					.BYTE	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
000EDBr 1  0A 00 09 9F  
000EDFr 1               ;
000EDFr 1               ;Disassembler handler table:
000EDFr 1               ;Handler address index: (referenced in table HDLR_IDX)
000EDFr 1  rr rr        HDLR_TAB	.WORD	IMPLIED	;$00
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000EE1r 1  rr rr        					.WORD	ACC_MODE	;$01
000EE3r 1  rr rr        					.WORD	ZP_IMED	;$02
000EE5r 1  rr rr        					.WORD	ZP_ABS	;$03
000EE7r 1  rr rr        					.WORD	ZP_ABS_X	;$04
000EE9r 1  rr rr        					.WORD	ZP_ABS_Y	;$05
000EEBr 1  rr rr        					.WORD	ZP_IND_X	;$06
000EEDr 1  rr rr        					.WORD	ZP_IND_Y	;$07
000EEFr 1  rr rr        					.WORD	ABSOLUTE	;$08
000EF1r 1  rr rr        					.WORD	ABS_X	;$09
000EF3r 1  rr rr        					.WORD	ABS_Y	;$0A
000EF5r 1  rr rr        					.WORD	INDIRECT	;$0B
000EF7r 1  rr rr        					.WORD	REL_BRA	;$0C
000EF9r 1  rr rr        					.WORD	IND_ABS_X	;$0D
000EFBr 1  rr rr        					.WORD	ZP_XMB	;$0E
000EFDr 1  rr rr        					.WORD	ZP_BBX	;$0F
000EFFr 1               ;
000EFFr 1               ;Disassembler mnemonic pointer table. This is indexed by the instruction opcode
000EFFr 1               ; The values in this table are an index to the mnemonic data used to print:
000EFFr 1               MNE_PTAB	;Mnemonic pointer index table
000EFFr 1  1C 4C 00 00  					.BYTE	$1C,$4C,$00,$00,$82,$4C,$06,$5E,$50,$4C,$06,$00,$82,$4C,$06,$08
000F03r 1  82 4C 06 5E  
000F07r 1  50 4C 06 00  
000F0Fr 1  18 4C 4C 00  					.BYTE	$18,$4C,$4C,$00,$80,$4C,$06,$5E,$22,$4C,$38,$00,$80,$4C,$06,$08
000F13r 1  80 4C 06 5E  
000F17r 1  22 4C 38 00  
000F1Fr 1  40 04 00 00  					.BYTE	$40,$04,$00,$00,$12,$04,$60,$5E,$58,$04,$60,$00,$12,$04,$60,$08
000F23r 1  12 04 60 5E  
000F27r 1  58 04 60 00  
000F2Fr 1  14 04 04 00  					.BYTE	$14,$04,$04,$00,$12,$04,$60,$5E,$6A,$04,$30,$00,$12,$04,$60,$08
000F33r 1  12 04 60 5E  
000F37r 1  6A 04 30 00  
000F3Fr 1  64 36 00 00  					.BYTE	$64,$36,$00,$00,$00,$36,$48,$5E,$4E,$36,$48,$00,$3E,$36,$48,$08
000F43r 1  00 36 48 5E  
000F47r 1  4E 36 48 00  
000F4Fr 1  1E 36 36 00  					.BYTE	$1E,$36,$36,$00,$00,$36,$48,$5E,$26,$36,$54,$00,$00,$36,$48,$08
000F53r 1  00 36 48 5E  
000F57r 1  26 36 54 00  
000F5Fr 1  66 02 00 00  					.BYTE	$66,$02,$00,$00,$7A,$02,$62,$5E,$56,$02,$62,$00,$3E,$02,$62,$08
000F63r 1  7A 02 62 5E  
000F67r 1  56 02 62 00  
000F6Fr 1  20 02 02 00  					.BYTE	$20,$02,$02,$00,$7A,$02,$62,$5E,$6E,$02,$5C,$00,$3E,$02,$62,$08
000F73r 1  7A 02 62 5E  
000F77r 1  6E 02 5C 00  
000F7Fr 1  1A 72 00 00  					.BYTE	$1A,$72,$00,$00,$78,$72,$76,$70,$34,$12,$86,$00,$78,$72,$76,$0A
000F83r 1  78 72 76 70  
000F87r 1  34 12 86 00  
000F8Fr 1  0C 72 72 00  					.BYTE	$0C,$72,$72,$00,$78,$72,$76,$70,$8A,$72,$88,$00,$7A,$72,$7A,$0A
000F93r 1  78 72 76 70  
000F97r 1  8A 72 88 00  
000F9Fr 1  46 42 44 00  					.BYTE	$46,$42,$44,$00,$46,$42,$44,$70,$7E,$42,$7C,$00,$46,$42,$44,$0A
000FA3r 1  46 42 44 70  
000FA7r 1  7E 42 7C 00  
000FAFr 1  0E 42 42 00  					.BYTE	$0E,$42,$42,$00,$46,$42,$44,$70,$28,$42,$84,$00,$46,$42,$44,$0A
000FB3r 1  46 42 44 70  
000FB7r 1  28 42 84 00  
000FBFr 1  2E 2A 00 00  					.BYTE	$2E,$2A,$00,$00,$2E,$2A,$30,$70,$3C,$2A,$32,$8C,$2E,$2A,$30,$0A
000FC3r 1  2E 2A 30 70  
000FC7r 1  3C 2A 32 8C  
000FCFr 1  16 2A 2A 00  					.BYTE	$16,$2A,$2A,$00,$00,$2A,$30,$70,$24,$2A,$52,$74,$00,$2A,$30,$0A
000FD3r 1  00 2A 30 70  
000FD7r 1  24 2A 52 74  
000FDFr 1  2C 68 00 00  					.BYTE	$2C,$68,$00,$00,$2C,$68,$38,$70,$3A,$68,$4A,$00,$2C,$68,$38,$0A
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

000FE3r 1  2C 68 38 70  
000FE7r 1  3A 68 4A 00  
000FEFr 1  10 68 68 00  					.BYTE	$10,$68,$68,$00,$00,$68,$38,$70,$6C,$68,$5A,$00,$00,$68,$38,$0A
000FF3r 1  00 68 38 70  
000FF7r 1  6C 68 5A 00  
000FFFr 1               ;
000FFFr 1               DIS_NMEM	;Mnemonic compressed table
000FFFr 1               ;	Uses two bytes per 3-character Mnemonic. 5-bits per character uses 15-bit total
000FFFr 1               ;	Characters are left to right. 5-bits shifted into A reg, add in $3F and print
000FFFr 1               ;	"?" starts with "00000", "A" starts with "00010", "B" starts with "00011", etc.
000FFFr 1               ;
000FFFr 1               ; A	00010		B	00011		C	00100		D	00101		E	00110		F	00111		G	01000		H	01001
000FFFr 1               ;	I	01010		J	01011		K	01100		L	01101		M	01110		N	01111		O	10000		P	10001
000FFFr 1               ;	Q	10010		R	10011		S	10100		T	10101		U	10110		V	10111		W	11000		X	11001
000FFFr 1               ;	Y	11010		Z	11011
000FFFr 1               ;
000FFFr 1  00 00        					.DBYT	%0000000000000000	;???	$00
001001r 1  11 48        					.DBYT	%0001000101001000	;ADC	$02
001003r 1  13 CA        					.DBYT	%0001001111001010	;AND	$04
001005r 1  15 1A        					.DBYT	%0001010100011010	;ASL	$06
001007r 1  18 E6        					.DBYT	%0001100011100110	;BBR	$08
001009r 1  18 E8        					.DBYT	%0001100011101000	;BBS	$0A
00100Br 1  19 08        					.DBYT	%0001100100001000	;BCC	$0C
00100Dr 1  19 28        					.DBYT	%0001100100101000	;BCS	$0E
00100Fr 1  19 A4        					.DBYT	%0001100110100100	;BEQ	$10
001011r 1  1A AA        					.DBYT	%0001101010101010	;BIT	$12
001013r 1  1B 94        					.DBYT	%0001101110010100	;BMI	$14
001015r 1  1B CC        					.DBYT	%0001101111001100	;BNE	$16
001017r 1  1C 5A        					.DBYT	%0001110001011010	;BPL	$18
001019r 1  1C C4        					.DBYT	%0001110011000100	;BRA	$1A
00101Br 1  1C D8        					.DBYT	%0001110011011000	;BRK	$1C
00101Dr 1  1D C8        					.DBYT	%0001110111001000	;BVC	$1E
00101Fr 1  1D E8        					.DBYT	%0001110111101000	;BVS	$20
001021r 1  23 48        					.DBYT	%0010001101001000	;CLC	$22
001023r 1  23 4A        					.DBYT	%0010001101001010	;CLD	$24
001025r 1  23 54        					.DBYT	%0010001101010100	;CLI	$26
001027r 1  23 6E        					.DBYT	%0010001101101110	;CLV	$28
001029r 1  23 A2        					.DBYT	%0010001110100010	;CMP	$2A
00102Br 1  24 72        					.DBYT	%0010010001110010	;CPX	$2C
00102Dr 1  24 74        					.DBYT	%0010010001110100	;CPY	$2E
00102Fr 1  29 88        					.DBYT	%0010100110001000	;DEC	$30
001031r 1  29 B2        					.DBYT	%0010100110110010	;DEX	$32
001033r 1  29 B4        					.DBYT	%0010100110110100	;DEY	$34
001035r 1  34 26        					.DBYT	%0011010000100110	;EOR	$36
001037r 1  53 C8        					.DBYT	%0101001111001000	;INC	$38
001039r 1  53 F2        					.DBYT	%0101001111110010	;INX	$3A
00103Br 1  53 F4        					.DBYT	%0101001111110100	;INY	$3C
00103Dr 1  5B A2        					.DBYT	%0101101110100010	;JMP	$3E
00103Fr 1  5D 26        					.DBYT	%0101110100100110	;JSR	$40
001041r 1  69 44        					.DBYT	%0110100101000100	;LDA	$42
001043r 1  69 72        					.DBYT	%0110100101110010	;LDX	$44
001045r 1  69 74        					.DBYT	%0110100101110100	;LDY	$46
001047r 1  6D 26        					.DBYT	%0110110100100110	;LSR	$48
001049r 1  7C 22        					.DBYT	%0111110000100010	;NOP	$4A
00104Br 1  84 C4        					.DBYT	%1000010011000100	;ORA	$4C
00104Dr 1  8A 44        					.DBYT	%1000101001000100	;PHA	$4E
00104Fr 1  8A 62        					.DBYT	%1000101001100010	;PHP	$50
001051r 1  8A 72        					.DBYT	%1000101001110010	;PHX	$52
001053r 1  8A 74        					.DBYT	%1000101001110100	;PHY	$54
001055r 1  8B 44        					.DBYT	%1000101101000100	;PLA	$56
001057r 1  8B 62        					.DBYT	%1000101101100010	;PLP	$58
001059r 1  8B 72        					.DBYT	%1000101101110010	;PLX	$5A
ca65 V2.18 - N/A
Main file   : src/monitor.s
Current file: src/monitor.s

00105Br 1  8B 74        					.DBYT	%1000101101110100	;PLY	$5C
00105Dr 1  9B 86        					.DBYT	%1001101110000110	;RMB	$5E
00105Fr 1  9C 1A        					.DBYT	%1001110000011010	;ROL	$60
001061r 1  9C 26        					.DBYT	%1001110000100110	;ROR	$62
001063r 1  9D 54        					.DBYT	%1001110101010100	;RTI	$64
001065r 1  9D 68        					.DBYT	%1001110101101000	;RTS	$66
001067r 1  A0 C8        					.DBYT	%1010000011001000	;SBC	$68
001069r 1  A1 88        					.DBYT	%1010000110001000	;SEC	$6A
00106Br 1  A1 8A        					.DBYT	%1010000110001010	;SED	$6C
00106Dr 1  A1 94        					.DBYT	%1010000110010100	;SEI	$6E
00106Fr 1  A3 86        					.DBYT	%1010001110000110	;SMB	$70
001071r 1  A5 44        					.DBYT	%1010010101000100	;STA	$72
001073r 1  A5 62        					.DBYT	%1010010101100010	;STP	$74
001075r 1  A5 72        					.DBYT	%1010010101110010	;STX	$76
001077r 1  A5 74        					.DBYT	%1010010101110100	;STY	$78
001079r 1  A5 76        					.DBYT	%1010010101110110	;STZ	$7A
00107Br 1  A8 B2        					.DBYT	%1010100010110010	;TAX	$7C
00107Dr 1  A8 B4        					.DBYT	%1010100010110100	;TAY	$7E
00107Fr 1  AC E8        					.DBYT	%1010110011101000	;TRB	$80
001081r 1  AD 06        					.DBYT	%1010110100000110	;TSB	$82
001083r 1  AD 32        					.DBYT	%1010110100110010	;TSX	$84
001085r 1  AE 44        					.DBYT	%1010111001000100	;TXA	$86
001087r 1  AE 68        					.DBYT	%1010111001101000	;TXS	$88
001089r 1  AE 84        					.DBYT	%1010111010000100	;TYA	$8A
00108Br 1  C0 94        					.DBYT	%1100000010010100	;WAI	$8C
00108Dr 1               ;
00108Dr 1               ;END OF DISASSEMBLER DATA
00108Dr 1               ;******************************************************************************
00108Dr 1               ;END OF MONITOR DATA
00108Dr 1               ;******************************************************************************
00108Dr 1               
